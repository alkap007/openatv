diff -uNr a/container/container_ffmpeg.c b/container/container_ffmpeg.c
--- a/container/container_ffmpeg.c	2019-05-19 08:46:16.000000000 +0200
+++ b/container/container_ffmpeg.c	2022-07-03 13:17:10.000000000 +0200
@@ -981,6 +981,11 @@
 
                 pcmExtradata.codec_id              = get_codecpar(audioTrack->stream)->codec_id;
                 pcmExtradata.bResampling           = restart_audio_resampling;
+				
+                audioTrack->channels = pcmExtradata.channels;
+                audioTrack->bits_per_coded_sample = pcmExtradata.bits_per_coded_sample;
+                audioTrack->sample_rate = pcmExtradata.sample_rate;
+				audioTrack->codec_id = pcmExtradata.codec_id; 				
                 
                 uint8_t *pAudioExtradata    = get_codecpar(audioTrack->stream)->extradata;
                 uint32_t audioExtradataSize = get_codecpar(audioTrack->stream)->extradata_size;
@@ -1182,7 +1187,12 @@
 #else
                         pcmExtradata.codec_id       = AV_CODEC_ID_PCM_S16LE;
 #endif
-
+                        audioTrack->channels = pcmExtradata.channels;
+                        audioTrack->bits_per_coded_sample = pcmExtradata.bits_per_coded_sample;
+                        audioTrack->sample_rate = pcmExtradata.sample_rate;
+						audioTrack->codec_id = pcmExtradata.codec_id; 
+						
+						
                         //////////////////////////////////////////////////////////////////////
 
                         avOut.data       = output[0];
Binary files a/exteplayer3 and b/exteplayer3 differ
diff -uNr a/hisi/hi_adp_hdmi.c b/hisi/hi_adp_hdmi.c
--- a/hisi/hi_adp_hdmi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/hisi/hi_adp_hdmi.c	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,572 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+
+#include "hi_unf_hdmi.h"
+#include "hi_unf_edid.h"
+#include "hi_unf_disp.h"
+#include "hi_adp.h"
+#include "hi_adp_hdmi.h"
+#include "hi_unf_pdm.h"
+
+typedef struct
+{
+    HI_UNF_HDMI_ID_E  enHdmi;
+    HI_U32            u32HdcpVersion;
+} HDMI_ARGS_S;
+
+#if defined(CHIP_TYPE_hi3798mv310) || defined(HI_BOOT_HOMOLOGOUS_SUPPORT)
+static HI_BOOL s_bFirstTiming = HI_TRUE;
+static HI_UNF_ENC_FMT_E s_enHdmiFormat;
+static HI_UNF_ENC_FMT_E s_enCvbsFormat;
+#endif
+
+static HDMI_ARGS_S g_stHdmiArgs;
+HI_U32 g_HDCPFlag         = HI_FALSE;
+HI_U32 g_HDMI_Bebug       = HI_FALSE;
+HI_U32 g_HDMIUserCallbackFlag = HI_FALSE;
+HI_U32 g_enDefaultMode    = HI_UNF_HDMI_DEFAULT_ACTION_HDMI;//HI_UNF_HDMI_DEFAULT_ACTION_NULL;
+HI_UNF_HDMI_CALLBACK_FUNC_S g_stCallbackFunc;
+
+User_HDMI_CallBack pfnHdmiUserCallback = NULL;
+
+#ifdef HI_HDCP_SUPPORT
+const HI_CHAR * pstencryptedHdcpKey = "EncryptedKey_332bytes.bin";
+#endif
+
+static HI_CHAR *g_pDispFmtString[HI_UNF_ENC_FMT_BUTT+1] = {
+    "1080P_60",
+    "1080P_50",
+    "1080P_30",
+    "1080P_25",
+
+    "1080P_24",
+    "1080i_60",
+    "1080i_50",
+
+    "720P_60",
+    "720P_50",
+
+    "576P_50",
+    "480P_60",
+
+    "PAL",
+    "PAL_N",
+    "PAL_Nc",
+
+    "NTSC",
+    "NTSC_J",
+    "NTSC_PAL_M",
+
+    "SECAM_SIN",
+    "SECAM_COS",
+
+    "1080P_24_FP",
+    "720P_60_FP",
+    "720P_50_FP",
+
+    "861D_640X480_60",
+    "VESA_800X600_60",
+    "VESA_1024X768_60",
+    "VESA_1280X720_60",
+    "VESA_1280X800_60",
+    "VESA_1280X1024_60",
+    "VESA_1360X768_60",
+    "VESA_1366X768_60",
+    "VESA_1400X1050_60",
+    "VESA_1440X900_60",
+    "VESA_1440X900_60_RB",
+    "VESA_1600X900_60_RB",
+    "VESA_1600X1200_60",
+    "VESA_1680X1050_60",
+    "VESA_1680X1050_60_RB",
+    "VESA_1920X1080_60",
+    "VESA_1920X1200_60",
+    "VESA_1920X1440_60",
+    "VESA_2048X1152_60",
+    "VESA_2560X1440_60_RB",
+    "VESA_2560X1600_60_RB",
+
+    "2160P_24",
+    "2160P_25",
+    "2160P_30",
+    "4090X2160_24",
+
+    "BUTT"
+};
+
+HI_UNF_ENC_FMT_E stringToUnfFmt(HI_CHAR *pszFmt)
+{
+    HI_S32 i;
+    HI_UNF_ENC_FMT_E fmtReturn = HI_UNF_ENC_FMT_BUTT;
+
+    if (NULL == pszFmt)
+    {
+        return HI_UNF_ENC_FMT_BUTT;
+    }
+
+    for (i = 0; i < HI_UNF_ENC_FMT_BUTT; i++)
+    {
+        if (strcasestr(pszFmt, g_pDispFmtString[i]))
+        {
+            fmtReturn = i;
+            break;
+        }
+    }
+
+    if (i >= HI_UNF_ENC_FMT_BUTT)
+    {
+        i = HI_UNF_ENC_FMT_720P_50;
+        fmtReturn = i;
+        sample_common_printf("\n!!! Can NOT match format, set format to is '%s'/%d.\n\n", g_pDispFmtString[i], i);
+    }
+    else
+    {
+        sample_common_printf("\n!!! The format is '%s'/%d.\n\n", g_pDispFmtString[i], i);
+    }
+    return fmtReturn;
+}
+
+static HI_VOID HDMI_PrintAttr(HI_UNF_HDMI_ATTR_S *pstHDMIAttr)
+{
+    if (HI_TRUE != g_HDMI_Bebug)
+    {
+        return;
+    }
+
+    sample_common_printf("=====HI_UNF_HDMI_SetAttr=====\n"
+           "bEnableHdmi:%d\n"
+           "bEnableVideo:%d\n"
+           "enVidOutMode:%d\n"
+           "enDeepColorMode:%d\n"
+           "bxvYCCMode:%d\n\n"
+           "bEnableAudio:%d\n"
+           "bEnableAviInfoFrame:%d\n"
+           "bEnableAudInfoFrame:%d\n"
+           "bEnableSpdInfoFrame:%d\n"
+           "bEnableMpegInfoFrame:%d\n\n"
+           "==============================\n",
+           pstHDMIAttr->bEnableHdmi,
+           pstHDMIAttr->bEnableVideo,
+           pstHDMIAttr->enVidOutMode,pstHDMIAttr->enDeepColorMode,pstHDMIAttr->bxvYCCMode,
+           pstHDMIAttr->bEnableAudio,
+           pstHDMIAttr->bEnableAudInfoFrame,pstHDMIAttr->bEnableAudInfoFrame,
+           pstHDMIAttr->bEnableSpdInfoFrame,pstHDMIAttr->bEnableMpegInfoFrame);
+    return;
+}
+
+void HDMI_HotPlug_Proc(HI_VOID *pPrivateData)
+{
+    HI_S32          ret = HI_SUCCESS;
+    HDMI_ARGS_S     *pArgs  = (HDMI_ARGS_S*)pPrivateData;
+    HI_UNF_HDMI_ID_E       hHdmi   =  pArgs->enHdmi;
+    HI_UNF_HDMI_ATTR_S             stHdmiAttr;
+    //HI_UNF_HDMI_INFOFRAME_S        stInfoFrame;
+    HI_UNF_EDID_BASE_INFO_S        stSinkCap;
+    HI_UNF_HDMI_STATUS_S           stHdmiStatus;
+
+#ifdef HI_HDCP_SUPPORT
+    static HI_U8 u8FirstTimeSetting = HI_TRUE;
+#endif
+
+    sample_common_printf("\n --- Get HDMI event: HOTPLUG. --- \n");
+
+    HI_UNF_HDMI_GetStatus(hHdmi,&stHdmiStatus);
+    if (HI_FALSE == stHdmiStatus.bConnected)
+    {
+        sample_common_printf("No Connect\n");
+        return;
+    }
+#if defined(CHIP_TYPE_hi3798mv310) || defined(HI_BOOT_HOMOLOGOUS_SUPPORT)
+    {
+        HI_UNF_DISP_INTF_S          DispIntf;
+
+        DispIntf.enIntfType = HI_UNF_DISP_INTF_TYPE_CVBS;
+        DispIntf.unIntf.stCVBS.u8Dac = HI_DAC_CVBS;
+        sample_common_printf("switch to hdmi output\n");
+        if (s_bFirstTiming)
+        {
+            s_bFirstTiming = HI_FALSE;
+            HI_UNF_DISP_GetFormat(HI_UNF_DISPLAY0, &s_enCvbsFormat);
+            HI_UNF_DISP_GetFormat(HI_UNF_DISPLAY1, &s_enHdmiFormat);
+            HI_UNF_DISP_DetachIntf(HI_UNF_DISPLAY0, &DispIntf, 1);
+            HI_UNF_DISP_AttachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+        }
+        else
+        {
+            HI_UNF_DISP_DetachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+            HI_UNF_DISP_SetFormat(HI_UNF_DISPLAY1, s_enHdmiFormat);
+            //HI_UNF_DISP_SetHDRType(HI_UNF_DISPLAY1, HI_UNF_DISP_HDR_TYPE_AUTO);
+            //HI_UNF_DISP_SetOutputColorSpace(HI_UNF_DISPLAY1, HI_UNF_DISP_COLOR_SPACE_AUTO);
+        }
+    }
+#endif
+
+    HI_UNF_HDMI_GetAttr(hHdmi, &stHdmiAttr);
+    ret = HI_UNF_HDMI_GetSinkCapability(hHdmi, &stSinkCap);
+    if (ret == HI_SUCCESS)
+    {
+        //stHdmiAttr.enVidOutMode = HI_UNF_HDMI_VIDEO_MODE_YCBCR444;
+        if(HI_TRUE == stSinkCap.bSupportHdmi)
+        {
+            stHdmiAttr.bEnableHdmi = HI_TRUE;
+            if(HI_TRUE != stSinkCap.stColorSpace.bYCbCr444)
+            {
+                stHdmiAttr.enVidOutMode = HI_UNF_HDMI_VIDEO_MODE_RGB444;
+            }
+            /* no change attr to make sure app smoothly */
+            //else
+            //{
+            //    stHdmiAttr.enVidOutMode = HI_UNF_HDMI_VIDEO_MODE_YCBCR444;  /* user can choicen RGB/YUV*/
+            //}
+        }
+        else
+        {
+            stHdmiAttr.enVidOutMode = HI_UNF_HDMI_VIDEO_MODE_RGB444;
+            //读取到了edid，并且不支持hdmi则进入dvi模式
+            //read real edid ok && sink not support hdmi,then we run in dvi mode
+            stHdmiAttr.bEnableHdmi = HI_FALSE;
+        }
+    }
+    else
+    {
+        //when get capability fail,use default mode
+        if (g_enDefaultMode != HI_UNF_HDMI_DEFAULT_ACTION_DVI)
+            stHdmiAttr.bEnableHdmi = HI_TRUE;
+        else
+            stHdmiAttr.bEnableHdmi = HI_FALSE;
+    }
+
+    if (HI_TRUE == stHdmiAttr.bEnableHdmi)
+    {
+        stHdmiAttr.bEnableAudio = HI_TRUE;
+        stHdmiAttr.bEnableVideo = HI_TRUE;
+        stHdmiAttr.bEnableAudInfoFrame = HI_TRUE;
+        stHdmiAttr.bEnableAviInfoFrame = HI_TRUE;
+    }
+    else
+    {
+        stHdmiAttr.bEnableAudio = HI_FALSE;
+        stHdmiAttr.bEnableVideo = HI_TRUE;
+        stHdmiAttr.bEnableAudInfoFrame = HI_FALSE;
+        stHdmiAttr.bEnableAviInfoFrame = HI_FALSE;
+        stHdmiAttr.enVidOutMode = HI_UNF_HDMI_VIDEO_MODE_RGB444;
+    }
+
+#ifdef HI_HDCP_SUPPORT
+    if (u8FirstTimeSetting == HI_TRUE)
+    {
+        u8FirstTimeSetting = HI_FALSE;
+        if (g_HDCPFlag == HI_TRUE)
+        {
+            stHdmiAttr.bHDCPEnable = HI_TRUE;//Enable HDCP
+        }
+        else
+        {
+            stHdmiAttr.bHDCPEnable= HI_FALSE;
+        }
+    }
+    else
+    {
+        //HDCP Enable use default setting!!
+    }
+#endif
+
+    ret = HI_UNF_HDMI_SetAttr(hHdmi, &stHdmiAttr);
+#if 0/*TODU: maybe need enable*/
+    HI_UNF_HDMI_HDCP_PARAM_S stHdcpParam;
+
+    if (stSinkCap.stHDCPSupport.bHdcp22Support == HI_TRUE)
+    {
+        stHdcpParam.bHdcpEnable = HI_TRUE;
+        stHdcpParam.enHdcpMode = HI_UNF_HDMI_HDCP_MODE_2_2;
+        HI_UNF_HDMI_HdcpEnable(HI_UNF_HDMI_ID_0, &stHdcpParam);
+    }
+    else if (stSinkCap.stHDCPSupport.bHdcp14Support == HI_TRUE)
+    {
+        //HIADP_HDMI_SetHDCPKey(HI_UNF_HDMI_ID_0);
+        stHdcpParam.bHdcpEnable = HI_TRUE;
+        stHdcpParam.enHdcpMode = HI_UNF_HDMI_HDCP_MODE_1_4;
+        HI_UNF_HDMI_HdcpEnable(HI_UNF_HDMI_ID_0, &stHdcpParam);
+    }
+#endif
+    /* HI_UNF_HDMI_SetAttr must before HI_UNF_HDMI_Start! */
+    ret = HI_UNF_HDMI_Start(hHdmi);
+
+    HDMI_PrintAttr(&stHdmiAttr);
+
+    return;
+}
+
+HI_VOID HDMI_UnPlug_Proc(HI_VOID *pPrivateData)
+{
+    HDMI_ARGS_S     *pArgs  = (HDMI_ARGS_S*)pPrivateData;
+    HI_UNF_HDMI_ID_E       hHdmi   =  pArgs->enHdmi;
+
+    sample_common_printf("\n --- Get HDMI event: UnPlug. --- \n");
+    HI_UNF_HDMI_Stop(hHdmi);
+#if defined(CHIP_TYPE_hi3798mv310) || defined(HI_BOOT_HOMOLOGOUS_SUPPORT)
+    {
+        HI_UNF_DISP_INTF_S          DispIntf;
+
+        DispIntf.enIntfType = HI_UNF_DISP_INTF_TYPE_CVBS;
+        DispIntf.unIntf.stCVBS.u8Dac = HI_DAC_CVBS;
+        sample_common_printf("switch to cvbs output\n");
+        if (s_bFirstTiming)
+        {
+            s_bFirstTiming = HI_FALSE;
+            HI_UNF_DISP_GetFormat(HI_UNF_DISPLAY0, &s_enCvbsFormat);
+            HI_UNF_DISP_GetFormat(HI_UNF_DISPLAY1, &s_enHdmiFormat);
+            HI_UNF_DISP_DetachIntf(HI_UNF_DISPLAY0, &DispIntf, 1);
+            HI_UNF_DISP_AttachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+        }
+        else
+        {
+            HI_UNF_DISP_AttachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+            HI_UNF_DISP_SetFormat(HI_UNF_DISPLAY1, s_enCvbsFormat);
+            //HI_UNF_DISP_SetHDRType(HI_UNF_DISPLAY1, HI_UNF_DISP_HDR_TYPE_NONE);
+        }
+    }
+#endif
+    return;
+}
+
+static HI_U32 HDCPFailCount = 0;
+
+HI_VOID HDMI_HdcpFail_Proc(HI_VOID *pPrivateData)
+{
+    HI_UNF_HDMI_STATUS_S        stHdmiStatus;
+    HDMI_ARGS_S                 *pArgs  = (HDMI_ARGS_S*)pPrivateData;
+    HI_UNF_HDMI_ID_E            hHdmi   =  pArgs->enHdmi;
+    HI_U32                      u32Ret  = HI_FAILURE;
+
+    memset(&stHdmiStatus, 0, sizeof(HI_UNF_HDMI_STATUS_S));
+    u32Ret = HI_UNF_HDMI_GetStatus(hHdmi, &stHdmiStatus);
+    if(u32Ret != HI_SUCCESS)
+    {
+        sample_common_printf("get hdmi status failed! \n");
+    }
+#ifdef HI_HDCP_SUPPORT
+#if defined(HI_HDMI_SUPPORT_2_0)
+    {
+        HI_UNF_HDCP_STATUS_S        stHdcpStatus ;
+        HI_UNF_HDMI_GetHdcpStatus(hHdmi,&stHdcpStatus );
+    	sample_common_printf("\nSTATUS:bHdcpEnable=%d,enHdcpVersion=%d,enHdcpErrCode=%d\n\n",
+            stHdcpStatus.bHdcpEnable,stHdcpStatus.enHdcpVersion,stHdcpStatus.enHdcpErrCode);
+    }
+#endif
+#endif
+    sample_common_printf("\n --- Get HDMI event: HDCP_FAIL, version(%d). --- \n", stHdmiStatus.enHDCPVersion);
+    HDCPFailCount ++ ;
+    if(HDCPFailCount >= 50)
+    {
+        HDCPFailCount = 0;
+        sample_common_printf("\nWarrning:Customer need to deal with HDCP Fail!!!!!!\n");
+    }
+#if 0
+    HI_UNF_HDMI_GetAttr(0, &stHdmiAttr);
+
+    stHdmiAttr.bHDCPEnable = HI_FALSE;
+
+    HI_UNF_HDMI_SetAttr(0, &stHdmiAttr);
+#endif
+    return;
+}
+
+HI_VOID HDMI_HdcpSuccess_Proc(HI_VOID *pPrivateData)
+{
+    HI_UNF_HDMI_STATUS_S        stHdmiStatus;
+    HDMI_ARGS_S                 *pArgs  = (HDMI_ARGS_S*)pPrivateData;
+    HI_UNF_HDMI_ID_E            hHdmi   =  pArgs->enHdmi;
+    HI_U32                      u32Ret  = HI_FAILURE;
+
+    memset(&stHdmiStatus, 0, sizeof(HI_UNF_HDMI_STATUS_S));
+    u32Ret = HI_UNF_HDMI_GetStatus(hHdmi, &stHdmiStatus);
+    if(u32Ret != HI_SUCCESS)
+    {
+        sample_common_printf("get hdmi status failed! \n");
+    }
+#ifdef HI_HDCP_SUPPORT
+#if defined(HI_HDMI_SUPPORT_2_0)
+    {
+        HI_UNF_HDCP_STATUS_S        stHdcpStatus ;
+        HI_UNF_HDMI_GetHdcpStatus(hHdmi,&stHdcpStatus );
+        sample_common_printf("\nSTATUS:bHdcpEnable=%d,enHdcpVersion=%d,enHdcpErrCode=%d\n\n",
+            stHdcpStatus.bHdcpEnable,stHdcpStatus.enHdcpVersion,stHdcpStatus.enHdcpErrCode);
+    }
+#endif
+#endif
+
+    sample_common_printf("\n --- Get HDMI event: HDCP_SUCCESS, version(%d) --- \n", stHdmiStatus.enHDCPVersion);
+    return;
+}
+
+HI_VOID HDMI_Event_Proc(HI_UNF_HDMI_EVENT_TYPE_E event, HI_VOID *pPrivateData)
+{
+    switch (event)
+    {
+        case HI_UNF_HDMI_EVENT_HOTPLUG:
+            HDMI_HotPlug_Proc(pPrivateData);
+            break;
+        case HI_UNF_HDMI_EVENT_NO_PLUG:
+            HDMI_UnPlug_Proc(pPrivateData);
+            break;
+        case HI_UNF_HDMI_EVENT_EDID_FAIL:
+            break;
+        case HI_UNF_HDMI_EVENT_HDCP_FAIL:
+            HDMI_HdcpFail_Proc(pPrivateData);
+            break;
+        case HI_UNF_HDMI_EVENT_HDCP_SUCCESS:
+            HDMI_HdcpSuccess_Proc(pPrivateData);
+            break;
+        case HI_UNF_HDMI_EVENT_RSEN_CONNECT:
+            //printf("HI_UNF_HDMI_EVENT_RSEN_CONNECT**********\n");
+            break;
+        case HI_UNF_HDMI_EVENT_RSEN_DISCONNECT:
+            //printf("HI_UNF_HDMI_EVENT_RSEN_DISCONNECT**********\n");
+            break;
+        default:
+            break;
+    }
+    /* Private Usage */
+    if ((g_HDMIUserCallbackFlag == HI_TRUE) && (pfnHdmiUserCallback != NULL))
+    {
+        pfnHdmiUserCallback(event, NULL);
+    }
+
+    return;
+}
+
+#ifdef HI_HDCP_SUPPORT
+#define ENCRYPTED_HDCP_KEY_MAX_LEN  332
+
+HI_S32 HIADP_HDMI_SetHDCPKey(HI_UNF_HDMI_ID_E HDMIId)
+{
+    HI_S32                  Ret;
+    FILE                   *pKeyFile;
+    HI_U8                   Key[ENCRYPTED_HDCP_KEY_MAX_LEN];
+    HI_S32                  Len;
+    HI_UNF_HDMI_LOAD_KEY_S  LoadKey;
+
+    pKeyFile = fopen(pstencryptedHdcpKey, "rb");
+    if (HI_NULL == pKeyFile)
+    {
+        sample_common_printf("can't open key file %s\n", pstencryptedHdcpKey);
+        return HI_FAILURE;
+    }
+
+    Len = fread(Key, 1, ENCRYPTED_HDCP_KEY_MAX_LEN, pKeyFile);
+
+    fclose(pKeyFile);
+
+    if (Len != ENCRYPTED_HDCP_KEY_MAX_LEN)
+    {
+        sample_common_printf("%s is error key file!\n", pstencryptedHdcpKey);
+        return HI_FAILURE;
+    }
+
+    LoadKey.u32KeyLength = ENCRYPTED_HDCP_KEY_MAX_LEN;
+    LoadKey.pu8InputEncryptedKey = Key;
+
+    Ret = HI_UNF_HDMI_LoadHDCPKey(HDMIId, &LoadKey);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_HDMI_LoadHDCPKey failed 0x%x\n", Ret);
+        return HI_FAILURE;
+    }
+
+    sample_common_printf("Load HDCP Key: SUCCESS!!!\n");
+
+    return HI_SUCCESS;
+}
+#endif
+
+HI_S32 HIADP_HDMI_Init(HI_UNF_HDMI_ID_E enHDMIId)
+{
+    HI_S32 Ret = HI_FAILURE;
+    HI_UNF_HDMI_OPEN_PARA_S stOpenParam;
+    HI_UNF_HDMI_DELAY_S  stDelay;
+
+    g_stHdmiArgs.enHdmi       = enHDMIId;
+
+    Ret = HI_UNF_HDMI_Init();
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("HI_UNF_HDMI_Init failed:%#x\n",Ret);
+        return HI_FAILURE;
+    }
+
+#ifdef HI_HDCP_SUPPORT
+    Ret = HIADP_HDMI_SetHDCPKey(enHDMIId);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("Set hdcp error\n");
+    }
+#endif
+
+    HI_UNF_HDMI_GetDelay(0,&stDelay);
+    stDelay.bForceFmtDelay = HI_TRUE;
+    stDelay.bForceMuteDelay = HI_TRUE;
+
+#if defined(CHIP_TYPE_hi3798mv200) || defined(CHIP_TYPE_hi3798mv300)
+    stDelay.u32FmtDelay  = 1;
+    stDelay.u32MuteDelay = 50;
+#else
+    stDelay.u32FmtDelay = 500;
+    stDelay.u32MuteDelay = 120;
+#endif
+    HI_UNF_HDMI_SetDelay(0,&stDelay);
+
+    g_stCallbackFunc.pfnHdmiEventCallback = HDMI_Event_Proc;
+    g_stCallbackFunc.pPrivateData = &g_stHdmiArgs;
+
+    Ret = HI_UNF_HDMI_RegCallbackFunc(enHDMIId, &g_stCallbackFunc);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("hdmi reg failed:%#x\n",Ret);
+        HI_UNF_HDMI_DeInit();
+        return HI_FAILURE;
+    }
+
+    stOpenParam.enDefaultMode = g_enDefaultMode;//HI_UNF_HDMI_FORCE_NULL;
+    Ret = HI_UNF_HDMI_Open(enHDMIId, &stOpenParam);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_HDMI_Open failed:%#x\n",Ret);
+        HI_UNF_HDMI_DeInit();
+        return HI_FAILURE;
+    }
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_HDMI_DeInit(HI_UNF_HDMI_ID_E enHDMIId)
+{
+//    HI_UNF_HDMI_Stop(enHDMIId);
+
+    HI_UNF_HDMI_Close(enHDMIId);
+
+    HI_UNF_HDMI_UnRegCallbackFunc(enHDMIId, &g_stCallbackFunc);
+
+    HI_UNF_HDMI_DeInit();
+
+    return HI_SUCCESS;
+}
+
+HI_VOID HDMI_SaveFmt(HI_UNF_ENC_FMT_E enFmt)
+{
+#if defined(CHIP_TYPE_hi3798mv310) || defined(HI_BOOT_HOMOLOGOUS_SUPPORT)
+    if (enFmt < HI_UNF_ENC_FMT_BUTT)
+    {
+        s_enHdmiFormat = enFmt;
+    }
+    else
+    {
+        s_enHdmiFormat = HI_UNF_ENC_FMT_720P_60;
+    }
+#endif
+    return ;
+}
+
+
diff -uNr a/hisi/hi_adp_ini.c b/hisi/hi_adp_ini.c
--- a/hisi/hi_adp_ini.c	1970-01-01 01:00:00.000000000 +0100
+++ b/hisi/hi_adp_ini.c	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,219 @@
+/******************************************************************************
+
+  Copyright (C), 2011-2018. Hisilicon Technologies Co., Ltd. All rights reserved.
+
+******************************************************************************
+    File Name     : hi_adp_ini.c
+    Version       : Initial Draft
+    Author        : Device Chipset STB Development Dept
+    Created       : 2018/08/23
+    Description   : Read value from ini file.
+******************************************************************************/
+
+#include <assert.h>
+#include <ctype.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "hi_adp_ini.h"
+
+static HI_CHAR *skiphead(const HI_CHAR *str)
+{
+    while (*str != '\0' && *str <= ' ')
+    {
+        str++;
+    }
+    return (HI_CHAR *)str;
+}
+
+static HI_CHAR *skiptail(const HI_CHAR *str, const HI_CHAR *base)
+{
+    while (str > base && *(str-1) <= ' ')
+    {
+        str--;
+    }
+    return (HI_CHAR *)str;
+}
+
+static HI_CHAR *striptail(HI_CHAR *str)
+{
+    HI_CHAR *p = skiptail(strchr(str, '\0'), str);
+    if(p != NULL)
+    {
+        *p = '\0';
+    }
+    return str;
+}
+
+static HI_CHAR * copystring(HI_CHAR *dest, const HI_CHAR *source, HI_U32 len)
+{
+    HI_U32 i;
+
+    for (i = 0; i < len - 1 && source[i] != '\0'; i++)
+    {
+        dest[i] = source[i];
+    }
+
+    dest[i] = '\0';
+
+    return dest;
+}
+
+static HI_CHAR *cleanstring(HI_CHAR *string)
+{
+    HI_S32 isstring;
+    HI_CHAR *p;
+
+    isstring = 0;
+    for (p = string; *p != '\0' && ((*p != ';' && *p != '#') || isstring); p++)
+    {
+        if (*p == '"')
+        {
+            if (*(p + 1) == '"')
+            {
+                p++;
+            }
+            else
+            {
+                isstring = !isstring;
+            }
+        }
+        else if (*p == '\\' && *(p + 1) == '"')
+        {
+            p++;
+        }
+    }
+
+    *p = '\0';
+    striptail(string);
+    if (*string == '"' && (p = strchr(string, '\0')) != NULL && *(p - 1) == '"')
+    {
+        string++;
+        *--p = '\0';
+    }
+
+    return string;
+}
+
+static HI_S32 getstring(FILE **fp, const HI_CHAR *section, const HI_CHAR *key, HI_CHAR *buffer, HI_S32 size)
+{
+    HI_CHAR *start, *end;
+    HI_S32 len;
+    HI_CHAR buf[HI_INI_BUFSIZE];
+
+
+    len = (section != NULL) ? strlen(section) : 0;
+
+    if (len > 0)
+    {
+        do
+        {
+            if (!HIADP_INI_Read(buf, HI_INI_BUFSIZE, fp))
+            {
+                return 0;
+            }
+            start = skiphead(buf);
+            end = strchr(start, ']');
+        } while (*start != '[' || end == NULL || ((HI_S32)(end-start-1) != len || strncasecmp(start+1,section,len) != 0));
+    }
+
+    len = (key != NULL) ? (HI_S32)strlen(key) : 0;
+    do
+    {
+        if (!HIADP_INI_Read(buf,HI_INI_BUFSIZE,fp) || *(start = skiphead(buf)) == '[')
+        {
+            return 0;
+        }
+        start = skiphead(buf);
+        end = strchr(start, '=');
+        if (end == NULL)
+        {
+            end = strchr(start, ':');
+        }
+    } while (*start == ';' || *start == '#' || end == NULL || ((HI_S32)(skiptail(end,start)-start) != len || strncasecmp(start,key,len) != 0));
+
+    start = skiphead(end + 1);
+    start = cleanstring(start);
+    copystring(buffer, start, size);
+
+    return 1;
+}
+
+HI_S32 HIADP_INI_Gets(const HI_CHAR *section, const HI_CHAR *key, const HI_CHAR *default_value,
+             HI_CHAR *buffer, HI_S32 size, const HI_CHAR *file)
+{
+    FILE *fp;
+    HI_S32 Ret = 0;
+
+    if (buffer == NULL || size <= 0 || key == NULL)
+    {
+        return 0;
+    }
+
+    if (HIADP_INI_OpenRead(file, &fp))
+    {
+        Ret = getstring(&fp, section, key, buffer, size);
+        (void)HIADP_INI_Close(&fp);
+    }
+    else if (HIADP_INI_OpenRead(basename(file), &fp))
+    {
+        Ret = getstring(&fp, section, key, buffer, size);
+        (void)HIADP_INI_Close(&fp);
+    }
+    else
+    {
+        printf("open file:%s or %s failed!\n",file,basename(file));
+        return HI_FAILURE;
+    }
+
+    if (!Ret)
+    {
+        copystring(buffer, default_value, size);
+    }
+
+    return strlen(buffer);
+}
+
+long HIADP_INI_Getl(const HI_CHAR *section, const HI_CHAR *key, long default_value, const HI_CHAR *file)
+{
+    HI_CHAR buf[64];
+
+    HI_S32 len = HIADP_INI_Gets(section, key, "", buf, sizeof(buf)/sizeof(buf[0]), file);
+    return (len == 0) ? default_value
+                    : ((len >= 2 && toupper(buf[1]) == 'X') ? strtol(buf, NULL, 16)
+                                                            : strtol(buf, NULL, 10));
+}
+
+float HIADP_INI_Getf(const HI_CHAR *section, const HI_CHAR *key, float default_value, const HI_CHAR *file)
+{
+    HI_CHAR buf[64];
+
+    HI_S32 len = HIADP_INI_Gets(section, key, "", buf, sizeof(buf)/sizeof(buf[0]), file);
+    return (len == 0) ? default_value : HIADP_INI_Atof(buf);
+}
+
+HI_BOOL HIADP_INI_Getbool(const HI_CHAR *section, const HI_CHAR *key, HI_BOOL default_value, const HI_CHAR *file)
+{
+    HI_CHAR buf[2];
+    HI_S32 Ret;
+
+    HIADP_INI_Gets(section, key, "", buf, sizeof(buf)/sizeof(buf[0]), file);
+
+    buf[0] = (HI_CHAR)toupper(buf[0]);
+
+    if (buf[0] == 'Y' || buf[0] == '1' || buf[0] == 'T')
+    {
+        Ret = HI_TRUE;
+    }
+    else if (buf[0] == 'N' || buf[0] == '0' || buf[0] == 'F')
+    {
+        Ret = HI_FALSE;
+    }
+    else
+    {
+        Ret = default_value;
+    }
+
+    return(Ret);
+}
+
diff -uNr a/hisi/hi_adp_mpi.c b/hisi/hi_adp_mpi.c
--- a/hisi/hi_adp_mpi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/hisi/hi_adp_mpi.c	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,1828 @@
+#include <string.h>
+#include <sys/time.h>
+
+#include "hi_unf_demux.h"
+#include "hi_unf_avplay.h"
+#include "hi_unf_common.h"
+#include "hi_unf_vo.h"
+#include "hi_unf_sound.h"
+#include "hi_unf_ai.h"
+#include "hi_common.h"
+#include "hi_unf_disp.h"
+#include "hi_unf_hdmi.h"
+#include "hi_audio_codec.h"
+#include "hi_error_mpi.h"
+#include "hi_unf_mce.h"
+#include "hi_unf_pdm.h"
+
+#include "hi_adp_mpi.h"
+#include "hi_adp.h"
+#include "hi_adp_data.h"
+#include "hi_adp_hdmi.h"
+#include "hi_adp_boardcfg.h"
+
+#include "HA.AUDIO.G711.codec.h"
+#include "HA.AUDIO.MP3.decode.h"
+#include "HA.AUDIO.MP2.decode.h"
+#include "HA.AUDIO.AAC.decode.h"
+#include "HA.AUDIO.DRA.decode.h"
+#include "HA.AUDIO.PCM.decode.h"
+#include "HA.AUDIO.WMA9STD.decode.h"
+#include "HA.AUDIO.AMRNB.codec.h"
+#include "HA.AUDIO.AMRWB.codec.h"
+#include "HA.AUDIO.TRUEHDPASSTHROUGH.decode.h"
+#include "HA.AUDIO.DOLBYTRUEHD.decode.h"
+#include "HA.AUDIO.DTSHD.decode.h"
+#if defined (DOLBYPLUS_HACODEC_SUPPORT)
+ #include "HA.AUDIO.DOLBYPLUS.decode.h"
+#endif
+#include "HA.AUDIO.AC3PASSTHROUGH.decode.h"
+#include "HA.AUDIO.DTSM6.decode.h"
+
+#include "HA.AUDIO.DTSPASSTHROUGH.decode.h"
+#include "HA.AUDIO.FFMPEG_DECODE.decode.h"
+#include "HA.AUDIO.AAC.encode.h"
+
+#include "HA.AUDIO.DOLBYMS12.decode.h"
+#include "HA.AUDIO.VOICE.codec.h"
+#include "HA.AUDIO.OPUS.codec.h"
+#include "HA.AUDIO.VORBIS.codec.h"
+#include "HA.AUDIO.CUSTOM.decode.h"
+
+#ifdef ANDROID
+#include <utils/Log.h>
+#include "hi_adp_osd.h"
+#endif
+
+#define MPI_DEMUX_NUM 5
+#define MPI_DEMUX_PLAY 0
+#define MPI_DEMUX_REC_0 1
+#define MPI_DEMUX_REC_1 2
+#define MPI_DEMUX_TIMETHIFT 3
+#define MPI_DEMUX_PLAYBACK 4
+
+/*
+big-endian pcm output format, if extword is 1, choose normal pcm decoder,
+                                            if extword is 2, choose wifidsp_lpcm decoder(Frame Header:0xA0,0x06)
+                                            if others, fail to decode.
+*/
+#define NORMAL_PCM_EXTWORD    1
+#define WIFIDSP_LPCM_EXTWORD  2
+
+
+HI_U8 u8DecOpenBuf[1024];
+HI_U8 u8EncOpenBuf[1024];
+
+#if defined (DOLBYPLUS_HACODEC_SUPPORT)
+
+DOLBYPLUS_STREAM_INFO_S g_stDDpStreamInfo;
+
+/*dolby Dual Mono type control*/
+HI_U32  g_u32DolbyAcmod = 0;
+HI_BOOL g_bDrawChnBar = HI_TRUE;
+
+#endif
+
+#ifdef ANDROID
+static HI_HANDLE               g_hSurface;
+
+#define LOG_MAX_LEN 1024
+
+void LogPrint(const char *format, ...)
+{
+    char LogStr[LOG_MAX_LEN];
+    va_list args = {0};
+
+    va_start(args, format);
+    vsnprintf(LogStr, LOG_MAX_LEN, format, args);
+    va_end(args);
+    android_printLog(ANDROID_LOG_ERROR, "SAMPLE", "%s", LogStr);
+}
+#endif
+
+/************************************DISPLAY Common Interface*******************************/
+HI_S32 HIADP_Disp_StrToFmt(HI_CHAR *pszFmt)
+{
+    HI_UNF_ENC_FMT_E fmtReturn = HI_UNF_ENC_FMT_BUTT;
+
+    if (NULL == pszFmt)
+    {
+        return HI_UNF_ENC_FMT_BUTT;
+    }
+
+    if (0 == strcasecmp(pszFmt, "1080P_60"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_1080P_60;
+    }
+    else if (0 == strcasecmp(pszFmt, "1080P_50"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_1080P_50;
+    }
+    else if (0 == strcasecmp(pszFmt, "1080P_30"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_1080P_30;
+    }
+    else if (0 == strcasecmp(pszFmt, "1080P_25"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_1080P_25;
+    }
+    else if (0 == strcasecmp(pszFmt, "1080P_24"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_1080P_24;
+    }
+    else if (0 == strcasecmp(pszFmt, "1080i_60"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_1080i_60;
+    }
+    else if (0 == strcasecmp(pszFmt, "1080i_50"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_1080i_50;
+    }
+    else if (0 == strcasecmp(pszFmt, "720P_60"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_720P_60;
+    }
+    else if (0 == strcasecmp(pszFmt, "720P_50"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_720P_50;
+    }
+    else if (0 == strcasecmp(pszFmt, "576P_50"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_576P_50;
+    }
+    else if (0 == strcasecmp(pszFmt, "480P_60"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_480P_60;
+    }
+    else if (0 == strcasecmp(pszFmt, "PAL"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_PAL;
+    }
+    else if (0 == strcasecmp(pszFmt, "NTSC"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_NTSC;
+    }
+    else if (0 == strcasecmp(pszFmt, "1080P_24_FP"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_1080P_24_FRAME_PACKING;
+    }
+    else if (0 == strcasecmp(pszFmt, "720P_60_FP"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_720P_60_FRAME_PACKING;
+    }
+    else if (0 == strcasecmp(pszFmt, "720P_50_FP"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_720P_50_FRAME_PACKING;
+    }
+    else if (0 == strcasecmp(pszFmt, "2160P_24"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_3840X2160_24;
+    }
+    else if (0 == strcasecmp(pszFmt, "2160P_25"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_3840X2160_25;
+    }
+    else if (0 == strcasecmp(pszFmt, "2160P_30"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_3840X2160_30;
+    }
+    else if (0 == strcasecmp(pszFmt, "2160P_50"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_3840X2160_50;
+    }
+    else if (0 == strcasecmp(pszFmt, "2160P_60"))
+    {
+        fmtReturn = HI_UNF_ENC_FMT_3840X2160_60;
+    }
+    else
+    {
+        fmtReturn = HI_UNF_ENC_FMT_720P_50;
+        sample_common_printf("\n!!! Can NOT match format, set format to is '720P_50'/%d.\n\n", HI_UNF_ENC_FMT_720P_50);
+    }
+
+    return fmtReturn;
+}
+
+#ifdef HI_BOOT_HOMOLOGOUS_SUPPORT
+HI_S32 hi_adp_disp_init_mutex(HI_UNF_ENC_FMT_E input_format)
+{
+    HI_S32                      ret;
+    HI_UNF_DISP_BG_COLOR_S      BgColor;
+    HI_UNF_DISP_INTF_S          DispIntf;
+    HI_UNF_DISP_OFFSET_S        offset;
+    HI_UNF_ENC_FMT_E            set_format = HI_UNF_ENC_FMT_PAL;
+    HI_UNF_HDMI_STATUS_S        get_hdmi_status = {0};
+
+    ret = HI_UNF_DISP_Init();
+    if (ret != HI_SUCCESS) {
+        sample_common_printf("HI_UNF_DISP_Init failed 0x%x\n", ret);
+        return ret;
+    }
+
+    DispIntf.enIntfType = HI_UNF_DISP_INTF_TYPE_HDMI;
+    DispIntf.unIntf.enHdmi = HI_UNF_HDMI_ID_0;
+    ret = HI_UNF_DISP_AttachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+    if (ret != HI_SUCCESS) {
+        sample_common_printf("HI_UNF_DISP_AttachIntf hdmi failed 0x%x\n", ret);
+        HI_UNF_DISP_DeInit();
+        return ret;
+    }
+
+    ret = HIADP_HDMI_Init(HI_UNF_HDMI_ID_0);
+    if (ret != HI_SUCCESS) {
+        printf("get HIADP_HDMI_Init failed ! \n");
+    }
+
+    ret = HI_UNF_HDMI_GetStatus(HI_UNF_HDMI_ID_0, &get_hdmi_status);
+    if (ret != HI_SUCCESS) {
+        printf("get hdmi status failed ! \n");
+    }
+
+    if (get_hdmi_status.bConnected == HI_TRUE) {
+#ifdef HI_DAC_CVBS
+        DispIntf.enIntfType = HI_UNF_DISP_INTF_TYPE_CVBS;
+        DispIntf.unIntf.stCVBS.u8Dac = HI_DAC_CVBS;
+        ret = HI_UNF_DISP_DetachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+        if (ret != HI_SUCCESS) {
+            sample_common_printf("HI_UNF_DISP_AttachIntf cvbs failed 0x%x\n", ret);
+            HI_UNF_DISP_DeInit();
+            return ret;
+        }
+#endif
+        set_format = input_format;
+    }
+    else {
+#ifdef HI_DAC_CVBS
+        DispIntf.enIntfType = HI_UNF_DISP_INTF_TYPE_CVBS;
+        DispIntf.unIntf.stCVBS.u8Dac = HI_DAC_CVBS;
+        ret = HI_UNF_DISP_AttachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+        if (ret != HI_SUCCESS) {
+            sample_common_printf("HI_UNF_DISP_AttachIntf cvbs failed 0x%x\n", ret);
+            HI_UNF_DISP_DeInit();
+            return ret;
+        }
+#endif
+
+        switch (input_format) {
+            case HI_UNF_ENC_FMT_4096X2160_60 :
+            case HI_UNF_ENC_FMT_4096X2160_30 :
+            case HI_UNF_ENC_FMT_4096X2160_24 :
+            case HI_UNF_ENC_FMT_3840X2160_60 :
+            case HI_UNF_ENC_FMT_3840X2160_30 :
+            case HI_UNF_ENC_FMT_3840X2160_24 :
+            case HI_UNF_ENC_FMT_1080P_60 :
+            case HI_UNF_ENC_FMT_1080P_30 :
+            case HI_UNF_ENC_FMT_1080i_60 :
+            case HI_UNF_ENC_FMT_720P_60 :
+            case HI_UNF_ENC_FMT_480P_60 :
+            case HI_UNF_ENC_FMT_NTSC :
+                set_format = HI_UNF_ENC_FMT_NTSC;
+                break;
+
+            case HI_UNF_ENC_FMT_4096X2160_50 :
+            case HI_UNF_ENC_FMT_4096X2160_25 :
+            case HI_UNF_ENC_FMT_3840X2160_50 :
+            case HI_UNF_ENC_FMT_3840X2160_25 :
+            case HI_UNF_ENC_FMT_1080P_50 :
+            case HI_UNF_ENC_FMT_1080P_25 :
+            case HI_UNF_ENC_FMT_1080i_50 :
+            case HI_UNF_ENC_FMT_720P_50 :
+            case HI_UNF_ENC_FMT_576P_50 :
+            case HI_UNF_ENC_FMT_PAL :
+                set_format = HI_UNF_ENC_FMT_PAL;
+                break;
+
+            default:
+                break;
+        }
+    }
+
+    ret = HI_UNF_DISP_SetFormat(HI_UNF_DISPLAY1, set_format);
+    if (ret != HI_SUCCESS) {
+        sample_common_printf("HI_UNF_DISP_SetFormat DISPLAY1 0x%x failed 0x%x\n", input_format, ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return ret;
+    }
+
+    ret = HI_UNF_DISP_SetVirtualScreen(HI_UNF_DISPLAY1, 1280, 720);
+    if (ret != HI_SUCCESS) {
+        sample_common_printf("HI_UNF_DISP_SetVirtualScreen failed 0x%x\n", ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return ret;
+    }
+
+    offset.u32Left      = 0;
+    offset.u32Top       = 0;
+    offset.u32Right     = 0;
+    offset.u32Bottom    = 0;
+
+    ret = HI_UNF_DISP_SetScreenOffset(HI_UNF_DISPLAY1, &offset);
+    if (ret != HI_SUCCESS) {
+        sample_common_printf("HI_UNF_DISP_SetScreenOffset DISPLAY1 failed 0x%x\n", ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return ret;
+    }
+
+    BgColor.u8Red   = 0;
+    BgColor.u8Green = 0;
+    BgColor.u8Blue  = 0;
+
+    ret = HI_UNF_DISP_SetBgColor(HI_UNF_DISPLAY1, &BgColor);
+    if (ret != HI_SUCCESS) {
+        sample_common_printf("HI_UNF_DISP_SetBgColor failed 0x%x\n", ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return ret;
+    }
+
+    ret = HI_UNF_DISP_Open(HI_UNF_DISPLAY1);
+    if (ret != HI_SUCCESS) {
+        sample_common_printf("HI_UNF_DISP_Open DISPLAY1 failed 0x%x\n", ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return ret;
+    }
+    return HI_SUCCESS;
+}
+#endif
+
+HI_S32 HIADP_Disp_Init(HI_UNF_ENC_FMT_E enFormat)
+{
+    HI_S32                      Ret;
+    HI_UNF_DISP_BG_COLOR_S      BgColor;
+    HI_UNF_DISP_INTF_S          DispIntf;
+    HI_UNF_DISP_OFFSET_S        offset;
+    HI_UNF_ENC_FMT_E            SdFmt = HI_UNF_ENC_FMT_PAL;
+
+#if    defined(CHIP_TYPE_hi3798cv200) \
+    || defined(CHIP_TYPE_hi3798mv200) \
+    || defined(CHIP_TYPE_hi3796mv200) \
+    || defined(CHIP_TYPE_hi3716mv450)
+
+    HI_UNF_EDID_BASE_INFO_S     stSinkAttr;
+#endif
+
+    Ret = HI_UNF_DISP_Init();
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_Init failed 0x%x\n", Ret);
+        return Ret;
+    }
+
+    DispIntf.enIntfType = HI_UNF_DISP_INTF_TYPE_HDMI;
+    DispIntf.unIntf.enHdmi = HI_UNF_HDMI_ID_0;
+    Ret = HI_UNF_DISP_AttachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_AttachIntf hdmi failed 0x%x\n", Ret);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+#if defined(HI_DAC_YPBPR_Y) && defined(HI_DAC_YPBPR_PB) && defined(HI_DAC_YPBPR_PR)
+    DispIntf.enIntfType = HI_UNF_DISP_INTF_TYPE_YPBPR;
+    DispIntf.unIntf.stYPbPr.u8DacY  = HI_DAC_YPBPR_Y;
+    DispIntf.unIntf.stYPbPr.u8DacPb = HI_DAC_YPBPR_PB;
+    DispIntf.unIntf.stYPbPr.u8DacPr = HI_DAC_YPBPR_PR;
+    Ret = HI_UNF_DISP_AttachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_AttachIntf ypbpr failed 0x%x\n", Ret);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+#endif
+
+#if defined(HI_DAC_VGA_R) && defined(HI_DAC_VGA_G) && defined(HI_DAC_VGA_B)
+    DispIntf.enIntfType = HI_UNF_DISP_INTF_TYPE_VGA;
+    DispIntf.unIntf.stYPbPr.u8DacY  = HI_DAC_VGA_R;
+    DispIntf.unIntf.stYPbPr.u8DacPb = HI_DAC_VGA_G;
+    DispIntf.unIntf.stYPbPr.u8DacPr = HI_DAC_VGA_B;
+    Ret = HI_UNF_DISP_AttachIntf(HI_UNF_DISPLAY1, &DispIntf, 1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_AttachIntf VGA failed 0x%x\n", Ret);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+#endif
+
+#ifdef HI_DAC_CVBS
+    DispIntf.enIntfType = HI_UNF_DISP_INTF_TYPE_CVBS;
+    DispIntf.unIntf.stCVBS.u8Dac = HI_DAC_CVBS;
+    Ret = HI_UNF_DISP_AttachIntf(HI_UNF_DISPLAY0, &DispIntf, 1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_AttachIntf cvbs failed 0x%x\n", Ret);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+#endif
+
+    Ret = HI_UNF_DISP_Attach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_Attach failed 0x%x\n", Ret);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+    Ret = HI_UNF_DISP_SetFormat(HI_UNF_DISPLAY1, enFormat);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_SetFormat DISPLAY1 0x%x failed 0x%x\n", enFormat, Ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+    switch (enFormat)
+    {
+        case HI_UNF_ENC_FMT_4096X2160_60 :
+        case HI_UNF_ENC_FMT_4096X2160_30 :
+        case HI_UNF_ENC_FMT_4096X2160_24 :
+        case HI_UNF_ENC_FMT_3840X2160_60 :
+        case HI_UNF_ENC_FMT_3840X2160_30 :
+        case HI_UNF_ENC_FMT_3840X2160_24 :
+        case HI_UNF_ENC_FMT_1080P_60 :
+        case HI_UNF_ENC_FMT_1080P_30 :
+        case HI_UNF_ENC_FMT_1080i_60 :
+        case HI_UNF_ENC_FMT_720P_60 :
+        case HI_UNF_ENC_FMT_480P_60 :
+        case HI_UNF_ENC_FMT_NTSC :
+            SdFmt = HI_UNF_ENC_FMT_NTSC;
+            break;
+
+        case HI_UNF_ENC_FMT_4096X2160_50 :
+        case HI_UNF_ENC_FMT_4096X2160_25 :
+        case HI_UNF_ENC_FMT_3840X2160_50 :
+        case HI_UNF_ENC_FMT_3840X2160_25 :
+        case HI_UNF_ENC_FMT_1080P_50 :
+        case HI_UNF_ENC_FMT_1080P_25 :
+        case HI_UNF_ENC_FMT_1080i_50 :
+        case HI_UNF_ENC_FMT_720P_50 :
+        case HI_UNF_ENC_FMT_576P_50 :
+        case HI_UNF_ENC_FMT_PAL :
+            SdFmt = HI_UNF_ENC_FMT_PAL;
+            break;
+
+        default:
+            break;
+    }
+
+    Ret = HI_UNF_DISP_SetFormat(HI_UNF_DISPLAY0, SdFmt);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("HI_UNF_DISP_SetFormat DISPLAY0 0x%x failed 0x%x\n", SdFmt, Ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+#ifndef ANDROID
+    Ret = HI_UNF_DISP_SetVirtualScreen(HI_UNF_DISPLAY1, 1280, 720);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_SetVirtualScreen failed 0x%x\n", Ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+    offset.u32Left      = 0;
+    offset.u32Top       = 0;
+    offset.u32Right     = 0;
+    offset.u32Bottom    = 0;
+    /*set display1 screen offset*/
+    Ret = HI_UNF_DISP_SetScreenOffset(HI_UNF_DISPLAY1, &offset);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_SetScreenOffset DISPLAY1 failed 0x%x\n", Ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+    /*set display0 screen offset*/
+    Ret = HI_UNF_DISP_SetScreenOffset(HI_UNF_DISPLAY0, &offset);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_SetScreenOffset DISPLAY0 failed 0x%x\n", Ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+#endif
+
+    BgColor.u8Red   = 0;
+    BgColor.u8Green = 0;
+    BgColor.u8Blue  = 0;
+
+    Ret = HI_UNF_DISP_SetBgColor(HI_UNF_DISPLAY1, &BgColor);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_SetBgColor failed 0x%x\n", Ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+    Ret = HI_UNF_DISP_Open(HI_UNF_DISPLAY1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_Open DISPLAY1 failed 0x%x\n", Ret);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+    Ret = HI_UNF_DISP_Open(HI_UNF_DISPLAY0);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("HI_UNF_DISP_Open DISPLAY0 failed 0x%x\n", Ret);
+        HI_UNF_DISP_Close(HI_UNF_DISPLAY1);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+    Ret = HIADP_HDMI_Init(HI_UNF_HDMI_ID_0);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("HIADP_HDMI_Init failed 0x%x\n", Ret);
+        HI_UNF_DISP_Close(HI_UNF_DISPLAY0);
+        HI_UNF_DISP_Close(HI_UNF_DISPLAY1);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        return Ret;
+    }
+
+#if    defined(CHIP_TYPE_hi3798cv200) \
+    || defined(CHIP_TYPE_hi3798mv200) \
+    || defined(CHIP_TYPE_hi3796mv200) \
+    || defined(CHIP_TYPE_hi3716mv450)
+
+    Ret = HI_UNF_HDMI_GetSinkCapability(HI_UNF_HDMI_ID_0, &stSinkAttr);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_HDMI_GetSinkCapability failed:%#x.\n",Ret);
+    }
+    else
+    {
+        Ret = HI_UNF_DISP_SetSinkCapability(HI_UNF_DISPLAY1, &stSinkAttr);
+        if (HI_SUCCESS != Ret)
+        {
+            sample_common_printf("call HI_UNF_DISP_SetSinkCapability failed:%#x.\n",Ret);
+        }
+
+        Ret = HI_UNF_DISP_SetOutputColorSpace(HI_UNF_DISPLAY1, HI_UNF_DISP_COLOR_SPACE_AUTO);
+        if (HI_SUCCESS != Ret)
+        {
+            sample_common_printf("call HI_UNF_DISP_SetOutputColorSpace failed:%#x.\n",Ret);
+        }
+
+        Ret = HI_UNF_DISP_SetHDRType(HI_UNF_DISPLAY1, HI_UNF_DISP_HDR_TYPE_AUTO);
+        if (HI_SUCCESS != Ret)
+        {
+            sample_common_printf("call HI_UNF_DISP_SetHDRType: failed:%#x.\n",Ret);
+            return Ret;
+        }
+    }
+#endif
+
+#ifdef ANDROID
+    HIADP_SURFACE_ATTR_S    stSurAttr;
+    HI_UNF_PDM_DISP_PARAM_S stDispParam;
+
+    HIADP_OSD_Init();
+
+    Ret = HI_UNF_PDM_GetBaseParam(HI_UNF_PDM_BASEPARAM_DISP0, &stDispParam);
+    if (HI_SUCCESS != Ret)
+    {
+        stSurAttr.u32Width = 1280;
+        stSurAttr.u32Height = 720;
+    }
+    else
+    {
+        stSurAttr.u32Width = stDispParam.u32VirtScreenWidth;
+        stSurAttr.u32Height = stDispParam.u32VirtScreenHeight;
+    }
+
+    stSurAttr.enPixelFormat = HIADP_PF_8888;
+    Ret = HIADP_OSD_CreateSurface(&stSurAttr, &g_hSurface);
+    if (HI_SUCCESS != Ret)
+    {
+        HI_UNF_DISP_Close(HI_UNF_DISPLAY0);
+        HI_UNF_DISP_Close(HI_UNF_DISPLAY1);
+        HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+        HI_UNF_DISP_DeInit();
+        HIADP_OSD_DeInit();
+        return Ret;
+    }
+#endif
+
+    return HI_SUCCESS;
+}
+
+
+HI_S32 HIADP_Disp_DeInit(HI_VOID)
+{
+    HI_S32                      Ret;
+
+#ifdef ANDROID
+    Ret = HIADP_OSD_DestroySurface(g_hSurface);
+    if (HI_SUCCESS != Ret)
+    {
+        return Ret;
+    }
+
+    HIADP_OSD_DeInit();
+#endif
+
+    Ret = HI_UNF_DISP_Close(HI_UNF_DISPLAY1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_DISP_Close failed, Ret=%#x.\n", Ret);
+        return Ret;
+    }
+
+    Ret = HI_UNF_DISP_Close(HI_UNF_DISPLAY0);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_DISP_Close failed, Ret=%#x.\n", Ret);
+        return Ret;
+    }
+
+    Ret = HI_UNF_DISP_Detach(HI_UNF_DISPLAY0, HI_UNF_DISPLAY1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_DISP_Detach failed, Ret=%#x.\n", Ret);
+        return Ret;
+    }
+
+    Ret = HI_UNF_DISP_DeInit();
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_DISP_DeInit failed, Ret=%#x.\n", Ret);
+        return Ret;
+    }
+
+    HIADP_HDMI_DeInit(HI_UNF_HDMI_ID_0);
+
+    return HI_SUCCESS;
+}
+
+/****************************VO Common Interface********************************************/
+HI_S32 HIADP_VO_Init(HI_UNF_VO_DEV_MODE_E enDevMode)
+{
+    HI_S32             Ret;
+
+
+    Ret = HI_UNF_VO_Init(enDevMode);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_VO_Init failed.\n");
+        return Ret;
+    }
+
+#if 0
+    Ret = HI_UNF_VO_Open(HI_UNF_DISPLAY1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_VO_Open failed.\n");
+        HI_UNF_VO_DeInit();
+        return Ret;
+    }
+#endif
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_VO_CreatWin(HI_RECT_S *pstWinRect,HI_HANDLE *phWin)
+{
+    HI_S32 Ret;
+    HI_UNF_WINDOW_ATTR_S   WinAttr;
+    memset(&WinAttr, 0, sizeof(HI_UNF_WINDOW_ATTR_S));
+    WinAttr.enDisp = HI_UNF_DISPLAY1;
+    WinAttr.bVirtual = HI_FALSE;
+    WinAttr.stWinAspectAttr.enAspectCvrs = HI_UNF_VO_ASPECT_CVRS_IGNORE;
+    WinAttr.stWinAspectAttr.bUserDefAspectRatio = HI_FALSE;
+    WinAttr.stWinAspectAttr.u32UserAspectWidth  = 0;
+    WinAttr.stWinAspectAttr.u32UserAspectHeight = 0;
+    WinAttr.bUseCropRect = HI_FALSE;
+    WinAttr.stInputRect.s32X = 0;
+    WinAttr.stInputRect.s32Y = 0;
+    WinAttr.stInputRect.s32Width = 0;
+    WinAttr.stInputRect.s32Height = 0;
+
+    if (HI_NULL == pstWinRect)
+    {
+        memset(&WinAttr.stOutputRect, 0x0, sizeof(HI_RECT_S));
+    }
+    else
+    {
+        memcpy(&WinAttr.stOutputRect,pstWinRect,sizeof(HI_RECT_S));
+    }
+
+    Ret = HI_UNF_VO_CreateWindow(&WinAttr, phWin);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_VO_CreateWindow failed.\n");
+        return Ret;
+    }
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_VO_CreatWinExt(HI_RECT_S *pstWinRect,HI_HANDLE *phWin,HI_BOOL bVirtScreen)
+{
+    HI_S32 Ret;
+    HI_UNF_WINDOW_ATTR_S   WinAttr;
+    memset(&WinAttr, 0, sizeof(HI_UNF_WINDOW_ATTR_S));
+    WinAttr.enDisp = HI_UNF_DISPLAY1;
+    WinAttr.bVirtual = HI_FALSE;
+    WinAttr.stWinAspectAttr.enAspectCvrs = HI_UNF_VO_ASPECT_CVRS_IGNORE;
+    WinAttr.stWinAspectAttr.bUserDefAspectRatio = HI_FALSE;
+    WinAttr.stWinAspectAttr.u32UserAspectWidth  = 0;
+    WinAttr.stWinAspectAttr.u32UserAspectHeight = 0;
+    WinAttr.bUseCropRect = HI_FALSE;
+    WinAttr.stInputRect.s32X = 0;
+    WinAttr.stInputRect.s32Y = 0;
+    WinAttr.stInputRect.s32Width = 0;
+    WinAttr.stInputRect.s32Height = 0;
+
+    if (HI_NULL == pstWinRect)
+    {
+        memset(&WinAttr.stOutputRect, 0x0, sizeof(HI_RECT_S));
+    }
+    else
+    {
+        memcpy(&WinAttr.stOutputRect,pstWinRect,sizeof(HI_RECT_S));
+    }
+
+    Ret =  HI_UNF_VO_CreateWindowExt(&WinAttr, phWin, bVirtScreen);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_VO_CreateWindowExt failed.\n");
+        return Ret;
+    }
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_VO_DeInit()
+{
+    HI_S32         Ret;
+
+#if 0
+    Ret = HI_UNF_VO_Close(HI_UNF_DISPLAY1);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_VO_Close failed.\n");
+        return Ret;
+    }
+#endif
+    Ret = HI_UNF_VO_DeInit();
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_VO_DeInit failed.\n");
+        return Ret;
+    }
+
+    return HI_SUCCESS;
+}
+
+/*****************************************SOUND Common Interface************************************/
+HI_S32 HIADP_Snd_Init(HI_VOID)
+{
+    HI_S32                  Ret;
+    HI_UNF_SND_ATTR_S       stAttr;
+
+    Ret = HI_UNF_SND_Init();
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_SND_Init failed.\n");
+        return Ret;
+    }
+    Ret = HI_UNF_SND_GetDefaultOpenAttr(HI_UNF_SND_0, &stAttr);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_SND_GetDefaultOpenAttr failed.\n");
+        return Ret;
+    }
+
+    Ret = HI_UNF_SND_Open(HI_UNF_SND_0, &stAttr);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_SND_Open failed.\n");
+        return Ret;
+    }
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_Snd_DeInit(HI_VOID)
+{
+    HI_S32                  Ret;
+
+    Ret = HI_UNF_SND_Close(HI_UNF_SND_0);
+    if (Ret != HI_SUCCESS )
+    {
+        sample_common_printf("call HI_UNF_SND_Close failed.\n");
+        return Ret;
+    }
+
+    Ret = HI_UNF_SND_DeInit();
+    if (Ret != HI_SUCCESS )
+    {
+        sample_common_printf("call HI_UNF_SND_DeInit failed.\n");
+        return Ret;
+    }
+
+    return HI_SUCCESS;
+}
+
+#ifdef HI_AUDIO_AI_SUPPORT
+/*****************************************AI Common Interface************************************/
+HI_S32 HIADP_AI_Init(HI_UNF_AI_E enAISrc, HI_HANDLE *pAIHandle, HI_HANDLE *pTrackSlave, HI_HANDLE *pATrackVir)
+{
+    HI_S32                  Ret;
+    HI_UNF_AI_ATTR_S        stAitAttr = {0};
+    HI_UNF_AUDIOTRACK_ATTR_S  stTrackAttr;
+
+    Ret = HI_UNF_AI_Init();
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_AI_Init failed.\n");
+    }
+
+    Ret = HI_UNF_AI_GetDefaultAttr(enAISrc,&stAitAttr);
+    stAitAttr.u32PcmFrameMaxNum = 8;
+    if(HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_AI_GetDefaultAttr Failed \n");
+        return Ret;
+    }
+
+    Ret = HI_UNF_AI_Create(enAISrc, &stAitAttr, pAIHandle);
+    if(HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_AI_Create Failed \n");
+        return Ret;
+    }
+
+
+    Ret = HI_UNF_SND_GetDefaultTrackAttr(HI_UNF_SND_TRACK_TYPE_SLAVE, &stTrackAttr);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_SND_GetDefaultTrackAttr failed.\n");
+        return Ret;
+    }
+    Ret = HI_UNF_SND_CreateTrack(HI_UNF_SND_0,&stTrackAttr, pTrackSlave);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_SND_CreateTrack failed.\n");
+        return Ret;
+    }
+
+    Ret = HI_UNF_SND_Attach(*pTrackSlave, *pAIHandle);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_SND_Attach failed.\n");
+        return Ret;
+    }
+
+    Ret = HI_UNF_SND_GetDefaultTrackAttr(HI_UNF_SND_TRACK_TYPE_VIRTUAL, &stTrackAttr);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_SND_GetDefaultTrackAttr failed.\n");
+        return Ret;
+    }
+
+    Ret = HI_UNF_SND_CreateTrack(HI_UNF_SND_0,&stTrackAttr,pATrackVir);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_SND_CreateTrack failed.\n");
+        return Ret;
+    }
+
+    Ret = HI_UNF_SND_Attach(*pATrackVir, *pAIHandle);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_SND_Attach failed.\n");
+        return Ret;
+    }
+
+    Ret = HI_UNF_AI_SetEnable(*pAIHandle, HI_TRUE);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_AI_SetEnable failed.\n");
+        return Ret;
+    }
+
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_AI_DeInit(HI_HANDLE hAI, HI_HANDLE hAISlave, HI_HANDLE hAIVir)
+{
+    HI_S32                  Ret;
+
+    Ret = HI_UNF_AI_SetEnable(hAI, HI_FALSE);
+    if (Ret != HI_SUCCESS )
+    {
+        sample_common_printf("call HI_UNF_AI_SetEnable failed.\n");
+        return Ret;
+    }
+
+    HI_UNF_SND_Detach(hAIVir, hAI);
+    HI_UNF_SND_DestroyTrack(hAIVir);
+    HI_UNF_SND_Detach(hAISlave, hAI);
+    HI_UNF_SND_DestroyTrack(hAISlave);
+
+    HI_UNF_AI_Destroy(hAI);
+    if (Ret != HI_SUCCESS )
+    {
+        sample_common_printf("call HI_UNF_AI_Destroy failed.\n");
+        return Ret;
+    }
+
+    HI_UNF_AI_DeInit();
+    if (Ret != HI_SUCCESS )
+    {
+        sample_common_printf("call HI_UNF_AI_DeInit failed.\n");
+        return Ret;
+    }
+
+    return HI_SUCCESS;
+}
+#endif
+#if 0  //v1r3
+HI_S32 HIADP_Snd_RegAefAuthLib()
+{
+    HI_S32 Ret = HI_SUCCESS;
+
+    Ret = HI_UNF_SND_RegisterAefAuthLib("libHA.AUDIO.SRS.effect.auth.so");
+
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("\n\n!!! some audio effect authorize lib NOT found. you may NOT able to realize some audio effect process.\n\n");
+    }
+
+    return HI_SUCCESS;
+}
+#endif
+
+/*
+HI_S32 HIADP_AVPlay_RegADecLib()
+{
+    HI_S32 Ret = HI_SUCCESS;
+
+    Ret = HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.AMRWB.codec.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.MP3.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.MP2.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.AAC.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.DOLBYTRUEHD.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.TRUEHDPASSTHROUGH.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.AMRNB.codec.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.COOK.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.VOICE.codec.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.G711.codec.so");
+#ifdef DOLBYPLUS_HACODEC_SUPPORT
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.DOLBYPLUS.decode.so");
+#endif
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.DTSHD.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.DTSM6.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.DTSPASSTHROUGH.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.AC3PASSTHROUGH.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.PCM.decode.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.OPUS.codec.so");
+    Ret |= HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.VORBIS.codec.so");
+
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("\n\n!!! some audio codec NOT found. you may NOT able to decode some audio type.\n\n");
+    }
+
+    return HI_SUCCESS;
+}
+*/
+
+HI_S32 HIADP_AVPlay_RegADecLib_perso_two()
+{
+    HI_S32 ret;
+
+    if ( HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.FFMPEG_DTS.decode.so") )
+        sample_common_printf("!!! libHA.AUDIO.FFMPEG_DTS.decode.so failed.\n");
+    else
+        sample_common_printf("!!! libHA.AUDIO.FFMPEG_DTS.decode.so ok.\n");
+
+    if ( HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.FFMPEG_EAC3.decode.so") )
+    {
+        sample_common_printf("!!! libHA.AUDIO.FFMPEG_EAC3.decode.so failed.\n");
+        ret = HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.FFMPEG_TRUEHD.decode.so");
+        if ( !ret )
+            goto LABEL_8;
+    }
+    else
+    {
+        sample_common_printf("!!! libHA.AUDIO.FFMPEG_EAC3.decode.so ok.\n");
+        ret = HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.FFMPEG_TRUEHD.decode.so");
+        if ( !ret )
+        {
+LABEL_8:
+            sample_common_printf("!!! libHA.AUDIO.FFMPEG_TRUEHD.decode.so ok.\n");
+            return ret;
+        }
+    }
+    sample_common_printf("!!! libHA.AUDIO.FFMPEG_TRUEHD.decode.so failed.\n");
+    return ret;
+}
+
+
+HI_S32 HIADP_AVPlay_RegADecLib()
+{
+    /*
+        if ( HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.FFMPEG_ADEC.decode.so") )
+            sample_common_printf("!!! libHA.AUDIO.FFMPEG_ADEC.codec.so failed.\n");
+        else
+            sample_common_printf("!!! libHA.AUDIO.FFMPEG_ADEC.codec.so ok.\n");
+    */
+    if ( HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.MP3.decode.so") )
+        sample_common_printf("!!! libHA.AUDIO.MP3.codec.so failed.\n");
+    else
+        sample_common_printf("!!! libHA.AUDIO.MP3.codec.so ok.\n");
+
+    if ( HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.MP2.decode.so") )
+        sample_common_printf("!!! libHA.AUDIO.MP2.codec.so failed.\n");
+    else
+        sample_common_printf("!!! libHA.AUDIO.MP2.codec.so ok.\n");
+
+    if ( HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.AAC.decode.so") )
+        sample_common_printf("!!! libHA.AUDIO.AAC.codec.so failed.\n");
+    else
+        sample_common_printf("!!! libHA.AUDIO.AAC.codec.so ok.\n");
+
+    if ( HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.DTSPASSTHROUGH.decode.so") )
+        sample_common_printf("!!! libHA.AUDIO.DTSPASSTHROUGH.decode.so failed.\n");
+    else
+        sample_common_printf("!!! libHA.AUDIO.DTSPASSTHROUGH.decode.so ok.\n");
+
+    if ( HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.AC3PASSTHROUGH.decode.so") )
+        sample_common_printf("!!! libHA.AUDIO.AC3PASSTHROUGH.decode.so failed.\n");
+    else
+        sample_common_printf("!!! libHA.AUDIO.AC3PASSTHROUGH.decode.so ok.\n");
+
+    if ( HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.TRUEHDPASSTHROUGH.decode.so") )
+        sample_common_printf("!!! libHA.AUDIO.TRUEHDPASSTHROUGH.decode.so failed.\n");
+    else
+        sample_common_printf("!!! libHA.AUDIO.TRUEHDPASSTHROUGH.decode.so ok.\n");
+
+    if ( HI_UNF_AVPLAY_RegisterAcodecLib("libHA.AUDIO.PCM.decode.so") )
+        sample_common_printf("!!! libHA.AUDIO.PCM.decode.so failed.\n");
+    else
+        sample_common_printf("!!! libHA.AUDIO.PCM.decode.so ok.\n");
+
+
+    HIADP_AVPlay_RegADecLib_perso_two();
+    return HI_SUCCESS;
+}
+HI_S32 HIADP_AVPlay_Init()
+{
+    HI_S32 Ret;
+    Ret = HIADP_AVPlay_RegADecLib();
+    Ret |= HI_UNF_AVPLAY_Init();
+    return Ret;
+}
+
+HI_S32 HIADP_AVPlay_Create(HI_HANDLE *avplay,
+                                 HI_U32 u32DemuxId,
+                                 HI_UNF_AVPLAY_STREAM_TYPE_E streamtype,
+                                 HI_UNF_VCODEC_CAP_LEVEL_E vdeccap,
+                                 HI_U32 channelflag)
+{
+    HI_UNF_AVPLAY_ATTR_S attr;
+    HI_HANDLE avhandle;
+    HI_UNF_AVPLAY_OPEN_OPT_S maxCapbility;
+
+    if(avplay == HI_NULL)
+        return HI_FAILURE;
+
+    if ((u32DemuxId != MPI_DEMUX_PLAY) && (u32DemuxId != MPI_DEMUX_PLAYBACK))
+    {
+        sample_common_printf("%d is not a play demux , please select play demux \n", u32DemuxId);
+        return HI_FAILURE;
+    }
+
+    if(streamtype >= HI_UNF_AVPLAY_STREAM_TYPE_BUTT)
+        return HI_FAILURE;
+
+    if(vdeccap >= HI_UNF_VCODEC_CAP_LEVEL_BUTT)
+        return HI_FAILURE;
+
+    HIAPI_RUN_RETURN(HI_UNF_AVPLAY_GetDefaultConfig(&attr, streamtype));
+
+    attr.u32DemuxId = u32DemuxId;
+    attr.stStreamAttr.u32VidBufSize = 0x300000;
+    HIAPI_RUN_RETURN(HI_UNF_AVPLAY_Create(&attr, &avhandle));
+    maxCapbility.enDecType = HI_UNF_VCODEC_DEC_TYPE_NORMAL;
+    maxCapbility.enCapLevel = vdeccap;
+    maxCapbility.enProtocolLevel = HI_UNF_VCODEC_PRTCL_LEVEL_H264;
+
+    if(channelflag&HI_UNF_AVPLAY_MEDIA_CHAN_AUD)
+        HIAPI_RUN_RETURN(HI_UNF_AVPLAY_ChnOpen(avhandle, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, NULL));
+
+    if(channelflag&HI_UNF_AVPLAY_MEDIA_CHAN_VID)
+        HIAPI_RUN_RETURN(HI_UNF_AVPLAY_ChnOpen(avhandle, HI_UNF_AVPLAY_MEDIA_CHAN_VID, &maxCapbility));
+
+    *avplay = avhandle;
+
+    sample_common_printf("demux %d create avplay 0x%x  \n", u32DemuxId, avhandle);
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_AVPlay_SetVdecAttr(HI_HANDLE hAvplay,HI_UNF_VCODEC_TYPE_E enType,HI_UNF_VCODEC_MODE_E enMode)
+{
+    HI_S32 Ret;
+    HI_UNF_VCODEC_ATTR_S        VdecAttr;
+
+    Ret = HI_UNF_AVPLAY_GetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_VDEC, &VdecAttr);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("HI_UNF_AVPLAY_GetAttr failed:%#x\n",Ret);
+        return Ret;
+    }
+
+    VdecAttr.enType = enType;
+    VdecAttr.enMode = enMode;
+    VdecAttr.u32ErrCover = 100;
+    VdecAttr.u32Priority = 3;
+
+    Ret = HI_UNF_AVPLAY_SetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_VDEC, &VdecAttr);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_AVPLAY_SetAttr failed.\n");
+        return Ret;
+    }
+
+    return Ret;
+}
+
+#if defined (DOLBYPLUS_HACODEC_SUPPORT)
+static HI_VOID DDPlusCallBack(DOLBYPLUS_EVENT_E Event, HI_VOID *pUserData)
+{
+    DOLBYPLUS_STREAM_INFO_S *pstInfo = (DOLBYPLUS_STREAM_INFO_S *)pUserData;
+#if 0
+    sample_common_printf( "DDPlusCallBack show info:\n \
+                s16StreamType          = %d\n \
+                s16Acmod               = %d\n \
+                s32BitRate             = %d\n \
+                s32SampleRateRate      = %d\n \
+                Event                  = %d\n",
+                pstInfo->s16StreamType, pstInfo->s16Acmod, pstInfo->s32BitRate, pstInfo->s32SampleRateRate,Event);
+#endif
+    g_u32DolbyAcmod = pstInfo->s16Acmod;
+
+    if (HA_DOLBYPLUS_EVENT_SOURCE_CHANGE == Event)
+    {
+        g_bDrawChnBar = HI_TRUE;
+        //printf("DDPlusCallBack enent !\n");
+    }
+    return;
+}
+#endif
+
+HI_S32 HIADP_AVPlay_SetAdecAttr(HI_HANDLE hAvplay, HI_U32 enADecType, HI_HA_DECODEMODE_E enMode, HI_S32 isCoreOnly)
+{
+    HI_UNF_ACODEC_ATTR_S AdecAttr;
+    WAV_FORMAT_S stWavFormat;
+    DOLBYMS12_CODEC_OPENCONFIG_S stMs12Cfg; //NOTE Static mem when being called
+    OPUS_HEAD_CONFIG_S stOpusHeadCfg;
+
+    HIAPI_RUN_RETURN(HI_UNF_AVPLAY_GetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_ADEC, &AdecAttr));
+    AdecAttr.enType = enADecType;
+
+    if (HA_AUDIO_ID_PCM == AdecAttr.enType)
+    {
+        HI_BOOL isBigEndian;
+
+        /* if big-endian pcm */
+        isBigEndian = HI_FALSE;
+        if(HI_TRUE == isBigEndian)
+        {
+            stWavFormat.cbSize = 4;
+            stWavFormat.cbExtWord[0] = NORMAL_PCM_EXTWORD; //choose normal pcm decoder
+            //stWavFormat.cbExtWord[0] = WIFIDSP_LPCM_EXTWORD; //choose wifi_dsp_lpcm decoder
+        }
+
+        if(stWavFormat.cbExtWord[0] == NORMAL_PCM_EXTWORD || HI_FALSE == isBigEndian)
+        {
+        /*
+            if choose normal pcm decoder, set attribute
+            if choose wifi_dsp_lpcm decoder, need not to set attribute by follows, ignore it
+        */
+            /* set pcm wav format here base on pcm file */
+            stWavFormat.nChannels = 1;
+            stWavFormat.nSamplesPerSec = 48000;
+            stWavFormat.wBitsPerSample = 16;
+        }
+        HA_PCM_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam),&stWavFormat);
+        sample_common_printf("please make sure the attributes of PCM stream is tme same as defined in function of \"HIADP_AVPlay_SetAdecAttr\"? \n");
+        sample_common_printf("(nChannels = 1, wBitsPerSample = 16, nSamplesPerSec = 48000, isBigEndian = HI_FALSE) \n");
+    }
+    else if (HA_AUDIO_ID_MP2 == AdecAttr.enType)
+    {
+         HA_MP2_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+    }
+    else if (HA_AUDIO_ID_AAC == AdecAttr.enType)
+    {
+         HA_AAC_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+    }
+    else if (HA_AUDIO_ID_MP3 == AdecAttr.enType)
+    {
+         HA_MP3_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+    }
+    else if (HA_AUDIO_ID_AMRNB == AdecAttr.enType)
+    {
+        AMRNB_DECODE_OPENCONFIG_S *pstConfig = (AMRNB_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        HA_AMRNB_GetDecDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+        pstConfig->enFormat = AMRNB_MIME;
+    }
+    else if (HA_AUDIO_ID_AMRWB == AdecAttr.enType)
+    {
+        AMRWB_DECODE_OPENCONFIG_S *pstConfig = (AMRWB_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        HA_AMRWB_GetDecDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+        pstConfig->enFormat = AMRWB_FORMAT_MIME;
+    }
+
+    else if (HA_AUDIO_ID_G711 == AdecAttr.enType)
+    {
+        HA_VOICE_OPENCONFIG_S *pstConfig = (HA_VOICE_OPENCONFIG_S *)u8DecOpenBuf;
+        AdecAttr.enType = HA_AUDIO_ID_VOICE;
+        pstConfig->enVoiceFormat = HA_VOICE_G711_A;
+        pstConfig->u32SamplePerFrame = 320;
+        HA_VOICE_GetDecDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+    }
+    else if (HA_AUDIO_ID_G726 == AdecAttr.enType)
+    {
+        HA_VOICE_OPENCONFIG_S *pstConfig = (HA_VOICE_OPENCONFIG_S *)u8DecOpenBuf;
+        AdecAttr.enType = HA_AUDIO_ID_VOICE;
+        pstConfig->enVoiceFormat = HA_VOICE_G726_40KBPS;
+        pstConfig->u32SamplePerFrame = 320;
+        HA_VOICE_GetDecDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+    }
+    else if (HA_AUDIO_ID_ADPCM == AdecAttr.enType)
+    {
+        HA_VOICE_OPENCONFIG_S *pstConfig = (HA_VOICE_OPENCONFIG_S *)u8DecOpenBuf;
+        AdecAttr.enType = HA_AUDIO_ID_VOICE;
+        pstConfig->enVoiceFormat = HA_VOICE_ADPCM_DVI4;
+        pstConfig->u32SamplePerFrame = 320;
+        HA_VOICE_GetDecDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+    }
+
+#if 0
+    else if (HA_AUDIO_ID_G711 == AdecAttr.enType)
+    {
+        G711_DECODE_OPENCONFIG_S *pstConfig = (G711_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        pstConfig->isAlaw = 1;
+        pstConfig->u32SamplePerFrame = G711_FRAME_LEN;
+        HA_G711_GetDecDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+    }
+#endif
+    else if (HA_AUDIO_ID_AC3PASSTHROUGH == AdecAttr.enType)
+    {
+        HA_AC3PASSTHROUGH_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+        AdecAttr.stDecodeParam.enDecMode = HD_DEC_MODE_THRU;
+    }
+    else if(HA_AUDIO_ID_DTSPASSTHROUGH == AdecAttr.enType)
+    {
+        HA_DTSPASSTHROUGH_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+        AdecAttr.stDecodeParam.enDecMode = HD_DEC_MODE_THRU;
+    }
+    else if (HA_AUDIO_ID_TRUEHD == AdecAttr.enType)
+    {
+        HA_TRUEHD_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+        if (HD_DEC_MODE_THRU != enMode)
+        {
+            sample_common_printf(" MLP decoder enMode(%d) error (mlp only support hbr Pass-through only).\n", enMode);
+            return -1;
+        }
+
+        AdecAttr.stDecodeParam.enDecMode = HD_DEC_MODE_THRU;        /* truehd just support pass-through */
+        sample_common_printf(" TrueHD decoder(HBR Pass-through only).\n");
+    }
+    else if (HA_AUDIO_ID_DOLBY_TRUEHD == AdecAttr.enType)
+    {
+        TRUEHD_DECODE_OPENCONFIG_S *pstConfig = (TRUEHD_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        HA_DOLBY_TRUEHD_DecGetDefalutOpenConfig(pstConfig);
+        HA_DOLBY_TRUEHD_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+    }
+    else if (HA_AUDIO_ID_DTSHD == AdecAttr.enType)
+    {
+        DTSHD_DECODE_OPENCONFIG_S *pstConfig = (DTSHD_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        HA_DTSHD_DecGetDefalutOpenConfig(pstConfig);
+        HA_DTSHD_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+        AdecAttr.stDecodeParam.enDecMode = HD_DEC_MODE_SIMUL;
+    }
+    else if (HA_AUDIO_ID_DTSM6 == AdecAttr.enType)
+    {
+        DTSM6_DECODE_OPENCONFIG_S *pstConfig = (DTSM6_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        HA_DTSM6_DecGetDefalutOpenConfig(pstConfig);
+        HA_DTSM6_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+    }
+#if defined (DOLBYPLUS_HACODEC_SUPPORT)
+    else if (HA_AUDIO_ID_DOLBY_PLUS == AdecAttr.enType)
+    {
+        DOLBYPLUS_DECODE_OPENCONFIG_S *pstConfig = (DOLBYPLUS_DECODE_OPENCONFIG_S *)u8DecOpenBuf;
+        HA_DOLBYPLUS_DecGetDefalutOpenConfig(pstConfig);
+        pstConfig->pfnEvtCbFunc[HA_DOLBYPLUS_EVENT_SOURCE_CHANGE] = DDPlusCallBack;
+        pstConfig->pAppData[HA_DOLBYPLUS_EVENT_SOURCE_CHANGE] = &g_stDDpStreamInfo;
+        /* Dolby DVB Broadcast default settings */
+        pstConfig->enDrcMode = DOLBYPLUS_DRC_RF;
+        pstConfig->enDmxMode = DOLBYPLUS_DMX_SRND;
+        HA_DOLBYPLUS_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam), pstConfig);
+        AdecAttr.stDecodeParam.enDecMode = HD_DEC_MODE_SIMUL;
+    }
+#endif
+    else if (HA_AUDIO_ID_MS12_DDP == AdecAttr.enType)
+    {
+        HA_DOLBYMS12_CodecGetDefaultOpenConfig(&stMs12Cfg);
+        HA_DOLBYMS12_CodecGetDefaultOpenParam(&AdecAttr.stDecodeParam, &stMs12Cfg);
+    }
+    else if (HA_AUDIO_ID_MS12_AAC == AdecAttr.enType)
+    {
+        HA_DOLBYMS12_CodecGetDefaultOpenConfig(&stMs12Cfg);
+        stMs12Cfg.enInputType = MS12_HEAAC;
+        HA_DOLBYMS12_CodecGetDefaultOpenParam(&AdecAttr.stDecodeParam, &stMs12Cfg);
+    }
+    else if (HA_AUDIO_ID_VORBIS == AdecAttr.enType)
+    {
+        HA_VORBIS_DecGetDefalutOpenParam(&AdecAttr.stDecodeParam);
+    }
+    else if (HA_AUDIO_ID_OPUS == AdecAttr.enType)
+    {
+        /*
+        Opus decoder support 1 2 6 8 channels 8 16 24 32 bits
+        Opus stream with sample rate not less than 8000 and not more than 48000
+        After the upper de-encapsulation need to provide code stream information This information can be found in the front page
+        The format is as follows:
+              0                   1                   2                   3
+        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        |      'O'           |      'p'             |      'u'          |      's'         |
+        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        |      'H'           |      'e'             |      'a'          |      'd'         |
+        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        |  Version = 1  |Channel Count |           Pre-skip                |
+        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        |                     Input Sample Rate (Hz)                               |
+        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        |   Output Gain (Q7.8 in dB)      | Mapping Family|               |
+        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+        |                                                                                      |
+        :               Optional Channel Mapping Table...
+        |                                                                                      |
+        +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+        The parsed out stream information needs to be stored in the OpusHeader structure
+        like this:
+        */
+        HA_OPUS_DecGetDefalutHeadConfig(&stOpusHeadCfg);
+
+#if 0
+        //test for 2 channel
+        stOpusHeadCfg.s32Version = 1;
+        stOpusHeadCfg.u32Channels = 2;
+        stOpusHeadCfg.s32Preskip = 0;
+        stOpusHeadCfg.u32SampleRate = 48000;
+        stOpusHeadCfg.s32ChannelMap = 0;
+#else
+        //test for 5.1 channel
+        stOpusHeadCfg.s32Version = 1;
+        stOpusHeadCfg.u32Channels = 6;
+        stOpusHeadCfg.s32Preskip = 312;
+        stOpusHeadCfg.s32Gain = 0;
+        stOpusHeadCfg.u32SampleRate = 48000;
+        stOpusHeadCfg.s32NBStreams = 4;
+        stOpusHeadCfg.s32NBCoupled = 2;
+        stOpusHeadCfg.s32ChannelMap = 1;
+
+        stOpusHeadCfg.u8StreamMap[0] = 0;
+        stOpusHeadCfg.u8StreamMap[1] = 4;
+        stOpusHeadCfg.u8StreamMap[2] = 1;
+        stOpusHeadCfg.u8StreamMap[3] = 2;
+        stOpusHeadCfg.u8StreamMap[4] = 3;
+        stOpusHeadCfg.u8StreamMap[5] = 5;
+#endif
+
+        HA_OPUS_DecGetDefalutOpenParam(&AdecAttr.stDecodeParam, &stOpusHeadCfg);
+    }
+    else if (HA_AUDIO_ID_CUSTOM_0 == AdecAttr.enType)
+    {
+	
+	     sample_common_printf("===============HA_AUDIO_ID_CUSTOM_0===============\n");
+		 HA_CUSTOM_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+	}
+    else if (HA_AUDIO_ID_CUSTOM_1 == AdecAttr.enType)
+    {
+	
+	     sample_common_printf("===============HA_AUDIO_ID_CUSTOM_1===============\n");
+		 HA_CUSTOM_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+	}
+    else if (HA_AUDIO_ID_CUSTOM_2 == AdecAttr.enType)
+    {
+	
+	     sample_common_printf("===============HA_AUDIO_ID_CUSTOM_2===============\n");
+		 HA_CUSTOM_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+	}
+    else if (HA_AUDIO_ID_CUSTOM_3 == AdecAttr.enType)
+    {
+	
+	     sample_common_printf("===============HA_AUDIO_ID_CUSTOM_3===============\n");
+		 HA_CUSTOM_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+	}
+    else if (HA_AUDIO_ID_CUSTOM_4 == AdecAttr.enType)
+    {
+	
+	     sample_common_printf("===============HA_AUDIO_ID_CUSTOM_4===============\n");
+		 HA_CUSTOM_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+	}
+    else if (HA_AUDIO_ID_CUSTOM_5 == AdecAttr.enType)
+    {
+	
+	     sample_common_printf("===============HA_AUDIO_ID_CUSTOM_5===============\n");
+		 HA_CUSTOM_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+	}	
+    else if (HA_AUDIO_ID_CUSTOM_6 == AdecAttr.enType)
+    {
+	
+	     sample_common_printf("===============HA_AUDIO_ID_CUSTOM_6===============\n");
+		 HA_CUSTOM_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam));
+	}	
+    else
+    {
+         HA_DRA_DecGetOpenParam_MultichPcm(&(AdecAttr.stDecodeParam));
+    }
+
+    HIAPI_RUN_RETURN(HI_UNF_AVPLAY_SetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_ADEC, &AdecAttr));
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_AVPlay_PlayProg(HI_HANDLE hAvplay,PMT_COMPACT_TBL *pProgTbl,HI_U32 ProgNum,HI_BOOL bAudPlay)
+{
+    HI_UNF_AVPLAY_STOP_OPT_S    Stop;
+    HI_U32                  VidPid;
+    HI_U32                  AudPid;
+    HI_U32                  PcrPid;
+    HI_UNF_VCODEC_TYPE_E    enVidType;
+    HI_U32                  u32AudType;
+    HI_S32                  Ret;
+
+    Stop.enMode = HI_UNF_AVPLAY_STOP_MODE_BLACK;
+    Stop.u32TimeoutMs = 0;
+    Ret = HI_UNF_AVPLAY_Stop(hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID | HI_UNF_AVPLAY_MEDIA_CHAN_AUD, &Stop);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_AVPLAY_Stop failed.\n");
+        return Ret;
+    }
+
+    ProgNum = ProgNum % pProgTbl->prog_num;
+    if (pProgTbl->proginfo[ProgNum].VElementNum > 0 )
+    {
+        VidPid = pProgTbl->proginfo[ProgNum].VElementPid;
+        enVidType = pProgTbl->proginfo[ProgNum].VideoType;
+    }
+    else
+    {
+        VidPid = INVALID_TSPID;
+        enVidType = HI_UNF_VCODEC_TYPE_BUTT;
+    }
+
+    if (pProgTbl->proginfo[ProgNum].AElementNum > 0)
+    {
+        AudPid  = pProgTbl->proginfo[ProgNum].AElementPid;
+        u32AudType = pProgTbl->proginfo[ProgNum].AudioType;
+    }
+    else
+    {
+        AudPid = INVALID_TSPID;
+        u32AudType = 0xffffffff;
+    }
+
+    PcrPid = pProgTbl->proginfo[ProgNum].PcrPid;
+    if (INVALID_TSPID != PcrPid)
+    {
+        HI_UNF_SYNC_ATTR_S  SyncAttr;
+
+        Ret = HI_UNF_AVPLAY_GetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_SYNC, &SyncAttr);
+        if (HI_SUCCESS != Ret)
+        {
+            sample_common_printf("HI_UNF_AVPLAY_GetAttr Sync failed 0x%x\n", Ret);
+            return Ret;
+        }
+
+        if (HI_UNF_SYNC_REF_PCR == SyncAttr.enSyncRef)
+        {
+            Ret = HI_UNF_AVPLAY_SetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_PCR_PID, &PcrPid);
+            if (HI_SUCCESS != Ret)
+            {
+                sample_common_printf("HI_UNF_AVPLAY_SetAttr Sync failed 0x%x\n", Ret);
+                return Ret;
+            }
+        }
+    }
+
+    if (VidPid != INVALID_TSPID)
+    {
+        Ret = HIADP_AVPlay_SetVdecAttr(hAvplay,enVidType,HI_UNF_VCODEC_MODE_NORMAL);
+        Ret |= HI_UNF_AVPLAY_SetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_VID_PID,&VidPid);
+        if (Ret != HI_SUCCESS)
+        {
+            sample_common_printf("call HIADP_AVPlay_SetVdecAttr failed.\n");
+            return Ret;
+        }
+
+        Ret = HI_UNF_AVPLAY_Start(hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID, HI_NULL);
+        if (Ret != HI_SUCCESS)
+        {
+            sample_common_printf("call HI_UNF_AVPLAY_Start failed.\n");
+            return Ret;
+        }
+    }
+
+    if (HI_TRUE == bAudPlay && AudPid != INVALID_TSPID)
+    {
+        //u32AudType = HA_AUDIO_ID_DTSHD;
+        //printf("u32AudType = %#x\n",u32AudType);
+        Ret  = HIADP_AVPlay_SetAdecAttr(hAvplay, u32AudType, HD_DEC_MODE_RAWPCM, 1);
+
+        Ret |= HI_UNF_AVPLAY_SetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_AUD_PID, &AudPid);
+        if (HI_SUCCESS != Ret)
+        {
+            sample_common_printf("HIADP_AVPlay_SetAdecAttr failed:%#x\n",Ret);
+            return Ret;
+        }
+
+        Ret = HI_UNF_AVPLAY_Start(hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, HI_NULL);
+        if (Ret != HI_SUCCESS)
+        {
+            printf("call HI_UNF_AVPLAY_Start to start audio failed.\n");
+            //return Ret;
+        }
+    }
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_AVPlay_PlayProg_MS12(HI_HANDLE hAvplay,PMT_COMPACT_TBL *pProgTbl,HI_U32 ProgNum)
+{
+    HI_UNF_AVPLAY_STOP_OPT_S    Stop;
+    HI_U32                  AudPid;
+    HI_U32                  u32AudType;
+    HI_S32                  Ret;
+    HI_S32                  MainProgNum = 0;
+    HI_S32                  PIDNum = 0;
+
+    Stop.enMode = HI_UNF_AVPLAY_STOP_MODE_BLACK;
+    Stop.u32TimeoutMs = 0;
+    Ret = HI_UNF_AVPLAY_Stop(hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, &Stop);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_AVPLAY_Stop failed.\n");
+        return Ret;
+    }
+
+    PIDNum = ProgNum % pProgTbl->proginfo[MainProgNum].AElementNum;
+
+    if (pProgTbl->proginfo[MainProgNum].AElementNum > 0)
+    {
+        AudPid  = pProgTbl->proginfo[MainProgNum].Audioinfo[PIDNum].u16AudioPid;
+        u32AudType = pProgTbl->proginfo[MainProgNum].Audioinfo[PIDNum].u32AudioEncType;
+    }
+    else
+    {
+        AudPid = INVALID_TSPID;
+        u32AudType = 0xffffffff;
+    }
+
+    if (AudPid != INVALID_TSPID)
+    {
+        Ret  = HIADP_AVPlay_SetAdecAttr(hAvplay, u32AudType, HD_DEC_MODE_RAWPCM, 1);
+        Ret |= HI_UNF_AVPLAY_SetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_AUD_PID, &AudPid);
+        if (HI_SUCCESS != Ret)
+        {
+            sample_common_printf("HIADP_AVPlay_SetAdecAttr failed:%#x\n",Ret);
+            return Ret;
+        }
+
+        Ret = HI_UNF_AVPLAY_Start(hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, HI_NULL);
+        if (Ret != HI_SUCCESS)
+        {
+            printf("call HI_UNF_AVPLAY_Start to start audio failed.\n");
+        }
+    }
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_AVPlay_PlayAud(HI_HANDLE hAvplay,PMT_COMPACT_TBL *pProgTbl,HI_U32 ProgNum)
+{
+    HI_U32                  AudPid;
+    HI_U32                  u32AudType;
+    HI_S32                  Ret;
+
+    Ret = HI_UNF_AVPLAY_Stop(hAvplay,HI_UNF_AVPLAY_MEDIA_CHAN_AUD, HI_NULL);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_AVPLAY_Stop failed.\n");
+        return Ret;
+    }
+
+    ProgNum = ProgNum % pProgTbl->prog_num;
+    if (pProgTbl->proginfo[ProgNum].AElementNum > 0)
+    {
+        AudPid  = pProgTbl->proginfo[ProgNum].AElementPid;
+        u32AudType = pProgTbl->proginfo[ProgNum].AudioType;
+    }
+    else
+    {
+        AudPid = INVALID_TSPID;
+        u32AudType = 0xffffffff;
+    }
+
+    if (AudPid != INVALID_TSPID)
+    {
+        Ret  = HIADP_AVPlay_SetAdecAttr(hAvplay, u32AudType, HD_DEC_MODE_RAWPCM, 1);
+        Ret |= HI_UNF_AVPLAY_SetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_AUD_PID, &AudPid);
+        if (HI_SUCCESS != Ret)
+        {
+            sample_common_printf("HIADP_AVPlay_SetAdecAttr failed:%#x\n",Ret);
+            return Ret;
+        }
+
+        Ret = HI_UNF_AVPLAY_Start(hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, HI_NULL);
+        if (Ret != HI_SUCCESS)
+        {
+            sample_common_printf("call HI_UNF_AVPLAY_Start failed.\n");
+            return Ret;
+        }
+    }
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_AVPlay_SwitchAud(HI_HANDLE hAvplay,HI_U32 AudPid, HI_U32 u32AudType)
+{
+    HI_S32 Ret = HI_SUCCESS;
+
+    if (AudPid == INVALID_TSPID)
+    {
+        sample_common_printf("%s, audio pid is invalid!\n", __func__);
+        return HI_FAILURE;
+    }
+
+    Ret = HI_UNF_AVPLAY_Stop(hAvplay,HI_UNF_AVPLAY_MEDIA_CHAN_AUD, HI_NULL);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_AVPLAY_Stop failed.\n");
+        return Ret;
+    }
+
+
+    Ret  = HIADP_AVPlay_SetAdecAttr(hAvplay, u32AudType, HD_DEC_MODE_RAWPCM, 1);
+    Ret |= HI_UNF_AVPLAY_SetAttr(hAvplay, HI_UNF_AVPLAY_ATTR_ID_AUD_PID, &AudPid);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("HIADP_AVPlay_SetAdecAttr failed:%#x\n",Ret);
+        return Ret;
+    }
+
+    Ret = HI_UNF_AVPLAY_Start(hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, HI_NULL);
+    if (Ret != HI_SUCCESS)
+    {
+        sample_common_printf("call HI_UNF_AVPLAY_Start failed.\n");
+        return Ret;
+    }
+
+    return HI_SUCCESS;
+}
+
+
+HI_S32 HIADP_MCE_Exit(HI_VOID)
+{
+#ifndef ANDROID
+    HI_S32                  Ret;
+    HI_UNF_MCE_STOPPARM_S   stStop;
+
+    Ret = HI_UNF_MCE_Init(HI_NULL);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_MCE_Init failed, Ret=%#x!\n", Ret);
+        return Ret;
+    }
+
+    Ret = HI_UNF_MCE_ClearLogo();
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_MCE_ClearLogo failed, Ret=%#x!\n", Ret);
+        return Ret;
+    }
+
+    stStop.enStopMode = HI_UNF_AVPLAY_STOP_MODE_STILL;
+    stStop.enCtrlMode = HI_UNF_MCE_PLAYCTRL_BY_TIME;
+    stStop.u32PlayTimeMs = 0;
+    Ret = HI_UNF_MCE_Stop(&stStop);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_MCE_Stop failed, Ret=%#x!\n", Ret);
+        return Ret;
+    }
+
+    Ret = HI_UNF_MCE_Exit(HI_NULL);
+    if (HI_SUCCESS != Ret)
+    {
+        sample_common_printf("call HI_UNF_MCE_Exit failed, Ret=%#x!\n", Ret);
+        return Ret;
+    }
+
+    HI_UNF_MCE_DeInit();
+#endif
+    return HI_SUCCESS;
+}
+HI_S32 HIADP_DMX_AttachTSPort(HI_U32 Dmxid, HI_U32 TunerID)
+{
+    HI_S32                      Ret;
+    HI_UNF_DMX_PORT_E           DmxAttachPort;
+    HI_UNF_DMX_PORT_ATTR_S      DmxAttachPortAttr;
+    HI_CHAR SectionName[SECTION_MAX_LENGTH] = {0};
+
+    snprintf(SectionName,SECTION_MAX_LENGTH,"tuner%dinfo",TunerID);
+    DmxAttachPort = HIADP_INI_Getl(SectionName, "DemuxPort", DEFAULT_DEMUX_PORT, FRONTEND_CONFIG_FILE);
+
+    Ret = HI_UNF_DMX_GetTSPortAttr(DmxAttachPort, &DmxAttachPortAttr);
+
+    DmxAttachPortAttr.enPortType           = HIADP_INI_Getl(SectionName, "DemuxPortType", DEFAULT_DEMUX_PORT_TYPE, FRONTEND_CONFIG_FILE);
+    DmxAttachPortAttr.u32SerialBitSelector = HIADP_INI_Getl(SectionName, "DemuxBitSel",   DEFAULT_DEMUX_BITSEL,    FRONTEND_CONFIG_FILE);
+    DmxAttachPortAttr.u32TunerInClk        = HIADP_INI_Getl(SectionName, "DemuxInClk",    DEFAULT_DEMUX_INCLK,     FRONTEND_CONFIG_FILE);
+    DmxAttachPortAttr.enSerialPortShareClk = HIADP_INI_Getl(SectionName, "DemuxPortShareClk", DEFAULT_DEMUX_PORT_SHARECLK, FRONTEND_CONFIG_FILE);
+
+    Ret |= HI_UNF_DMX_SetTSPortAttr(DmxAttachPort, &DmxAttachPortAttr);
+    if (HI_SUCCESS != Ret)
+    {
+        printf("call HI_UNF_DMX_SetTSPortAttr failed.\n");
+        return HI_FAILURE;
+    }
+
+    Ret = HI_UNF_DMX_AttachTSPort(Dmxid, DmxAttachPort);
+    if (HI_SUCCESS != Ret)
+    {
+        printf("call HI_UNF_DMX_AttachTSPort.\n");
+        return HI_FAILURE;
+    }
+
+    return HI_SUCCESS;
+}
+
+HI_S32 HIADP_DMX_PushTsBuffer(HI_HANDLE hTsBuf, HI_UNF_STREAM_BUF_S *pstBuf, HI_U32 u32StartPos, HI_U32 u32ValidLen)
+{
+    HI_S32 s32Ret = HI_SUCCESS;
+
+#ifdef HI_DMX_TSBUF_MULTI_THREAD_SUPPORT
+    HI_UNF_STREAM_BUF_S stData;
+
+    if ((HI_NULL == pstBuf) || (HI_NULL == pstBuf->pu8Data) || (pstBuf->u32Size < u32StartPos + u32ValidLen))
+    {
+        printf("invalided parameter!\n");
+        return HI_FAILURE;
+    }
+    stData.pu8Data = pstBuf->pu8Data + u32StartPos;
+    stData.u32Size = u32ValidLen;
+    s32Ret = HI_UNF_DMX_PushTSBuffer(hTsBuf, &stData);
+    if (HI_SUCCESS != s32Ret)
+    {
+        printf("[%s_%d]calling HI_UNF_DMX_PushTSBuffer failed! ret = 0x%08x\n", __FILE__, __LINE__, s32Ret);
+        return HI_FAILURE;
+    }
+
+    s32Ret = HI_UNF_DMX_ReleaseTSBuffer(hTsBuf, pstBuf);
+#else
+    if ((HI_NULL == pstBuf) || (HI_NULL == pstBuf->pu8Data) || (pstBuf->u32Size < u32StartPos + u32ValidLen))
+    {
+        printf("invalided parameter!\n");
+        return HI_FAILURE;
+    }
+    s32Ret = HI_UNF_DMX_PutTSBuffer(hTsBuf, u32ValidLen);
+#endif
+
+    if (HI_SUCCESS != s32Ret)
+    {
+        printf("[pu8Data, u32StartPos, u32ValidLen, s32Ret] = [%p, %u, %u, 0x%x]\n", pstBuf->pu8Data, u32StartPos, u32ValidLen, s32Ret);
+    }
+
+    return s32Ret;
+}
diff -uNr a/include/HA.AUDIO.AAC.decode.h b/include/HA.AUDIO.AAC.decode.h
--- a/include/HA.AUDIO.AAC.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.AAC.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,100 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.AAC.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_AAC_H__
+#define __HISI_AUDIO_DECODER_AAC_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define    HA_AAC_ID 0x001
+
+#define HA_CODEC_AAC_SET_TRANSPORT_TYPE_CMD  ((((HI_U32)HA_AAC_ID) << 16) | 0x1000)
+#define HA_CODEC_AAC_SET_CONFIGRAW_CMD       ((((HI_U32)HA_AAC_ID) << 16) | 0x1001)
+#define FILEREAD_MAX_LAYERS 2
+
+#define HA_CODEC_AAC_GET_CHNANEL_MODE_CMD    ((((HI_U32)HA_AAC_ID) << 16) | 0x1002)
+
+/**
+ * Transport type identifiers.
+ */
+typedef enum
+{
+  HA_TT_UNKNOWN           = -1, /**< Unknown format.            */
+  HA_TT_MP4_RAW           = 0,  /**< "as is" access units (packet based since there is obviously no sync layer) */
+  HA_TT_MP4_ADIF          = 1,  /**< ADIF bitstream format.     */
+  HA_TT_MP4_ADTS          = 2,  /**< ADTS bitstream format.     */
+
+  HA_TT_MP4_LATM_MCP1     = 6,  /**< Audio Mux Elements with muxConfigPresent = 1 */
+  HA_TT_MP4_LATM_MCP0     = 7,  /**< Audio Mux Elements with muxConfigPresent = 0, out of band StreamMuxConfig */
+
+  HA_TT_MP4_LOAS          = 10, /**< Audio Sync Stream.         */
+
+  HA_TT_DRM               = 12, /**< Digital Radio Mondial (DRM30/DRM+) bitstream format. */
+
+  HA_TT_MP1_L1            = 16, /**< MPEG 1 Audio Layer 1 audio bitstream. */
+  HA_TT_MP1_L2            = 17, /**< MPEG 1 Audio Layer 2 audio bitstream. */
+  HA_TT_MP1_L3            = 18, /**< MPEG 1 Audio Layer 3 audio bitstream. */
+
+  HA_TT_RSVD50            = 50 /**< */
+
+} HA_AAC_TRANSPORT_TYPE;
+
+
+typedef struct
+{
+    HI_U32  enCmd;
+    HA_AAC_TRANSPORT_TYPE stType;
+} HA_AAC_SET_TRANSPORT_TYPE_S;
+
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_UCHAR *conf[FILEREAD_MAX_LAYERS];
+    HI_U32 length[FILEREAD_MAX_LAYERS];
+} HA_AAC_SET_CONFIGRAW_S;
+
+typedef struct
+{
+    HI_U32  enCmd;              /* HA_CODEC_AAC_GET_CHNANEL_MODE_CMD */
+    HI_S32* ps32ChannelConfig;
+} HA_AAC_GET_CHNANEL_MODE_S;
+
+#define HA_AAC_DecGetDefalutOpenParam(pOpenParam) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 8; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_FALSE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+}while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_AAC_H__ */
+
diff -uNr a/include/HA.AUDIO.AAC.encode.h b/include/HA.AUDIO.AAC.encode.h
--- a/include/HA.AUDIO.AAC.encode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.AAC.encode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,87 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.AAC.encode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_ENCODER_AAC_H__
+#define __HISI_AUDIO_ENCODER_AAC_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+#define    HA_AAC_ID 0x001         
+
+typedef enum
+{
+    AAC_QualityExcellent = 0,
+    AAC_QualityHigh   = 1,
+    AAC_QualityMedium = 2,
+    AAC_QualityLow = 3,
+} AAC_AuQuality;
+
+typedef enum
+{
+    AAC_FORMAT_LC = 0,                  /**< AAC LC */
+    AAC_FORMAT_EAAC = 1,                    /**< eAAC  (HEAAC or AAC+  or aacPlusV1) */
+    AAC_FORMAT_EAACPLUS = 2,            /**< eAAC+ (AAC++ or aacPlusV2) */
+} AAC_AuEncoderFormat;
+
+typedef  struct
+{
+    AAC_AuQuality       quality;
+    AAC_AuEncoderFormat coderFormat;
+    HI_S16          bitsPerSample;
+    HI_S32          sampleRate;    /**< audio file sample rate */
+    HI_S32          bitRate;            /**< encoder bit rate in bits/sec */
+    HI_S16          nChannelsIn;    /**< number of channels on input (1,2) */
+    HI_S16          nChannelsOut;  /**< number of channels on output (1,2) */
+    HI_S16          bandWidth;       /**< targeted audio bandwidth in Hz */
+} AAC_ENC_CONFIG;
+
+#define HA_AAC_GetDefaultConfig(pstConfig) \
+do{ ((AAC_ENC_CONFIG *)(pstConfig))->coderFormat = AAC_FORMAT_LC; \
+    ((AAC_ENC_CONFIG *)(pstConfig))->bitsPerSample = 16; \
+    ((AAC_ENC_CONFIG *)(pstConfig))->quality = AAC_QualityHigh; \
+    ((AAC_ENC_CONFIG *)(pstConfig))->bitRate = 128000; \
+    ((AAC_ENC_CONFIG *)(pstConfig))->sampleRate = 48000; \
+    ((AAC_ENC_CONFIG *)(pstConfig))->bandWidth    = ((AAC_ENC_CONFIG *)(pstConfig))->sampleRate / 2; \
+    ((AAC_ENC_CONFIG *)(pstConfig))->nChannelsIn  = 2; \
+    ((AAC_ENC_CONFIG *)(pstConfig))->nChannelsOut = 2; \
+}while(0)
+
+#define HA_AAC_GetEncDefaultOpenParam(pOpenParam, pstPrvateConfig) \
+do{ HI_U32 inSamplePerFrame; \
+    inSamplePerFrame = 1024; \
+    if ((((AAC_ENC_CONFIG *)pstPrvateConfig)->coderFormat == AAC_FORMAT_EAAC) || (((AAC_ENC_CONFIG *)pstPrvateConfig)->coderFormat == AAC_FORMAT_EAACPLUS)) \
+    { \
+        inSamplePerFrame <<= 1; \
+    } \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredOutChannels = ((AAC_ENC_CONFIG *)pstPrvateConfig)->nChannelsOut; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->bInterleaved = HI_TRUE; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->s32BitPerSample = ((AAC_ENC_CONFIG *)pstPrvateConfig)->bitsPerSample; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredSampleRate = ((AAC_ENC_CONFIG *)pstPrvateConfig)->sampleRate; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32SamplePerFrame = inSamplePerFrame; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrvateConfig; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(AAC_ENC_CONFIG); \
+}while(0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_ENCODER_AAC_H__ */
diff -uNr a/include/HA.AUDIO.AC3PASSTHROUGH.decode.h b/include/HA.AUDIO.AC3PASSTHROUGH.decode.h
--- a/include/HA.AUDIO.AC3PASSTHROUGH.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.AC3PASSTHROUGH.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,49 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.AC3PASSTHROUGH.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_AC3PASSTHROUGH_H__
+#define __HISI_AUDIO_DECODER_AC3PASSTHROUGH_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define HA_AC3PASSTHROUGH_ID 0x0055        
+
+#define HA_AC3PASSTHROUGH_DecGetDefalutOpenParam(pOpenParam) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_THRU; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+}while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_AC3PASSTHROUGH_H__ */
+
diff -uNr a/include/HA.AUDIO.AMRNB.codec.h b/include/HA.AUDIO.AMRNB.codec.h
--- a/include/HA.AUDIO.AMRNB.codec.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.AMRNB.codec.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,113 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.AMRNB.codec.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_CODEC_AMRNB_H__
+#define __HISI_AUDIO_CODEC_AMRNB_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+#define    HA_AMRNB_ID 0x0100        
+
+
+#ifndef AMR_MAGIC_NUMBER
+ #define AMR_MAGIC_NUMBER "#!AMR\n"/*magic number for AMR-NB*/
+#endif
+
+typedef enum
+{
+    AMRNB_MR475 = 0,     /*4.75kbit/s*/
+    AMRNB_MR515,
+    AMRNB_MR59,
+    AMRNB_MR67,
+    AMRNB_MR74,
+    AMRNB_MR795,
+    AMRNB_MR102,
+    AMRNB_MR122,
+    AMRNB_MRDTX,             /*SID mode*/
+    AMRNB_N_MODES                /* number of (SPC) modes */
+} AMRNB_MODE_E;
+
+typedef enum
+{
+    AMRNB_MIME = 0,     /*4.75kbit/s*/
+    AMRNB_IF1,
+    AMRNB_IF2,
+} AMRNB_FORMAT_E;
+
+typedef struct
+{
+    AMRNB_FORMAT_E enFormat;
+
+    AMRNB_MODE_E enMode;
+
+    HI_BOOL bDTX;  /* HI_TRUE=enable dtx, HI_FALSE=disable dtx  */
+} AMRNB_ENCODE_OPENCONFIG_S;
+
+typedef struct
+{
+    AMRNB_FORMAT_E enFormat;
+} AMRNB_DECODE_OPENCONFIG_S;
+
+typedef enum
+{
+    AMRNB_CONFIGCMD_MODE = 0,
+}  AMRNB_CONFIG_COMMAND_E;
+
+/* struct for 
+    HI_HA_ERRORTYPE_E (*EncodeSetConfig)(HI_VOID * hEncoder, HI_VOID *pstConfigStructure);
+*/
+typedef struct
+{
+    AMRNB_CONFIG_COMMAND_E enCmd;
+
+    HI_VOID *pstPrivateParams;
+} AMRNB_ENCODE_CONFIG_MODE_S;
+
+#define HA_AMRNB_GetEncDefaultOpenParam(pOpenParam, pstPrivateParams) \
+do{ ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredOutChannels = 1; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->bInterleaved  = HI_TRUE; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->s32BitPerSample = 16; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredSampleRate = 8000; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32SamplePerFrame = 160; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(AMRNB_ENCODE_OPENCONFIG_S); \
+}while(0)
+
+#define HA_AMRNB_GetDecDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 1; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 8000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(AMRNB_DECODE_OPENCONFIG_S); \
+}while(0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_CODEC_AMRNB_H__ */
diff -uNr a/include/HA.AUDIO.AMRWB.codec.h b/include/HA.AUDIO.AMRWB.codec.h
--- a/include/HA.AUDIO.AMRWB.codec.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.AMRWB.codec.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,112 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.AMRWB.codec.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_CODEC_AMRWB_H__
+#define __HISI_AUDIO_CODEC_AMRWB_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+#define    HA_AMRWB_ID 0x0110
+
+#ifndef AMRWB_MAGIC_NUMBER
+ #define AMRWB_MAGIC_NUMBER "#!AMR-WB\n" /*magic number for AMR-WB*/
+#endif
+
+#if 1
+typedef enum
+{
+    AMRWB_MR66 = 0,                /* AMR-WB 6.60 kbit/s  */
+    AMRWB_MR885,                    /* AMR-WB 8.85 kbit/s  */
+    AMRWB_MR1265,                  /* AMR-WB 12.65 kbit/s */
+    AMRWB_MR1425,                  /* AMR-WB 14.25 kbit/s */
+    AMRWB_MR1585,                  /* AMR-WB 15.85 kbit/s */
+    AMRWB_MR1825,                  /* AMR-WB 18.25 kbit/s */
+    AMRWB_MR1985,                  /* AMR-WB 19.85 kbit/s */
+    AMRWB_MR2305,                  /* AMR-WB 23.05 kbit/s */
+    AMRWB_MR2385                   /* AMR-WB 23.85 kbit/s */
+}AMRWB_MODE_E;
+#endif
+
+typedef enum
+{
+    AMRWB_FORMAT_MIME, 
+    AMRWB_FORMAT_IF2
+} AMRWB_FORMAT_E;
+
+typedef struct
+{
+    AMRWB_FORMAT_E enFormat;
+
+    AMRWB_MODE_E enMode;
+
+    HI_BOOL bDTX;  /* HI_TRUE=enable dtx, HI_FALSE=disable dtx  */
+} AMRWB_ENCODE_OPENCONFIG_S;
+
+typedef struct
+{
+    AMRWB_FORMAT_E enFormat;
+} AMRWB_DECODE_OPENCONFIG_S;
+
+typedef enum
+{
+    AMRWB_CONFIGCMD_MODE = 0,
+}  AMRWB_CONFIG_COMMAND_E;
+
+/* struct for 
+    HI_HA_ERRORTYPE_E (*EncodeSetConfig)(HI_VOID * hEncoder, HI_VOID *pstConfigStructure);
+*/
+typedef struct
+{
+    AMRWB_CONFIG_COMMAND_E enCmd;
+
+    HI_VOID *pstPrivateParams;
+} AMRWB_ENCODE_CONFIG_MODE_S;
+
+#define HA_AMRWB_GetEncDefaultOpenParam(pOpenParam, pstPrivateParams) \
+do{ ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredOutChannels = 1; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->bInterleaved  = HI_TRUE; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->s32BitPerSample = 16; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredSampleRate = 16000; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32SamplePerFrame = 320; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(AMRWB_ENCODE_OPENCONFIG_S); \
+}while(0)
+
+#define HA_AMRWB_GetDecDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 1; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 16000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(AMRWB_DECODE_OPENCONFIG_S); \
+}while(0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_CODEC_AMRWB_H__ */
diff -uNr a/include/HA.AUDIO.BLURAYLPCM.decode.h b/include/HA.AUDIO.BLURAYLPCM.decode.h
--- a/include/HA.AUDIO.BLURAYLPCM.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.BLURAYLPCM.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,62 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.BLURAYLPCM.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_BLURAYLPCM_H__
+#define __HISI_AUDIO_DECODER_BLURAYLPCM_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define HA_BLYRAYLPCM_ID 0x021        
+
+typedef struct  hiHA_BLURAYLPCM_DECODE_OPENCONFIG_S
+{
+    HI_BOOL                 bAutoDmxStereo; /* automatic downmix multi-ch to stereo. */
+    HI_BOOL                 bConvert2fmt16bit; /* automatic convert none-16bit pcm to 16bit pcm. */
+} HA_BLURAYLPCM_DECODE_OPENCONFIG_S;
+
+#define HA_BLYRAYLPCM_DecGetDefalutOpenConfig(pConfigParam) \
+    do { \
+        ((HA_BLURAYLPCM_DECODE_OPENCONFIG_S *)(pConfigParam))->bAutoDmxStereo = HI_TRUE; \
+        ((HA_BLURAYLPCM_DECODE_OPENCONFIG_S *)(pConfigParam))->bConvert2fmt16bit = HI_TRUE; \
+    } while (0)
+
+
+#define HA_BLYRAYLPCM_DecGetDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->u32CodecPrivateDataSize = sizeof(HA_BLURAYLPCM_DECODE_OPENCONFIG_S); \
+}while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_BLURAYLPCM_H__ */
+
diff -uNr a/include/HA.AUDIO.COOK.decode.h b/include/HA.AUDIO.COOK.decode.h
--- a/include/HA.AUDIO.COOK.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.COOK.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,69 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.COOK.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_COOK_H__
+#define __HISI_AUDIO_DECODER_COOK_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define    HA_COOK_ID 0x0009        
+
+/*
+ * ra_format_info struct
+ *
+ */
+
+typedef struct  hiRA_FORMAT_INFO_S
+{
+    HI_U32 ulSampleRate;
+    HI_U32 ulActualRate;
+    HI_U16 usBitsPerSample;
+    HI_U16 usNumChannels;
+    HI_U16 usAudioQuality;
+    HI_U16 usFlavorIndex;
+    HI_U32 ulBitsPerFrame;
+    HI_U32 ulGranularity;
+    HI_U32 ulOpaqueDataSize;
+    HI_U8*  pOpaqueData;
+} RA_FORMAT_INFO_S;
+
+
+#define HA_COOK_DecGetDefalutOpenParam(pOpenParam, pstPrivateParams) \
+		do { HI_S32 i; \
+			 ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+			 ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+			 ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+			 ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+			 ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+			 for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+			 { \
+				 ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+			 } \
+			 ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+			 ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(RA_FORMAT_INFO_S); \
+		} while (0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_COOK_H__ */
+
diff -uNr a/include/HA.AUDIO.CUSTOM.decode.h b/include/HA.AUDIO.CUSTOM.decode.h
--- a/include/HA.AUDIO.CUSTOM.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.CUSTOM.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,48 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.CUSTOM.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_CUSTOM_H__
+#define __HISI_AUDIO_DECODER_CUSTOM_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+      
+
+#define HA_CUSTOM_DecGetDefalutOpenParam(pOpenParam) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)NULL; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+}while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_CUSTOM_H__ */
+
diff -uNr a/include/HA.AUDIO.DOLBYMS12.decode.h b/include/HA.AUDIO.DOLBYMS12.decode.h
--- a/include/HA.AUDIO.DOLBYMS12.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.DOLBYMS12.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,332 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.DOLBYMS12.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HA_AUDIO_DOLBYMS12_DECODE_H__
+#define __HA_AUDIO_DOLBYMS12_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#define  HA_MS12_ID         (0x2050)
+
+#define  HA_CODEC_MS12_SET_VOLUME_CMD             ((((HI_U32)HA_MS12_ID) << 16) | 0x1000)
+#define  HA_CODEC_MS12_GET_VOLUME_CMD             ((((HI_U32)HA_MS12_ID) << 16) | 0x1001)
+#define  HA_CODEC_MS12_SET_DRC_MODE_CMD           ((((HI_U32)HA_MS12_ID) << 16) | 0x1002)
+#define  HA_CODEC_MS12_SET_LFE_MODE_CMD           ((((HI_U32)HA_MS12_ID) << 16) | 0x1003)
+#define  HA_CODEC_MS12_SET_DMX_MODE_CMD           ((((HI_U32)HA_MS12_ID) << 16) | 0x1004)
+#define  HA_CODEC_MS12_SET_DYNSCALE_MODE_CMD      ((((HI_U32)HA_MS12_ID) << 16) | 0x1005)
+#define  HA_CODEC_MS12_SET_AD_BALANCE_CMD         ((((HI_U32)HA_MS12_ID) << 16) | 0x1006)
+#define  HA_CODEC_MS12_SET_PASSTHROUGH_STATUS_CMD ((((HI_U32)HA_MS12_ID) << 16) | 0x1007)
+#define  HA_CODEC_MS12_SET_MIN_VOLUME_CMD         ((((HI_U32)HA_MS12_ID) << 16) | 0x1008)
+#define  HA_CODEC_MS12_SET_PTS_MUTE_CMD           ((((HI_U32)HA_MS12_ID) << 16) | 0x1009)
+#define  HA_CODEC_MS12_GET_STREAM_INFO_CMD        ((((HI_U32)HA_MS12_ID) << 16) | 0x100A)
+#define  HA_CODEC_MS12_GET_AD_STREAM_INFO_CMD     ((((HI_U32)HA_MS12_ID) << 16) | 0x100B)
+#define  HA_CODEC_MS12_SET_DRC_SCALE_CMD          ((((HI_U32)HA_MS12_ID) << 16) | 0x100C)
+#define  HA_CODEC_MS12_SET_DUAL_MODE_CMD          ((((HI_U32)HA_MS12_ID) << 16) | 0x100D)
+#define  HA_CODEC_MS12_SET_SUBSTREAMID_CMD        ((((HI_U32)HA_MS12_ID) << 16) | 0x100E)
+
+/** Define DAP configuration:
+    - 0: No DAP (default)
+    - 1: Content processing only;
+    - 2: Device processing only
+    - 3: Both with two DAP instances
+    - 4: Both with single instance DAP processing */
+typedef enum
+{
+    MS12_DAP_NO_PROC = 0,
+    MS12_DAP_CONTENT_PROC,
+    MS12_DAP_DEVICE_PROC,
+    MS12_DAP_DEVICE_CONTENT_PROC,
+    MS12_DAP_SI_PROC,
+} MS12_DAP_MODE_E;
+
+/** Define input stream type:
+    - 0: Dolby digital (plus) stream (default)
+    - 1: AAC or HEAAC stream
+    - 2: AC4 stream
+    - 3: PCM stream */
+typedef enum
+{
+    MS12_DOLBY_DIGITAL_PLUS = 0,
+    MS12_HEAAC,
+    MS12_AC4,
+    MS12_EXTERNAL_PCM,
+    MS12_MPEG,
+} MS12_INPUT_TYPE_E;
+
+/** Define volume curve type:
+    - 0: Linear curve, up:g(x)=x, down:f(x)=1-x (default)
+    - 1: In cube curve, up:g(x)=x^3, down:f(x)=1-x^3
+    - 2: Out cube curve, up:g(x)=1-(1-x)^3, down:f(x)=(1-x)^3 */
+typedef enum
+{
+    MS12_VOLCURVE_LINEAR = 0,
+    MS12_VOLCURVE_INCUBE,
+    MS12_VOLCURVE_OUTCUBE,
+} MS12_VOLUME_CURVE_E;
+
+/** Define stereo down mix mode:
+    - 0: 2/0 Dolby Surround compatible (Lt/Rt) (default)
+    - 1: 2/0 Stereo without surround
+    - 2: Only HEAAC and AC4 stream are vaild */
+typedef enum
+{
+    MS12_DMX_LTRT = 0,
+    MS12_DMX_LORO,
+    MS12_DMX_ARIB,
+} MS12_STEREODMX_MODE_E;
+
+/** Define decoder compression mode:
+    - 0: Line out mode, used in DMA
+    - 1: RF out mode, used in broadcast or iptv (default) */
+typedef enum
+{
+    MS12_DRC_LINE = 0,
+    MS12_DRC_RF,
+} MS12_DRC_MODE_E;
+
+/** Define LFE Downmixing mode
+     - 0 = Properly downmixes the LFE channel according to the lfemixlevcod parameter
+           when DRC is set to Line mode
+     - 1 = LFE channel is not downmixed when DRC is set to RF mode (default) */
+typedef enum
+{
+    MS12_LFEOUT_OFF = 0,
+    MS12_LFEOUT_ON,
+} MS12_LFEOUT_MODE_E;
+
+/** Define Decoder dual mono mode (Only when <i>acmod</i> is 1/1 (acmod=0))
+     - 0 = Stereo (default)
+     - 1 = Left mono
+     - 2 = Right mono */
+typedef enum
+{
+    MS12_DUAL_STEREO = 0,
+    MS12_DUAL_LEFTMONO,
+    MS12_DUAL_RIGHTMONO,
+} MS12_DUAL_MODE_E;
+
+/** Define stream type:
+    - 0: Dolby digital
+    - 1: Dolby digital plus
+    - 2: Dolby atmos stream
+    - 3: AAC stream
+    - 4: AC4 stream
+    - 5: PCM stream
+    - 6: MP1/MP2/MP3 stream */
+typedef enum
+{
+    MS12_STREAM_DD = 0,
+    MS12_STREAM_DDP,
+    MS12_STREAM_ATMOS,
+    MS12_STREAM_AAC,
+    MS12_STREAM_AC4,
+    MS12_STREAM_PCM,
+    MS12_STREAM_MPEG,
+} MS12_STREAM_TYPE_E;
+
+/** Define Setting and getting volume parameter
+    - enCmd: HA_CODEC_MS12_SET_VOLUME_CMD or HA_CODEC_MS12_GET_VOLUME_CMD
+    - s32VolumedB: -96 ~ 0 (dB)
+    - u32FadeMs: Fade time:0 ~ 60000 (ms) */
+typedef struct
+{
+    HI_U32 enCmd;
+    MS12_VOLUME_CURVE_E enVolumeCurve;
+    HI_S32 s32VolumedB;
+    HI_U32 u32FadeMs;
+} HA_MS12_VOLUME_S;
+
+/** Define Setting parameter of drc mode
+    - enCmd: HA_CODEC_MS12_SET_DRC_MODE_CMD */
+typedef struct
+{
+    HI_U32  enCmd;
+    MS12_DRC_MODE_E enDrcMode;
+} HA_MS12_SET_DRC_MODE_S;
+
+/** Define Setting parameter of drc scale
+    - enCmd: HA_CODEC_MS12_SET_DRC_SCALE_CMD */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_U32  u32DrcCut;
+    HI_U32  u32DrcBoost;
+} HA_MS12_SET_DRC_SCALE_S;
+
+/** Define Setting parameter of lfe mode
+    - enCmd: HA_CODEC_MS12_SET_LFE_MODE_CMD */
+typedef struct
+{
+    HI_U32 enCmd;
+    MS12_LFEOUT_MODE_E enLfeMode;
+} HA_MS12_SET_LFE_MODE_S;
+
+/** Define Setting parameter of downmix mode
+    - enCmd: HA_CODEC_SET_DMX_MODE_CMD */
+typedef struct
+{
+    HI_U32 enCmd;
+    MS12_STEREODMX_MODE_E enDmxMode;
+} HA_MS12_SET_DMX_MODE_S;
+
+/** Define Setting parameter of dual mode
+    - enCmd: HA_CODEC_MS12_SET_DUAL_MODE_CMD */
+typedef struct
+{
+    HI_U32 enCmd;
+    MS12_DUAL_MODE_E enDualMode;
+} HA_MS12_SET_DUAL_MODE_S;
+
+/** Define Setting parameter of dynamic scale mode
+    -enCmd:       HA_CODEC_MS12_SET_DYNSCALE_MODE_CMD
+    -u32DrcCut:   Scale factor for incoming DRC cut value: 0 ~ 100
+    -u32DrcBoost: Scale factor for incoming DRC boost value: 0 ~ 100 */
+typedef struct
+{
+    HI_U32 enCmd;
+    HI_U16 u32DrcCut;
+    HI_U16 u32DrcBoost;
+} HA_MS12_SET_DYNSCALE_MODE_S;
+
+/** Define Setting parameter of ad balance
+    -enCmd:      HA_CODEC_MS12_SET_AD_BALANCE_CMD
+    -s32Balance: User defined balance between main and associated signal
+                 Value range is between -32 and +32 (in dB)
+                 -32dB indicates main only (mute associated)
+                 +32dB indicates associated only (mute main) */
+typedef struct
+{
+    HI_U32 enCmd;
+    HI_S32 s32Balance;
+} HA_MS12_SET_AD_BALANCE_S;
+
+/** Define Setting parameter of pts mute
+    -enCmd:       HA_CODEC_MS12_SET_PTS_MUTE_CMD
+    -u32StartPts: Start mute pts
+    -u32StopPts:  Stop mute pts */
+typedef struct
+{
+    HI_U32 enCmd;
+    HI_U32 u32StartPts;
+    HI_U32 u32StopPts;
+} HA_MS12_SET_PTS_MUTE_S;
+
+/** Define Setting parameter of SubstreamID
+    -enCmd:       HA_CODEC_MS12_SET_SUBSTREAMID_CMD
+    -u32SubStreamID: The ID of SubStream, normally the value is [1, 3] */
+typedef struct
+{
+    HI_U32 enCmd;
+    HI_U32 u32SubStreamID;
+} HA_MS12_SET_SUBSTREAMID_S;
+
+/** Define Getting parameter of stream info
+    -enCmd:         HA_CODEC_MS12_GET_STREAM_INFO_CMD
+    -enStreamType:  Detail stream type
+    -u32Acmod:      Acmod
+                    0  = 1/1 (dual mono)
+                    1  = 1/0 (C)
+                    2  = 2/0 (L, R)
+                    3  = 3/0 (L, R, C)
+                    4  = 2/1 (L, R, l)
+                    5  = 3/1 (L, R, C, l)
+                    6  = 2/2 (L, R, l, r)
+                    7  = 3/2 (L, R, C, l, r)
+                    9  = 2/2/1 (L, R, l, r, Ts)
+                    10 = 3/2/1 (L, R, C, l, r, Ts)
+                    11 = 3/2/1 (L, R, C, l, r, Cvh)
+                    12 = 3/0/2 (L, R, C, Lc, Rc)
+                    13 = 2/2/2 (L, R, l, r, Lw, Rw)
+                    14 = 2/2/2 (L, R, l, r, Lvh, Rvh)
+                    15 = 2/2/2 (L, R, l, r, Lsd, Rsd)
+                    16 = 2/2/2 (L, R, l, r, Lrs, Rrs)
+                    17 = 3/2/2 (L, R, C, l, r, Lc, Rc)
+                    18 = 3/2/2 (L, R, C, l, r, Lw, Rw)
+                    19 = 3/2/2 (L, R, C, l, r, Lvh, Rvh)
+                    20 = 3/2/2 (L, R, C, l, r, Lsd, Rsd)
+                    21 = 3/2/2 (L, R, C, l, r, Lrs, Rrs)
+                    22 = 3/2/2 (L, R, C, l, r, Ts, Cvh)
+    -bLfeExist      Whether LFE is exist
+    -u32BitRate:    Stream bitrate (bps)
+    -u32SampleRate: Stream original sample rate */
+typedef struct
+{
+    HI_U32  enCmd;
+    MS12_STREAM_TYPE_E enStreamType;
+    HI_U32  u32Acmod;
+    HI_BOOL bLfeExist;
+    HI_U32  u32BitRate;
+    HI_U32  u32SampleRate;
+} HA_MS12_GET_STREAM_INFO_S;
+
+/** Define opening parameter of MS12 decoder
+    -u32DrcCut:   Determines the percentage of application of DRC
+                  attenuation factors for the 2 channel output.0 ~ 100 default: 100
+    -u32DrcBoost: Determines the percentage of application of DRC
+                  boost factors for the 2 channel output. 0 ~ 100 default: 100
+    -s32Balance:  User defined balance between main and associated signal
+                  Value range is between -32 and +32 (in dB)
+                  -32dB indicates main only (mute associated)
+                  +32dB indicates associated only (mute main) */
+typedef struct
+{
+    MS12_INPUT_TYPE_E       enInputType;
+    MS12_DAP_MODE_E         enDapMode;
+    MS12_LFEOUT_MODE_E      enLfeOutMode;
+    MS12_STEREODMX_MODE_E   enDmxMode;
+    MS12_DRC_MODE_E         enDrcMode;
+    HI_U32                  u32DrcCut;
+    HI_U32                  u32DrcBoost;
+    HI_S32                  s32AdBalance;
+} DOLBYMS12_CODEC_OPENCONFIG_S;
+
+#define HA_DOLBYMS12_CodecGetDefaultOpenConfig(pConfigParam) \
+    do { \
+        ((DOLBYMS12_CODEC_OPENCONFIG_S *)(pConfigParam))->enInputType   = MS12_DOLBY_DIGITAL_PLUS; \
+        ((DOLBYMS12_CODEC_OPENCONFIG_S *)(pConfigParam))->enDapMode     = MS12_DAP_NO_PROC; \
+        ((DOLBYMS12_CODEC_OPENCONFIG_S *)(pConfigParam))->enLfeOutMode  = MS12_LFEOUT_ON; \
+        ((DOLBYMS12_CODEC_OPENCONFIG_S *)(pConfigParam))->enDmxMode     = MS12_DMX_LTRT; \
+        ((DOLBYMS12_CODEC_OPENCONFIG_S *)(pConfigParam))->enDrcMode     = MS12_DRC_RF; \
+        ((DOLBYMS12_CODEC_OPENCONFIG_S *)(pConfigParam))->u32DrcCut     = 100; \
+        ((DOLBYMS12_CODEC_OPENCONFIG_S *)(pConfigParam))->u32DrcBoost   = 100; \
+        ((DOLBYMS12_CODEC_OPENCONFIG_S *)(pConfigParam))->s32AdBalance  = 0; \
+    } while (0)
+
+#define HA_DOLBYMS12_CodecGetDefaultOpenParam(pOpenParam, pstPrivateParams) \
+    do { HI_U32 i; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_SIMUL; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved    = HI_TRUE; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate  = 48000; \
+        for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+        { \
+            ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+        } \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(DOLBYMS12_CODEC_OPENCONFIG_S); \
+    } while (0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HA_AUDIO_DOLBYMS12_DECODE_H__ */
diff -uNr a/include/HA.AUDIO.DOLBYMS12EXT.decode.h b/include/HA.AUDIO.DOLBYMS12EXT.decode.h
--- a/include/HA.AUDIO.DOLBYMS12EXT.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.DOLBYMS12EXT.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,318 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.DOLBYMS12EXT.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HA_AUDIO_DOLBYMS12EXT_DECODE_H__
+#define __HA_AUDIO_DOLBYMS12EXT_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+#include "HA.AUDIO.DOLBYMS12.decode.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#define  MS12_MAX_STREAM_NUM         (6)
+#define  MS12_MIXER_NUM              (2)
+#define  MS12_MIXER_MAX_SOURCE_NUM   (3)
+
+#define  MS12_SUPPORT_FORMAT_DDP     (1 << 0)
+#define  MS12_SUPPORT_FORMAT_AAC     (1 << 1)
+#define  MS12_SUPPORT_FORMAT_AC4     (1 << 2)
+#define  MS12_SUPPORT_FORMAT_MP3     (1 << 3)
+
+#define  HA_CODEC_MS12_DECODE_FRAME_CMD               ((((HI_U32)HA_MS12_ID) << 16) | 0x2000)
+#define  HA_CODEC_MS12_ENABLE_DECODE_CMD              ((((HI_U32)HA_MS12_ID) << 16) | 0x2001)
+#define  HA_CODEC_MS12_ENABLE_MIX_CMD                 ((((HI_U32)HA_MS12_ID) << 16) | 0x2002)
+#define  HA_CODEC_MS12_DROP_FRAME_CMD                 ((((HI_U32)HA_MS12_ID) << 16) | 0x2003)
+#define  HA_CODEC_MS12_SET_STREAM_INDEX_CMD           ((((HI_U32)HA_MS12_ID) << 16) | 0x2004)
+#define  HA_CODEC_MS12_ADJUST_STRATEGY_CMD            ((((HI_U32)HA_MS12_ID) << 16) | 0x2005)
+#define  HA_CODEC_MS12_RESET_CMD                      ((((HI_U32)HA_MS12_ID) << 16) | 0x2006)
+#define  HA_CODEC_MS12_SET_EOSFLAG_CMD                ((((HI_U32)HA_MS12_ID) << 16) | 0x2007)
+#define  HA_CODEC_MS12_SET_MEDIAVOLATTENUATE_CMD      ((((HI_U32)HA_MS12_ID) << 16) | 0x2008)
+#define  HA_CODEC_MS12_SET_PROCINFO_CMD               ((((HI_U32)HA_MS12_ID) << 16) | 0x2009)
+#define  HA_CODEC_MS12_SET_MIXER1_VOLUME_CMD          ((((HI_U32)HA_MS12_ID) << 16) | 0x200A)
+#define  HA_CODEC_MS12_GET_CAPABILITY_CMD             ((((HI_U32)HA_MS12_ID) << 16) | 0x200B)
+#define  HA_CODEC_MS12_SET_DEC_POLICY_CMD             ((((HI_U32)HA_MS12_ID) << 16) | 0x200C)
+#define  HA_CODEC_MS12_SOFTRESET_CMD                  ((((HI_U32)HA_MS12_ID) << 16) | 0x200D)
+#define  HA_CODEC_MS12_SET_PES_DATA_CMD               ((((HI_U32)HA_MS12_ID) << 16) | 0x200E)
+#define  HA_CODEC_MS12_SET_INPUTTYPE_CMD              ((((HI_U32)HA_MS12_ID) << 16) | 0x200F)
+#define  HA_CODEC_MS12_SET_ATMOSLOCK_CMD              ((((HI_U32)HA_MS12_ID) << 16) | 0x2010)
+#define  HA_CODEC_MS12_SET_SOURCEMUTE_CMD             ((((HI_U32)HA_MS12_ID) << 16) | 0x2011)
+#define  HA_CODEC_MS12_SET_SOURCEPRESCALE_CMD         ((((HI_U32)HA_MS12_ID) << 16) | 0x2012)
+
+typedef enum
+{
+    MS11_CONFIG,
+    MS12_CONFIG_B,
+    MS12_CONFIG_D,
+} MS12_CONFIG_E;
+
+typedef enum
+{
+    MS12_STREAM_IDLE = 0,
+    MS12_STREAM_RUNNING,
+    MS12_STREAM_PAUSE,
+    MS12_STREAM_STOP,
+    MS12_STREAM_ACTIVATE,
+} MS12_STREAM_STATE_E;
+
+/** Define Dec Policy mode
+    - 0: Only dec main
+    - 1: Only dec assoc
+    - 2: dec dual */
+typedef enum
+{
+    MS12_DEC_MAIN = 0,
+    MS12_DEC_ASSOC,
+    MS12_DEC_DUAL,
+} MS12_DEC_POLICY_E;
+
+typedef struct
+{
+    HI_U32 u32TryCnt;
+    HI_U32 u32OkCnt;
+    HI_U32 u32PriUnderRunCnt;
+    HI_U32 u32SecUnderRunCnt;
+    HI_U32 u32ThirdUnderRunCnt;
+    HI_U32 u32InBufBytes[MS12_MIXER_MAX_SOURCE_NUM];
+} MS12_MIXER_PROC_S;
+
+/** Define proc info of stream */
+typedef struct
+{
+    MS12_STREAM_TYPE_E enStreamType;
+    HI_BOOL            bDecodeEnable;
+    HI_BOOL            bMixEnable;
+    HI_BOOL            bLfeExist;
+    HI_U32             u32StreamLeftBytes;
+    HI_U32             u32SampleRate;
+    HI_U32             u32BitRate;
+    HI_U32             u32Acmod;
+    HI_U32             u32LeftDropMs;
+    HI_S32             s32Volume;
+    HI_U32             u32CurOutFrameMs;
+    HI_U32             u32NotEnoughCnt;
+    HI_U32             u32DecodeTryCnt;
+    HI_U32             u32DecodeOkCnt;
+    HI_U32             u32DecodeErrCnt;
+    HI_U32             u32DecodeInBufBytes;
+    HI_BOOL            bMute;
+    HI_U32             u32IntPrescale;
+    HI_S32             s32DecPrescale;
+} MS12_STREAM_PROC_S;
+
+typedef struct
+{
+    MS12_CONFIG_E      enConfig;
+    HI_BOOL            bSupportHeaac;
+    HI_U32             u32OutChannels;
+    HI_U32             u32OutSampleRate;
+    HI_U32             u32DebugLevel;
+    HI_BOOL            bDumpFile;
+    HI_BOOL            bDumpSectionFile;
+    HI_U32             u32FlushCnt;
+    HI_U32             u32SoftResetCnt;
+    HI_BOOL            bExtMain;
+    MS12_MIXER_PROC_S  stMixerProc[MS12_MIXER_NUM];
+    MS12_STREAM_PROC_S stStreamProc[MS12_MAX_STREAM_NUM];
+    DOLBYMS12_CODEC_OPENCONFIG_S stCodecConfig;
+    HI_BOOL            bAtmosOutput;
+} HA_MS12_PROC_S;
+
+typedef struct
+{
+    MS12_STREAM_STATE_E     enStreamState[MS12_MAX_STREAM_NUM];
+    HI_HADECODE_INPACKET_S* pstInPack[MS12_MAX_STREAM_NUM];
+
+    HI_BOOL  bPassthruBypass;
+    HI_U32   u32TrackDelayMs;
+    HI_CHAR* acUnifyWorkBuf[2];
+    HI_U32   u32UseCase;
+} MS12_INPUT_S;
+
+typedef struct
+{
+    HI_U32  u32OutFrameMs[MS12_MAX_STREAM_NUM];
+    HI_U32  u32DecodeLeftBytes[MS12_MAX_STREAM_NUM];
+    HI_U32  u32PcmDelayMs[MS12_MAX_STREAM_NUM];
+    HI_U32  u32DecoderStaticDelay[MS12_MAX_STREAM_NUM];
+    HI_S32  s32ErrState[MS12_MAX_STREAM_NUM];
+    HI_BOOL bStreamEnough[MS12_MAX_STREAM_NUM];
+    HI_HADECODE_OUTPUT_S* pstOutput;
+    HI_BOOL bAtmosOutActive;
+    HI_U32  u32AddMediaPauseMuteMs;
+    HI_U32  u32AddMediaMixerMuteMs;
+} MS12_OUTPUT_S;
+
+typedef struct
+{
+    MS12_INPUT_S  stInput;
+    MS12_OUTPUT_S stOutput;
+} HA_MS12_STREAM_S;
+
+/** Define decoding parameter
+    - enCmd: HA_CODEC_MS12_DECODE_FRAME_CMD */
+typedef struct
+{
+    HI_U32 enCmd;
+    HA_MS12_STREAM_S stStream;
+} HA_MS12_DECODE_STREAM_S;
+
+/** Define Setting proc info parameter
+    - enCmd: HA_CODEC_MS12_SET_PROCINFO_CMD */
+typedef struct
+{
+    HI_U32 enCmd;
+    HA_MS12_PROC_S stProc;
+} HA_MS12_SET_PROCINFO_S;
+
+/** Define Setting stream index parameter
+    - enCmd: HA_CODEC_MS12_SET_STREAM_INDEX_CMD
+    - u32Index: Indicates the stream index, support 0 ~ 3 */
+typedef struct
+{
+    HI_U32 enCmd;
+    HI_U32 u32Index;
+} HA_MS12_SET_STREAM_INDEX_S;
+
+/** Define adjusting strategy parameter
+    - enCmd: HA_CODEC_MS12_ADJUST_STRATEGY_CMD
+    - s32AdjustTime: The time to adjust (ms) */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_S32  s32AdjustTime;
+} HA_MS12_ADJUST_STRATEGY_S;
+
+/** Define enable decode parameter
+    -enCmd: HA_CODEC_ENABLE_DECODE_CMD
+    -bEnable: Indicates whether to decode */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_BOOL bEnable;
+} HA_MS12_DECODE_ENABLE_S;
+
+/** Define parameter of enable mix
+    -enCmd: HA_CODEC_ENABLE_MIX_CMD
+    -bEnable: Indicates whether to mix to the output */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_BOOL bEnable;
+} HA_MS12_MIX_ENABLE_S;
+
+/** Define dropping frame parameter
+    -enCmd: HA_CODEC_DROP_FRAME_CMD
+    -u32FrameCnt: frame count to drop for one stream */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_U32  u32FrameCnt;
+} HA_MS12_DROP_FRAME_S;
+
+/** Define Setting parameter of eos flag
+    -enCmd: HA_CODEC_SET_EOSFLAG_CMD
+    -bEosFlag: Is the stream reach the end */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_BOOL bEosFlag;
+} HA_MS12_SET_EOSFLAG_S;
+
+/** Define Setting parameter of media volume attenuation
+    -enCmd: HA_CODEC_SET_MEDIAVOLATTENUATE_CMD
+    -bEnable: Indicates whether to attenuate media volume */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_BOOL bEnable;
+} HA_MS12_SET_MEDIAVOLATTENUATE_S;
+
+/** Define Getting MS12 Capability
+    -enCmd: HA_CODEC_MS12_GET_CAPABILITY_CMD
+    -u32Capability: Indicates MS12 support all format */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_U32  u32Capability;
+} HA_MS12_GET_CAPABILITY_S;
+
+/** Define Setting parameter of dec policy mode
+    - enCmd: HA_CODEC_MS12_SET_DEC_POLICY_CMD */
+typedef struct
+{
+    HI_U32 enCmd;
+    MS12_DEC_POLICY_E enPolicy;
+} HA_MS12_DEC_POLICY_S;
+
+/** Define Setting parameter of Audio Description
+    -enCmd:          HA_CODEC_MS12_SET_PES_DATA_CMD
+    -au8Data[0]:  fade_byte
+    -au8Data[1]:  gain_byte_center
+    -au8Data[2]:  gain_byte_front
+    -au8Data[3]:  gain_byte_surround
+    -au8Data[4]:  pan_byte */
+typedef struct
+{
+    HI_U32 enCmd;
+    HI_U8  au8Data[5];
+} HA_MS12_SET_PES_DATA_S;
+
+/** Define Setting parameter of main input type
+    -enCmd: HA_CODEC_MS12_SET_INPUTTYPE_CMD
+    -enInputType: Indicates main input type */
+typedef struct
+{
+    HI_U32  enCmd;
+    MS12_INPUT_TYPE_E enInputType;
+} HA_MS12_SET_INPUTTYPE_S;
+
+/** Define Setting parameter of atmos lock
+    -enCmd: HA_CODEC_MS12_SET_ATMOSLOCK_CMD
+    -bEnable: Indicates atmos lock */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_BOOL bEnable;
+} HA_MS12_SET_ATMOSLOCK_S;
+
+/** Define Setting parameter of source mute
+    -enCmd: HA_CODEC_MS12_SET_SOURCEMUTE_CMD
+    -bEnable: Indicates mute status */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_BOOL bEnable;
+} HA_MS12_SET_SOURCEMUTE_S;
+
+/** Define Setting parameter of source prescale
+    -enCmd: HA_CODEC_MS12_SET_SOURCEPRESCALE_CMD
+    -s32IntegerGain: Interger part of high preicision gain
+    -s32DecimalGain: decimal part of high preicision gain, if -0.125dB, value is -125 */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_S32  s32IntegerGain;
+    HI_S32  s32DecimalGain;
+} HA_MS12_SET_SOURCEPRESCALE_S;
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HA_AUDIO_DOLBYMS12EXT_DECODE_H__ */
diff -uNr a/include/HA.AUDIO.DOLBYPLUS.decode.h b/include/HA.AUDIO.DOLBYPLUS.decode.h
--- a/include/HA.AUDIO.DOLBYPLUS.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.DOLBYPLUS.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,278 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.DOLBYPLUS.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HA_AUDIO_DOLBYPLUS_DECODE_H__
+#define __HA_AUDIO_DOLBYPLUS_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+
+
+#define HA_DOLBYPLUS_ID 0x1010
+
+/* The Command of online setting DRC mode, etc. */
+#define HA_CODEC_DOLBYPLUS_SET_DRC_MODE_CMD       ((((HI_U32)HA_DOLBYPLUS_ID) << 16) | 0x1000)
+#define HA_CODEC_DOLBYPLUS_SET_LFE_MODE_CMD       ((((HI_U32)HA_DOLBYPLUS_ID) << 16) | 0x1001)
+#define HA_CODEC_DOLBYPLUS_SET_DMX_MODE_CMD       ((((HI_U32)HA_DOLBYPLUS_ID) << 16) | 0x1002)
+#define HA_CODEC_DOLBYPLUS_SET_DYNSCALE_MODE_CMD  ((((HI_U32)HA_DOLBYPLUS_ID) << 16) | 0x1003)
+
+/* The Command of set stop flag (normally only used in chip certification). */
+#define HA_CODEC_SET_STOP_FLAG_CMD                ((((HI_U32)HA_DOLBYPLUS_ID) << 16) | 0x1004)
+
+#define IEC61937_PAYLOAD_SIZE_EAC3_HD             (6144 * 4 + 1536 * 4)
+
+
+
+/*!< Decoder dynamic range compression mode
+     - 0 = custom mode, analog dialnorm
+     - 1 = custom mode, digital dialnorm
+     - 2 = line out mode
+     - 3 = RF remod mode (default)
+     - 4 = Portable mode -8dB (output reference level is -8dB)
+     - 5 = Portable mode -11dB (output reference level is -11dB)
+     - 6 = Portable mode -14dB (output reference level is -14dB)
+     - t = Portable mode test (use this ONLY for bit-for-bit validation)
+     - x = Dynamic range control suppression mode */
+typedef enum
+{
+    DOLBYPLUS_DRC_CUSTOM_0 = 0,
+    DOLBYPLUS_DRC_CUSTOM_1,
+    DOLBYPLUS_DRC_LINE,
+    DOLBYPLUS_DRC_RF,            // (default)
+    DOLBYPLUS_DRC_PORTABLE_L8,
+    DOLBYPLUS_DRC_PORTABLE_L11,
+    DOLBYPLUS_DRC_PORTABLE_L14,
+    DOLBYPLUS_DRC_PORTABLE_TEST
+} DOLBYPLUS_DRC_MODE_E;
+
+/*!< Define LFE Downmixing mode
+     - 0 = Properly downmixes the LFE channel according to the lfemixlevcod parameter
+           when DRC is set to Line mode
+     - 1 = LFE channel is not downmixed when DRC is set to RF mode
+     - 2 = .2 channels (only available for 7.1 PCM output) */
+typedef enum
+{
+    DOLBYPLUS_LFEOUTOFF = 0,
+    DOLBYPLUS_LFEOUTON,
+    DOLBYPLUS_LFEDOWNMIX    = DOLBYPLUS_LFEOUTOFF,
+    DOLBYPLUS_LFENOTDOWNMIX = DOLBYPLUS_LFEOUTON,    // (default)
+    DOLBYPLUS_LFEOUTDUAL,
+} DOLBYPLUS_LFEOUT_MODE;
+
+/*!< Decoder output mode. If the output mode does not equal the bitstream audio 
+     coding mode (acmod), then the decoder will perform downmixing or fill channels
+     with zero values to meet the desired output configuration.
+
+     Note: only the first main output can support values > 7
+     - r = raw mode (outputs all standard (non-replaced) channels in 7.1-channel
+           bitstream; no channel mixing or remapping performed)
+     - 0 = reserved
+     - 1 = 1/0 (C)
+     - 2 = 2/0 (L, R)
+     - 3 = 3/0 (L, R, C)
+     - 4 = 2/1 (L, R, l)
+     - 5 = 3/1 (L, R, C, l)
+     - 6 = 2/2 (L, R, l, r)
+     - 7 = 3/2 (L, R, C, l, r)
+     - 9 = 2/2/1 (L, R, l, r, Ts)
+     - 10 = 3/2/1 (L, R, C, l, r, Ts)
+     - 11 = 3/2/1 (L, R, C, l, r, Cvh)
+     - 12 = 3/0/2 (L, R, C, Lc, Rc)
+     - 13 = 2/2/2 (L, R, l, r, Lw, Rw)
+     - 14 = 2/2/2 (L, R, l, r, Lvh, Rvh)
+     - 15 = 2/2/2 (L, R, l, r, Lsd, Rsd)
+     - 16 = 2/2/2 (L, R, l, r, Lrs, Rrs)
+     - 17 = 3/2/2 (L, R, C, l, r, Lc, Rc)
+     - 18 = 3/2/2 (L, R, C, l, r, Lw, Rw)
+     - 19 = 3/2/2 (L, R, C, l, r, Lvh, Rvh)
+     - 20 = 3/2/2 (L, R, C, l, r, Lsd, Rsd)
+     - 21 = 3/2/2 (L, R, C, l, r, Lrs, Rrs)
+     - 22 = 3/2/2 (L, R, C, l, r, Ts, Cvh)
+     - 23 = Follow (not yet implemented)  */
+typedef enum
+{
+    DOLBYPLUS_OUT_MODE11 = 0,
+    DOLBYPLUS_OUT_MODE10,
+    DOLBYPLUS_OUT_MODE20,          // (default)
+    DOLBYPLUS_OUT_MODE30,
+    DOLBYPLUS_OUT_MODE21,
+    DOLBYPLUS_OUT_MODE31,
+    DOLBYPLUS_OUT_MODE22,
+    DOLBYPLUS_OUT_MODE32,
+} DOLBYPLUS_OUTPUT_MODE_E;
+
+/*!< Decoder dual mono mode (Only when <i>acmod</i> is 1/1)
+     - 0 = Stereo
+     - 1 = Left mono
+     - 2 = Right mono
+     - 3 = Mixed mono */
+typedef enum
+{
+    DOLBYPLUS_DUAL_STEREO = 0,   // (default)
+    DOLBYPLUS_DUAL_LEFTMONO,
+    DOLBYPLUS_DUAL_RGHTMONO,
+    DOLBYPLUS_DUAL_MIXMONO,
+} DOLBYPLUS_DUAL_MODE_E;
+
+/*!< Decoder stereo output mode.  This parameter specifies the
+     reproduction mode associated with stereo output(output mode = 2/0).
+     - 0 = Automatically detects stereo mode based on setting in the bit stream.
+     - 1 = 2/0 Dolby Surround compatible (Lt/Rt)
+     - 2 = 2/0 Stereo (Lo/Ro)
+     - 3 = Reserved */
+typedef enum
+{
+    DOLBYPLUS_DMX_AUTO = 0,
+    DOLBYPLUS_DMX_SRND,
+    DOLBYPLUS_DMX_STEREO,
+    DOLBYPLUS_DMX_LTRT = DOLBYPLUS_DMX_SRND,    // (default)
+    DOLBYPLUS_DMX_LORO = DOLBYPLUS_DMX_STEREO,
+} DOLBYPLUS_STEREODMX_MODE_E;
+
+/*!< Define DDP convert on/off */
+typedef enum
+{
+    DOLBYPLUS_CONVERTER_OFF = 0,
+    DOLBYPLUS_CONVERTER_ON                      // (default)
+} DOLBYPLUS_CONVERTER_MODE;
+
+
+typedef struct
+{
+    HI_U32  enCmd;          /* HA_CODEC_SET_STOP_FLAG_CMD */
+    HI_BOOL bStopFlag;
+    HI_BOOL bADStopFlag;
+} HA_SET_STOP_FLAG_S;
+
+/** DDP  HA_DOLBYPLUS_EVENT_SOURCE_CHANGE event, stream information user data definition */
+typedef struct  hiDOLBYPLUS_STREAM_INFO_S
+{
+    HI_S16 s16StreamType;   /* 0: dolby digital, 1: dolby digital plus */
+    HI_S16 s16Acmod;
+    HI_S32 s32BitRate;
+    HI_S32 s32SampleRateRate;
+} DOLBYPLUS_STREAM_INFO_S;
+
+/* Define the struct for set drc mode from .DecSetConfig */
+typedef struct
+{
+    HI_U32  enCmd;
+    DOLBYPLUS_DRC_MODE_E eDrcMode;
+} HA_DOLBYPLUS_SET_DRC_MODE_S;
+
+/* Define the struct for set lfe out mode from .DecSetConfig */
+typedef struct
+{
+    HI_U32  enCmd;
+    DOLBYPLUS_LFEOUT_MODE eLfeMode;
+} HA_DOLBYPLUS_SET_LFE_MODE_S;
+
+/* Define the struct for set downmix mode from .DecSetConfig */
+typedef struct
+{
+    HI_U32  enCmd;
+    DOLBYPLUS_STEREODMX_MODE_E eDmxMode;
+} HA_DOLBYPLUS_SET_DMX_MODE_S;
+
+/* Define the struct for set dynamic scale value from .DecSetConfig */
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_S16  s16DynScaleHigh;
+    HI_S16  s16DynScaleLow;
+} HA_DOLBYPLUS_SET_DYNSCALE_MODE_S;
+
+/** DDP callback event defination */
+typedef enum
+{
+    HA_DOLBYPLUS_EVENT_SOURCE_CHANGE = 0,     /**< stream information change event, DOLBYPLUS_STREAM_INFO_S */
+    HA_DOLBYPLUS_EVENT_BUTT
+} DOLBYPLUS_EVENT_E;
+
+
+/** DDP callback method definition */
+typedef HI_VOID (*DOLBYPLUS_EVENT_CB_FN)(DOLBYPLUS_EVENT_E enEvent, HI_VOID* pAppData);
+
+
+typedef struct  hiDOLBYPLUS_DECODE_OPENCONFIG_S
+{
+    DOLBYPLUS_DRC_MODE_E       enDrcMode;      /* dynamic range compression mode */
+    DOLBYPLUS_LFEOUT_MODE      enOutLfe;       /* output LFE channel present     */
+    DOLBYPLUS_OUTPUT_MODE_E    enOutputMode;   /* output channel configuration   */
+    DOLBYPLUS_STEREODMX_MODE_E enDmxMode;      /* stereo output mode    */
+    DOLBYPLUS_DUAL_MODE_E      enDualMode;     /* dual mono reproduction mode   */
+    HI_S16                     s16PcmScale;    /* PCM scale factor, 0~100,default:100,  100 means 1.0, 33 means 0.33,etc */
+    HI_S16                     s16DynScaleHigh;/* dynamic range compression cut scale factor, 0~100,default:100,  100 means 1.0, 33 means 0.33,etc*/
+    HI_S16                     s16DynScaleLow; /* dynamic range compression boost scale factor, 0~100,default:100, 100 means 1.0, 33 means 0.33,etc   */
+    DOLBYPLUS_CONVERTER_MODE   enConvertMode;  /* ddp decoder-converter on/off     */
+    HI_S16                     PirvateControl; /* private test control(0~255), default:0. */
+    HI_CHAR                    szInputFileName[256]; /*  private test params */
+    DOLBYPLUS_EVENT_CB_FN      pfnEvtCbFunc[HA_DOLBYPLUS_EVENT_BUTT];      /* ddp call back method */
+    HI_VOID*                   pAppData[HA_DOLBYPLUS_EVENT_BUTT];          /* application defined value for ddp call back method */
+} DOLBYPLUS_DECODE_OPENCONFIG_S;
+
+
+#define HA_DOLBYPLUS_DecGetDefalutOpenConfig(pConfigParam) \
+    do { HI_S32 n; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->enDrcMode = DOLBYPLUS_DRC_RF; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->enOutLfe  = DOLBYPLUS_LFEOUTON; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->enOutputMode = DOLBYPLUS_OUT_MODE20; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->enDmxMode    = DOLBYPLUS_DMX_SRND; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->enDualMode   = DOLBYPLUS_DUAL_STEREO; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->s16PcmScale  = 100; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->s16DynScaleHigh = 100; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->s16DynScaleLow  = 100; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->enConvertMode   = DOLBYPLUS_CONVERTER_OFF; \
+        ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->PirvateControl  = 0; \
+        for (n = 0; n < HA_DOLBYPLUS_EVENT_BUTT; n++) \
+        { \
+            ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->pfnEvtCbFunc[n] = HI_NULL; \
+            ((DOLBYPLUS_DECODE_OPENCONFIG_S *)(pConfigParam))->pAppData[n] = HI_NULL; \
+        } \
+    } while (0)
+
+
+#define HA_DOLBYPLUS_DecGetDefalutOpenParam(pOpenParam, pstPrivateParams) \
+    do { HI_S32 i; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_SIMUL; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+        for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+        { \
+            ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+        } \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(DOLBYPLUS_DECODE_OPENCONFIG_S); \
+    } while (0)
+
+
+#define HA_DOLBYPLUS_DecSetMode(pOpenParam, eDecMode) \
+    do { ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = eDecMode; } while (0)
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HA_AUDIO_DOLBYPLUS_DECODE_H__ */
+
diff -uNr a/include/HA.AUDIO.DOLBYTRUEHD.decode.h b/include/HA.AUDIO.DOLBYTRUEHD.decode.h
--- a/include/HA.AUDIO.DOLBYTRUEHD.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.DOLBYTRUEHD.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,87 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.TRUEHD.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_DOLBY_TRUEHD_H__
+#define __HISI_AUDIO_DECODER_DOLBY_TRUEHD_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */  
+
+
+typedef enum hiTRUEHD_DRC_STATEMODE_TYPE_E
+{
+    TRUEHD_DRC_STATEMODE_TYPE_OFF,
+    TRUEHD_DRC_STATEMODE_TYPE_FOLLOW,      /**<default*/ /**<默认配置 */
+    TRUEHD_DRC_STATEMODE_TYPE_ON
+} TRUEHD_DRC_STATEMODE_TYPE_E;
+
+
+typedef struct hiTRUEHD_DECODE_OPENCONFIG_S
+{
+    HI_S32            				startByte ;
+    HI_S32           				s32chanflag;
+    HI_BOOL           			    fbaChannelOrder;
+
+    HI_BOOL           			    lossless;
+    TRUEHD_DRC_STATEMODE_TYPE_E     enDrcMode;
+    HI_S32            				drcBoost;
+    HI_S32            				drcCut;            
+    HI_BOOL           			    verbose;
+    HI_S32			  				lenSamp ;
+    HI_S32            				lenByte ;
+    HI_BOOL           			    archive;
+} TRUEHD_DECODE_OPENCONFIG_S;
+
+
+#define HA_DOLBY_TRUEHD_DecGetDefalutOpenConfig(pConfigParam) \
+do { ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->s32chanflag = 0x2; \
+     ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->startByte   = 0; \
+     ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->lenByte   = 0x7fffffff; \
+	 ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->lenSamp   = 0x7fffffff; \
+     ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->fbaChannelOrder = HI_FALSE; \
+     ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->lossless = HI_TRUE; \
+     ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->enDrcMode   = TRUEHD_DRC_STATEMODE_TYPE_FOLLOW; \
+     ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->drcBoost  = 100; \
+     ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->drcCut = 100; \
+     ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->verbose = HI_FALSE; \
+     ((TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->archive = HI_FALSE; \
+} while (0)
+
+#define HA_DOLBY_TRUEHD_DecGetDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_SIMUL; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 24; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(TRUEHD_DECODE_OPENCONFIG_S); \
+}while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_TRUEHD_H__ */
+
diff -uNr a/include/HA.AUDIO.DRA.decode.h b/include/HA.AUDIO.DRA.decode.h
--- a/include/HA.AUDIO.DRA.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.DRA.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,93 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.DRA.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_DRA_H__
+#define __HISI_AUDIO_DECODER_DRA_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define    HA_DRA_ID 0x007        
+
+#define HA_CODEC_GET_DRA_DonwmixMultich_MODE_CMD  ((((HI_U32)HA_DRA_ID) << 16) | 0x1000)
+#define HA_CODEC_GET_DRA_RAWCHANNEL_MODE_CMD      ((((HI_U32)HA_DRA_ID) << 16) | 0x1001)
+
+typedef struct
+{
+    HI_U32  enCmd;              /* HA_DRA_GET_DonwmixMultich_MODE_S */
+    HI_BOOL  *pbDonwmixMultichMode;
+} HA_DRA_GET_DonwmixMultich_MODE_S;
+
+typedef enum
+{
+    DRA_RAWCHANNEL_MODE10 = 0,
+    DRA_RAWCHANNEL_MODE11,
+    DRA_RAWCHANNEL_MODE20,
+    DRA_RAWCHANNEL_MODE21,
+    DRA_RAWCHANNEL_MODE30,
+    DRA_RAWCHANNEL_MODE31,
+    DRA_RAWCHANNEL_MODE40,
+    DRA_RAWCHANNEL_MODE41,
+    DRA_RAWCHANNEL_MODE50,
+    DRA_RAWCHANNEL_MODE51,
+    DRA_RAWCHANNEL_BUTT = 0x100,   /* Unsupported Channel Mode */
+} HA_DRA_RAWCHANNEL_MODE;
+
+typedef struct
+{
+    HI_U32  enCmd;              /* HA_CODEC_GET_DRA_RAWCHANNEL_MODE_CMD */
+    HA_DRA_RAWCHANNEL_MODE  eRawChannelMode;
+} HA_DRA_GET_RawChannel_MODE_S;
+
+#define HA_DRA_DecGetDefalutOpenParam(pOpenParam) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_SIMUL; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 24; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+}while(0)
+
+#define HA_DRA_DecGetOpenParam_MultichPcm(pOpenParam) \
+    do{ HI_S32 i; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_SIMUL; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 8; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 24; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+        for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+        { \
+            ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+        } \
+    }while(0)
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_DRA_H__ */
+
diff -uNr a/include/HA.AUDIO.DTSHD.decode.h b/include/HA.AUDIO.DTSHD.decode.h
--- a/include/HA.AUDIO.DTSHD.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.DTSHD.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,73 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.DTSHD.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_DTSHD_H__
+#define __HISI_AUDIO_DECODER_DTSHD_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+
+typedef  struct
+{
+    HI_U32  spkrOut;              /* set as a result of spkrout ,default is 2(Lo/Ro) */
+    HI_BOOL enableDownmix; /* default true */
+    HI_BOOL coreOnly;       /**< true: core decode only, false: dts hd decode,default value is true */
+	HI_BOOL lfeMixedToFrontWhenNoDedicatedLFEOutput;         /**< true: enable lfe,default value is false */    
+    HI_U32 outputBitWidth;        /**< 16: 16bit, 24: 24bit, 0,:native, defalut is 24 */
+    HI_BOOL enableDialNorm; /* true: enable , default value is true */
+    HI_U32  DRCPercent;      /* 0~100 - default is 0 ,no DRC */
+    HI_BOOL enableHDPassThrough;       /* true: enable , default value is true */
+    HI_U32  PirvateControl;     
+} DTSHD_DECODE_OPENCONFIG_S;
+
+#define HA_DTSHD_DecGetDefalutOpenConfig(pConfigParam) \
+    do {  \
+         ((DTSHD_DECODE_OPENCONFIG_S *)(pConfigParam))->spkrOut = 2; \
+         ((DTSHD_DECODE_OPENCONFIG_S *)(pConfigParam))->enableDownmix = HI_TRUE; \
+         ((DTSHD_DECODE_OPENCONFIG_S *)(pConfigParam))->coreOnly = HI_TRUE; \
+		 ((DTSHD_DECODE_OPENCONFIG_S *)(pConfigParam))->lfeMixedToFrontWhenNoDedicatedLFEOutput = HI_FALSE; \
+         ((DTSHD_DECODE_OPENCONFIG_S *)(pConfigParam))->outputBitWidth   = 24; \
+         ((DTSHD_DECODE_OPENCONFIG_S *)(pConfigParam))->enableDialNorm  = HI_TRUE; \
+         ((DTSHD_DECODE_OPENCONFIG_S *)(pConfigParam))->DRCPercent = 0; \
+		((DTSHD_DECODE_OPENCONFIG_S *)(pConfigParam))->enableHDPassThrough = HI_TRUE; \
+         ((DTSHD_DECODE_OPENCONFIG_S *)(pConfigParam))->PirvateControl = 0; \
+    } while (0)
+
+#define HA_DTSHD_DecGetDefalutOpenParam(pOpenParam, pstPrvateConfig) \
+    do { HI_S32 i; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_SIMUL; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+         for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+         { \
+             ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+         } \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrvateConfig; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(DTSHD_DECODE_OPENCONFIG_S); \
+    } while (0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_DTSHD_H__ */
diff -uNr a/include/HA.AUDIO.DTSM6.decode.h b/include/HA.AUDIO.DTSM6.decode.h
--- a/include/HA.AUDIO.DTSM6.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.DTSM6.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,113 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.DTSHD.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_DTSM6_H__
+#define __HISI_AUDIO_DECODER_DTSM6_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+
+
+/** DTSM6 HA_DOLBYPLUS_EVENT_SOURCE_CHANGE event, stream information user data defination
+    u32StreamType:
+        DTSDECSTRMTYPE_UNKNOWN              = 0x00000000,(indicator: Unkown)
+        DTSDECSTRMTYPE_DTS_LEGACY           = 0x00000001,(indicator: DTS)
+        DTSDECSTRMTYPE_DTS_ES_MATRIX        = 0x00000002,(indicator: DTS)
+        DTSDECSTRMTYPE_DTS_ES_DISCRETE      = 0x00000004,(indicator: DTS)
+        DTSDECSTRMTYPE_DTS_9624             = 0x00000008,(indicator: DTS)
+        DTSDECSTRMTYPE_DTS_ES_8CH_DISCRETE  = 0x00000010,(indicator: DTS)
+        DTSDECSTRMTYPE_DTS_HIRES            = 0x00000020,(indicator: DTS)
+        DTSDECSTRMTYPE_DTS_MA               = 0x00000040,(indicator: DTS)
+        DTSDECSTRMTYPE_DTS_LBR              = 0x00000080,(indicator: DTS Express)
+        DTSDECSTRMTYPE_DTS_LOSSLESS         = 0x00000100,(indicator: DTS-HD Mater Audio/DTS-HD MSTR)
+*/
+
+typedef struct
+{
+    HI_U32 u32StreamType;
+    HI_S32 s32BitRate;
+    HI_S32 s32SampleRate;
+} DTSM6_STREAM_INFO_S;
+
+/** DTSM6 callback event defination */
+typedef enum
+{
+    HA_DTSM6_EVENT_SOURCE_CHANGE = 0,     /**< stream information change event, DTSM6_STREAM_INFO_S */
+    HA_DTSM6_EVENT_BUTT
+} DTSM6_EVENT_E;
+
+/** DTSM6 callback method definition */
+typedef HI_VOID (*DTSM6_EVENT_CB_FN)(DTSM6_EVENT_E enEvent, HI_VOID* pAppData);
+
+
+typedef struct
+{
+    HI_U32  spkrOut;              /* set as a result of spkrout ,default is 2(Lo/Ro) */
+    HI_BOOL coreOnly;             /**< true: core decode only, false: dts hd decode,default value is false */
+    HI_U32  outputBitWidth;       /**< 16: 16bit, 24: 24bit, 0,:native, defalut is 16 */
+    HI_U32  DRCPercent;           /* 0~100 - default is 0 ,no DRC */
+    HI_BOOL enableHDPassThrough;  /* true: enable , default value is true */
+    HI_BOOL enableSPDIFOutput;    /* true: enable , default value is true */
+    HI_BOOL enableTransEncode;    /* true: enable , default value is false */
+    HI_U32  transEncodeMode;      /* 0,DTSTRANSCODEMODE_5_1_MIXOUT;1,DTSTRANSCODEMODE_FULL_MIXOUT;default 1 */
+    HI_BOOL allowUalignWord;      /* true: allow , default value is true */
+    DTSM6_EVENT_CB_FN  pfnEvtCbFunc[HA_DTSM6_EVENT_BUTT];   /* dtsm6 call back method */
+    HI_VOID*           pAppData[HA_DTSM6_EVENT_BUTT];       /* application defined value for dtsm6 call back method */
+} DTSM6_DECODE_OPENCONFIG_S;
+
+#define HA_DTSM6_DecGetDefalutOpenConfig(pConfigParam) \
+    do { HI_S32 n; \
+        ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->spkrOut = 2; \
+        ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->coreOnly = HI_FALSE; \
+        ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->outputBitWidth  = 24; \
+        ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->DRCPercent = 0; \
+        ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->enableHDPassThrough = HI_TRUE; \
+        ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->enableSPDIFOutput = HI_TRUE; \
+        ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->enableTransEncode = HI_TRUE; \
+        ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->transEncodeMode = 1; \
+        ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->allowUalignWord = HI_TRUE; \
+        for (n = 0; n < HA_DTSM6_EVENT_BUTT; n++) \
+        { \
+            ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->pfnEvtCbFunc[n] = HI_NULL; \
+            ((DTSM6_DECODE_OPENCONFIG_S *)(pConfigParam))->pAppData[n] = HI_NULL; \
+        } \
+    } while (0)
+
+#define HA_DTSM6_DecGetDefalutOpenParam(pOpenParam, pstPrvateConfig) \
+    do { HI_S32 i; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_SIMUL; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+        for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+        { \
+            ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+        } \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrvateConfig; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(DTSM6_DECODE_OPENCONFIG_S); \
+    } while (0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_DTSM6_H__ */
diff -uNr a/include/HA.AUDIO.DTSPASSTHROUGH.decode.h b/include/HA.AUDIO.DTSPASSTHROUGH.decode.h
--- a/include/HA.AUDIO.DTSPASSTHROUGH.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.DTSPASSTHROUGH.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,49 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.DTSPASSTHROUGH.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_DTSPASSTHROUGH_H__
+#define __HISI_AUDIO_DECODER_DTSPASSTHROUGH_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define HA_DTSPASSTHROUGH_ID 0x1025      
+
+#define HA_DTSPASSTHROUGH_DecGetDefalutOpenParam(pOpenParam) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_THRU; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+}while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_DTSPASSTHROUGH_H__ */
+
diff -uNr a/include/HA.AUDIO.FFMPEG_DECODE.decode.h b/include/HA.AUDIO.FFMPEG_DECODE.decode.h
--- a/include/HA.AUDIO.FFMPEG_DECODE.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.FFMPEG_DECODE.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,114 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.FFMPEG_DECODE.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_FFMPEG_DECODE_H__
+#define __HISI_AUDIO_DECODER_FFMPEG_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+
+#define HA_FFMPEG_ID 0x03ff        
+
+/**define status parameter of update information*/ /**CNcomment:状态信息更新，事件回调用户数据定义*/
+typedef struct  hiFFMPEG_STATUS_INFO_S
+{
+    HI_CHAR *name;
+    HI_S32  codec_id;
+    HI_S32  codec_type;
+    HI_S32  sample_fmt;
+    HI_S32  channels;
+    HI_S32  sample_rate;
+    HI_S32  bit_rate;
+    HI_S32  block_align;
+} FFMPEG_STATUS_INFO_S;
+
+
+/** Audio stream information */
+/** CNcomment:音频流信息 */
+typedef struct hiFFMPEG_AUD_INFO_S
+{
+    HI_S32   codec_id;
+    HI_S32   s32StreamIndex;
+    HI_U32   u32Format;
+    HI_U32   u32Profile;
+    HI_U32   u32SampleRate;
+    HI_U16   u16BitPerSample;
+    HI_U16   u16Channels;
+    HI_U32   u32BlockAlign;
+    HI_U32   u32Bitrate;
+    HI_BOOL  bBigEndian;
+    HI_U32   u32ExtradataSize;
+    HI_U8   *pu8Extradata;
+} FFMPEG_AUD_INFO_S;
+
+/**define the type of callback function*/ /**CNcomment:事件回调函数类型*/
+typedef enum
+{
+    HA_FFMPEG_EVENT_STATUS_CHANGE = 0,                   /**<update status information by every frame*/ /**<CNcomment:状态信息更新, 每帧更新一次*/
+    HA_FFMPEG_EVENT_BUTT
+} HA_FFMPEG_EVENT_E;
+
+/**define callback function*/ /**CNcomment:定义事件回调函数枚举类型*/
+typedef HI_VOID (*FFMPEG_EVENT_CB_FN)(HI_VOID* pAppData1, HI_VOID* pAppData2, HA_FFMPEG_EVENT_E enEvent);
+
+typedef struct  hiHA_FFMPEG_DECODE_OPENCONFIG_S
+{
+    HI_VOID *               hAvCtx; /* Same as libavcodec AVCodecContext, Set/allocated/freed by user. */
+    HI_BOOL                 bAutoDmxStereo; /* automatic downmix multi-ch to stereo. */
+    HI_BOOL                 bConvert2fmt16bit; /* automatic convert none-16bit pcm to 16bit pcm. */
+    FFMPEG_EVENT_CB_FN      pfnEvtCbFunc[HA_FFMPEG_EVENT_BUTT];    /* call back method */
+    HI_VOID*                pAppData1[HA_FFMPEG_EVENT_BUTT];       /* application handle,   Set/allocated/freed by user. */
+    HI_VOID*                pAppData2[HA_FFMPEG_EVENT_BUTT];       /* application defined value for call back method,  allocated/freed by user, set by ha_codec,*/
+    FFMPEG_AUD_INFO_S       stFfmpeg_AudInfo;
+} HA_FFMPEG_DECODE_OPENCONFIG_S;
+
+#define HA_FFMPEG_DecGetDefalutOpenConfig(pConfigParam) \
+    do { \
+        ((HA_FFMPEG_DECODE_OPENCONFIG_S *)(pConfigParam))->bAutoDmxStereo = HI_TRUE; \
+        ((HA_FFMPEG_DECODE_OPENCONFIG_S *)(pConfigParam))->bConvert2fmt16bit = HI_TRUE; \
+    } while (0)
+
+#define HA_FFMPEGC_DecGetDefalutOpenParam(pOpenParam, pFfmpegConfig) \
+    do { HI_S32 i; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+         for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+         { \
+             ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+         } \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = pFfmpegConfig; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(HA_FFMPEG_DECODE_OPENCONFIG_S); \
+         for (i = 0; i < HA_FFMPEG_EVENT_BUTT; i++) \
+         { \
+             ((HA_FFMPEG_DECODE_OPENCONFIG_S *)(pFfmpegConfig))->pfnEvtCbFunc[i] = HI_NULL; \
+             ((HA_FFMPEG_DECODE_OPENCONFIG_S *)(pFfmpegConfig))->pAppData1[i] = HI_NULL; \
+             ((HA_FFMPEG_DECODE_OPENCONFIG_S *)(pFfmpegConfig))->pAppData2[i] = HI_NULL; \
+         } \
+    } while (0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_FFMPEG_DECODE_H__ */
diff -uNr a/include/HA.AUDIO.FFMPEG_DTS.decode.h b/include/HA.AUDIO.FFMPEG_DTS.decode.h
--- a/include/HA.AUDIO.FFMPEG_DTS.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.FFMPEG_DTS.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,139 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.FFMPEG_DTS.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_FFMPEG_DTS_DECODE_H__
+#define __HISI_AUDIO_DECODER_FFMPEG_DTS_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+#define HA_FFMPEG_DTS_ID 0x0340     
+#define HA_CODEC_SET_DTS_DOWNMIX_INFO_CMD  	((((HI_U32)HA_FFMPEG_DTS_ID) << 16) | 0x1000)
+
+typedef struct hiFFMPEG_DTS_DownmixInfo_S {
+    /**
+     * Type of downmix preferred by the mastering engineer.
+     */
+	int preferred_downmix_type;
+
+    /**
+     * Absolute scale factor representing the nominal level of the center
+     * channel during a regular downmix.
+     */
+	double center_mix_level;
+
+    /**
+     * Absolute scale factor representing the nominal level of the center
+     * channel during an Lt/Rt compatible downmix.
+     */
+	double center_mix_level_ltrt;
+
+    /**
+     * Absolute scale factor representing the nominal level of the surround
+     * channels during a regular downmix.
+     */
+	double surround_mix_level;
+
+    /**
+     * Absolute scale factor representing the nominal level of the surround
+     * channels during an Lt/Rt compatible downmix.
+     */
+	double surround_mix_level_ltrt;
+
+    /**
+     * Absolute scale factor representing the level at which the LFE data is
+     * mixed into L/R channels during downmixing.
+     */
+	double lfe_mix_level;
+}FFMPEG_DTS_DownmixInfo_S;
+
+typedef struct
+{
+	HI_U32  enCmd;              /* HA_CODEC_SET_DTS_DOWNMIX_INFO_CMD */
+	FFMPEG_DTS_DownmixInfo_S* peDTSDownmixInfo;
+} HA_FFMPEG_DTS_DOWNMIX_INFO_S;
+
+/**define the type of callback function*/ /**CNcomment:事件回调函数类型*/
+typedef enum
+{
+	HA_FFMPEG_DTS_EVENT_STATUS_CHANGE = 0,                   /**<update status information by every frame*/ /**<CNcomment:状态信息更新, 每帧更新一次*/
+	HA_FFMPEG_DTS_EVENT_BUTT
+} HA_FFMPEG_DTS_EVENT_E;
+
+/**define callback function*/ /**CNcomment:定义事件回调函数枚举类型*/
+typedef HI_VOID (*FFMPEG_DTS_EVENT_CB_FN)(HI_VOID* pAppData1, HI_VOID* pAppData2, HA_FFMPEG_DTS_EVENT_E enEvent);
+
+typedef struct  hiHA_FFMPEG_DTS_DECODE_OPENCONFIG_S
+{
+	HI_VOID *               hAvCtx; /* Same as libavcodec AVCodecContext, Set/allocated/freed by user. */
+	HI_BOOL                 bAutoDmxStereo; /* automatic downmix multi-ch to stereo. */
+	HI_BOOL                 bConvert2fmt16bit; /* automatic convert none-16bit pcm to 16bit pcm. */
+	FFMPEG_DTS_EVENT_CB_FN      pfnEvtCbFunc[HA_FFMPEG_DTS_EVENT_BUTT];    /* call back method */
+	HI_VOID*                pAppData1[HA_FFMPEG_DTS_EVENT_BUTT];       /* application handle,   Set/allocated/freed by user. */
+	HI_VOID*                pAppData2[HA_FFMPEG_DTS_EVENT_BUTT];       /* application defined value for call back method,  allocated/freed by user, set by ha_codec,*/
+} HA_FFMPEG_DTS_DECODE_OPENCONFIG_S;
+
+#define FFMPEDTS_DecGetDefalutOpenConfig(pConfigParam) \
+    do { \
+		((HA_FFMPEG_DTS_DECODE_OPENCONFIG_S *)(pConfigParam))->bAutoDmxStereo = HI_TRUE; \
+		((HA_FFMPEG_DTS_DECODE_OPENCONFIG_S *)(pConfigParam))->bConvert2fmt16bit = HI_TRUE; \
+    } while (0)
+
+#define HA_FFMPEDTS_DecGetDefalutOpenParam_Config(pOpenParam, pFfmpegDTSConfig) \
+    do { 	HI_S32 i; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+		for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+		{ \
+			((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+		} \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = pFfmpegDTSConfig; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(HA_FFMPEG_DTS_DECODE_OPENCONFIG_S); \
+		for (i = 0; i < HA_FFMPEG_DTS_EVENT_BUTT; i++) \
+		{ \
+			((HA_FFMPEG_DTS_DECODE_OPENCONFIG_S *)(pFfmpegDTSConfig))->pfnEvtCbFunc[i] = HI_NULL; \
+			((HA_FFMPEG_DTS_DECODE_OPENCONFIG_S *)(pFfmpegDTSConfig))->pAppData1[i] = HI_NULL; \
+			((HA_FFMPEG_DTS_DECODE_OPENCONFIG_S *)(pFfmpegDTSConfig))->pAppData2[i] = HI_NULL; \
+		} \
+    } while (0)
+
+#define HA_FFMPEDTS_DecGetDefalutOpenParam(pOpenParam) \
+            do {    HI_S32 i; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+                for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+                { \
+                    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+                } \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = NULL; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+            } while (0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_FFMPEG_DTS_DECODE_H__ */
diff -uNr a/include/HA.AUDIO.FFMPEG_EAC3.decode.h b/include/HA.AUDIO.FFMPEG_EAC3.decode.h
--- a/include/HA.AUDIO.FFMPEG_EAC3.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.FFMPEG_EAC3.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,200 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.FFMPEG_EAC3.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_FFMPEG_EAC3_DECODE_H__
+#define __HISI_AUDIO_DECODER_FFMPEG_EAC3_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+#define HA_FFMPEG_EAC3_ID 0x0320     
+#define HA_CODEC_SET_EAC3_DEC_CONTEXT_CMD  		((((HI_U32)HA_FFMPEG_EAC3_ID) << 16) | 0x1000)
+#define HA_CODEC_SET_EAC3_DOWNMIX_INFO_CMD  	((((HI_U32)HA_FFMPEG_EAC3_ID) << 16) | 0x1001)
+#define HA_CODEC_SET_EAC3_CLEAR_CMD  			((((HI_U32)HA_FFMPEG_EAC3_ID) << 16) | 0x1003)
+
+/**define status parameter of update information*/ /**CNcomment:状态信息更新，事件回调用户数据定义*/
+typedef struct hiFFMPEG_EAC3_DecodeContext_S {
+	int frame_type;                         ///< frame type                             (strmtyp)
+	int substreamid;                        ///< substream identification
+	int frame_size;                         ///< current frame size, in bytes
+	int bit_rate;                           ///< stream bit rate, in bits-per-second
+	int sample_rate;                        ///< sample frequency, in Hz
+	int num_blocks;                         ///< number of audio blocks
+	int bitstream_id;                       ///< bitstream id                           (bsid)
+	int bitstream_mode;                     ///< bitstream mode                         (bsmod)
+	int channel_mode;                       ///< channel mode                           (acmod)
+	int lfe_on;                             ///< lfe channel in use
+	int dialog_normalization[2];            ///< dialog level in dBFS                   (dialnorm)
+	int compression_exists[2];              ///< compression field is valid for frame   (compre)
+	int compression_gain[2];                ///< gain to apply for heavy compression    (compr)
+	int channel_map;                        ///< custom channel map
+	int preferred_downmix;                  ///< Preferred 2-channel downmix mode       (dmixmod)
+	int center_mix_level;                   ///< Center mix level index
+	int center_mix_level_ltrt;              ///< Center mix level index for Lt/Rt       (ltrtcmixlev)
+	int surround_mix_level;                 ///< Surround mix level index
+	int surround_mix_level_ltrt;            ///< Surround mix level index for Lt/Rt     (ltrtsurmixlev)
+	int lfe_mix_level_exists;               ///< indicates if lfemixlevcod is specified (lfemixlevcode)
+	int lfe_mix_level;                      ///< LFE mix level index                    (lfemixlevcod)
+	int eac3;                               ///< indicates if current frame is E-AC-3
+	int eac3_frame_dependent_found;         ///< bitstream has E-AC-3 dependent frame(s)
+	int eac3_subsbtreamid_found;            ///< bitstream has E-AC-3 additional substream(s)
+	int dolby_surround_mode;                ///< dolby surround mode                    (dsurmod)
+	int dolby_surround_ex_mode;             ///< dolby surround ex mode                 (dsurexmod)
+	int dolby_headphone_mode;               ///< dolby headphone mode                   (dheadphonmod)
+
+	int snr_offset_strategy;                ///< SNR offset strategy                    (snroffststr)
+	int block_switch_syntax;                ///< block switch syntax enabled            (blkswe)
+	int dither_flag_syntax;                 ///< dither flag syntax enabled             (dithflage)
+	int bit_allocation_syntax;              ///< bit allocation model syntax enabled    (bamode)
+	int fast_gain_syntax;                   ///< fast gain codes enabled                (frmfgaincode)
+	int dba_syntax;                         ///< delta bit allocation syntax enabled    (dbaflde)
+	int skip_syntax;                        ///< skip field syntax enabled              (skipflde)
+
+	int fbw_channels;                           ///< number of full-bandwidth channels
+	int channels;                               ///< number of total channels
+	int lfe_ch;                                 ///< index of LFE channel
+	int16_t *downmix_coeffs[2];              ///< stereo downmix coefficients
+	int downmixed;                              ///< indicates if coeffs are currently downmixed
+	int output_mode;                            ///< output channel configuration
+	int out_channels;                           ///< number of output channels
+}FFMPEG_EAC3_DecodeContext_S;
+
+typedef struct
+{
+	HI_U32  enCmd;              /* HA_CODEC_SET_EAC3_DEC_CONTEXT_CMD */
+	FFMPEG_EAC3_DecodeContext_S* peEAc3DecodeContext;
+} HA_FFMPEG_EAC3_DEC_CONTEXT_S;
+
+typedef struct hiFFMPEG_EAC3_DownmixInfo_S {
+    /**
+     * Type of downmix preferred by the mastering engineer.
+     */
+	int preferred_downmix_type;
+
+    /**
+     * Absolute scale factor representing the nominal level of the center
+     * channel during a regular downmix.
+     */
+	double center_mix_level;
+
+    /**
+     * Absolute scale factor representing the nominal level of the center
+     * channel during an Lt/Rt compatible downmix.
+     */
+	double center_mix_level_ltrt;
+
+    /**
+     * Absolute scale factor representing the nominal level of the surround
+     * channels during a regular downmix.
+     */
+	double surround_mix_level;
+
+    /**
+     * Absolute scale factor representing the nominal level of the surround
+     * channels during an Lt/Rt compatible downmix.
+     */
+	double surround_mix_level_ltrt;
+
+    /**
+     * Absolute scale factor representing the level at which the LFE data is
+     * mixed into L/R channels during downmixing.
+     */
+	double lfe_mix_level;
+}FFMPEG_EAC3_DownmixInfo_S;
+
+typedef struct
+{
+	HI_U32  enCmd;              /* HA_CODEC_SET_EAC3_DOWNMIX_INFO_CMD */
+	FFMPEG_EAC3_DownmixInfo_S* peEAc3DownmixInfo;
+} HA_FFMPEG_EAC3_DOWNMIX_INFO_S;
+
+typedef struct
+{
+	HI_U32  enCmd;              /* HA_CODEC_SET_EAC3_CLEAR_CMD */
+	void* Null;
+} HA_FFMPEG_EAC3_CLEAR_S;
+
+/**define the type of callback function*/ /**CNcomment:事件回调函数类型*/
+typedef enum
+{
+	HA_FFMPEG_EAC3_EVENT_STATUS_CHANGE = 0,                   /**<update status information by every frame*/ /**<CNcomment:状态信息更新, 每帧更新一次*/
+	HA_FFMPEG_EAC3_EVENT_BUTT
+} HA_FFMPEG_EAC3_EVENT_E;
+
+/**define callback function*/ /**CNcomment:定义事件回调函数枚举类型*/
+typedef HI_VOID (*FFMPEG_EAC3_EVENT_CB_FN)(HI_VOID* pAppData1, HI_VOID* pAppData2, HA_FFMPEG_EAC3_EVENT_E enEvent);
+
+typedef struct  hiHA_FFMPEG_EAC3_DECODE_OPENCONFIG_S
+{
+	HI_VOID *               hAvCtx; /* Same as libavcodec AVCodecContext, Set/allocated/freed by user. */
+	HI_BOOL                 bAutoDmxStereo; /* automatic downmix multi-ch to stereo. */
+	HI_BOOL                 bConvert2fmt16bit; /* automatic convert none-16bit pcm to 16bit pcm. */
+	FFMPEG_EAC3_EVENT_CB_FN      pfnEvtCbFunc[HA_FFMPEG_EAC3_EVENT_BUTT];    /* call back method */
+	HI_VOID*                pAppData1[HA_FFMPEG_EAC3_EVENT_BUTT];       /* application handle,   Set/allocated/freed by user. */
+	HI_VOID*                pAppData2[HA_FFMPEG_EAC3_EVENT_BUTT];       /* application defined value for call back method,  allocated/freed by user, set by ha_codec,*/
+} HA_FFMPEG_EAC3_DECODE_OPENCONFIG_S;
+
+#define FFMPEEAC3_DecGetDefalutOpenConfig(pConfigParam) \
+    do { \
+		((HA_FFMPEG_EAC3_DECODE_OPENCONFIG_S *)(pConfigParam))->bAutoDmxStereo = HI_TRUE; \
+		((HA_FFMPEG_EAC3_DECODE_OPENCONFIG_S *)(pConfigParam))->bConvert2fmt16bit = HI_TRUE; \
+    } while (0)
+
+#define HA_FFMPEEAC3_DecGetDefalutOpenParam_Config(pOpenParam, pFfmpegEAc3Config) \
+    do { 	HI_S32 i; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+		for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+		{ \
+			((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+		} \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = pFfmpegEAc3Config; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(HA_FFMPEG_EAC3_DECODE_OPENCONFIG_S); \
+		for (i = 0; i < HA_FFMPEG_EAC3_EVENT_BUTT; i++) \
+		{ \
+			((HA_FFMPEG_EAC3_DECODE_OPENCONFIG_S *)(pFfmpegEAc3Config))->pfnEvtCbFunc[i] = HI_NULL; \
+			((HA_FFMPEG_EAC3_DECODE_OPENCONFIG_S *)(pFfmpegEAc3Config))->pAppData1[i] = HI_NULL; \
+			((HA_FFMPEG_EAC3_DECODE_OPENCONFIG_S *)(pFfmpegEAc3Config))->pAppData2[i] = HI_NULL; \
+		} \
+    } while (0)
+
+#define HA_FFMPEEAC3_DecGetDefalutOpenParam(pOpenParam) \
+            do {    HI_S32 i; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+                for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+                { \
+                    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+                } \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = NULL; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+            } while (0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_FFMPEG_EAC3_DECODE_H__ */
diff -uNr a/include/HA.AUDIO.FFMPEG_LPCM.decode.h b/include/HA.AUDIO.FFMPEG_LPCM.decode.h
--- a/include/HA.AUDIO.FFMPEG_LPCM.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.FFMPEG_LPCM.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,94 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.FFMPEG_LPCM.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_FFMPEG_LPCM_DECODE_H__
+#define __HISI_AUDIO_DECODER_FFMPEG_LPCM_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+
+/**define the type of callback function*/ /**CNcomment:事件回调函数类型*/
+typedef enum
+{
+	HA_FFMPEG_LPCM_EVENT_STATUS_CHANGE = 0,                   /**<update status information by every frame*/ /**<CNcomment:状态信息更新, 每帧更新一次*/
+	HA_FFMPEG_LPCM_EVENT_BUTT
+} HA_FFMPEG_LPCM_EVENT_E;
+
+/**define callback function*/ /**CNcomment:定义事件回调函数枚举类型*/
+typedef HI_VOID (*FFMPEG_LPCM_EVENT_CB_FN)(HI_VOID* pAppData1, HI_VOID* pAppData2, HA_FFMPEG_LPCM_EVENT_E enEvent);
+
+typedef struct  hiHA_FFMPEG_LPCM_DECODE_OPENCONFIG_S
+{
+	HI_VOID *               hAvCtx; /* Same as libavcodec AVCodecContext, Set/allocated/freed by user. */
+	HI_BOOL                 bAutoDmxStereo; /* automatic downmix multi-ch to stereo. */
+	HI_BOOL                 bConvert2fmt16bit; /* automatic convert none-16bit pcm to 16bit pcm. */
+	FFMPEG_LPCM_EVENT_CB_FN      pfnEvtCbFunc[HA_FFMPEG_LPCM_EVENT_BUTT];    /* call back method */
+	HI_VOID*                pAppData1[HA_FFMPEG_LPCM_EVENT_BUTT];       /* application handle,   Set/allocated/freed by user. */
+	HI_VOID*                pAppData2[HA_FFMPEG_LPCM_EVENT_BUTT];       /* application defined value for call back method,  allocated/freed by user, set by ha_codec,*/
+} HA_FFMPEG_LPCM_DECODE_OPENCONFIG_S;
+
+#define FFMPELPCM_DecGetDefalutOpenConfig(pConfigParam) \
+    do { \
+		((HA_FFMPEG_LPCM_DECODE_OPENCONFIG_S *)(pConfigParam))->bAutoDmxStereo = HI_TRUE; \
+		((HA_FFMPEG_LPCM_DECODE_OPENCONFIG_S *)(pConfigParam))->bConvert2fmt16bit = HI_TRUE; \
+    } while (0)
+
+#define HA_FFMPELPCM_DecGetDefalutOpenParam_Config(pOpenParam, pFfmpegLPCMConfig) \
+    do { 	HI_S32 i; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+		for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+		{ \
+			((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+		} \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = pFfmpegLPCMConfig; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(HA_FFMPEG_LPCM_DECODE_OPENCONFIG_S); \
+		for (i = 0; i < HA_FFMPEG_LPCM_EVENT_BUTT; i++) \
+		{ \
+			((HA_FFMPEG_LPCM_DECODE_OPENCONFIG_S *)(pFfmpegLPCMConfig))->pfnEvtCbFunc[i] = HI_NULL; \
+			((HA_FFMPEG_LPCM_DECODE_OPENCONFIG_S *)(pFfmpegLPCMConfig))->pAppData1[i] = HI_NULL; \
+			((HA_FFMPEG_LPCM_DECODE_OPENCONFIG_S *)(pFfmpegLPCMConfig))->pAppData2[i] = HI_NULL; \
+		} \
+    } while (0)
+
+#define HA_FFMPELPCM_DecGetDefalutOpenParam(pOpenParam) \
+            do {    HI_S32 i; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+                for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+                { \
+                    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+                } \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = NULL; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+            } while (0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_FFMPEG_LPCM_DECODE_H__ */
diff -uNr a/include/HA.AUDIO.FFMPEG_TRUEHD.decode.h b/include/HA.AUDIO.FFMPEG_TRUEHD.decode.h
--- a/include/HA.AUDIO.FFMPEG_TRUEHD.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.FFMPEG_TRUEHD.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,93 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.FFMPEG_TRUEHD.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_FFMPEG_TRUEHD_DECODE_H__
+#define __HISI_AUDIO_DECODER_FFMPEG_TRUEHD_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+/**define the type of callback function*/ /**CNcomment:事件回调函数类型*/
+typedef enum
+{
+	HA_FFMPEG_TRUEHD_EVENT_STATUS_CHANGE = 0,                   /**<update status information by every frame*/ /**<CNcomment:状态信息更新, 每帧更新一次*/
+	HA_FFMPEG_TRUEHD_EVENT_BUTT
+} HA_FFMPEG_TRUEHD_EVENT_E;
+
+/**define callback function*/ /**CNcomment:定义事件回调函数枚举类型*/
+typedef HI_VOID (*FFMPEG_TRUEHD_EVENT_CB_FN)(HI_VOID* pAppData1, HI_VOID* pAppData2, HA_FFMPEG_TRUEHD_EVENT_E enEvent);
+
+typedef struct  hiHA_FFMPEG_TRUEHD_DECODE_OPENCONFIG_S
+{
+	HI_VOID *               hAvCtx; /* Same as libavcodec AVCodecContext, Set/allocated/freed by user. */
+	HI_BOOL                 bAutoDmxStereo; /* automatic downmix multi-ch to stereo. */
+	HI_BOOL                 bConvert2fmt16bit; /* automatic convert none-16bit pcm to 16bit pcm. */
+	FFMPEG_TRUEHD_EVENT_CB_FN      pfnEvtCbFunc[HA_FFMPEG_TRUEHD_EVENT_BUTT];    /* call back method */
+	HI_VOID*                pAppData1[HA_FFMPEG_TRUEHD_EVENT_BUTT];       /* application handle,   Set/allocated/freed by user. */
+	HI_VOID*                pAppData2[HA_FFMPEG_TRUEHD_EVENT_BUTT];       /* application defined value for call back method,  allocated/freed by user, set by ha_codec,*/
+} HA_FFMPEG_TRUEHD_DECODE_OPENCONFIG_S;
+
+#define FFMPETRUEHD_DecGetDefalutOpenConfig(pConfigParam) \
+    do { \
+		((HA_FFMPEG_TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->bAutoDmxStereo = HI_TRUE; \
+		((HA_FFMPEG_TRUEHD_DECODE_OPENCONFIG_S *)(pConfigParam))->bConvert2fmt16bit = HI_TRUE; \
+    } while (0)
+
+#define HA_FFMPETRUEHD_DecGetDefalutOpenParam_Config(pOpenParam, pFfmpegTrueHDConfig) \
+    do { 	HI_S32 i; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+		for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+		{ \
+			((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+		} \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = pFfmpegTrueHDConfig; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(HA_FFMPEG_TRUEHD_DECODE_OPENCONFIG_S); \
+		for (i = 0; i < HA_FFMPEG_TRUEHD_EVENT_BUTT; i++) \
+		{ \
+			((HA_FFMPEG_TRUEHD_DECODE_OPENCONFIG_S *)(pFfmpegTrueHDConfig))->pfnEvtCbFunc[i] = HI_NULL; \
+			((HA_FFMPEG_TRUEHD_DECODE_OPENCONFIG_S *)(pFfmpegTrueHDConfig))->pAppData1[i] = HI_NULL; \
+			((HA_FFMPEG_TRUEHD_DECODE_OPENCONFIG_S *)(pFfmpegTrueHDConfig))->pAppData2[i] = HI_NULL; \
+		} \
+    } while (0)
+
+#define HA_FFMPETRUEHD_DecGetDefalutOpenParam(pOpenParam) \
+            do {    HI_S32 i; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+                for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+                { \
+                    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+                } \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = NULL; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+            } while (0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_FFMPEG_TRUEHD_DECODE_H__ */
diff -uNr a/include/HA.AUDIO.FFMPEG_WMA.decode.h b/include/HA.AUDIO.FFMPEG_WMA.decode.h
--- a/include/HA.AUDIO.FFMPEG_WMA.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.FFMPEG_WMA.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,126 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.FFMPEG_WMA.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_FFMPEG_WMA_DECODE_H__
+#define __HISI_AUDIO_DECODER_FFMPEG_WMA_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+#define HA_FFMPEG_WMA_ID 0x0300        
+#define HA_CODEC_SET_WMA_INFO_CMD  ((((HI_U32)HA_FFMPEG_WMA_ID) << 16) | 0x1000)
+#define HA_CODEC_SET_WMA_CLEAR_CMD  ((((HI_U32)HA_FFMPEG_WMA_ID) << 16) | 0x1001)
+
+/**define status parameter of update information*/ /**CNcomment:状态信息更新，事件回调用户数据定义*/
+typedef struct  hiFFMPEG_WMA_INFO_S
+{
+	HI_S32  wma_version;
+	HI_S32  codec_id;
+	HI_S32  codec_type;
+	HI_S32  codec_tag;
+	HI_S32  sample_fmt;
+	HI_S32  channels;
+	HI_S32  sample_rate;
+	HI_S32  bit_rate;
+	HI_S32  block_align;
+	HI_S32  word_size;
+	HI_UCHAR extradata[1024];
+	HI_S32 extradata_size;
+} FFMPEG_WMA_INFO_S;
+
+typedef struct
+{
+	HI_U32  enCmd;              /* HA_CODEC_SET_WMA_INFO_CMD */
+	FFMPEG_WMA_INFO_S* peWmaInfo;
+} HA_FFMPEG_WMA_INFO_S;
+
+typedef struct
+{
+	HI_U32  enCmd;              /* HA_CODEC_SET_WMA_CLEAR_CMD */
+	void* Null;
+} HA_FFMPEG_WMA_CLEAR_S;
+
+/**define the type of callback function*/ /**CNcomment:事件回调函数类型*/
+typedef enum
+{
+	HA_FFMPEG_WMA_EVENT_STATUS_CHANGE = 0,                   /**<update status information by every frame*/ /**<CNcomment:状态信息更新, 每帧更新一次*/
+	HA_FFMPEG_WMA_EVENT_BUTT
+} HA_FFMPEG_WMA_EVENT_E;
+
+/**define callback function*/ /**CNcomment:定义事件回调函数枚举类型*/
+typedef HI_VOID (*FFMPEG_WMA_EVENT_CB_FN)(HI_VOID* pAppData1, HI_VOID* pAppData2, HA_FFMPEG_WMA_EVENT_E enEvent);
+
+typedef struct  hiHA_FFMPEG_WMA_DECODE_OPENCONFIG_S
+{
+	HI_VOID *               hAvCtx; /* Same as libavcodec AVCodecContext, Set/allocated/freed by user. */
+	HI_BOOL                 bAutoDmxStereo; /* automatic downmix multi-ch to stereo. */
+	HI_BOOL                 bConvert2fmt16bit; /* automatic convert none-16bit pcm to 16bit pcm. */
+	FFMPEG_WMA_EVENT_CB_FN      pfnEvtCbFunc[HA_FFMPEG_WMA_EVENT_BUTT];    /* call back method */
+	HI_VOID*                pAppData1[HA_FFMPEG_WMA_EVENT_BUTT];       /* application handle,   Set/allocated/freed by user. */
+	HI_VOID*                pAppData2[HA_FFMPEG_WMA_EVENT_BUTT];       /* application defined value for call back method,  allocated/freed by user, set by ha_codec,*/
+} HA_FFMPEG_WMA_DECODE_OPENCONFIG_S;
+
+#define FFMPEWMA_DecGetDefalutOpenConfig(pConfigParam) \
+    do { \
+		((HA_FFMPEG_WMA_DECODE_OPENCONFIG_S *)(pConfigParam))->bAutoDmxStereo = HI_TRUE; \
+		((HA_FFMPEG_WMA_DECODE_OPENCONFIG_S *)(pConfigParam))->bConvert2fmt16bit = HI_TRUE; \
+    } while (0)
+
+#define HA_FFMPEWMA_DecGetDefalutOpenParam_Config(pOpenParam, pFfmpegWmaConfig) \
+    do { 	HI_S32 i; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+		for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+		{ \
+			((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+		} \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = pFfmpegWmaConfig; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(HA_FFMPEG_WMA_DECODE_OPENCONFIG_S); \
+		for (i = 0; i < HA_FFMPEG_WMA_EVENT_BUTT; i++) \
+		{ \
+			((HA_FFMPEG_WMA_DECODE_OPENCONFIG_S *)(pFfmpegWmaConfig))->pfnEvtCbFunc[i] = HI_NULL; \
+			((HA_FFMPEG_WMA_DECODE_OPENCONFIG_S *)(pFfmpegWmaConfig))->pAppData1[i] = HI_NULL; \
+			((HA_FFMPEG_WMA_DECODE_OPENCONFIG_S *)(pFfmpegWmaConfig))->pAppData2[i] = HI_NULL; \
+		} \
+    } while (0)
+
+#define HA_FFMPEWMA_DecGetDefalutOpenParam(pOpenParam) \
+            do {    HI_S32 i; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+                for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+                { \
+                    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+                } \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = NULL; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+            } while (0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_FFMPEG_WMA_DECODE_H__ */
diff -uNr a/include/HA.AUDIO.FFMPEG_WMAPRO.decode.h b/include/HA.AUDIO.FFMPEG_WMAPRO.decode.h
--- a/include/HA.AUDIO.FFMPEG_WMAPRO.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.FFMPEG_WMAPRO.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,70 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.FFMPEG_WMAPRO.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_FFMPEG_WMAPRO_H__
+#define __HISI_AUDIO_DECODER_FFMPEG_WMAPRO_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+
+#define HA_WMAPRO_ID 0x041f
+#define HA_AUDIO_ID_FFMPEG_WMAPRO   HA_BUILD_CODEC_ID(VENDOR_HISI,FORMAT_WMAPRO,HA_WMAPRO_ID)  /* support FORMAT_WMAPRO */
+
+
+typedef struct hiWMAPro_FORMAT_S
+{
+    HI_VOID *               hAvCtx; /* Same as libavcodec AVCodecContext, Set/allocated/freed by user. */
+
+    HI_U16 wFormatTag;          /* format type,0x160->WMAV1,0x161->WMAV2, 0x162->WMAV3 */
+    HI_U16 nChannels;            /* number of channels (i.e. mono, stereo...) */
+    HI_U32 nSamplesPerSec;   /* sample rate */
+    HI_U32 nAvgBytesPerSec;  /* for buffer estimation */
+    HI_U16 nBlockAlign;          /* block size of data */
+    HI_U16 wBitsPerSample;   /* number of bits per sample of mono data */
+    HI_U16 cbSize;                /* the count in bytes of the size of */
+    HI_U8 cbExtWord[32];       /* extra information (after cbSize).
+                                WMAV1: need  4 Bytes extra information at least
+                                    WMAV2: need 10 Bytes extra information at least
+                                WMAV3: need 18 Bytes extra information at least
+                                 */
+} WMAPro_FORMAT_S;
+
+
+#define HA_FFMPEGC_WMAPROC_DecGetDefalutOpenParam(pOpenParam, pstWmaProConfig) \
+    do { HI_S32 i; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+         for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+         { \
+             ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+         } \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = pstWmaProConfig; \
+         ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(WMAPro_FORMAT_S); \
+    } while (0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_FFMPEG_WMAPRO_H__ */
diff -uNr a/include/HA.AUDIO.FFMPEG_WMA_PRO.decode.h b/include/HA.AUDIO.FFMPEG_WMA_PRO.decode.h
--- a/include/HA.AUDIO.FFMPEG_WMA_PRO.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.FFMPEG_WMA_PRO.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,126 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.FFMPEG_WMAPRO.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_FFMPEG_WMA_PRO_DECODE_H__
+#define __HISI_AUDIO_DECODER_FFMPEG_WMA_PRO_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+#define HA_FFMPEG_WMAPRO_ID 0x0310        
+#define HA_CODEC_SET_WMAPRO_INFO_CMD  ((((HI_U32)HA_FFMPEG_WMAPRO_ID) << 16) | 0x1000)
+#define HA_CODEC_SET_WMAPRO_CLEAR_CMD  ((((HI_U32)HA_FFMPEG_WMAPRO_ID) << 16) | 0x1001)
+
+/**define status parameter of update information*/ /**CNcomment:状态信息更新，事件回调用户数据定义*/
+typedef struct  hiFFMPEG_WMAPRO_INFO_S
+{
+	HI_S32  wma_version;
+	HI_S32  codec_id;
+	HI_S32  codec_type;
+	HI_S32  codec_tag;
+	HI_S32  sample_fmt;
+	HI_S32  channels;
+	HI_S32  sample_rate;
+	HI_S32  bit_rate;
+	HI_S32  block_align;
+	HI_S32  word_size;
+	HI_UCHAR extradata[1024];
+	HI_S32 extradata_size;
+} FFMPEG_WMAPRO_INFO_S;
+
+typedef struct
+{
+	HI_U32  enCmd;              /* HA_CODEC_SET_WMA_INFO_CMD */
+	FFMPEG_WMAPRO_INFO_S* peWmaProInfo;
+} HA_FFMPEG_WMAPRO_INFO_S;
+
+typedef struct
+{
+	HI_U32  enCmd;              /* HA_CODEC_SET_WMAPRO_CLEAR_CMD */
+	void* Null;
+} HA_FFMPEG_WMAPRO_CLEAR_S;
+
+/**define the type of callback function*/ /**CNcomment:事件回调函数类型*/
+typedef enum
+{
+	HA_FFMPEG_WMAPRO_EVENT_STATUS_CHANGE = 0,                   /**<update status information by every frame*/ /**<CNcomment:状态信息更新, 每帧更新一次*/
+	HA_FFMPEG_WMAPRO_EVENT_BUTT
+} HA_FFMPEG_WMAPRO_EVENT_E;
+
+/**define callback function*/ /**CNcomment:定义事件回调函数枚举类型*/
+typedef HI_VOID (*FFMPEG_WMAPRO_EVENT_CB_FN)(HI_VOID* pAppData1, HI_VOID* pAppData2, HA_FFMPEG_WMAPRO_EVENT_E enEvent);
+
+typedef struct  hiHA_FFMPEG_WMAPRO_DECODE_OPENCONFIG_S
+{
+	HI_VOID *               hAvCtx; /* Same as libavcodec AVCodecContext, Set/allocated/freed by user. */
+	HI_BOOL                 bAutoDmxStereo; /* automatic downmix multi-ch to stereo. */
+	HI_BOOL                 bConvert2fmt16bit; /* automatic convert none-16bit pcm to 16bit pcm. */
+	FFMPEG_WMAPRO_EVENT_CB_FN      pfnEvtCbFunc[HA_FFMPEG_WMAPRO_EVENT_BUTT];    /* call back method */
+	HI_VOID*                pAppData1[HA_FFMPEG_WMAPRO_EVENT_BUTT];       /* application handle,   Set/allocated/freed by user. */
+	HI_VOID*                pAppData2[HA_FFMPEG_WMAPRO_EVENT_BUTT];       /* application defined value for call back method,  allocated/freed by user, set by ha_codec,*/
+} HA_FFMPEG_WMAPRO_DECODE_OPENCONFIG_S;
+
+#define FFMPEWMAPRO_DecGetDefalutOpenConfig(pConfigParam) \
+    do { \
+		((HA_FFMPEG_WMAPRO_DECODE_OPENCONFIG_S *)(pConfigParam))->bAutoDmxStereo = HI_TRUE; \
+		((HA_FFMPEG_WMAPRO_DECODE_OPENCONFIG_S *)(pConfigParam))->bConvert2fmt16bit = HI_TRUE; \
+    } while (0)
+
+#define HA_FFMPEWMAPRO_DecGetDefalutOpenParam_Config(pOpenParam, pFfmpegWmaProConfig) \
+    do { 	HI_S32 i; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+		for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+		{ \
+			((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+		} \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = pFfmpegWmaProConfig; \
+		((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(HA_FFMPEG_WMAPRO_DECODE_OPENCONFIG_S); \
+		for (i = 0; i < HA_FFMPEG_WMAPRO_EVENT_BUTT; i++) \
+		{ \
+			((HA_FFMPEG_WMAPRO_DECODE_OPENCONFIG_S *)(pFfmpegWmaProConfig))->pfnEvtCbFunc[i] = HI_NULL; \
+			((HA_FFMPEG_WMAPRO_DECODE_OPENCONFIG_S *)(pFfmpegWmaProConfig))->pAppData1[i] = HI_NULL; \
+			((HA_FFMPEG_WMAPRO_DECODE_OPENCONFIG_S *)(pFfmpegWmaProConfig))->pAppData2[i] = HI_NULL; \
+		} \
+    } while (0)
+
+#define HA_FFMPEWMAPRO_DecGetDefalutOpenParam(pOpenParam) \
+            do {    HI_S32 i; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+                for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+                { \
+                    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+                } \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = NULL; \
+                ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+            } while (0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_FFMPEG_WMAPRO_DECODE_H__ */
diff -uNr a/include/HA.AUDIO.G711.codec.h b/include/HA.AUDIO.G711.codec.h
--- a/include/HA.AUDIO.G711.codec.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.G711.codec.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,70 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.G711.codec.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_CODEC_G711_H__
+#define __HISI_AUDIO_CODEC_G711_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+#define G711_FRAME_BLOCK_LEN_10MS  80
+
+typedef struct
+{
+    HI_S32  isAlaw;  /* 1=A Law, 0= u Law  */
+    HI_BOOL bVAD;  /* HI_TRUE=enable vad, HI_FALSE=disable vad  */
+} G711_ENCODE_OPENCONFIG_S;
+
+#define HA_G711_GetEncDefaultOpenParam(pOpenParam, pstPrivateParams) \
+do{ ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredOutChannels = 1; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->bInterleaved = HI_TRUE; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->s32BitPerSample = 16; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredSampleRate = 8000; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32SamplePerFrame = G711_FRAME_BLOCK_LEN_10MS; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(G711_ENCODE_OPENCONFIG_S); \
+}while(0)
+
+typedef struct
+{
+    HI_S32  isAlaw;  /* 1=A Law, 0= u Law  */
+    HI_U32 u32SamplePerFrame;
+} G711_DECODE_OPENCONFIG_S;
+
+#define HA_G711_GetDecDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 1; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 8000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(G711_DECODE_OPENCONFIG_S); \
+}while(0)
+    
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_CODEC_G711_H__ */
diff -uNr a/include/HA.AUDIO.G722.codec.h b/include/HA.AUDIO.G722.codec.h
--- a/include/HA.AUDIO.G722.codec.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.G722.codec.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,67 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.G722.codec.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_CODEC_G722_H__
+#define __HISI_AUDIO_CODEC_G722_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+#define HA_G722_ID 0x0105        
+
+#define G722_FRAME_BLOCK_LEN_10MS  160
+#define G722_FRAME_BLOCK_LEN_20MS  320
+
+#define HA_G722_GetEncDefaultOpenParam(pOpenParam) \
+do{ ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredOutChannels = 1; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->bInterleaved = HI_TRUE; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->s32BitPerSample = 16; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredSampleRate = 16000; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32SamplePerFrame = G722_FRAME_BLOCK_LEN_10MS; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+}while(0)
+
+typedef struct
+{
+    HI_S32  mode;  /* 1=64kbps, 2= 56kbps, 3= 48kbps  */
+} G722_DECODE_OPENCONFIG_S;
+
+#define HA_G722_GetDecDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 1; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 16000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(G722_DECODE_OPENCONFIG_S); \
+}while(0)
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+
+#endif /* __HISI_AUDIO_CODEC_G722_H__ */
diff -uNr a/include/HA.AUDIO.MP2.decode.h b/include/HA.AUDIO.MP2.decode.h
--- a/include/HA.AUDIO.MP2.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.MP2.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,65 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.MP2.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_MP2_H__
+#define __HISI_AUDIO_DECODER_MP2_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define HA_MP2_ID 0x0002        
+       
+#define HA_CODEC_GET_MP2_CHNANEL_MODE_CMD  ((((HI_U32)HA_MP2_ID) << 16) | 0x1000)
+
+typedef enum
+{
+    MP2_CHANNEL_MODE_STEREO = 0,
+    MP2_CHANNEL_MODE_JOINTSTERERO,
+    MP2_CHANNEL_MODE_DUALSTERERO,
+    MP2_CHANNEL_MODE_MONO,
+}HA_MP2_CHANNEL_MODE;
+
+typedef struct
+{
+    HI_U32  enCmd;              /* HA_CODEC_GET_MP2_CHNANEL_MODE_CMD */
+    HA_MP2_CHANNEL_MODE *peChannelMode;
+} HA_MP2_GET_CHNANEL_MODE_S;
+
+#define HA_MP2_DecGetDefalutOpenParam(pOpenParam) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+}while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_MP2_H__ */
+
diff -uNr a/include/HA.AUDIO.MP3.decode.h b/include/HA.AUDIO.MP3.decode.h
--- a/include/HA.AUDIO.MP3.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.MP3.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,71 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.MP3.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_MP3_H__
+#define __HISI_AUDIO_DECODER_MP3_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#define HA_MP3_ID 0x0003
+#define HA_CODEC_GET_MP3_CHNANEL_MODE_CMD  ((((HI_U32)HA_MP3_ID) << 16) | 0x1000)
+#define HA_CODEC_SET_MP3_CHECKONESYNC_CMD  ((((HI_U32)HA_MP3_ID) << 16) | 0x1001)
+
+typedef struct
+{
+    HI_U32  enCmd;              /* HA_CODEC_SET_MP3_CHECKONESYNC_CMD */
+    HI_BOOL bCheckOneSync;
+} HA_MP3_CHECKONESYNC_FLAG_S;
+
+typedef enum
+{
+    MP3_CHANNEL_MODE_STEREO = 0,
+    MP3_CHANNEL_MODE_JOINTSTERERO,
+    MP3_CHANNEL_MODE_DUALSTERERO,
+    MP3_CHANNEL_MODE_MONO,
+} HA_MP3_CHANNEL_MODE;
+
+typedef struct
+{
+    HI_U32  enCmd;              /* HA_CODEC_GET_MP3_CHNANEL_MODE_CMD */
+    HA_MP3_CHANNEL_MODE* peChannelMode;
+} HA_MP3_GET_CHNANEL_MODE_S;
+
+#define HA_MP3_DecGetDefalutOpenParam(pOpenParam) \
+    do{ HI_S32 i; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+        for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+        { \
+            ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+        } \
+    }while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_MP3_H__ */
+
diff -uNr a/include/HA.AUDIO.OPUS.codec.h b/include/HA.AUDIO.OPUS.codec.h
--- a/include/HA.AUDIO.OPUS.codec.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.OPUS.codec.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,63 @@
+#ifndef __HA_AUDIO_OPUS_CODEC_H__
+#define __HA_AUDIO_OPUS_CODEC_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+typedef struct {
+   HI_S32 s32Version;
+   HI_U32 u32Channels; /* Number of channels: 1..255 */
+   HI_S32 s32Preskip;
+   HI_U32 u32SampleRate;
+   HI_S32 s32Gain; /* in dB S7.8 should be zero whenever possible */
+   HI_S32 s32ChannelMap;
+   /* The rest is only used if channel_mapping != 0 */
+   HI_S32 s32NBStreams;
+   HI_S32 s32NBCoupled;
+   HI_U8  u8StreamMap[255];
+} OPUS_HEAD_CONFIG_S;
+
+#define HA_OPUS_DecGetDefalutHeadConfig(pConfigParam) \
+    do { \
+        ((OPUS_HEAD_CONFIG_S*)(pConfigParam))->s32Version = 1; \
+        ((OPUS_HEAD_CONFIG_S*)(pConfigParam))->u32Channels = 2; \
+        ((OPUS_HEAD_CONFIG_S*)(pConfigParam))->s32Preskip = 0; \
+        ((OPUS_HEAD_CONFIG_S*)(pConfigParam))->u32SampleRate = 0; \
+        ((OPUS_HEAD_CONFIG_S*)(pConfigParam))->s32Gain = 0; \
+        ((OPUS_HEAD_CONFIG_S*)(pConfigParam))->s32ChannelMap = 0; \
+        ((OPUS_HEAD_CONFIG_S*)(pConfigParam))->s32NBStreams = 0; \
+        ((OPUS_HEAD_CONFIG_S*)(pConfigParam))->s32NBCoupled = 0; \
+        memset(((OPUS_HEAD_CONFIG_S*)(pConfigParam))->u8StreamMap, 0, 255); \
+    } while (0)
+
+#define HA_OPUS_DecGetDefalutOpenParam(pOpenParam, pstPrivateParams) \
+    do { HI_S32 i; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+        for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+        { \
+            ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+        } \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(OPUS_HEAD_CONFIG_S); \
+    } while (0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_OPUS_H__ */
+
diff -uNr a/include/HA.AUDIO.PCM.decode.h b/include/HA.AUDIO.PCM.decode.h
--- a/include/HA.AUDIO.PCM.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.PCM.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,67 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.PCM.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_PCM_H__
+#define __HISI_AUDIO_DECODER_PCM_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define HA_PCM_ID 0x0000        
+
+typedef struct hiWAV_FORMAT_S
+{
+    HI_U16 wFormatTag;          /* format category */
+    HI_U16 nChannels;            /* number of channels (i.e. mono, stereo...) */
+    HI_U32 nSamplesPerSec;   /* sample rate */
+    HI_U32 nAvgBytesPerSec;  /* for buffer estimation */
+    HI_U16 nBlockAlign;          /* the block alignment (in bytes) of the
+                                      waveform data */
+    HI_U16 wBitsPerSample;   /* number of bits per sample of mono data */
+    HI_U16 cbSize;                /* number of bytes of wave raw data cbExtWord*/
+    HI_U16 cbExtWord[16];       /* extra information (after cbSize).                      */
+   /* note: big-endian pcm supprt(microsoft wav file only support little-endian pcm format):
+        cbSize = 4;
+        cbExtWord[0] = 1;
+        cbExtWord[1] ; //reserved
+   */
+} WAV_FORMAT_S;
+
+#define HA_PCM_DecGetDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->u32CodecPrivateDataSize = sizeof(WAV_FORMAT_S); \
+}while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_PCM_H__ */
+
diff -uNr a/include/HA.AUDIO.TRUEHDPASSTHROUGH.decode.h b/include/HA.AUDIO.TRUEHDPASSTHROUGH.decode.h
--- a/include/HA.AUDIO.TRUEHDPASSTHROUGH.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.TRUEHDPASSTHROUGH.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,49 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.TRUEHD.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_TRUEHD_H__
+#define __HISI_AUDIO_DECODER_TRUEHD_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define HA_TRUEHD_ID 0x0008        
+
+#define HA_TRUEHD_DecGetDefalutOpenParam(pOpenParam) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_THRU; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)NULL; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+}while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_TRUEHD_H__ */
+
diff -uNr a/include/HA.AUDIO.VOICE.codec.h b/include/HA.AUDIO.VOICE.codec.h
--- a/include/HA.AUDIO.VOICE.codec.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.VOICE.codec.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,116 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+ File Name     : HA.AUDIO.G726.codec.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HI_AUDIO_VOICE_CODEC_H__
+#define __HI_AUDIO_VOICE_CODEC_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+typedef enum
+{
+    HA_VOICE_G711_A      = 0x01,  /**<64kbps G.711 A, see RFC3551.txt  4.5.14 PCMA */ /**<CNcomment: G711 A格式*/
+    HA_VOICE_G711_U      = 0x02,  /**<64kbps G.711 U, see RFC3551.txt  4.5.14 PCMU */ /**<CNcomment: G711 U格式*/
+    HA_VOICE_ADPCM_DVI4  = 0x03,  /**<32kbps ADPCM(DVI4) for RTP; see DVI4 diiffers in three respects from the IMA ADPCM at RFC3551.txt 4.5.1 DVI4 */
+                                                /**<CNcomment: RTP ADPCM DVI4格式*/
+    HA_VOICE_G726_16KBPS = 0x04,  /**<16kbps G.726, see RFC3551.txt  4.5.4 G726-16 */ /**<CNcomment: G726 16kbps格式*/
+    HA_VOICE_G726_24KBPS = 0x05,  /**<24kbps G.726, see RFC3551.txt  4.5.4 G726-24 */ /**<CNcomment: G726 24kbps格式*/
+    HA_VOICE_G726_32KBPS = 0x06,  /**<32kbps G.726, see RFC3551.txt  4.5.4 G726-32 */ /**<CNcomment: G726 32kbps格式*/
+    HA_VOICE_G726_40KBPS = 0x07,  /**<40kbps G.726, see RFC3551.txt  4.5.4 G726-40 */ /**<CNcomment: G726 40kbps格式*/
+
+    HA_VOICE_ADPCM_IMA   = 0x23,  /**<32kbps ADPCM(IMA) */ /**<CNcomment: 32kbps ADPCM IMA格式*/
+
+    /**
+    An example of the packing scheme for G726-32 codewords is as shown, and bit A3 is the least significant bit of the first codeword:
+    RTP G726-32:
+    0                   1
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
+    |B B B B|A A A A|D D D D|C C C C| ...
+    |0 1 2 3|0 1 2 3|0 1 2 3|0 1 2 3|
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
+
+    MEDIA G726-32:
+    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
+    |A A A A|B B B B|C C C C|D D D D| ...
+    |3 2 1 0|3 2 1 0|3 2 1 0|3 2 1 0|
+    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
+    */
+    HA_VOICE_MEDIA_G726_16KBPS = 0x24,  /**<media G726 16kbps for ASF ... */ /**<CNcomment: 媒体G726 16kbps格式*/
+    HA_VOICE_MEDIA_G726_24KBPS = 0x25,  /**<media G726 24kbps for ASF ... */ /**<CNcomment: 媒体G726 24kbps格式*/
+    HA_VOICE_MEDIA_G726_32KBPS = 0x26,  /**<media G726 32kbps for ASF ... */ /**<CNcomment: 媒体G726 32kbps格式*/
+    HA_VOICE_MEDIA_G726_40KBPS = 0x27,  /**<media G726 40kbps for ASF ... */ /**<CNcomment: 媒体G726 40kbps格式*/
+
+    /* ORIGINE VERSION CODEC */
+    HA_VOICE_G711_ORG_A        = 0x41,  /**<original version 64kbps G.711 A */ /**<CNcomment: 原始G711 A格式*/
+    HA_VOICE_G711_ORG_U        = 0x42,  /**<original version 64kbps G.711 U */ /**<CNcomment: 原始G711 U格式*/
+    HA_VOICE_ADPCM_ORG_DVI4    = 0x43,  /**<original version 32kbps ADPCM */ /**<CNcomment: 原始ADPCM DVI4格式*/
+    HA_VOICE_G726_ORG_16KBPS   = 0x44,  /**<original version(DVS1.0) 16kbps G.726 */ /**<CNcomment: 原始G726 16kbps格式*/
+} HA_VOICE_FORMAT_E;
+
+typedef struct
+{
+    HA_VOICE_FORMAT_E  enVoiceFormat;
+    HI_U32             u32SamplePerFrame;
+} HA_VOICE_OPENCONFIG_S;
+
+#define HA_VOICE_EncGetDefalutOpenConfig(pConfigParam) \
+    do { \
+        ((HA_VOICE_OPENCONFIG_S *)(pConfigParam))->enVoiceFormat = HA_VOICE_G711_A; \
+        ((HA_VOICE_OPENCONFIG_S *)(pConfigParam))->u32SamplePerFrame = 320; \
+    } while (0)
+
+#define HA_VOICE_GetEncDefaultOpenParam(pOpenParam, pstPrivateParams) \
+do{ ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredOutChannels = 1; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->bInterleaved = HI_TRUE; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->s32BitPerSample = 16; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32DesiredSampleRate = 8000; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32SamplePerFrame = 160; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HAENCODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(HA_VOICE_OPENCONFIG_S); \
+} while(0)
+
+#define HA_VOICE_DecGetDefalutOpenConfig(pConfigParam) \
+    do { \
+        ((HA_VOICE_OPENCONFIG_S *)(pConfigParam))->enVoiceFormat = HA_VOICE_G711_A; \
+        ((HA_VOICE_OPENCONFIG_S *)(pConfigParam))->u32SamplePerFrame = 320; \
+    } while (0)
+
+#define HA_VOICE_GetDecDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 1; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 8000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(HA_VOICE_OPENCONFIG_S); \
+} while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_AUDIO_VOICE_CODEC_H__ */
diff -uNr a/include/HA.AUDIO.VORBIS.codec.h b/include/HA.AUDIO.VORBIS.codec.h
--- a/include/HA.AUDIO.VORBIS.codec.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.VORBIS.codec.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,46 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.VORBIS.codec.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       :
+ Last Modified :
+ Description   :
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HA_AUDIO_VORBIS_CODEC_H__
+#define __HA_AUDIO_VORBIS_CODEC_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define HA_VORBIS_DecGetDefalutOpenParam(pOpenParam) \
+    do { HI_S32 i; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = HI_NULL; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = 0; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_TRUE; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+        for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+        { \
+            ((HI_HADECODE_OPENPARAM_S *)pOpenParam)->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+        } \
+    } while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HA_AUDIO_VORBIS_CODEC_H__ */
diff -uNr a/include/HA.AUDIO.WMA9STD.decode.h b/include/HA.AUDIO.WMA9STD.decode.h
--- a/include/HA.AUDIO.WMA9STD.decode.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.WMA9STD.decode.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,146 @@
+/******************************************************************************
+ Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : HA.AUDIO.WMA.decode.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 
+ Last Modified :
+ Description   : 
+ Function List :
+ History       :
+******************************************************************************/
+#ifndef __HISI_AUDIO_DECODER_WMA_H__
+#define __HISI_AUDIO_DECODER_WMA_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define HA_WMA9STD_ID 0x0006        
+
+typedef struct hiWMA_FORMAT_S
+{
+    HI_U16 wFormatTag;          /* format type,0x160->WMAV1,0x161->WMAV2, 0x162->WMAV3 */
+    HI_U16 nChannels;            /* number of channels (i.e. mono, stereo...) */
+    HI_U32 nSamplesPerSec;   /* sample rate */
+    HI_U32 nAvgBytesPerSec;  /* for buffer estimation */
+    HI_U16 nBlockAlign;          /* block size of data */
+    HI_U16 wBitsPerSample;   /* number of bits per sample of mono data */
+    HI_U16 cbSize;                /* the count in bytes of the size of */
+    HI_U16 cbExtWord[16];       /* extra information (after cbSize).
+                                WMAV1: need  4 Bytes extra information at least
+                                    WMAV2: need 10 Bytes extra information at least
+                                WMAV3: need 18 Bytes extra information at least
+                                 */
+} WMA_FORMAT_S;
+
+#define HA_WMA_DecGetDefalutOpenParam(pOpenParam, pstPrivateParams) \
+do{ HI_S32 i; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->enDecMode = HD_DEC_MODE_RAWPCM; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredOutChannels = 2; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.bInterleaved  = HI_FALSE; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32BitPerSample = 16; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.u32DesiredSampleRate = 48000; \
+    for (i = 0; i < HA_AUDIO_MAXCHANNELS; i++) \
+    { \
+        ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->sPcmformat.enChannelMapping[i] = HA_AUDIO_ChannelNone; \
+    } \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->pCodecPrivateData = (HI_VOID*)pstPrivateParams; \
+    ((HI_HADECODE_OPENPARAM_S *)(pOpenParam))->u32CodecPrivateDataSize = sizeof(WMA_FORMAT_S); \
+}while(0)
+
+/*=====================================================================
+	CMP demux, only use for debug
+=====================================================================*/
+
+#if 1
+#define HA_WMA_ParseCmp(pfcmp, pstWfx) \
+({ HI_S32 nRead; \
+    nRead=0; \
+    fread(&(((WMA_FORMAT_S *)pstWfx)->wFormatTag), sizeof(HI_U16), 1, (FILE *)pfcmp); \
+    fread(&(((WMA_FORMAT_S *)pstWfx)->nChannels), sizeof(HI_U16), 1, (FILE *)pfcmp); \
+    fread(&(((WMA_FORMAT_S *)pstWfx)->nSamplesPerSec), sizeof(HI_U32), 1, (FILE *)pfcmp); \
+    fread(&(((WMA_FORMAT_S *)pstWfx)->nAvgBytesPerSec), sizeof(HI_U32), 1, (FILE *)pfcmp); \
+    fread(&(((WMA_FORMAT_S *)pstWfx)->nBlockAlign), sizeof(HI_U16), 1, (FILE *)pfcmp); \
+    fread(&(((WMA_FORMAT_S *)pstWfx)->wBitsPerSample), sizeof(HI_U16), 1, (FILE *)pfcmp); \
+    fread(&(((WMA_FORMAT_S *)pstWfx)->cbSize), sizeof(HI_U16), 1, (FILE *)pfcmp); \
+    nRead += 7*sizeof(HI_U16)+ 2*sizeof(HI_U32); \
+    if (((WMA_FORMAT_S *)pstWfx)->wFormatTag != 1) \
+    { \
+    } \
+    if (((WMA_FORMAT_S *)pstWfx)->cbSize == 4) \
+    { \
+        ((WMA_FORMAT_S *)pstWfx)->wFormatTag = 0x160; \
+        fread(&(((WMA_FORMAT_S *)pstWfx)->cbExtWord), 1, ((WMA_FORMAT_S *)pstWfx)->cbSize, (FILE *)pfcmp); \
+       	nRead +=((WMA_FORMAT_S *)pstWfx)->cbSize; \
+    } \
+    else if ((((WMA_FORMAT_S *)pstWfx)->cbSize == 10) || (((WMA_FORMAT_S *)pstWfx)->cbSize == (10 + 22))) \
+    { \
+        ((WMA_FORMAT_S *)pstWfx)->wFormatTag = 0x161; \
+        fread(&(((WMA_FORMAT_S *)pstWfx)->cbExtWord), 1, ((WMA_FORMAT_S *)pstWfx)->cbSize, (FILE *)pfcmp); \
+       	nRead +=((WMA_FORMAT_S *)pstWfx)->cbSize; \
+    } \
+    else \
+    { \
+    } \
+    nRead; \
+})
+
+#else
+static HI_S32 HA_WMA_ParseCmp(FILE *pfcmp, WMA_FORMAT_S *pstWfx)
+{
+       HI_S32 nRead=0;
+
+#if 1                                                                 
+	fread(&(pstWfx->wFormatTag), sizeof(HI_U16), 1, pfcmp);       
+	fread(&(pstWfx->nChannels), sizeof(HI_U16), 1, pfcmp);        
+	fread(&(pstWfx->nSamplesPerSec), sizeof(HI_U32), 1, pfcmp);   
+	fread(&(pstWfx->nAvgBytesPerSec), sizeof(HI_U32), 1, pfcmp);  
+	fread(&(pstWfx->nBlockAlign), sizeof(HI_U16), 1, pfcmp);      
+	fread(&(pstWfx->wBitsPerSample), sizeof(HI_U16), 1, pfcmp);   
+	fread(&(pstWfx->cbSize), sizeof(HI_U16), 1, pfcmp);           
+	nRead += 7*sizeof(HI_U16)+ 2*sizeof(HI_U32);                  
+#endif                                                                
+	if (pstWfx->wFormatTag != 1) // not v1 or v2
+	{
+		//HA_PRINT("Support only CMP V1 format wFormatTag=0x%x!\n",pstWfx->wFormatTag);
+		return -1;
+	}
+
+	if (pstWfx->cbSize == 4)  //g45208
+	{
+		//WMA v1 bitstream
+		pstWfx->wFormatTag = 0x160;
+		fread(&pstWfx->cbExtWord, 1, pstWfx->cbSize, pfcmp);
+       	nRead +=pstWfx->cbSize;
+	}
+	else if ((pstWfx->cbSize == 10) || (pstWfx->cbSize == (10 + 22) ) )  //g45208
+	{
+		//WMA v2/v3 bitstream
+		pstWfx->wFormatTag = 0x161;
+		fread(&pstWfx->cbExtWord, 1, pstWfx->cbSize, pfcmp);
+       	nRead +=pstWfx->cbSize;
+	}
+	else
+	{
+		//HA_PRINT("Error cbSize=%d\n",pstWfx->cbSize);
+		return -1;
+	}
+	return nRead;
+}
+#endif
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_DECODER_WMA_H__ */
+
diff -uNr a/include/HA.AUDIO.codec.common.h b/include/HA.AUDIO.codec.common.h
--- a/include/HA.AUDIO.codec.common.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/HA.AUDIO.codec.common.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,28 @@
+#ifndef __HISI_AUDIO_CODEC_COMMON_H__
+#define __HISI_AUDIO_CODEC_COMMON_H__
+
+#include "hi_type.h"
+#include "hi_audio_codec.h"
+#include "securec.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#define HA_CHECK_MEM_SUCCESS(api)\
+do {\
+    errno_t _ret_mem_ = (api); \
+    if(EOK != _ret_mem_) { \
+        HA_ERR_PRINT("%s[%d]:%s failed(0x%x)\n", __FUNCTION__, __LINE__, #api, _ret_mem_); \
+    } \
+} while(0)
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HISI_AUDIO_CODEC_COMMON_H__ */
diff -uNr a/include/des.h b/include/des.h
--- a/include/des.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/des.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,52 @@
+
+#ifndef _DES_H_
+#define _DES_H_
+
+#define CRYPT           0
+#define HASH            1
+#define UPDATE          2
+
+#define DES_IP              1
+#define DES_IP_1            2
+#define DES_RIGHT           4
+#define DES_HASH            8
+
+#define DES_ECM_CRYPT       0
+#define DES_ECM_HASH        DES_HASH
+#define DES_ECS2_DECRYPT    (DES_IP | DES_IP_1 | DES_RIGHT)
+#define DES_ECS2_CRYPT      (DES_IP | DES_IP_1)
+
+#define F_EURO_S2       0
+#define F_TRIPLE_DES    1
+
+#define SetBit(addr, bit) (addr) |= (1 << (bit))
+#define UnsetBit(addr, bit) (addr) &= ~(1<< (bit))
+#define TestBit(addr, bit) ((addr) & (1 << bit))
+
+typedef unsigned char byte;
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif		/* __cplusplus */
+
+extern void EuroDes(byte key1[], byte key2[], byte DesMode, byte OperatingMode, 
+                    byte data[]);
+extern int des_encrypt(byte *buffer, int len, byte *deskey);
+extern int des_decrypt(byte *buffer, int len, byte *deskey);
+extern void des_login_key_get(byte *key1, byte *key2, int len, byte *des16);
+
+#ifdef __cplusplus
+}
+#endif		/* __cplusplus */
+
+extern void doPC1(byte data[]);
+extern void des(byte key[], byte mode, byte data[]);
+
+enum { ECM=0, ECS2=1, ECS3=2 };
+
+#endif
+
+
+
+
diff -uNr a/include/hi_adp.h b/include/hi_adp.h
--- a/include/hi_adp.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_adp.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,131 @@
+#ifndef __HI_ADP_H__
+#define __HI_ADP_H__
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+
+#include "hi_type.h"
+
+#if defined(ANDROID)
+extern void LogPrint(const char *format, ...);
+#endif
+
+#ifdef CONFIG_SUPPORT_CA_RELEASE
+#define sample_common_printf
+#else
+#if defined(ANDROID)
+#define sample_common_printf LogPrint
+#else
+#define sample_common_printf printf
+#endif
+#endif
+
+#define HIAPI_RUN(api, ret) \
+    do {\
+        HI_S32 errCode; \
+        errCode = api; \
+        if (errCode != 0)\
+        {\
+            ret |= errCode; \
+            sample_common_printf("\033[0;31m" "[Function: %s line: %d] %s failed ret = 0x%x \n" "\033[0m", __FUNCTION__, __LINE__, # api, errCode); \
+        } \
+    } while (0)
+
+#define HIAPI_RUN_RETURN(api) \
+    do {\
+        HI_S32 errCode; \
+        errCode = api; \
+        if (errCode != 0)\
+        {\
+            sample_common_printf("\033[0;31m" "[Function: %s line: %d] %s failed ret = 0x%x \n" "\033[0m", __FUNCTION__, __LINE__, # api, errCode); \
+            return HI_FAILURE; \
+        } \
+    } while (0)
+
+#define HIAPI_RUN_RETURN_FN(api, fn) \
+    do {\
+        HI_S32 errCode; \
+        errCode = api; \
+        if (errCode != 0)\
+        {\
+            sample_common_printf("\033[0;31m" "[Function: %s line: %d] %s failed ret = 0x%x \n" "\033[0m", __FUNCTION__, __LINE__, # api, errCode); \
+            fn; \
+            return HI_FAILURE; \
+        } \
+    } while (0)
+
+#define HIAPI_ERR_PRINTF(ret) \
+    do {\
+        sample_common_printf("\033[0;31m" " [Function: %s line: %d]  ret = 0x%x \n" "\033[0m", __FUNCTION__, __LINE__, ret); \
+    } while (0)\
+
+
+#define PRINT_SMP(fmt...) sample_common_printf(fmt)
+
+#define SAMPLE_RUN(api, ret) \
+    do { \
+        HI_S32 l_ret = api; \
+        if (l_ret != HI_SUCCESS) \
+        { \
+            PRINT_SMP("run %s failed, ERRNO:%#x.\n", # api, l_ret); \
+        } \
+        else \
+        {\
+            /*printf("sample %s: run %s ok.\n", __FUNCTION__, #api);}*/ \
+        } \
+        ret = l_ret; \
+    } while (0)
+
+#define SAMPLE_CheckNullPTR(pointer) \
+    do  \
+    { \
+        if (NULL == pointer) \
+        {   \
+            PRINT_SMP("%s failed:NULL Pointer in Line:%d!\n", __FUNCTION__, __LINE__); \
+            return HI_FAILURE;  \
+        }   \
+    } while (0)
+
+#ifdef ANDROID
+#define SAMPLE_GET_INPUTCMD(InputCmd)   \
+    do { \
+        memset(InputCmd, 0, sizeof(InputCmd)); \
+        read(0, InputCmd, sizeof(InputCmd)); \
+    } while (0)
+
+#define HISI_SAMPLE_FIFO "/dev/hisi_sample_fifo"
+
+#define HI_GET_INPUTCMD(InputCmd)   \
+    do { \
+        int t_fd; \
+        unlink(HISI_SAMPLE_FIFO); \
+        if (mkfifo(HISI_SAMPLE_FIFO, 0777) != -1) \
+        { \
+            t_fd = open(HISI_SAMPLE_FIFO, O_RDONLY); \
+            if (t_fd != -1)  \
+            { \
+                memset(InputCmd, 0, sizeof(InputCmd));   \
+                read(t_fd, InputCmd, sizeof(InputCmd));  \
+                close(t_fd); \
+            } \
+            else  \
+            { \
+                perror("Can't open the FIFO:");  \
+                exit(0); \
+            } \
+        } \
+        else  \
+        { \
+            perror("Can't create FIFO channel:"); \
+            exit(0); \
+        } \
+    } while (0)
+#else
+#define SAMPLE_GET_INPUTCMD(InputCmd) fgets((char *)(InputCmd), (sizeof(InputCmd) - 1), stdin)
+
+#define HI_GET_INPUTCMD(InputCmd) fgets((char *)(InputCmd), (sizeof(InputCmd) - 1), stdin)
+#endif
+
+#endif
diff -uNr a/include/hi_adp_boardcfg.h b/include/hi_adp_boardcfg.h
--- a/include/hi_adp_boardcfg.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_adp_boardcfg.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,117 @@
+#ifndef __BOARDCFG_H__
+#define __BOARDCFG_H__
+
+#include "hi_unf_demux.h"
+#include "hi_unf_frontend.h"
+#include "hi_adp_ini.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef HI_TUNER_NUMBER
+#define HI_TUNER_NUMBER         8
+#endif
+
+#ifdef ANDROID
+#define FRONTEND_CONFIG_PATH  "/system/lib/"
+#else
+#define FRONTEND_CONFIG_PATH  "/usr/local/cfg/"
+#endif
+#define FRONTEND_CONFIG_FILE  FRONTEND_CONFIG_PATH "frontend_config.ini"
+#define TUNERNUM_SECTION      "tunernum"
+#define SECTION_MAX_LENGTH    (64)
+
+#define USE_I2C      (0)
+#define NOT_MODIFY   (0)
+#define NEED_RESET   (1)
+#define USER_DEFINED (1)
+
+/* The default value when read failed. */
+#define DEFAULT_TUNER_NUM        (1)
+#define DEFAULT_SIG_TYPE         (HI_UNF_TUNER_SIG_TYPE_CAB)
+
+/* Tuner and Demod device and info. */
+#define DEFAULT_TUNER_TYPE        (HI_UNF_TUNER_DEV_TYPE_TDA18250B)
+#define DEFAULT_TUNER_ADDR        (0xc0)
+#define DEFAULT_DEMOD_TYPE        (HI_UNF_DEMOD_DEV_TYPE_3130E)
+#define DEFAULT_DEMOD_ADDR        (0xa0)
+#define DEFAULT_DEMOD_OUTPUT_MODE (HI_UNF_TUNER_OUTPUT_MODE_SERIAL)
+#define DEFAULT_DEMOD_RST_TYPE    (NEED_RESET)
+#define DEFAULT_DEMOD_RST_GPIO    (0)
+#define DEFAULT_MEMORY_MODE       (0)
+
+/* I2C */
+#define DEFAULT_I2C_TYPE          (USE_I2C)
+#define DEFAULT_I2C_CHNUM         (1)
+#define DEFAULT_GPIOI2C_SCL       (0)
+#define DEFAULT_GPIOI2C_SDA       (0)
+
+/* TSOUT  */
+#define DEFAULT_DEMOD_TSOUT_MODE    (NOT_MODIFY)
+#define DEFAULT_DEMOD_OUTPUT_TSDAT0 (HI_UNF_TUNER_OUTPUT_TSDAT0)
+#define DEFAULT_DEMOD_OUTPUT_TSDAT1 (HI_UNF_TUNER_OUTPUT_TSDAT1)
+#define DEFAULT_DEMOD_OUTPUT_TSDAT2 (HI_UNF_TUNER_OUTPUT_TSDAT2)
+#define DEFAULT_DEMOD_OUTPUT_TSDAT3 (HI_UNF_TUNER_OUTPUT_TSDAT3)
+#define DEFAULT_DEMOD_OUTPUT_TSDAT4 (HI_UNF_TUNER_OUTPUT_TSDAT4)
+#define DEFAULT_DEMOD_OUTPUT_TSDAT5 (HI_UNF_TUNER_OUTPUT_TSDAT5)
+#define DEFAULT_DEMOD_OUTPUT_TSDAT6 (HI_UNF_TUNER_OUTPUT_TSDAT6)
+#define DEFAULT_DEMOD_OUTPUT_TSDAT7 (HI_UNF_TUNER_OUTPUT_TSDAT7)
+#define DEFAULT_DEMOD_OUTPUT_TSSYNC (HI_UNF_TUNER_OUTPUT_TSSYNC)
+#define DEFAULT_DEMOD_OUTPUT_TSVLD  (HI_UNF_TUNER_OUTPUT_TSVLD)
+#define DEFAULT_DEMOD_OUTPUT_TSERR  (HI_UNF_TUNER_OUTPUT_TSERR)
+
+/* Demux Attr */
+#define DEFAULT_DEMUX_PORT          (HI_UNF_DMX_PORT_TSI_0)
+#define DEFAULT_DEMUX_PORT_TYPE     (HI_UNF_DMX_PORT_TYPE_SERIAL_NOSYNC)
+#define DEFAULT_DEMUX_PORT_SHARECLK (HI_UNF_DMX_PORT_TSI_0)
+#define DEFAULT_DEMUX_BITSEL        (1)
+#define DEFAULT_DEMUX_INCLK         (0)
+
+/*  Cable Attr */
+#define DEFAULT_CAB_DEMOD_CLK       (24000) /*KHz*/
+#define DEFAULT_CAB_TS_SER_PIN      (HI_UNF_TUNER_TS_SERIAL_PIN_0)
+
+/*  Sat Attr */
+#define DEFAULT_SAT_DEMOD_CLK       (16000) /*KHz*/
+#define DEFAULT_SAT_TUNER_MAXLPF    (34)    /*MHz*/
+#define DEFAULT_SAT_TUNER_I2CCLK    (400)   /*KHz*/
+#define DEFAULT_SAT_RF_AGC          (HI_UNF_TUNER_RFAGC_INVERT)
+#define DEFAULT_SAT_IQ_SPECTRUM     (HI_UNF_TUNER_IQSPECTRUM_NORMAL)
+#define DEFAULT_SAT_TS_CLK_POLAR    (HI_UNF_TUNER_TSCLK_POLAR_RISING)
+#define DEFAULT_SAT_TS_FORMAT       (HI_UNF_TUNER_TS_FORMAT_TS)
+#define DEFAULT_SAT_TS_SER_PIN      (HI_UNF_TUNER_TS_SERIAL_PIN_0)
+#define DEFAULT_SAT_DISEQC_WAVE     (HI_UNF_TUNER_DISEQCWAVE_NORMAL)
+#define DEFAULT_SAT_LNBCTRL_DEV     (HI_UNF_LNBCTRL_DEV_TYPE_MPS8125)
+#define DEFAULT_SAT_LNBCTRL_DEV_ADDR (0)
+
+/* Ter Attr */
+#define DEFAULT_TER_DEMOD_CLK       (24000) /*KHz*/
+#define DEFAULT_TER_TUNER_MAXLPF    (34)    /*MHz*/
+#define DEFAULT_TER_TUNER_I2CCLK    (400)   /*KHz*/
+#define DEFAULT_TER_RF_AGC          (HI_UNF_TUNER_RFAGC_INVERT)
+#define DEFAULT_TER_IQ_SPECTRUM     (HI_UNF_TUNER_IQSPECTRUM_NORMAL)
+#define DEFAULT_TER_TS_CLK_POLAR    (HI_UNF_TUNER_TSCLK_POLAR_RISING)
+#define DEFAULT_TER_TS_FORMAT       (HI_UNF_TUNER_TS_FORMAT_TS)
+#define DEFAULT_TER_TS_SER_PIN      (HI_UNF_TUNER_TS_SERIAL_PIN_0)
+#define DEFAULT_TER_TS_SYNC_HEAD    (HI_UNF_TUNER_TS_SYNC_HEAD_AUTO)
+
+/* TSO */
+#define DEFAULT_DEMUX_TSO_NUM       (1)
+/* TSO Attr */
+#define DEFAULT_DEMUX_TSO_CLK       (HI_UNF_DMX_TSO_CLK_1200M)
+#define DEFAULT_DEMUX_TSO_CLK_MODE  (HI_UNF_DMX_TSO_CLK_MODE_NORMAL)
+#define DEFAULT_DEMUX_TSO_VLD_MODE  (HI_UNF_DMX_TSO_VALID_ACTIVE_HIGH)
+#define DEFAULT_DEMUX_TSO_PORT_TYPE (HI_UNF_DMX_PORT_TYPE_SERIAL)
+#define DEFAULT_DEMUX_TSO_BITSEL    (HI_UNF_DMX_TSO_SERIAL_BIT_0)
+
+
+#define TUNER_USE        (0)
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
diff -uNr a/include/hi_adp_data.h b/include/hi_adp_data.h
--- a/include/hi_adp_data.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_adp_data.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,138 @@
+#ifndef _COMMON_DATA_H
+#define _COMMON_DATA_H
+
+#include "hi_type.h"
+
+#define     MAX_PROGNAME_LENGTH 32
+#define     MAX_AUDIO_LANGUAGE 5
+#define     MAX_PROG_COUNT 200
+#define     MAX_FRONTEND_COUNT 30
+
+#define     SEARCHING_FRONTEND_ID	0xffff
+
+typedef enum hiFRONTEND_TYPE_E
+{
+    FE_TYPE_RF   = 1,
+    FE_TYPE_IP   = 2,
+    FE_TYPE_FILE = 3
+} FRONTEND_TYPE_E;
+
+typedef enum hiFILE_TYPE_E
+{
+    FILE_TYPE_TS = 0,
+    FILE_TYPE_ES = 1,
+}FILE_TYPE_E;
+
+typedef enum hiFILE_AUDIO_TYPE_E
+{
+    FILE_AUDIO_TYPE_NONE = 0,
+    FILE_AUDIO_TYPE_AAC   = 1,
+    FILE_AUDIO_TYPE_MP3   = 2,
+    FILE_AUDIO_TYPE_AC3   = 3,
+    FILE_AUDIO_TYPE_DTS = 4,
+    FILE_AUDIO_TYPE_DRA = 5
+} FILE_AUDIO_TYPE_E;
+
+typedef enum hiFILE_VIDEO_TYPE_E
+{
+    FILE_VIDEO_TYPE_NONE = 0,
+    FILE_VIDEO_TYPE_MPEG2   = 1,
+    FILE_VIDEO_TYPE_MPEG4   = 2,
+    FILE_VIDEO_TYPE_H263 = 3,
+    FILE_VIDEO_TYPE_H264 = 4,
+    FILE_VIDEO_TYPE_AVS = 5,
+    FILE_VIDEO_TYPE_REAL = 6,
+    FILE_VIDEO_TYPE_AV1 = 7
+} FILE_VIDEO_TYPE_E;
+
+typedef struct hiFE_TYPEIP_S
+{
+    HI_CHAR multiIPAddr[20];
+    HI_U32  port;
+} FE_TYPE_IP_S;
+
+typedef struct hiFE_TYPERF_S
+{
+    HI_U32 u32TunerPort; /*Tuner port*/
+    HI_U32 u32Frequency;  /*unit:MHZ */
+    HI_U32 u32SymbolRate; /*unit:KHZ*/
+    HI_U32 u32Modulation;  /* 0:16QAM 1:32QAM 2:64QAM 3:128QAM 4:256QAM*/
+} FE_TYPE_RF_S;
+
+typedef struct hiFE_TYPEFILE_S
+{
+    HI_CHAR path[256];
+    FILE_TYPE_E filetype;
+    FILE_VIDEO_TYPE_E videotype;
+    FILE_AUDIO_TYPE_E audiotype;
+} FE_TYPE_FILE_S;
+
+/* channel dot struct */
+typedef struct hiDB_FRONTEND_S
+{
+    FRONTEND_TYPE_E eFEType;
+    HI_U16          u16NetworkID;
+    HI_U16          u16TsID;
+    union
+    {
+	 FE_TYPE_FILE_S  sFEParaFile;  //file type
+        FE_TYPE_IP_S    sFEParaIp;  //IP type
+        FE_TYPE_RF_S    sFEParaRf; //RF type
+    }unFEtype;
+
+} DB_FRONTEND_S;
+
+/* program struct */
+typedef struct hiDB_VIDEOEX_S
+{
+    HI_U16 u16VideoPid;
+    HI_U32 u32VideoEncType;
+} DB_VIDEOEX_S;
+
+typedef struct hiDB_AUDIOEX_S
+{
+    HI_U16 u16audiopid;
+    HI_U16 u16audiolan;
+    HI_U32 u32AudioEncType;
+} DB_AUDIOEX_S;
+
+typedef struct  hiDB_PROGRAM_S
+{
+    HI_U16 u16FrontendID;
+    HI_U16 u16NetworkID;
+    HI_U16 u16TsID;
+    HI_U16 u16ServiceID;
+
+    HI_U8 enServiceType;
+
+    HI_S8 ProgramName[MAX_PROGNAME_LENGTH];
+
+    HI_U16 u16PmtPid;
+    HI_U16 u16PcrPid;
+
+    HI_U32 u16ProgProperty;
+
+    HI_U16 u16AudioVol;
+    HI_U8  u8AudioChannel;
+    HI_U8  u8VideoChannel;
+
+    DB_VIDEOEX_S VideoEX;
+    DB_AUDIOEX_S AudioEX[MAX_AUDIO_LANGUAGE];
+
+    HI_U16 Reserved;
+} DB_PROGRAM_S;
+
+HI_S32   DB_GetDVBProgInfoByServiceID(HI_U16 u16ServiceID, DB_PROGRAM_S *proginfo );
+HI_S32	DB_GetDVBProgInfo(HI_U32 prognum, DB_PROGRAM_S *proginfo );
+HI_S32	DB_SetDVBProgInfo(HI_U32 prognum, DB_PROGRAM_S *proginfo );
+HI_S32	DB_AddDVBProg(DB_PROGRAM_S *proginfo );
+HI_S32	DB_GetProgTotalCount(void);
+HI_S32	DB_GetFEChanInfo(HI_U32 channum, DB_FRONTEND_S *chaninfo );
+HI_S32	DB_SetFEChanInfo(HI_U32 channum, DB_FRONTEND_S *chaninfo );
+HI_S32	DB_AddFEChan(DB_FRONTEND_S *chaninfo);
+HI_S32	DB_GetFEChanTotalCount(void);
+HI_S32	DB_Reset(void);
+HI_S32	DB_RestoreFromFile(FILE *filestream);
+HI_S32	DB_SaveToFile(FILE *filestream);
+
+#endif
diff -uNr a/include/hi_adp_hdmi.h b/include/hi_adp_hdmi.h
--- a/include/hi_adp_hdmi.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_adp_hdmi.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,16 @@
+#ifndef __SAMPLE_HDMI_COMMON_H__
+#define __SAMPLE_HDMI_COMMON_H__
+
+#include "hi_unf_hdmi.h"
+
+typedef void (*User_HDMI_CallBack)(HI_UNF_HDMI_EVENT_TYPE_E event, HI_VOID *pPrivateData);
+
+HI_UNF_ENC_FMT_E stringToUnfFmt(HI_CHAR *pszFmt);
+HI_S32 HIADP_HDMI_Init(HI_UNF_HDMI_ID_E enHDMIId);
+HI_S32 HIADP_HDMI_DeInit(HI_UNF_HDMI_ID_E enHDMIId);
+//HI_S32 HIADP_HDMI_SetAdecAttr(HI_UNF_SND_INTERFACE_E enInterface, HI_UNF_SAMPLE_RATE_E enRate);
+HI_VOID HDMI_PrintSinkCap(HI_UNF_EDID_BASE_INFO_S *pCapbility);
+HI_VOID HDMI_SaveFmt(HI_UNF_ENC_FMT_E enFmt);
+
+#endif /* #if pub_HDMI_H_ */
+
diff -uNr a/include/hi_adp_ini.h b/include/hi_adp_ini.h
--- a/include/hi_adp_ini.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_adp_ini.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,35 @@
+/******************************************************************************
+
+  Copyright (C), 2011-2018. Hisilicon Technologies Co., Ltd. All rights reserved.
+
+******************************************************************************
+    File Name     : hi_adp_ini.h
+    Version       : Initial Draft
+    Author        : Device Chipset STB Development Dept
+    Created       : 2018/08/23
+    Description   : head file
+
+******************************************************************************/
+
+#ifndef HI_ADP_INI_H
+#define HI_ADP_INI_H
+
+#include <stdio.h>
+#include "hi_type.h"
+
+#define HI_INI_BUFSIZE  512
+
+#define HIADP_INI_OpenRead(filename,file)   ((*(file) = fopen((filename),"rb")) != NULL)
+#define HIADP_INI_Close(file)               (fclose(*(file)) == 0)
+#define HIADP_INI_Read(buffer,size,file)    (fgets((buffer),(size),*(file)) != NULL)
+#define HIADP_INI_Atof(string)              (float)strtod((string),NULL)
+
+
+HI_BOOL  HIADP_INI_Getbool(const HI_CHAR *section, const HI_CHAR *key, HI_BOOL default_value, const HI_CHAR *file);
+long     HIADP_INI_Getl(const HI_CHAR *section, const HI_CHAR *key, long default_value, const HI_CHAR *file);
+HI_S32   HIADP_INI_Gets(const HI_CHAR *section, const HI_CHAR *key, const HI_CHAR *default_value, HI_CHAR *buffer, HI_S32 size, const HI_CHAR *file);
+float    HIADP_INI_Getf(const HI_CHAR *section, const HI_CHAR *key, float default_value, const HI_CHAR *file);
+
+
+
+#endif /* HI_ADP_INI_H */
diff -uNr a/include/hi_adp_mpi.h b/include/hi_adp_mpi.h
--- a/include/hi_adp_mpi.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_adp_mpi.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,95 @@
+#ifndef  __HI_ADP_MPI_H__
+#define  __HI_ADP_MPI_H__
+
+#include "hi_type.h"
+#include "hi_unf_common.h"
+#include "hi_unf_avplay.h"
+#include "hi_unf_vo.h"
+#include "hi_adp.h"
+#include "hi_adp_search.h"
+#include "hi_adp_boardcfg.h"
+#include "hi_unf_ai.h"
+
+#define DOLBYPLUS_HACODEC_SUPPORT
+#define SLIC_AUDIO_DEVICE_ENABLE
+
+#define G711_FRAME_LEN 320
+
+/********************************* Demux Common Interface *******************************/
+HI_S32 HIADP_Demux_Init(HI_U32 DmxPortID,HI_U32 TsPortID);
+
+HI_S32 HIADP_Demux_DeInit(HI_U32 DmxPortID);
+
+/************************************DISPLAY  Common Interface*******************************/
+HI_S32 HIADP_Disp_StrToFmt(HI_CHAR *pszFmt);
+
+HI_S32 hi_adp_disp_init_mutex(HI_UNF_ENC_FMT_E enFormat);
+
+HI_S32 HIADP_Disp_Init(HI_UNF_ENC_FMT_E enFormat);
+
+HI_S32 HIADP_Disp_DeInit(HI_VOID);
+
+
+/****************************VO  Common Interface********************************************/
+HI_S32 HIADP_VO_Init(HI_UNF_VO_DEV_MODE_E enDevMode);
+
+HI_S32 HIADP_VO_CreatWin(HI_RECT_S * pstWinRect, HI_HANDLE * phWin);
+
+HI_S32 HIADP_VO_CreatWinExt(HI_RECT_S * pstWinRect, HI_HANDLE * phWin, HI_BOOL bVirtScreen);
+
+HI_S32 HIADP_VO_DeInit();
+
+/*****************************************SOUND  Common Interface************************************/
+HI_S32 HIADP_Snd_Init(HI_VOID);
+
+
+HI_S32 HIADP_Snd_DeInit(HI_VOID);
+
+#ifdef HI_AUDIO_AI_SUPPORT
+/*Only Support Single AI Chn*/
+HI_S32 HIADP_AI_Init(HI_UNF_AI_E enAISrc, HI_HANDLE *pAIHandle, HI_HANDLE *pTrackSlave, HI_HANDLE *pATrackVir);
+HI_S32 HIADP_AI_DeInit(HI_HANDLE hAI, HI_HANDLE hAISlave, HI_HANDLE hAIVir);
+#endif
+
+/*****************************************AIAO  Common Interface************************************/
+HI_S32 HIADP_AIAO_Init(HI_S32 DevId, HI_S32 AI_Ch, HI_S32 AO_Ch, HI_UNF_SAMPLE_RATE_E enSamplerate, HI_U32 u32SamplePerFrame);
+
+
+HI_S32 HIADP_AIAO_DeInit(HI_VOID);
+
+HI_S32 HIADP_SLIC_Open(HI_VOID);
+HI_S32 HIADP_SLIC_Close(HI_VOID);
+HI_S32 HIADP_SLIC_GetHookOff(HI_BOOL *pbEnable);
+HI_S32 HIADP_SLIC_GetHookOn(HI_BOOL *pbEnable);
+HI_S32 HIADP_SLIC_SetRinging(HI_BOOL bEnable);
+
+
+/**************************************AVPLAY  Common Interface***************************************/
+HI_S32 HIADP_AVPlay_RegADecLib();
+
+HI_S32 HIADP_AVPlay_Init();
+
+HI_S32 HIADP_AVPlay_Create(HI_HANDLE *avplay,HI_U32 u32DemuxId,
+                                 HI_UNF_AVPLAY_STREAM_TYPE_E streamtype,
+                                 HI_UNF_VCODEC_CAP_LEVEL_E vdeccap,
+                                 HI_U32 channelflag);
+
+HI_S32 HIADP_AVPlay_SetVdecAttr(HI_HANDLE hAvplay,HI_UNF_VCODEC_TYPE_E enType,HI_UNF_VCODEC_MODE_E enMode);
+
+HI_S32 HIADP_AVPlay_SetAdecAttr(HI_HANDLE hAvplay,HI_U32 enADecType,HI_HA_DECODEMODE_E enMode, HI_S32 isCoreOnly);
+
+HI_S32 HIADP_AVPlay_PlayProg(HI_HANDLE hAvplay,PMT_COMPACT_TBL *pProgTbl,HI_U32 ProgNum,HI_BOOL bAudPlay);
+
+HI_S32 HIADP_AVPlay_PlayProg_MS12(HI_HANDLE hAvplay,PMT_COMPACT_TBL *pProgTbl,HI_U32 ProgNum);
+
+HI_S32 HIADP_AVPlay_PlayAud(HI_HANDLE hAvplay,PMT_COMPACT_TBL *pProgTbl,HI_U32 ProgNum);
+
+HI_S32 HIADP_AVPlay_SwitchAud(HI_HANDLE hAvplay,HI_U32 AudPid, HI_U32 u32AudType);
+
+HI_S32 HIADP_MCE_Exit(HI_VOID);
+
+HI_S32 HIADP_DMX_AttachTSPort(HI_U32 Dmxid, HI_U32 TunerID);
+HI_S32 HIADP_DMX_PushTsBuffer(HI_HANDLE hTsBuf, HI_UNF_STREAM_BUF_S *pstBuf, HI_U32 u32StartPos, HI_U32 u32ValidLen);
+
+#endif
+
diff -uNr a/include/hi_adp_search.h b/include/hi_adp_search.h
--- a/include/hi_adp_search.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_adp_search.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,382 @@
+#ifndef _COMMON_SEARCH_H__
+#define _COMMON_SEARCH_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/********************Descriptor flag definition******************/
+/********************CNcomment:描述符标识符定义******************/
+
+#define STREAM_TYPE_11172_VIDEO         0x01
+#define STREAM_TYPE_13818_VIDEO         0x02
+#define STREAM_TYPE_11172_AUDIO         0x03
+#define STREAM_TYPE_13818_AUDIO         0x04
+#define STREAM_TYPE_14496_2_VIDEO       0x10    // MPEG4
+#define STREAM_TYPE_14496_10_VIDEO      0x1B    // H264
+#define STREAM_TYPE_AVS_VIDEO           0x42    // AVS
+#define STREAM_TYPE_AVS2_VIDEO          0xD2    // AVS2
+#define STREAM_TYPE_HEVC_VIDEO          0x24    // HEVC
+#define STREAM_TYPE_13818_7_AUDIO       0x0F    // AAC
+#define STREAM_TYPE_14496_3_AUDIO       0x11    // AAC
+#define STREAM_TYPE_AC3_AUDIO           0x81    // AC3
+#define STREAM_TYPE_SCTE                0x82    // TS packets containing SCTE data
+#define STREAM_TYPE_DTS_AUDIO           0x82    // DTS
+#define STREAM_TYPE_DOLBY_TRUEHD_AUDIO  0x83    // dolby true HD
+#define STREAM_TYPE_DTS_MA				0x86	// DTS MA which conflict with CAPTION_SERVICE_DESCRIPTOR
+#define STREAM_TYPE_PRIVATE             0x06    // PES packets containing private data
+
+#define VIDEO_STREAM_DESCRIPTOR             0x02
+#define AUDIO_STREAM_DESCRIPTOR             0x03
+#define HIERACHY_DESCRIPTOR                 0x04
+#define REGISTRATION_DESCRIPTOR             0x05
+#define DATA_STREAM_ALIGNMENT_DESCRIPTOR    0x06
+#define TARGET_BACKGROUND_GRID_DESCRIPTOR   0x07
+#define VIDEO_WINDOW_DESCRIPTOR             0x08
+#define CA_DESCRIPTOR                       0x09
+#define LANGUAGE_DESCRIPTOR                 0x0A
+#define SYSTEM_CLOCK_DESCRIPTOR             0x0B
+#define MULTIPLEX_BUFFER_USAGE_DESCRIPTOR   0x0C
+#define COPYRIGHT_DESCRIPTOR                0x0D
+#define MAXIMUM_BITRATE_DESCRIPTOR          0x0E
+#define PRIVATE_DATA_INDICATOR_DESCRIPTOR   0x0F
+#define SMOOTHING_BUFFER_DESCRIPTOR         0x10
+#define STD_DESCRIPTOR                      0x11
+#define IBP_DESCRIPTOR                      0x12
+#define AC4_DESCRIPTOR                      0x15
+
+#define NETWORK_NAME_DESCRIPTOR 0x40
+#define SERVICE_LIST_DESCRIPTOR 0x41
+#define STUFFING_DESCRIPTOR 0x42
+#define SATELLITE_DELIVERY_DESCRIPTOR 0x43
+#define CABLE_DELIVERY_DESCRIPTOR 0x44
+#define BOUQUET_NAME_DESCRIPTOR 0x47
+#define SERVICE_DESCRIPTOR 0x48
+#define COUNTRY_AVAILABILITY_DESCRIPTOR 0x49
+#define LINKAGE_DESCRIPTOR 0x4A
+#define NVOD_REFERENCE_DESCRIPTOR 0x4B
+#define TIME_SHIFTED_SERVICE_DESCRIPTOR 0x4C
+#define SHORT_EVENT_DESCRIPTOR 0x4D
+#define EXTENDED_EVENT_DESCRIPTOR 0x4E
+#define TIME_SHIFTED_EVENT_DESCRIPTOR 0x4F
+#define COMPONENT_DESCRIPTOR 0x50
+#define MOSAIC_DESCRIPTOR 0x51
+#define STREAM_IDENTIFIER_DESCRIPTOR 0x52
+#define CA_IDENTIFIER_DESCRIPTOR 0x53
+#define CONTENT_DESCRIPTOR 0x54
+#define PARENTAL_RATING_DESCRIPTOR 0x55
+#define TELETEXT_DESCRIPTOR 0x56
+#define TELEPHONE_DESCRIPTOR 0x57
+#define LOCAL_TIME_OFFSET_DESCRIPTOR 0x58
+#define SUBTITLING_DESCRIPTOR 0x59
+#define TERRESTRIAL_DELIVERY_DESCRIPTOR 0x5A
+#define MULTILINGUAL_NETWORK_NAME_DESCRIPTOR 0x5B
+#define MULTILINGUAL_BOUQUET_NAME_DESCRIPTOR 0x5C
+#define MULTILINGUAL_SERVICE_NAME_DESCRIPTOR 0x5D
+#define MULTILINGUAL_COMPONENT_DESCRIPTOR 0x5E
+#define PRIVATE_DATA_SPECIFIER_DESCRIPTOR 0x5F
+#define SERVICE_MOVE_DESCRIPTOR 0x60
+#define SHORT_SMOOTHING_BUFFER_DESCRIPTOR 0x61
+#define FREQUENCY_LIST_DESCRIPTOR 0x62
+#define PARTIAL_TRANSPORT_STREAM_DESCRIPTOR 0x63
+#define DATA_BROADCAST_DESCRIPTOR 0x64
+#define CA_SYSTEM_DESCRIPTOR 0x65
+#define DATA_BROADCAST_ID_DESCRIPTOR 0x66
+#define TRANSPORT_STREAM_DESCRIPTOR 0x67
+#define DSNG_DESCRIPTOR 0x68
+#define PDC_DESCRIPTOR 0x69
+#define AC3_DESCRIPTOR 0x6A
+#define AC3_PLUS_DESCRIPTOR 0x7A
+#define ANCILLARY_DATA_DESCRIPTOR 0x6B
+#define CELL_LIST_DESCRIPTOR 0x6C
+#define CELL_FREQUENCY_LINK_DESCRIPTOR 0x6D
+#define ANNOUNCEMENT_SUPPORT_DESCRIPTOR 0x6E
+#define DRA_DESCRIPTOR 0x05
+
+#define AC3_EXT_DESCRIPTOR 0x52
+
+#define CAPTION_SERVICE_DESCRIPTOR 0x86
+#define EXTENSION_DESCRIPTOR 0x7F
+#define SUPPLEMENTARY_AUDIO_DESCRIPTOR 0x06
+
+#define STREAM_TYPE_HEVC_VIDEO_IDENTIFY 0x48455643
+#define STREAM_TYPE_DTS1_AUDIO_IDENTIFY 0x44545331
+#define STREAM_TYPE_DTS2_AUDIO_IDENTIFY 0x44545332
+#define STREAM_TYPE_DTS3_AUDIO_IDENTIFY 0x44545333
+
+#define MAX_PMT_LEN     1024
+/***********TS PID defintion**************/
+
+#define PAT_TSPID (0x0000)
+#define CAT_TSPID (0x0001)
+#define NIT_TSPID (0x0010)
+#define EIT_TSPID (0x0012)
+#define TOT_TSPID (0x0014)
+#define TDT_TSPID (0x0014)
+#define SDT_TSPID (0x0011)
+#define BAT_TSPID (0x0011)
+
+#define INVALID_TSPID (0x1fff)
+
+/***********Table ID defintion**************/
+#define PAT_TABLE_ID (0x00)
+#define CAT_TABLE_ID (0x01)
+#define PMT_TABLE_ID (0x02)
+#define NIT_TABLE_ID_ACTUAL (0x40)
+#define NIT_TABLE_ID_OTHER (0x41)
+
+#define SDT_TABLE_ID_ACTUAL (0x42)
+#define SDT_TABLE_ID_OTHER (0x46)
+
+#define BAT_TABLE_ID (0x4A)
+#define EIT_TABLE_ID_PF_ACTUAL (0x4E)
+#define EIT_TABLE_ID_PF_OTHER (0x4F)
+#define EIT_TABLE_ID_SCHEDULE_ACTUAL_LOW (0x50)
+#define EIT_TABLE_ID_SCHEDULE_ACTUAL_HIGH (0x5F)
+
+#define EIT_TABLE_ID_SCHEDULE_OTHER_LOW (0x60)
+#define EIT_TABLE_ID_SCHEDULE_OTHER_HIGH (0x6F)
+
+#define TDT_TABLE_ID (0x70)
+#define TOT_TABLE_ID (0x73)
+
+#define INVALID_TABLE_ID (0xff)
+#define CHANNEL_MAX_PROG    256
+#define PROG_MAX_VIDEO      8
+#define PROG_MAX_AUDIO      8
+#define PROG_MAX_CA         15
+
+#define SUBTDES_INFO_MAX 10
+#define SUBTITLING_MAX 1500
+#define CAPTION_SERVICE_MAX 16
+#define TTX_DES_MAX    10
+#define TTX_MAX        15
+
+#define SUBT_TYPE_DVB  (0x1)
+#define SUBT_TYPE_SCTE (0x2)
+#define SUBT_TYPE_BOTH (SUBT_TYPE_DVB | SUBT_TYPE_SCTE)
+
+typedef struct hiPAT_INFO_S
+{
+    HI_U16 u16ServiceID;    /*Progam 's SERVICE ID*/
+    HI_U16 u16PmtPid;        /*Progam 's PMT ID*/
+} PAT_INFO;
+
+typedef struct hiPAT_TB_S
+{
+    HI_U16 u16ProgNum;
+    HI_U16 u16TsID;
+    PAT_INFO PatInfo[CHANNEL_MAX_PROG];
+} PAT_TB;
+
+typedef struct hiPMT_VIDEO_S
+{
+    HI_U32 u32VideoEncType;
+    HI_U16 u16VideoPid;
+} PMT_VIDEO;
+
+typedef struct hiPMT_AUDIO_S
+{
+    HI_U32         u32AudioEncType;
+    HI_U16         u16AudioPid;
+    HI_U16         u16ADType;
+    HI_U8          u8AudLang[3];
+} PMT_AUDIO;
+typedef struct hiPMT_CA_S
+{
+    HI_U16 u16CASystemID;
+    HI_U16 u16CAPID ;
+} PMT_CA;
+
+typedef struct hiPMP_SUBTITLE_DES_S
+{
+    HI_U32 u32LangCode; /* low 24-bit valid */
+    HI_U8  u8SubtitleType;
+    HI_U16 u16PageID;
+    HI_U16 u16AncillaryPageID;
+
+} PMP_SUBTITLE_DES;
+
+typedef struct hiPMT_SUBTITLE_S
+{
+    HI_U16 u16SubtitlingPID;
+
+    HI_U8 u8DesTag; /*  */
+    HI_U8 u8DesLength;
+
+    HI_U8 u8DesInfoCnt;
+
+    PMP_SUBTITLE_DES DesInfo[SUBTDES_INFO_MAX];
+
+} PMT_SUBTITLE;
+
+typedef struct hiPMT_SCTE_SUBTITLE_S
+{
+
+    HI_U16 u16SCTESubtPID;
+    HI_U32 u32LanguageCode;
+} PMT_SCTE_SUBTITLE_S;
+
+typedef struct hiPMT_CLOSED_CAPTION_S
+{
+    HI_U32 u32LangCode;
+    HI_U8 u8IsDigitalCC;
+    HI_U8 u8ServiceNumber;
+    HI_U8 u8IsEasyReader;
+    HI_U8 u8IsWideAspectRatio;
+} PMT_CLOSED_CAPTION_S;
+
+typedef struct hiPMT_TTX_DES_S
+{
+    HI_U32 u32ISO639LanguageCode; /* low 24-bit valid */
+    HI_U8  u8TtxType;
+    HI_U8  u8TtxMagazineNumber;
+    HI_U8  u8TtxPageNumber;
+} PMT_TTX_DES_S;
+
+typedef struct hiPMT_TTX_S
+{
+    HI_U16 u16TtxPID;
+
+    HI_U8 u8DesTag;
+    HI_U8 u8DesLength;
+
+    HI_U8 u8DesInfoCnt;
+
+    PMT_TTX_DES_S stTtxDes[TTX_DES_MAX];
+
+} PMT_TTX_S;
+
+
+typedef struct hiPMT_TB_S
+{
+    HI_U16 u16ServiceID;
+    HI_U16 u16PcrPid;
+    HI_U16 u16VideoNum;
+    HI_U16 u16AudoNum;
+    HI_U16 u16CANum;
+    PMT_VIDEO Videoinfo[PROG_MAX_VIDEO];
+    PMT_AUDIO Audioinfo[PROG_MAX_AUDIO];
+    PMT_CA CASystem[PROG_MAX_CA];
+
+    HI_U16 u16SubtitlingNum;
+    PMT_SUBTITLE SubtitingInfo[SUBTITLING_MAX];
+    PMT_SCTE_SUBTITLE_S stSCTESubtInfo;
+    HI_U16 u16ClosedCaptionNum;
+    PMT_CLOSED_CAPTION_S stClosedCaption[CAPTION_SERVICE_MAX];
+    HI_U16 u16ARIBCCPid;
+
+    HI_U16 u16TtxNum;
+    PMT_TTX_S stTtxInfo[TTX_MAX];
+    HI_U8  u8PmtData[MAX_PMT_LEN];
+    HI_U32 u32PmtLen;
+} PMT_TB;
+
+typedef enum hiRUN_STATE_E
+{
+    UnDefined = 0,
+    NotRun,
+    StartInSeconds,
+    Pause,
+    Running,
+    Run_Reserved1,
+    Run_Reserved2,
+    Run_Reserved3
+} RUN_STATE_E;
+
+typedef enum hiCA_MODE_E
+{
+    CA_NotNeed = 0,
+    CA_Need
+} CA_MODE_E;
+
+typedef struct hiSDT_INFO_S
+{
+    HI_U16          u16ServiceID;
+    HI_U8       u8EitFlag;
+    HI_U8       u8EitFlag_PF;
+    RUN_STATE_E RunState;
+    CA_MODE_E   CAMode;
+
+    HI_U32      u32ServiceType;
+    HI_S8   s8ProgName[32];
+} SDT_INFO;
+
+typedef struct hiSDT_TB_S
+{
+    HI_U32 u32ProgNum;
+    HI_U16 u16TsId;
+    HI_U16 u16NetID;
+    SDT_INFO SdtInfo[CHANNEL_MAX_PROG];
+} SDT_TB;
+
+
+typedef struct hiPMT_COMPACT_PROG_S
+{
+    HI_U32 ProgID;          /* program ID */
+    HI_U32 PmtPid;          /*program PMT PID*/
+    HI_U32 PmtRemapPid; /* overlapped when remux, remap to new pid */
+    HI_U32 PcrPid;          /*program PCR PID*/
+
+    HI_U32   VideoType;
+    HI_U16               VElementNum;        /* video stream number */
+    HI_U16               VElementPid;        /* the first video stream PID*/
+    HI_U16               VElementRemapPid; /* overlapped when remux, remap to new pid */
+
+    HI_U32   AudioFormat;
+    HI_U32   AudioType;
+    HI_U16               AElementNum;        /* audio stream number */
+    HI_U16               AElementPid;        /* the first audio stream PID*/
+    HI_U16               AElementRemapPid; /* overlapped when remux, remap to new pid */
+
+    HI_U16 u16CANum;
+    PMT_CA CASystem[PROG_MAX_CA];
+    PMT_AUDIO Audioinfo[PROG_MAX_AUDIO];     /* multi-audio info, added by gaoyanfeng 00182102 */
+
+    HI_U32              SubtType;            /*0---NONE,1---DVB,2---SCTE,3---BOTH*/
+    HI_U16              u16SubtitlingNum;
+    PMT_SUBTITLE        SubtitingInfo[SUBTITLING_MAX];
+    PMT_SCTE_SUBTITLE_S stSCTESubtInfo;
+    HI_U16               u16ClosedCaptionNum;
+    PMT_CLOSED_CAPTION_S stClosedCaption[CAPTION_SERVICE_MAX];
+    HI_U16              u16ARIBCCPid;
+
+    HI_U16 u16TtxNum;
+    PMT_TTX_S stTtxInfo[TTX_MAX];
+    HI_U8  u8PmtData[MAX_PMT_LEN];
+    HI_U32 u32PmtLen;
+} PMT_COMPACT_PROG;
+
+typedef struct hiPMT_COMPACT_TBL_S
+{
+    HI_U32            prog_num;
+    PMT_COMPACT_PROG* proginfo;
+} PMT_COMPACT_TBL;
+
+HI_S32      DVB_SearchStart(HI_U32 u32DmxID);
+HI_VOID     DVB_SaveSearch(HI_U32 u32FrontendID);
+HI_VOID     DVB_ListProg();
+HI_S32      SRH_ParseSDT(const HI_U8* pu8SectionData, HI_S32 s32Length, HI_U8* pSectionStruct);
+HI_S32      SRH_ParsePMT ( const HI_U8* pu8SectionData, HI_S32 s32Length, HI_U8* pSectionStruct);
+HI_S32      SRH_ParsePAT( const HI_U8*  pu8SectionData, HI_S32 s32Length, HI_U8* pSectionStruct);
+HI_S32      SRH_PATRequest(HI_U32 u32DmxID, PAT_TB* pat_tb);
+HI_S32      SRH_PMTRequest(HI_U32 u32DmxID, PMT_TB* pmt_tb, HI_U16 u16PmtPid, HI_U16 u16ServiceId);
+HI_S32      SRH_PATRequestExt(HI_U32 u32DmxID, PAT_TB* pat_tb, HI_BOOL bTeeEnable);
+HI_S32      SRH_PMTRequestExt(HI_U32 u32DmxID, PMT_TB* pmt_tb, HI_U16 u16PmtPid, HI_U16 u16ServiceId, HI_BOOL bTeeEnable);
+HI_S32      SRH_SDTRequest(HI_U32 u32DmxID, SDT_TB* sdt_tb);
+/******************************************Search public interface***********************************/
+HI_VOID     HIADP_Search_Init();
+HI_S32      HIADP_Search_GetAllPmt(HI_U32 u32DmxId, PMT_COMPACT_TBL** ppProgTable);
+HI_S32      HIADP_Search_FreeAllPmt(PMT_COMPACT_TBL* pProgTable);
+HI_VOID     HIADP_Search_DeInit();
+HI_S32      HIADP_Search_GetAllPmtExt(HI_U32 u32DmxId, PMT_COMPACT_TBL **ppProgTable, HI_BOOL bTeeEnable);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif /*__SEARCH_H__*/
diff -uNr a/include/hi_audio_codec.h b/include/hi_audio_codec.h
--- a/include/hi_audio_codec.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_audio_codec.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,863 @@
+/******************************************************************************
+Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_audio_codec.h
+Version       : Initial Draft
+Author        : Hisilicon multimedia software group
+Created       : 2009/11/01
+Last Modified :
+Description   : define audio common data structure
+  History       :
+  1.Date        : 2009/11/10
+    Author      : zgjie
+    Modification: Created file
+******************************************************************************/
+
+/**
+ * \file
+ * \brief Describes the information about the audio codec. CNcomment:提供AUDIO_CODEC的相关信息 CNend
+ */
+
+#ifndef __HI_AUDIO_CODEC_H__
+#define __HI_AUDIO_CODEC_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/**Define HA codec Print Level*/
+/**CNcomment:定义HA codec打印级别*/
+#define HA_TRACE_LEVEL_FATAL    (0)
+#define HA_TRACE_LEVEL_ERROR    (1)
+#define HA_TRACE_LEVEL_WARN     (2)
+#define HA_TRACE_LEVEL_INFO     (3)
+#define HA_TRACE_LEVEL_DBG      (4)
+
+
+#ifndef HI_ADVCA_FUNCTION_RELEASE
+
+#ifndef CFG_HA_LOG_LEVEL
+#define CFG_HA_LOG_LEVEL         (HA_TRACE_LEVEL_ERROR)
+#endif
+
+#if (CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_FATAL)
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)
+#define HA_WARN_PRINT(fmt...)
+#define HA_INFO_PRIN(fmt...)
+#define HA_DBG_PRINT(fmt...)
+
+#elif (CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_ERROR)
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_WARN_PRIN(fmt...)
+#define HA_INFO_PRIN(fmt...)
+#define HA_DBG_PRINT(fmt...)
+
+#elif(CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_WARN)
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_WARN_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_INFO_PRINT(fmt...)
+#define HA_DBG_PRINT(fmt...)
+
+#elif(CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_INFO)
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_WARN_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_INFO_PRINT(fmt...)    do{printf(fmt);}while(0)
+#define HA_DBG_PRINT(fmt...)
+
+#elif(CFG_HA_LOG_LEVEL == HA_TRACE_LEVEL_DBG)
+
+#define HA_FATAL_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_ERR_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_WARN_PRINT(fmt...)   do{printf(fmt);}while(0)
+#define HA_INFO_PRINT(fmt...)    do{printf(fmt);}while(0)
+#define HA_DBG_PRINT(fmt...)     do{printf(fmt);}while(0)
+
+#endif
+
+#else
+
+#define HA_FATAL_PRINT(fmt...)
+#define HA_ERR_PRINT(fmt...)
+#define HA_WARN_PRINT(fmt...)
+#define HA_INFO_PRIN(fmt...)
+#define HA_DBG_PRINT(fmt...)
+
+#endif
+
+/**Define software dual decode*/
+/**CNcomment:定义软解双路解码*/
+#define HA_SW_DUALDEC_SUPPORT
+
+/**Define HA codec ID*/
+/**CNcomment:定义HA codec ID*/
+/*
+*                HA CODEC_ID defination
+*   |      7bit                9bit                3bit                   13bit  |
+*   |---vendor---|---format---|---reserved---|---id---|
+*/
+#define VENDOR_HISI 0x040
+#define VENDOR_NONE 0x010
+#define HA_VENDOR_OFFSETK  25 /* (32-7) */
+#define HA_VENDOR_MASK     (0x007fUL << HA_VENDOR_OFFSETK)
+#define HA_FORMAT_OFFSETK  16 /* (32-7-9) */
+#define HA_FORMAT_MASK     (0x01ffUL << HA_FORMAT_OFFSETK)
+#define HA_RESERVED_OFFSET 13 /* (32-7-9-3) */
+#define HA_RESERVED_MASK   (0x007UL << HA_RESERVED_OFFSET)
+#define HA_ID_OFFSET       0 /* (32-7-9-3-13) */
+#define HA_ID_MASK         (0x1fffUL<< HA_ID_OFFSET)
+
+#define HA_BUILD_CODEC_ID(vendor, format, id) (((((HI_U32)vendor) << HA_VENDOR_OFFSETK) & HA_VENDOR_MASK) | ((((HI_U32)format) << HA_FORMAT_OFFSETK) & HA_FORMAT_MASK) | (((HI_U32)id) & HA_ID_MASK))
+#define HA_GET_VENDOR(codec) ((HI_U32)(codec&HA_VENDOR_MASK)>>HA_VENDOR_OFFSETK)
+#define HA_GET_FORMAT(codec) ((HI_U32)(codec&HA_FORMAT_MASK)>>HA_FORMAT_OFFSETK)
+#define HA_GET_ID(codec)     ((HI_U32)(codec&HA_ID_MASK)>>HA_ID_OFFSET)
+
+/********************************Macro Definition********************************/
+/** \addtogroup      ACODEC */
+/** @{ */  /** <!-- 【ACODEC】 */
+
+/**Define HA codec common command ID*/
+/**CNcomment:定义HA codec 公共CMD ID*/
+#define HA_COMMON_CMD_ID   0xffff
+
+/**Define HA codec format query command ID*/
+/**CNcomment:定义HA codec 格式查询CMD ID*/
+#define HA_CODEC_FORMAT_QUERY_CMD         ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1000)
+
+/**Define HA codec decoder open parameter command ID*/
+/**CNcomment:定义HA codec 解码器打开参数CMD ID*/
+#define HA_CODEC_GET_DECOPENPARAM_CMD     ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1001)
+
+/**Define HA codec encoder open parameter command ID*/
+/**CNcomment:定义HA codec 编码器打开参数CMD ID*/
+#define HA_CODEC_GET_ENCOPENPARAM_CMD     ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1002)
+
+/**Define HA codec packet query command ID*/
+/**CNcomment:定义HA codec packet解码模式CMD ID*/
+#define HA_CODEC_PACKETDECODER_QUERY_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1003)
+
+/**Define HA codec hwdecode query command ID*/
+/**CNcomment:定义HA codec hwdecode解码模式CMD ID*/
+#define HA_CODEC_HARDWARECODEC_QUERY_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1004)
+
+/**Define HA codec set outbuf addr command ID  only for hardware codec*/
+/**CNcomment:定义输出Buffer地址设置CMD ID*/
+#define HA_CODEC_OUTBUFADDR_SET_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1005)
+
+/**Define dual decode capability support query command ID*/
+/**CNcomment:定义双路解码能力查询CMD ID*/
+#define HA_CODEC_DUAL_DECODE_QUERY_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1006)
+
+/**Define dual decode set ad output mode command ID*/
+/**CNcomment:定义双路解码AD输出模式设置CMD ID*/
+#define HA_CODEC_AD_OUTPUTMODE_SET_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1007)
+
+/**Define AD Balance Setting command ID*/
+/**CNcomment:定义AD 权重设置CMD ID*/
+#define HA_CODEC_AD_BALANCE_SET_CMD     ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1008)
+
+/**Define PTS Delay command ID*/
+/**CNcomment:定义PTS Delay CMD ID*/
+#define HA_CODEC_PTS_DELAY_SET_CMD      ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x1009)
+
+/**Define HA codec set whether work in compress mode command ID */
+/**CNcomment:定义是否工作于在线压缩模式设置CMD ID*/
+#define HA_CODEC_COMPRESSMODE_SET_CMD ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x100A)
+
+/**Define HA codec get codec output delay ms*/
+/**CNcomment:定义获取解码器输出延时CMD ID*/
+#define HA_CODEC_OUTPUTDELAY_GET_CMD  ((((HI_U32)HA_COMMON_CMD_ID) << 16) | 0x100B)
+
+/**Define HA codec maximum audio channel*/
+/**CNcomment:定义HA codec 最大音频通道 */
+#define HA_AUDIO_MAXCHANNELS 8
+/** @} */  /** <!-- ==== Macro Definition end ==== */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      ACODEC */
+/** @{ */  /** <!--  【ACODEC】 */
+
+/**HA format definition*/
+/**CNcomment:HA format 定义*/
+typedef enum hiHA_FORMAT_E
+{
+    FORMAT_MP2 = 0x000,  /**<MPEG audio layer 1, 2.*/ /**<CNcomment:MPEG音频第一层、第二层 */
+    FORMAT_MP3, /**<MPEG audio layer 1, 2, 3.*/ /**<CNcomment:MPEG音频第一层、第二层 、第三层*/
+    FORMAT_AAC,
+    FORMAT_AC3,
+    FORMAT_DTS,
+    FORMAT_VORBIS,
+    FORMAT_DVAUDIO,
+    FORMAT_WMAV1,
+    FORMAT_WMAV2,
+    FORMAT_MACE3,
+    FORMAT_MACE6,
+    FORMAT_VMDAUDIO,
+    FORMAT_SONIC,
+    FORMAT_SONIC_LS,
+    FORMAT_FLAC,
+    FORMAT_MP3ADU,
+    FORMAT_MP3ON4,
+    FORMAT_SHORTEN,
+    FORMAT_ALAC,
+    FORMAT_WESTWOOD_SND1,
+    FORMAT_GSM,
+    FORMAT_QDM2,
+    FORMAT_COOK,
+    FORMAT_TRUESPEECH,
+    FORMAT_TTA,
+    FORMAT_SMACKAUDIO,
+    FORMAT_QCELP,
+    FORMAT_WAVPACK,
+    FORMAT_DSICINAUDIO,
+    FORMAT_IMC,
+    FORMAT_MUSEPACK7,
+    FORMAT_MLP,
+    FORMAT_GSM_MS, /**<as found in WAV.*/ /**<CNcomment:存在WAV格式中 */
+    FORMAT_ATRAC3,
+    FORMAT_VOXWARE,
+    FORMAT_APE,
+    FORMAT_NELLYMOSER,
+    FORMAT_MUSEPACK8,
+    FORMAT_SPEEX,
+    FORMAT_WMAVOICE,
+    FORMAT_WMAPRO,
+    FORMAT_WMALOSSLESS,
+    FORMAT_ATRAC3P,
+    FORMAT_EAC3,
+    FORMAT_SIPR,
+    FORMAT_MP1,
+    FORMAT_TWINVQ,
+    FORMAT_TRUEHD,
+    FORMAT_MP4ALS,
+    FORMAT_ATRAC1,
+    FORMAT_BINKAUDIO_RDFT,
+    FORMAT_BINKAUDIO_DCT,
+    FORMAT_DRA,
+
+    FORMAT_PCM = 0x100,/**<various PCM codecs.*/ /**<CNcomment:PCM格式 */
+    FORMAT_PCM_BLURAY = 0x121,
+
+    FORMAT_ADPCM = 0x130,/**<various ADPCM codecs.*/ /**<CNcomment:ADPCM格式 */
+
+    FORMAT_AMR_NB = 0x160,/**<various AMR codecs.*/ /**<CNcomment:AMR格式 */
+    FORMAT_AMR_WB,
+    FORMAT_AMR_AWB,
+
+    FORMAT_RA_144 = 0x170,/**<RealAudio codecs.*/ /**<CNcomment:RealAudio格式 */
+    FORMAT_RA_288,
+
+    FORMAT_DPCM = 0x180,/**<various DPCM codecs.*/ /**<CNcomment:DPCM格式 */
+
+    FORMAT_G711 = 0x190,/**<various G.7xx codecs.*/ /**<CNcomment:G.7xx格式 */
+    FORMAT_G722,
+    FORMAT_G7231,
+    FORMAT_G726,
+    FORMAT_G728,
+    FORMAT_G729AB,
+
+    FORMAT_OPUS = 0x1a0,
+
+    FORMAT_MULTI = 0x1f0,/**<support multi codecs.*/ /**<CNcomment:多种格式 */
+/*ZHTQ ADD*/
+	FORMAT_MULTI_TRUEHD = 0x1f6,
+	FORMAT_MULTI_LPCM = 0x1f7,
+	FORMAT_MULTI_WMA = 0x1f8,
+	FORMAT_MULTI_WMAPRO = 0x1f9,
+    FORMAT_BUTT = 0x1ff,
+} HA_FORMAT_E;
+
+/**HA format definition*/
+/**CNcomment:HA_Codec定义*/
+typedef enum hiHA_CODEC_ID_E
+{
+    /** HISI Codec*/
+    HA_AUDIO_ID_PCM             = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_PCM, 0x0000),
+    HA_AUDIO_ID_MP2             = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MP2, 0x0002),
+    HA_AUDIO_ID_MP3             = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MULTI, 0x0003),
+    HA_AUDIO_ID_AAC             = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_AAC, 0x001),
+    HA_AUDIO_ID_BLYRAYLPCM      = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_PCM_BLURAY, 0x021),
+    HA_AUDIO_ID_COOK            = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_COOK, 0x0009),
+    HA_AUDIO_ID_DRA             = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_DRA, 0x007),
+    HA_AUDIO_ID_WMA9STD         = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MULTI, 0x0006),
+    HA_AUDIO_ID_AMRNB           = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_AMR_NB, 0x0100),
+    HA_AUDIO_ID_AMRWB           = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_AMR_WB, 0x0110),
+    HA_AUDIO_ID_G711            = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_G711, 0x0102),
+    HA_AUDIO_ID_G722            = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_G722, 0x0105),
+    HA_AUDIO_ID_G726            = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_G726, 0x0106),
+    HA_AUDIO_ID_ADPCM           = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_ADPCM, 0x0107),
+    HA_AUDIO_ID_VOICE           = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MULTI, 0x0108),
+    HA_AUDIO_ID_TRUEHD          = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_TRUEHD, 0x0008),
+    HA_AUDIO_ID_AC3PASSTHROUGH  = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI, 0x0055),
+    HA_AUDIO_ID_DTSPASSTHROUGH  = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_DTS, 0x1025),
+    HA_AUDIO_ID_OPUS            = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_OPUS, 0x1006),
+    HA_AUDIO_ID_VORBIS          = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_VORBIS, 0x1007),
+
+    /** DOLBY/DTS IPR Codec*/
+    HA_AUDIO_ID_DOLBY_PLUS      = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI, 0x1010),
+    HA_AUDIO_ID_DOLBY_TRUEHD    = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_TRUEHD, 0x1011),
+    HA_AUDIO_ID_MS12_DDP        = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MULTI, 0x1012),
+    HA_AUDIO_ID_MS12_AAC        = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MULTI, 0x1013),
+    HA_AUDIO_ID_MS12_AC4        = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_MULTI, 0x1014),
+    HA_AUDIO_ID_DTSHD           = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_DTS, 0x1020),
+    HA_AUDIO_ID_DTSM6           = HA_BUILD_CODEC_ID(VENDOR_NONE, FORMAT_DTS, 0x1030),
+
+    /** FFMPEG Codec*/
+    HA_AUDIO_ID_FFMPEG_DECODE   = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI,  0x03ff),
+    HA_AUDIO_ID_FFMPEG_WMAPRO   = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_WMAPRO, 0x041f),
+
+    /** CUSTOMER Codec*/
+    HA_AUDIO_ID_CUSTOM_0        = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI, 0x0400),
+    HA_AUDIO_ID_CUSTOM_1        = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI, 0x0401),
+/*ZHTQ ADD*/	
+	HA_AUDIO_ID_CUSTOM_2        = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI, 0x0402),
+	HA_AUDIO_ID_CUSTOM_3        = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI_TRUEHD, 0x0403),
+	HA_AUDIO_ID_CUSTOM_4        = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI_LPCM, 0x0404),
+	HA_AUDIO_ID_CUSTOM_5	  = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI_WMA, 0x0405),
+	HA_AUDIO_ID_CUSTOM_6	  = HA_BUILD_CODEC_ID(VENDOR_HISI, FORMAT_MULTI_WMAPRO, 0x0406),
+} HA_CODEC_ID_E;
+
+/**HA Channel Mode definition*/
+/**CNcomment:声道配置信息定义*/
+typedef enum
+{
+    HA_AUDIO_CH_MODE_DUAL_MONO = 0x0,
+    HA_AUDIO_CH_MODE_MONO      = 0x1,
+    HA_AUDIO_CH_MODE_STEREO    = 0x2,
+    HA_AUDIO_CH_MODE_3_0_MODE  = 0x3,
+    HA_AUDIO_CH_MODE_2_1_MODE  = 0x4,
+    HA_AUDIO_CH_MODE_3_1_MODE  = 0x5,
+    HA_AUDIO_CH_MODE_2_2_MODE  = 0x6,
+    HA_AUDIO_CH_MODE_3_2_MODE  = 0x7,
+    HA_AUDIO_CH_MODE_JOINT_STEREO = 0x8,   /**<only in mp3 format.*/ /**<CNcomment:仅mp3格式才有joint stereo模式*/
+    HA_AUDIO_CH_MODE_BUTT      = 0x1ff
+} HA_AUDIO_CHANNELMODE_E;
+
+/**HA Audio Output AD Mode definition*/
+/**CNcomment:HA OUTPUT AD MODE 定义*/
+typedef enum
+{
+    HA_OUTPUT_AD_OFF = 0,
+    HA_OUTPUT_AD_ON,
+    HA_OUTPUT_AD_OFF_WITHASSOC,
+    HA_OUTPUT_AD_BUTT
+} HA_CODEC_OUTPUT_AD_MODE_E;
+
+/**Define query parameter of an HA codec.*/
+/**CNcomment:定义HA codec 查询参数*/
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_VOID *pPara;
+} HA_CODEC_PARAMETER_QUERY_S;
+
+/**Define format query parameter of an HA codec.*/
+/**CNcomment:定义HA codec 格式查询参数*/
+typedef struct
+{
+    HI_U32  enCmd;
+    HA_FORMAT_E enFormat;
+} HA_CODEC_FORMAT_QUERY_PARAM_S;
+
+/**Define packet query parameter of an HA codec.*/
+/**CNcomment:定义HA codec packet解码模式查询参数*/
+typedef struct
+{
+    HI_U32  enCmd;              /**<packet query command.*/ /**<CNcomment:packet模式查询命令*/
+    HI_BOOL bPacketDecoder;     /**<Packet mode.In this mode, the decoder can decode the next packet only after processing an entire packet. */
+                                /**<CNcomment:packet模式.在这种模式下，只有处理完当前整个packet后解码器才能处理下一个packet包*/
+} HA_CODEC_PACKETDECODER_QUERY_PARAM_S;
+
+/**Define hardware decode query parameter of an HA codec.*/
+/**CNcomment:定义HA codec hardware解码模式查询参数*/
+typedef struct
+{
+    HI_U32  enCmd;      /**<hwdecode query command.*/ /**<CNcomment: hwdecode模式查询命令*/
+    HI_BOOL bHwCodec;   /**<HI_TRUE: hwdecode mode else swdecode mode. */ /**<CNcomment:hwdecode模式*/
+} HA_CODEC_HARDWARECODER_QUERY_PARAM_S;
+
+/**Define query parameter of dual decode capability.*/
+/**CNcomment:定义双路解码能力查询参数*/
+typedef struct
+{
+    HI_U32  enCmd;                  /**<query dual decode capability command.*/ /**<CNcomment: 查询双路解码能力命令*/
+    HI_BOOL bDualDecSupport;        /**<support dual decode or not. */  /**<CNcomment:是否支持双路解码*/
+} HA_CODEC_DUALDECODE_QUERY_PARAM_S;
+
+/**Define setting parameter of dual decode ad output mode.*/
+/**CNcomment:设置双路解码AD输出模式**/
+typedef struct
+{
+    HI_U32               enCmd;             /**<set AD Output Mode command.*/ /**<CNcomment: 设置AD输出模式命令*/
+    HA_CODEC_OUTPUT_AD_MODE_E  enAdMode;    /**<AD Output Mode. */  /**<CNcomment:AD输出模式*/
+} HA_CODEC_ADMODE_SET_PARAM_S;
+
+/**Define setting parameter of AD Balance.*/
+/**CNcomment:设置AD 权重**/
+typedef struct
+{
+    HI_U32  enCmd;                      /**<set AD Balance command.*/ /**<CNcomment: 设置AD权重命令*/
+    HI_S16  s16ADBalance;               /**<set the value of AD Balance */  /**<CNcomment:设置AD权重值*/
+} HA_CODEC_ADBALANCE_SET_PARAM_S;
+
+/**Define set parameter of whether work in compress mode.*/
+/**CNcomment:定义是否工作于在线压缩模式设置参数*/
+typedef struct
+{
+    HI_U32  enCmd;          /**<set the compress mode command. */ /**<CNcomment:设置是否在线压缩模式命令*/
+    HI_BOOL bCompressMode;  /**<whether work in compress mode. */ /**<CNcomment:是否工作于在线压缩模式*/
+} HA_CODEC_COMPRESSMODE_SET_PARAM_S;
+
+/**Define get parameter of decoder output delay.*/
+/**CNcomment:定义获取解码器输出延时参数*/
+typedef struct
+{
+    HI_U32  enCmd;          /**<get the output delay command. */ /**<CNcomment:获取解码器输出延时命令*/
+    HI_U32  u32OutputDelay; /**<decoder output delay ms. */ /**<CNcomment:解码器的输出延时(毫秒)*/
+} HA_CODEC_OUTOUTDELAY_GET_PARAM_S;
+
+/**Define the error codes of an HA codec.*/
+/**CNcomment:定义HA codec 错误码*/
+typedef enum hiHA_ERRORTYPE_E
+{
+    HA_ErrorNone = 0, /**<None error.*/ /**<CNcomment:没有错误 */
+
+    HA_ErrorInsufficientResources = (HI_S32) 0x80001000,/**<The device fails to be created due to insufficient resources.*/ /**<CNcomment:资源不够，创建设备失败 */
+
+    HA_ErrorInvalidParameter = (HI_S32) 0x80001001, /**<The input parameter is invalid.*/ /**<CNcomment:输入参数非法 */
+
+    HA_ErrorStreamCorrupt = (HI_S32) 0x80001002, /**<The decoding fails due to incorrect input streams.*/ /**<CNcomment:输入码流错误，解码失败 */
+
+    HA_ErrorNotEnoughData = (HI_S32) 0x80001003,/**<The decoding ends due to insufficient streams.*/ /**<CNcomment:输入码流不够，退出解码 */
+
+    HA_ErrorDecodeMode = (HI_S32) 0x80001004,/**<The decoding mode is not supported.*/ /**<CNcomment:解码模式不支持 */
+
+    HA_ErrorNotSupportCodec = (HI_S32) 0x80001005,/**<The codec is not supported.*/ /**<CNcomment:解码器不支持 */
+
+    HA_ErrorInBufFull = (HI_S32) 0x80001006,/**<Input buffer is full.*/ /**<CNcomment:输入缓存满 */
+
+    HA_ErrorOutBufEmpty = (HI_S32) 0x80001007,/**<Output buffer is empty.*/ /**<CNcomment:输出缓存空 */
+
+#ifdef HA_SW_DUALDEC_SUPPORT
+    HA_ErrorNotEnoughADData = (HI_S32) 0x80001008,/**<The decoding ends due to insufficient ad streams.*/ /**<CNcomment:ad输入码流不够，退出解码 */
+
+    HA_ErrorADDecFailed = (HI_S32) 0x80001009,
+#endif
+
+    HA_ErrorMax = 0x9FFFFFFF
+} HI_HA_ERRORTYPE_E;
+
+/**Definition of the distribution mode of the channels of an HA codec.*/
+/**CNcomment:定义HA codec 声道分布模式*/
+typedef enum hiHA_CHANNELTYPE_E
+{
+    HA_AUDIO_ChannelNone = 0x0,    /**< Unused or empty.*/ /**<CNcomment:未使用或为空*/
+    HA_AUDIO_ChannelLF  = 0x1,     /**< Left front.*/ /**<CNcomment:左前*/
+    HA_AUDIO_ChannelRF  = 0x2,     /**< Right front.*/ /**<CNcomment:右前*/
+    HA_AUDIO_ChannelCF  = 0x3,     /**< Center front.*/ /**<CNcomment:中置*/
+    HA_AUDIO_ChannelLS  = 0x4,     /**< Left surround.*/ /**<CNcomment:左环绕*/
+    HA_AUDIO_ChannelRS  = 0x5,     /**< Right surround.*/ /**<CNcomment:右环绕*/
+    HA_AUDIO_ChannelLFE = 0x6,     /**< Low frequency effects.*/ /**<CNcomment:低音*/
+    HA_AUDIO_ChannelCS  = 0x7,     /**< Back surround.*/ /**<CNcomment:后环绕*/
+    HA_AUDIO_ChannelLR  = 0x8,     /**< Left rear.*/ /**<CNcomment:左后*/
+    HA_AUDIO_ChannelRR  = 0x9,     /**< Right rear.*/ /**<CNcomment:右后*/
+    HA_AUDIO_ChannelMax = 0x7FFFFFFF
+} HI_HA_CHANNELTYPE_E;
+
+/**Definition of the decoding mode of an HA decoder.*/
+/**CNcomment:定义HA 解码器解码模式*/
+typedef enum hiHA_DECODEMODE_E
+{
+    HD_DEC_MODE_RAWPCM = 0,        /**<PCM decoding mode.*/ /**<CNcomment:PCM 解码模式*/
+    HD_DEC_MODE_THRU,              /**<SPIDF61937 passthrough decoding mode only, such as AC3/DTS.*/ /**<CNcomment:透传解码模式*/
+    HD_DEC_MODE_SIMUL,             /**<PCM and passthrough decoding mode.*/ /**<CNcomment:PCM + 透传解码模式*/
+    HD_DEC_MODE_BUTT = 0x7FFFFFFF
+} HI_HA_DECODEMODE_E;
+
+/**Definition of the HA codec version.*/
+/**CNcomment:HA codec 版本定义*/
+typedef union hiHI_HAAUDIO_VERSIONTYPE_U
+{
+    struct
+    {
+        HI_U8 u8VersionMajor;      /**< Major version.*/ /**<CNcomment:主版本号 */
+        HI_U8 u8VersionMinor;      /**< Minor version.*/ /**<CNcomment:副版本号 */
+        HI_U8 u8Revision;          /**< Revision version.*/ /**<CNcomment:修订版本 */
+        HI_U8 u8Step;              /**< Step version.*/ /**<CNcomment:阶段性版本 */
+    } s;
+    HI_U32 u32Version;
+} HI_HAAUDIO_VERSIONTYPE_U;
+
+/**Definition of the data types of the PCM module in an HA codec HA codec.*/
+/**CNcomment:pcm 数据类型结构体定义*/
+typedef struct hiHA_PCMMODETYPE_S
+{
+    HI_U32              u32DesiredOutChannels;/**<Input,number of expected output channels.If the number of original channels is not equal to the number of expected output channels,
+                                                  the decoded automatically performs down-mixing or up-mixing,In this way,
+                                                  the number of output channels is equal to the value of u32DesiredOutChannels,1: mono; 2 stereo. \n*/
+                                              /**<CNcomment:IN 期望输出声道数目. 如果码流原始声道不等于
+                                                  期望输出声道，解码器自动进行down-mix 或up-mix 处理，使得输出
+                                                  声道等于u32DesiredOutChannels.  1: mono, 2 for stereo*/
+    HI_BOOL             bInterleaved;/**<Whether the PCM data is interleaved.
+                                         HI_TRUE: interleaved mode (L/R/L/R.. .L/R/L/R).
+                                         HI_FALSE: non-interleaved mode (L/L/L.../R/R/R...). \n*/
+                                     /**<CNcomment:IN PCM 数据是否交织模式
+                                         HI_TRUE:  交织模式: L/R/L/R...L/R/L/R.
+                                         HI_FALSE: 非交织模式: L/L/L......../R/R/R....... */
+    HI_U32              u32BitPerSample;/**<Input Bit width of the PCM data.Only 16-bit or 24-bit width is supported.For the data of 16-bit width, 16-bit memory is used,
+                                            For the data of 24-bit width, 32-bit memory is used,The active bits of the 24-bit PCM data are upper bits, and the lower eight bits are padded with 0s. \n*/
+                                        /**<CNcomment:IN PCM 数据位宽,仅支持16 或24 数据位宽 16bit 位宽占用16bit 内存,
+                                            24bit 位宽占用32比特内存.24bit PCM数据有效为在高位，低8 位补0*/
+    HI_U32              u32DesiredSampleRate; /**<Input, expected output sampling rate.*/ /**<CNcomment:IN 期望输出采样频率*/
+    HI_HA_CHANNELTYPE_E enChannelMapping[HA_AUDIO_MAXCHANNELS]; /**<Input, distribution mode of output channels.*/ /**<CNcomment:IN 输出声道分布模式*/
+} HI_HA_PCMMODETYPE_S;
+
+/**Configuration parameters required by an HA codec for creating devices.*/
+/**CNcomment:HA 解码器创建设备的配置参数*/
+typedef struct hiHADECODE_OPENPARAM_S
+{
+    HI_HA_DECODEMODE_E  enDecMode;  /**<IN Decode Mode.*/ /**<CNcomment:解码模式*/
+    HI_HA_PCMMODETYPE_S sPcmformat; /**<IN data types of pcm module.*/ /**<CNcomment:PCM数据类型结构体*/
+    HI_VOID *           pCodecPrivateData;/**<Input, pointer to private data.If the decoder does not contain private data, this parameter is set to 0. */
+                                          /**<CNcomment:IN  指向私有配置结构体的指针，如果解码器没有私有配置，设置为0*/
+    HI_U32              u32CodecPrivateDataSize;/**<Input, size of the private data.If the decoder does not contain private data, this parameter is set to 0. */
+                                                /**<CNcomment:IN 私有结构体大小, 如果解码器没有私有配置，设置为0*/
+} HI_HADECODE_OPENPARAM_S;
+
+/**Input streams of an HA decoder.*/
+/**CNcomment:HA 解码器输入码流结构体*/
+typedef struct hiHADECODE_INPACKET_S
+{
+    HI_U32  u32PtsMs;  /**<Input, presentation time stamp (PTS) (in ms).Note: The HA decoder must discard this information. */ /**<CNcomment:当前时间戳*/
+    HI_U8  *pu8Data;   /**<Input/output, pointer to input streams.The decoder update this pointer after decoding. */ /**<CNcomment:IN/OUT 输入码流指针，解码完成后解码器更新该指针*/
+    HI_S32  s32Size;   /**<Input, size (in byte) of input streams.*/ /**<CNcomment:IN 输入码流大小. unit: Byte*/
+    HI_BOOL bEndOfFrm; /**<Input, the last frame or not.*/ /**<CNcomment:IN 是否最后一帧*/
+} HI_HADECODE_INPACKET_S;
+
+/**Get Open parameter of an HA decoder.*/
+/**CNcomment:获取HA 解码器打开参数*/
+typedef struct
+{
+    HI_U32  enCmd;
+    HI_HADECODE_OPENPARAM_S *pstDecodeParams;
+} HA_CODEC_GET_DECOPENPARAM_PARAM_S;
+
+/**Definition of the decoder output pts infomations.*/
+/**CNcomment:pts输出信息*/
+typedef struct hiHI_HA_OUTPTSINFO_S
+{
+    union
+    {
+        HI_U32 u32SwDecoderBytesLeft;   /**<left bytes of software decoder.*/ /**<CNcomment:软解剩余字节数 */
+        HI_U32 u32HwDecoderPtsReadPos;  /**<pts read position of software decoder.*/ /**<CNcomment:硬解pts读位置 */
+    } unPts;
+
+    union
+    {
+        HI_U32 u32SwAdDecoderBytesLeft;     /**<ad left bytes of software decoder.*/ /**<CNcomment:软解ad剩余字节数 */
+        HI_U32 u32HwAdDecoderPtsReadPos;    /**<ad pts read position of software decoder.*/ /**<CNcomment:硬解ad pts读位置 */
+    } unAdPts;
+} HI_HA_OUTPTSINFO_S;
+
+/**Output structure of the HA decoder.*/
+/**CNcomment:HA 解码器输出结构体*/
+typedef struct hiHI_HADECODE_OUTPUT_S
+{
+    HI_S32 *ps32PcmOutBuf;       /**<Input, pointer to the decoded PCM data.
+                                     Note: 1) ps32PcmOutBuf must be 32-word aligned.
+                                           2) ps32PcmOutBuf is NULL when the decoder is working in HD_DEC_MODE_THRU mode.\n*/
+                                 /**<CNcomment:IN 指向PCM 解码输出的指针. */
+
+    HI_U32  u32PcmOutBufSize;    /**<Input, size (in byte) of the buffer for storing the decoded PCM data
+                                     Note: u32PcmOutBufSize is 0 when the decoder is working in HD_DEC_MODE_THRU mode.\n*/
+                                 /**<CNcomment:IN  PCM 解码输出缓冲区大小. unit:Byte */
+
+    HI_S32 *ps32BitsOutBuf;      /**<Input, pointer to the decoded passthrough data.
+                                     Note: 1) ps32BitsOutBuf must be 32-word aligned.
+                                           2) ps32BitsOutBuf is NULL when the decoder is working in HD_DEC_MODE_RAWPCM mode.\n*/
+                                 /**<CNcomment:IN 指向透传解码输出的指针. */
+
+    HI_U32  u32BitsOutBufSize;   /**<Input, size (in byte) of the buffer for storing the decoded passthrough data (IEC61937)
+                                     Note: u32BitsOutBufSize is 0 when the decoder is working in HD_DEC_MODE_RAWPCM mode.\n*/
+                                 /**<CNcomment:IN 透传(IEC61937) 解码输出缓冲区大小. unit:Byte */
+
+    HI_U32  u32PcmOutSamplesPerFrame; /**<Output, number of output sampling points after the PCM data is decoded.*/ /**<CNcomment:OUT. 解码Pcm 输出样点数 */
+    HI_BOOL bInterleaved;             /**<Output, interleaved mode for PCM decoding.*/ /**<CNcomment:OUT PCM  解码交织模式*/
+    HI_U32  u32BitPerSample;          /**<Output, bit per sampling.*/ /**<CNcomment:OUT 位宽*/
+    HI_U32  u32BitsOutBytesPerFrame;  /**<Output, size (in byte) of the passthrough frame.*/ /**<CNcomment:OUT 透传输出帧大小. unit: Byte*/
+    HI_U32  u32OutChannels;           /**<Output, number of output channels.*/ /**<CNcomment:OUT 输出声道数*/
+    HI_U32  u32OutSampleRate;         /**<Output, output sampling rate.*/ /**<CNcomment:OUT. 输出采样频率*/
+    HI_U32  u32OrgChannels;           /**<Output, number of original channels.*/ /**<CNcomment:OUT 码流原始声道数*/
+    HI_U32  u32OrgSampleRate;         /**<Output, original sampling rate.*/ /**<CNcomment:OUT 码流原始采样频率*/
+    HI_U32  u32BitRate;               /**<Output, bit rate (in bit/s) of the compressed streams.*/ /**<CNcomment:OUT 码流压缩率unit: bit/S*/
+    HI_HA_OUTPTSINFO_S stPtsInfo;     /**<Output, pts information.*/ /**<CNcomment:OUT. pts信息*/
+    HI_U32  u32FrameIndex;   /**<Output, output frame index.*/ /**<CNcomment:OUT. 输出帧序号*/
+} HI_HADECODE_OUTPUT_S;
+
+/**Definition of the HA decoder.*/
+/**CNcomment:HA 解码器设备定义*/
+typedef struct hiHA_DECODE_S
+{
+    const HI_PCHAR szName;/**<Input, description information about a decoder, such as MP3 or AAC. */
+                          /**<CNcomment:IN 解码器描述名字，如MP3,AAC*/
+
+    const HI_U32 enCodecID;/**<Input, decoder ID.Note: This ID is the identifier of a decoder, and must be unique. */
+                           /**<CNcomment:IN 解码器标识，注意: 此标识作为解码器唯一身份标识，必须唯一而不能有重复*/
+
+    const HI_HAAUDIO_VERSIONTYPE_U uVersion;/**<Input, decoder version.*/ /**<CNcomment:IN 解码器版本描述*/
+
+    const HI_PCHAR pszDescription;/**<Input, detailed information about a decoder.*/ /**<CNcomment:IN 解码器详细描述信息*/
+
+
+
+    struct hiHA_DECODE_S *pstNext;/**<Output, pointer to the next decoder.This member variable is maintained by the client that calls the HA codec,
+                                      Therefore, the developers of the HA decoder can ignore this member variable. \n*/
+                                  /**<CNcomment:OUT  指向下个解码器设备的指针.  该成员变量由调用HA Codec 的客户端维护, HA 解码器开发者可以忽略该成员*/
+
+    HI_VOID  * pDllModule;/**<Output, pointer to the dll symbol of an HA decoder,This member variable is maintained by the client that calls the HA codec,
+                              Therefore, the developers of the HA decoder can ignore this member variable.\n*/
+                          /**<CNcomment:OUT 该成员变量由调用HA Codec 的客户端维护, HA 解码器开发者可以忽略该成员*/
+
+    /**
+    \brief Initializes a decoder. CNcomment:初始化解码器 CNend
+    \attention \n
+    \param[in] pstOpenParam pointer of the open params CNcomment:open参数结构体指针 CNend
+    \param[out] phDecoder   pointer of the decoder handle CNcomment:解码器句柄指针 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecInit)(HI_VOID * *phDecoder,
+                                 const HI_HADECODE_OPENPARAM_S * pstOpenParam);
+
+    /**
+    \brief DeInitializes a decoder. CNcomment:去初始化解码器 CNend
+    \attention \n
+    \param[in] hDecoder   pointer of the decoder handle CNcomment:解码器句柄指针 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecDeInit)(HI_VOID* hDecoder);
+
+    /**
+    \brief Configure a decoder dynamically. You can call this API when a decoder works.
+    CNcomment:解码器动态配置方法，用户可以在解码器运行时调用该接口 CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment:解码器句柄 CNend
+    \param[in] pstConfigStructure pointer to application allocated structure to be used for initialization by the decoder CNcomment:解码器初始化结构体 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecSetConfig)(HI_VOID* hDecoder, HI_VOID* pstConfigStructure);
+
+    /**
+    \brief Maximum size of the buffer required for storing the PCM data decoded by the decoder,
+    The memory needs to be allocated based on the size on the client.
+    CNcomment:解码器PCM输出所需最大缓冲区size. 客户端需要根据该方法分配内存 CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment:解码器句柄 CNend
+    \param[out] pu32OutSizes pointer to the max size of the pcm audio frame. unit:Byte CNcomment:最大PCM输出缓冲区大小 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecGetMaxPcmOutSize)(HI_VOID* hDecoder,
+            HI_U32* pu32OutSizes);
+
+    /**
+    \brief Maximum size of the buffer required for storing the passthrough data decoded by the decoder,
+    The memory needs to be allocated based on the size on the client.
+    CNcomment:解码器透传输出所需最大缓冲区size.客户端需要根据该方法分配内存 CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment:解码器句柄 CNend
+    \param[out] pu32OutSizes pointer to the max size of the iec61937 audio frame. unit:Byte CNcomment:最大透传输出缓冲区大小 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecGetMaxBitsOutSize)(HI_VOID* hDecoder,
+            HI_U32* pu32OutSizes);
+
+    /**
+    \brief This method is used to decode a frame. CNcomment:解码器解码一帧方法 CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment:解码器句柄 CNend
+    \param[in] pstApkt pointer to audio stream packet CNcomment:音频输入流指针 CNend
+    \param[out] pstAOut pointer to audio output CNcomment:音频输出流指针 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecDecodeFrame)(HI_VOID* hDecoder,
+                                        HI_HADECODE_INPACKET_S* pstApkt,
+                                        HI_HADECODE_OUTPUT_S* pstAOut);
+
+#ifdef HA_SW_DUALDEC_SUPPORT
+    /**
+    \brief This method is used to dual decode a frame. CNcomment:解码器双路解码一帧方法 CNend
+    \attention \n
+    \param[in] hDecoder   the decoder handle CNcomment:解码器句柄 CNend
+    \param[in] pstApkt pointer to audio stream packet CNcomment:音频输入流指针 CNend
+    \param[in] pstADApkt pointer to AD audio stream packet CNcomment:AD音频输入流指针 CNend
+    \param[out] pstAOut pointer to audio output CNcomment:音频输出流指针 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*DecDualDecodeFrame)(HI_VOID* hDecoder,
+                                            HI_HADECODE_INPACKET_S* pstApkt,
+                                            HI_HADECODE_INPACKET_S* pstADApkt,
+                                            HI_HADECODE_OUTPUT_S* pstAOut);
+#endif
+
+} HI_HA_DECODE_S;
+
+/**Parameters for creating an HA encoder.*/
+/**CNcomment:HA 编码器创建配置参数*/
+typedef struct hiHAENCODE_OPENPARAM_S
+{
+    HI_U32      u32DesiredOutChannels; /**<IN Number of channels (e.g 2 for stereo).*/ /**<CNcomment:声道数*/
+    HI_BOOL     bInterleaved;       /**<IN interleave or not.*/ /**<CNcomment:交织模式*/
+    HI_S32      s32BitPerSample;    /**<IN bitwidth per sample.*/ /**<CNcomment:位宽*/
+    HI_U32      u32DesiredSampleRate; /**<IN desired samplerate.*/ /**<CNcomment:期望采样率*/
+    HI_U32      u32SamplePerFrame;  /**<IN Pcm samples per frame for encoder.*/ /**<CNcomment:每帧采样点*/
+    HI_VOID*    pCodecPrivateData;  /**<IN Pointer of decoder private open parameters note: if there is none private parameters, pCodecPrivateData=0.*/
+                                    /**<CNcomment:私有参数*/
+    HI_U32      u32CodecPrivateDataSize;/**<IN Size of decoder private open parameters note: if there is none private parameters, u32CodecPrivateDataSize=0.*/
+                                        /**<CNcomment:私有参数大小*/
+} HI_HAENCODE_OPENPARAM_S;
+
+/**HA input pcm  packet struct.*/
+/**CNcomment:packet模式结构体*/
+typedef struct hiHAENCODE_INPACKET_S
+{
+    HI_U32  u32PtsMs;       /**<IN  PTS (unit:MS) Note: HA encoder should discard this infomation.*/
+                            /**<CNcomment:PTS，单位:毫秒*/
+    HI_U8*  pu8Data;        /**<IN/OUT pointer to input auduo pcm data note: HA encoder would update pu8Data after encode.*/
+                            /**<CNcomment:输入数据指针*/
+    HI_U32  u32Size;        /**<IN/OUT size of the input auduo data. unit: Byte.*/ /**<CNcomment:输入数据大小*/
+} HI_HAENCODE_INPACKET_S;
+
+/**HA encoder output struct.*/
+/**CNcomment:编码器输出结构体*/
+typedef struct hiHAENCODE_OUTPUT_S
+{
+    HI_S32* ps32BitsOutBuf;         /**<IN the pointer to encoded bitstream output buffer note: ps32BitsOutBuf must  be word32-aligned.*/
+                                    /**<CNcomment:编码数据输出buffer*/
+    HI_U32  u32BitsOutBufSize;      /**<IN the buffer size of bitstream output buffer. unit:Byte.*/ /**<CNcomment:编码器输出buffer大小*/
+    HI_U32  u32BitsOutBytesPerFrame;/**<IN size of the encoded audio data frame ,unit: Byte.*/ /**<CNcomment:编码数据帧大小，单位:Byte*/
+    HI_U32  u32BitRate;             /**<IN compress bit rate of the audio stream.*/ /**<CNcomment:比特率*/
+} HI_HAENCODE_OUTPUT_S;
+
+/**HA encoder struct define.*/
+/**CNcomment:定义编码器结构体*/
+typedef struct hiHA_ENCODE_S
+{
+    const HI_PCHAR szName;/**<Input, description information about audio encoder. */
+    /**<CNcomment:IN 编码器描述名字*/
+
+    const HI_U32 enCodecID;/**<Input, encoder ID.Note: This ID is the identifier of a encoder, and must be unique. */
+    /**<CNcomment:IN 编码器标识，注意: 此标识作为编码器唯一身份标识，必须唯一而不能有重复*/
+
+    const HI_HAAUDIO_VERSIONTYPE_U uVersion;/**<Input, encoder version.*/ /**<CNcomment:IN 编码器版本描述*/
+
+    const HI_PCHAR pszDescription;/**<Input, Description infomation of the audio encoder. */ /**<CNcomment:IN 编码器详细描述信息*/
+
+    struct hiHA_ENCODE_S* pstNext;/**<OUT pointer to next HA enocder.manager by client.client:The layer of software that invokes the methods of the HA encoder. */
+    /**<CNcomment:OUT 下个编码器结构体指针，由客户管理 */
+
+    HI_VOID*   pDllModule;/**<Output, pointer to the dll symbol of an HA encoder.This member variable is maintained by the client that calls the HA codec
+                              Therefore, the developers of the HA encoder can ignore this member variable. \n*/
+    /**<CNcomment:OUT 该成员变量由调用HA Codec 的客户端维护, HA 编码器开发者可以忽略该成员*/
+
+    /**
+    \brief Initializes a encoder. CNcomment:初始化编码器 CNend
+    \attention \n
+    \param[in] pstOpenParam pointer of the open params CNcomment:open参数结构体指针 CNend
+    \param[out] phEncoder   pointer of the encoder handle CNcomment:编码器句柄指针 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeInit)(HI_VOID * *phEncoder,
+                                    const HI_HAENCODE_OPENPARAM_S* pstOpenParam);
+
+    /**
+    \brief DeInitializes a encoder. CNcomment:去初始化编码器 CNend
+    \attention \n
+    \param[in] hEncoder   pointer of the encoder handle CNcomment:编码器句柄 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeDeInit)(HI_VOID* hEncoder);
+
+    /**
+    \brief Configure a encoder dynamically. It can be invoked anytime after the Encoder has been loaded.
+    CNcomment:编码器动态配置方法。用户可以在编码器运行时调用该接口 CNend
+    \attention \n
+    \param[in] hEncoder   the encoder handle CNcomment:编码器句柄 CNend
+    \param[in] pstConfigStructure pointer to application allocated structure to be used for initialization by the encoder CNcomment:编码器初始化结构体 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeSetConfig)(HI_VOID* hEncoder, HI_VOID* pstConfigStructure);
+
+    /**
+    \brief Maximum output size of an encoded bitstream CNcomment:编码器输出所需最大缓冲区size CNend
+    \attention \n
+    \param[in] hEncoder   the decoder handle CNcomment:解码器句柄 CNend
+    \param[out] pu32OutSizes pointer to the max size of the encoded audio frame. unit:Byte CNcomment:最大编码帧输出缓冲区大小 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeGetMaxBitsOutSize)(HI_VOID* hEncoder,
+            HI_U32* pu32OutSizes);
+
+    /**
+    \brief This method is used to encode a frame. CNcomment:编码器编码一帧方法 CNend
+    \attention \n
+    \param[in] hEncoder   the decoder handle CNcomment:编码器句柄 CNend
+    \param[in] pstApkt pointer to audio stream packet CNcomment:音频输入流指针 CNend
+    \param[out] pstAOut pointer to audio output CNcomment:音频输出流指针 CNend
+    \retval ::HA_ErrorNone  SUCCESS CNcomment:成功 CNend
+    \retval ::HI_HA_ERRORTYPE_E FAILURE CNcomment:失败 CNend
+    \see \n
+    N/A
+    */
+    HI_HA_ERRORTYPE_E (*EncodeFrame)(HI_VOID* hEncoder,
+                                     HI_HAENCODE_INPACKET_S* pstApkt,
+                                     HI_HAENCODE_OUTPUT_S* pstAOut);
+} HI_HA_ENCODE_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif /* #ifndef __HI_AUDIO_CODEC_H__ */
diff -uNr a/include/hi_common.h b/include/hi_common.h
--- a/include/hi_common.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_common.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2009-2019. All rights reserved.
+ * Description:
+ * Author: guoqingbo
+ * Create: 2009-12-15
+ */
+
+#ifndef __HI_COMMON_H__
+#define __HI_COMMON_H__
+
+#define CHIP_TYPE_hi3798mv200 1
+#define HI_DAC_CVBS 1
+
+#include "hi_system.h"
+#include "hi_memory.h"
+#include "hi_user_proc.h"
+
+/*******************************Structure declaration *****************************/
+/** @addtogroup     COMMON */
+/** @{ */ /** <!--  [COMMON] */
+
+typedef struct hiRECT_S
+{
+    HI_S32 s32X;
+    HI_S32 s32Y;
+    HI_S32 s32Width;
+    HI_S32 s32Height;
+} HI_RECT_S;
+
+typedef enum hiLAYER_ZORDER_E
+{
+    HI_LAYER_ZORDER_MOVETOP = 0,  /**<Move to the top*/ /**<CNcomment:  移到最顶部 */
+    HI_LAYER_ZORDER_MOVEUP,       /**<Move up*/ /**<CNcomment:  向上移到 */
+    HI_LAYER_ZORDER_MOVEBOTTOM,   /**<Move to the bottom*/ /**<CNcomment:  移到最底部 */
+    HI_LAYER_ZORDER_MOVEDOWN,     /**<Move down*/ /**<CNcomment:  向下移到 */
+    HI_LAYER_ZORDER_BUTT
+} HI_LAYER_ZORDER_E;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+#endif /* __HI_COMMON_H__ */
+
diff -uNr a/include/hi_debug.h b/include/hi_debug.h
--- a/include/hi_debug.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_debug.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,239 @@
+/******************************************************************************
+Copyright (C), 2005-2018, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_debug.h
+Version       : Initial Draft
+Author        : Hisilicon multimedia software group
+Created       : 2005/4/23
+Description   : Common debugging macro definition
+Function List :
+History       :
+******************************************************************************/
+#ifndef __HI_DEBUG_H__
+#define __HI_DEBUG_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#include "hi_type.h"
+#include "hi_module.h"
+
+#ifdef HI_LOG_SUPPORT
+#define HI_DEBUG
+
+#ifdef __KERNEL__
+    #define HI_PRINT printk
+    #define HI_PANIC printk
+#else
+#include <stdio.h>
+    #define HI_PRINT printf
+    #define HI_PANIC printf
+#endif
+#else
+#undef HI_DEBUG
+
+#define HI_PANIC(fmt...)    \
+    do { \
+    } while (0)
+
+#define HI_PRINT(fmt...)    \
+    do { \
+    } while (0)
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup     HI_DEBUG */
+/** @{ */  /** <!-- [HI_DEBUG] */
+
+
+/**Default level of the output debugging information*/
+/**CNcomment: 默认的调试信息输出级别*/
+#define HI_LOG_LEVEL_DEFAULT HI_LOG_LEVEL_ERROR
+
+/**Level of the output debugging information*/
+/**CNcomment: 调试信息输出级别*/
+typedef enum hiLOG_LEVEL_E
+{
+    HI_LOG_LEVEL_FATAL   = 0,     /**<Fatal error. It indicates that a critical problem occurs in the system. Therefore, you must pay attention to it.*/
+                                  /**<CNcomment: 致命错误, 此类错误需要特别关注，一般出现此类错误代表系统出现了重大问题 */
+    HI_LOG_LEVEL_ERROR   = 1,     /**<Major error. It indicates that a major problem occurs in the system and the system cannot run.*/
+                                  /**<CNcomment: 一般错误, 一般出现此类错误代表系统出现了比较大的问题，不能再正常运行 */
+    HI_LOG_LEVEL_WARNING = 2,     /**<Warning. It indicates that a minor problem occurs in the system, but the system still can run properly.*/
+                                  /**<CNcomment: 告警信息, 一般出现此类信息代表系统可能出现问题，但是还能继续运行 */
+    HI_LOG_LEVEL_INFO    = 3,     /**<Message. It is used to prompt users. Users can open the message when locating problems. It is recommended to disable this message in general.*/
+                                  /**<CNcomment: 提示信息, 一般是为提醒用户而输出，在定位问题的时候可以打开，一般情况下建议关闭 */
+    HI_LOG_LEVEL_DBG     = 4,     /**<Debug. It is used to prompt developers. Developers can open the message when locating problems. It is recommended to disable this message in general.*/
+                                  /**<CNcomment: 提示信息, 一般是为开发人员调试问题而设定的打印级别，一般情况下建议关闭 */
+    HI_LOG_LEVEL_TRACE   = 5,     /**<Trace. It is used to track the entry and exit of function when the interface is called.*/
+                                  /**<CNcomment: 提示信息，一般用于跟踪接口调用时函数的进入与退出 */
+    HI_LOG_LEVEL_BUTT
+} HI_LOG_LEVEL_E;
+
+/** @} */
+
+/**Just only for fatal level print.   */   /**CNcomment: 为了打印致命信息而制定的宏打印级别 */
+#define HI_TRACE_LEVEL_FATAL    (0)
+/**Just only for error level print.   */   /**CNcomment: 为了打印错误信息而制定的宏打印级别 */
+#define HI_TRACE_LEVEL_ERROR    (1)
+/**Just only for warning level print. */   /**CNcomment: 为了打印警告信息而制定的宏打印级别 */
+#define HI_TRACE_LEVEL_WARN     (2)
+/**Just only for info level print.    */   /**CNcomment: 为了打印信息级别而制定的宏打印级别 */
+#define HI_TRACE_LEVEL_INFO     (3)
+/**Just only for debug level print.   */   /**CNcomment: 为了打印调试信息而制定的宏打印级别 */
+#define HI_TRACE_LEVEL_DBG      (4)
+/**Just only for trace level print.   */   /**CNcomment: 为了打印接口跟踪信息而制定的宏打印级别 */
+#define HI_TRACE_LEVEL_TRACE    (5)
+
+#ifndef HI_LOG_LEVEL
+#define HI_LOG_LEVEL         (HI_TRACE_LEVEL_INFO)
+#endif
+
+
+/**Just only debug output,MUST BE NOT calling it. */
+/**CNcomment: 调试输出信息接口，不推荐直接调用此接口 */
+extern HI_VOID HI_LogOut(HI_U32 u32Level, HI_MOD_ID_E enModId,
+            HI_U8 *pFuncName, HI_U32 u32LineNum, const char *format, ...);
+
+#ifdef HI_DEBUG
+
+#define HI_TRACE(level, module_id, fmt...)                      \
+    do{                                                         \
+        HI_LogOut(level, module_id, (HI_U8*)__FUNCTION__,__LINE__,fmt);  \
+    }while(0)
+
+#define HI_ASSERT(expr)                                     \
+    do{                                                     \
+        if (!(expr)) {                                      \
+            HI_PANIC("\nASSERT failed at:\n  >File name: %s\n  >Function : %s\n  >Line No. : %d\n  >Condition: %s\n", \
+                __FILE__,__FUNCTION__, __LINE__, #expr);    \
+        }                                                   \
+    }while(0)
+
+
+#define HI_ASSERT_RET(expr)                                     \
+    do{                                                         \
+        if (!(expr)) {                                          \
+            HI_PRINT("\n<%s %d>: ASSERT Failure{" #expr "}\n",  \
+                          __FUNCTION__, __LINE__);              \
+            return HI_FAILURE;                                  \
+        }                                                       \
+    }while(0)
+
+#define HI_DEBUG_LOG(fmt...) \
+            HI_TRACE(HI_LOG_LEVEL_INFO, HI_ID_SYS, fmt)
+
+
+/**Supported for debug output to serial/network/u-disk. */
+/**CNcomment: 各个模块需要调用以下宏进行输出调试信息、可输出到串口、网口、U盘存储等 */
+/**Just only reserve the fatal level output. */
+/**CNcomment: 仅仅保留致命的调试信息 */
+#if (HI_LOG_LEVEL == HI_TRACE_LEVEL_FATAL)
+#define HI_FATAL_PRINT(module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_FATAL,    module_id, fmt)
+#define HI_ERR_PRINT(  module_id, fmt...)
+#define HI_WARN_PRINT( module_id, fmt...)
+#define HI_INFO_PRINT( module_id, fmt...)
+#define HI_DBG_PRINT(  module_id, fmt...)
+#define HI_TRACE_PRINT(module_id, fmt...)
+/**Just only reserve the fatal/error level output. */
+/**CNcomment: 仅仅保留致命的和错误级别的调试信息 */
+#elif (HI_LOG_LEVEL == HI_TRACE_LEVEL_ERROR)
+#define HI_FATAL_PRINT(module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_FATAL,    module_id, fmt)
+#define HI_ERR_PRINT(  module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_ERROR,    module_id, fmt)
+#define HI_WARN_PRINT( module_id, fmt...)
+#define HI_INFO_PRINT( module_id, fmt...)
+#define HI_DBG_PRINT(  module_id, fmt...)
+#define HI_TRACE_PRINT(module_id, fmt...)
+/**Just only reserve the fatal/error/warning level output. */
+/**CNcomment: 仅仅保留致命的、错误的、警告级别的调试信息 */
+#elif (HI_LOG_LEVEL == HI_TRACE_LEVEL_WARN)
+#define HI_FATAL_PRINT(module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_FATAL,    module_id, fmt)
+#define HI_ERR_PRINT(  module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_ERROR,    module_id, fmt)
+#define HI_WARN_PRINT( module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_WARN,     module_id, fmt)
+#define HI_INFO_PRINT( module_id, fmt...)
+#define HI_DBG_PRINT(  module_id, fmt...)
+#define HI_TRACE_PRINT(module_id, fmt...)
+/**Just only reserve the fatal/error/warning/info level output. */
+/**CNcomment: 仅仅保留致命的、错误的、警告和信息级别的调试信息 */
+#elif (HI_LOG_LEVEL == HI_TRACE_LEVEL_INFO)
+#define HI_FATAL_PRINT(module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_FATAL,    module_id, fmt)
+#define HI_ERR_PRINT(  module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_ERROR,    module_id, fmt)
+#define HI_WARN_PRINT( module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_WARN,     module_id, fmt)
+#define HI_INFO_PRINT( module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_INFO,     module_id, fmt)
+#define HI_DBG_PRINT(  module_id, fmt...)
+#define HI_TRACE_PRINT(module_id, fmt...)
+#else
+/**Reserve all the levels output. */
+/**CNcomment: 保留所有级别调试信息 */
+#define HI_FATAL_PRINT(module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_FATAL,    module_id, fmt)
+#define HI_ERR_PRINT(  module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_ERROR,    module_id, fmt)
+#define HI_WARN_PRINT( module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_WARN,     module_id, fmt)
+#define HI_INFO_PRINT( module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_INFO,     module_id, fmt)
+#define HI_DBG_PRINT(  module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_DBG,      module_id, fmt)
+#define HI_TRACE_PRINT(module_id, fmt...)   HI_TRACE(HI_TRACE_LEVEL_TRACE,    module_id, fmt)
+#endif
+
+#else
+#define HI_FATAL_PRINT(module_id, fmt...)
+#define HI_ERR_PRINT(  module_id, fmt...)
+#define HI_WARN_PRINT( module_id, fmt...)
+#define HI_INFO_PRINT( module_id, fmt...)
+#define HI_DBG_PRINT(  module_id, fmt...)
+#define HI_TRACE_PRINT(module_id, fmt...)
+
+#define HI_TRACE(level, module_id, fmt...)
+#define HI_ASSERT(expr)
+#define HI_ASSERT_RET(expr)
+#define HI_DEBUG_LOG(fmt...)
+#endif /* endif HI_DEBUG */
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+
+#define MKSTR(exp) # exp
+#define MKMARCOTOSTR(exp) MKSTR(exp)
+#define VERSION_STRING ("SDK_VERSION: [" MKMARCOTOSTR(SDK_VERSION) "] Build Time: [" __DATE__ ", " __TIME__ "]")
+#define USER_VERSION_STRING ("SDK_VERSION: [" MKMARCOTOSTR(SDK_VERSION) "]")
+
+/**Initialize a user module.*/
+/**CNcomment: 用户模块初始化 */
+#define HI_MODULE_DECLARE(MODULE_NAME)	\
+	static HI_U32 g_u32ModuleId = HI_INVALID_MODULE_ID;	\
+	static HI_S32 __attribute__((constructor(200))) init_module_id() \
+	{	 \
+		return HI_MODULE_RegisterByName(MODULE_NAME, &g_u32ModuleId); \
+	} \
+    static HI_S32 __attribute__((destructor(200))) deinit_module_id() \
+    { \
+        return HI_MODULE_UnRegister(g_u32ModuleId); \
+    }
+
+/**Defines a user module ID.*/
+/**CNcomment: 用户模块ID宏定义 */
+#define MODULE_ID (g_u32ModuleId)
+
+/**Defines the command of the user module different level log print.*/
+/**CNcomment: 用户模块日志输出宏定义 */
+#define HI_MODULE_FATAL(pszFormat...)  HI_FATAL_PRINT(MODULE_ID,pszFormat)
+#define HI_MODULE_ERROR(pszFormat...)  HI_ERR_PRINT(MODULE_ID,pszFormat)
+#define HI_MODULE_WARN(pszFormat...)   HI_WARN_PRINT(MODULE_ID,pszFormat)
+#define HI_MODULE_DEBUG(pszFormat...)  HI_DBG_PRINT(MODULE_ID,pszFormat)
+#define HI_MODULE_INFO(pszFormat...)   HI_INFO_PRINT(MODULE_ID,pszFormat)
+
+/**Defines the memory allocate and free command used by user module.*/
+/**CNcomment: 用户模块内存分配宏定义 */
+#define HI_MODULE_MALLOC(u32Size)               HI_MEM_Malloc(MODULE_ID, u32Size)
+#define HI_MODULE_FREE(pMemAddr)                HI_MEM_Free(MODULE_ID, pMemAddr)
+#define HI_MODULE_CALLOC(u32MemBlock, u32Size)  HI_MEM_Calloc(MODULE_ID, u32MemBlock, u32Size)
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_DEBUG_H__ */
+
diff -uNr a/include/hi_error_mpi.h b/include/hi_error_mpi.h
--- a/include/hi_error_mpi.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_error_mpi.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,936 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_error_mpi.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2008/04/24
+  Description   : error code of MPI
+  History       :
+  1.Date        : 2008/04/24
+    Author      :
+    Modification: Created file
+
+******************************************************************************/
+/**
+\file
+\brief Describes the information about common error codes. CNcomment: 提供公共错误码的相关信息
+*/
+/* add include here */
+#ifndef __HI_UNF_MPI_ERRORCODE_H__
+#define __HI_UNF_MPI_ERRORCODE_H__
+
+#include "hi_module.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"
+{
+#endif
+#endif /* End of #ifdef __cplusplus */
+
+/***************************** Macro Definition ******************************/
+/** \addtogroup      MSP_ERRCODE */
+/** @{ */  /** <!-- 【MSP_ERRCODE】 */
+
+#define HI_ERRCODE_DEF(moduleid, errid) (HI_U32)(0x80000000 | ((moduleid) << 16)  | (errid))
+
+#define HI_ERR_DISP_DEV_NOT_EXIST           (HI_S32)(0x80100001)
+#define HI_ERR_DISP_NOT_DEV_FILE            (HI_S32)(0x80100002)
+#define HI_ERR_DISP_DEV_OPEN_ERR            (HI_S32)(0x80100003)
+#define HI_ERR_DISP_DEV_CLOSE_ERR           (HI_S32)(0x80100004)
+#define HI_ERR_DISP_NULL_PTR                (HI_S32)(0x80100005)
+#define HI_ERR_DISP_NO_INIT                 (HI_S32)(0x80100006)
+#define HI_ERR_DISP_INVALID_PARA            (HI_S32)(0x80100007)
+#define HI_ERR_DISP_CREATE_ERR              (HI_S32)(0x80100008)
+#define HI_ERR_DISP_DESTROY_ERR             (HI_S32)(0x80100009)
+#define HI_ERR_DISP_NOT_EXIST               (HI_S32)(0x8010000A)
+#define HI_ERR_DISP_INVALID_OPT             (HI_S32)(0x8010000B)
+#define HI_ERR_DISP_NOT_SUPPORT_FMT         (HI_S32)(0x8010000C)
+#define HI_ERR_DISP_NOT_OPEN                (HI_S32)(0x8010000D)
+#define HI_ERR_DISP_SRC_UNAVAILABLE         (HI_S32)(0x8010000E)
+#define HI_ERR_DISP_NOT_SUPPORT             (HI_S32)(0x8010000F)
+#define HI_ERR_DISP_MALLOC_FAILED           (HI_S32)(0x80100010)
+#define HI_ERR_DISP_UNKNOWN                 (HI_S32)(0x801000FF)
+#define HI_ERR_DISP_TIMEOUT                 (HI_S32)(0x801000F1)
+#define HI_ERR_DISP_MALLOC_MAP_ERR          (HI_S32)(0x801000F2)
+
+
+
+#define HI_ERR_VO_DEV_NOT_EXIST             (HI_S32)(0x80110001)
+#define HI_ERR_VO_NOT_DEV_FILE              (HI_S32)(0x80110002)
+#define HI_ERR_VO_DEV_OPEN_ERR              (HI_S32)(0x80110003)
+#define HI_ERR_VO_DEV_CLOSE_ERR             (HI_S32)(0x80110004)
+#define HI_ERR_VO_NULL_PTR                  (HI_S32)(0x80110005)
+#define HI_ERR_VO_NO_INIT                   (HI_S32)(0x80110006)
+#define HI_ERR_VO_INVALID_PARA              (HI_S32)(0x80110007)
+#define HI_ERR_VO_CREATE_ERR                (HI_S32)(0x80110008)
+#define HI_ERR_VO_DESTROY_ERR               (HI_S32)(0x80110009)
+#define HI_ERR_VO_NOT_EXIST                 (HI_S32)(0x80110010)
+#define HI_ERR_VO_INVALID_OPT               (HI_S32)(0x80110030)
+#define HI_ERR_VO_WIN_NOT_EXIST             (HI_S32)(0x80110040)
+#define HI_ERR_VO_WIN_NOT_ENABLE            (HI_S32)(0x80110041)
+#define HI_ERR_VO_WIN_UNSUPPORT             (HI_S32)(0x80110042)
+#define HI_ERR_VO_TIMEOUT                   (HI_S32)(0x80110043)
+#define HI_ERR_VO_OPERATION_DENIED          (HI_S32)(0x80110044)
+#define HI_ERR_VO_SLAVE_WIN_LOST            (HI_S32)(0x80110045)
+#define HI_ERR_VO_FRAME_INFO_ERROR          (HI_S32)(0x80110046)
+#define HI_ERR_VO_FRAME_RELEASE_FAILED      (HI_S32)(0x80110047)
+#define HI_ERR_VO_NO_FRAME_TO_RELEASE       (HI_S32)(0x80110048)
+#define HI_ERR_VO_ADD_PROC_ERR              (HI_S32)(0x80110049)
+#define HI_ERR_VO_MALLOC_FAILED             (HI_S32)(0x80110050)
+#define HI_ERR_VO_DEPEND_DEVICE_NOT_READY   (HI_S32)(0x80110051)
+#define HI_ERR_VO_BUFQUE_FULL               (HI_S32)(0x80110052)
+#define HI_ERR_VO_BUFQUE_EMPTY              (HI_S32)(0x80110053)
+#define HI_ERR_VO_NO_SOURCE                 (HI_S32)(0x80110054)
+
+
+#define HI_ERR_VDEC_NOT_OPEN                (HI_S32)(0x80120001)
+#define HI_ERR_VDEC_INVALID_PARA            (HI_S32)(0x80120002)
+#define HI_ERR_VDEC_NULL_PTR                (HI_S32)(0x80120003)
+#define HI_ERR_VDEC_NOT_SUPPORT             (HI_S32)(0x80120004)
+#define HI_ERR_VDEC_TIMEOUT                 (HI_S32)(0x80120005)
+#define HI_ERR_VDEC_INPUT_CORRUPT           (HI_S32)(0x80120006)
+#define HI_ERR_VDEC_NO_ENOUGH_DATA          (HI_S32)(0x80120007)
+#define HI_ERR_VDEC_UNKNOWN                 (HI_S32)(0x80120008)
+#define HI_ERR_VDEC_MALLOC_FAILED           (HI_S32)(0x80120044)
+#define HI_ERR_VDEC_CREATECH_FAILED         (HI_S32)(0x80120047)
+#define HI_ERR_VDEC_DESTROYCH_FAILED        (HI_S32)(0x80120048)
+#define HI_ERR_VDEC_INVALID_CHANID          (HI_S32)(0x80120049)
+#define HI_ERR_VDEC_RESETCH_FAILED          (HI_S32)(0x80120050)
+#define HI_ERR_VDEC_SETATTR_FAILED          (HI_S32)(0x80120051)
+#define HI_ERR_VDEC_GETATTR_FAILED          (HI_S32)(0x80120052)
+#define HI_ERR_VDEC_SENDSTREAM_FAILED       (HI_S32)(0x80120053)
+#define HI_ERR_VDEC_RECEIVE_FAILED          (HI_S32)(0x80120054)
+#define HI_ERR_VDEC_DISCARD_PRIDATA         (HI_S32)(0x80120055)
+#define HI_ERR_VDEC_RELEASEFRAME_FAILED     (HI_S32)(0x80120056)
+#define HI_ERR_VDEC_RELEASEPRI_FAILED       (HI_S32)(0x80120057)
+#define HI_ERR_VDEC_NOT_INIT                (HI_S32)(0x80120059)
+#define HI_ERR_VDEC_USERCOPY_ERR            (HI_S32)(0x8012005A)
+#define HI_ERR_VDEC_LIST_EMPTY              (HI_S32)(0x8012005B)
+#define HI_ERR_VDEC_INVALID_STATE           (HI_S32)(0x8012005C)
+#define HI_ERR_VDEC_NOT_ENABLE              (HI_S32)(0x80120060)
+#define HI_ERR_VDEC_BUFFER_NOT_ATTACH       (HI_S32)(0x80120061)
+#define HI_ERR_VDEC_BUFFER_REQUIRE_INVALID  (HI_S32)(0x80120062)
+#define HI_ERR_VDEC_BUFFER_ATTACHED         (HI_S32)(0x80120063)
+#define HI_ERR_VDEC_BUFFER_FULL             (HI_S32)(0x80120064)
+
+#define HI_ERR_AO_NOT_INIT                  (HI_S32)(0x80130001)
+#define HI_ERR_AO_INVALID_PARA              (HI_S32)(0x80130002)
+#define HI_ERR_AO_NULL_PTR                  (HI_S32)(0x80130003)
+#define HI_ERR_AO_INVALID_ID                (HI_S32)(0x80130004)
+#define HI_ERR_AO_USED                      (HI_S32)(0x80130005)
+#define HI_ERR_AO_NOTSUPPORT                (HI_S32)(0x80130006)
+#define HI_ERR_AO_USERCOPY_ERR              (HI_S32)(0x80130007)
+#define HI_ERR_AO_SOUND_NOT_OPEN            (HI_S32)(0x80130008)
+#define HI_ERR_AO_INTR                      (HI_S32)(0x80130009)
+#define HI_ERR_AO_DEV_NOT_OPEN              (HI_S32)(0x80130041)
+#define HI_ERR_AO_CREATE_FAIL               (HI_S32)(0x80130042)
+#define HI_ERR_AO_OUT_BUF_FULL              (HI_S32)(0x80130046)
+#define HI_ERR_AO_INVALID_OUTFRAME          (HI_S32)(0x80130047)
+#define HI_ERR_AO_DATASIZE_EXCEED           (HI_S32)(0x80130048)
+#define HI_ERR_AO_INVALID_INFRAME           (HI_S32)(0x80130049)
+#define HI_ERR_AO_INBUF_EMPTY               (HI_S32)(0x8013004a)
+#define HI_ERR_AO_INVALID_PORT              (HI_S32)(0x8013004c)
+#define HI_ERR_AO_SENDMUTE                  (HI_S32)(0x8013004d)
+#define HI_ERR_AO_VIRTUALBUF_EMPTY          (HI_S32)(0x8013004e)
+#define HI_ERR_AO_PAUSE_STATE               (HI_S32)(0x8013004f)
+#define HI_ERR_AO_OUTPORT_NOT_ATTATCH       (HI_S32)(0x80130050)
+#define HI_ERR_AO_CAST_TIMEOUT              (HI_S32)(0x80130051)
+#define HI_ERR_AO_MALLOC_FAILED             (HI_S32)(0x80130052)
+#define HI_ERR_AO_DEVICE_BUSY               (HI_S32)(0x80130053)
+#define HI_ERR_AO_NOT_ACTIVED               (HI_S32)(0x80130054)
+
+#define HI_ERR_ADEC_DEV_NOT_OPEN            (HI_S32)(0x80140001)
+#define HI_ERR_ADEC_INVALID_PARA            (HI_S32)(0x80140002)
+#define HI_ERR_ADEC_NULL_PTR                (HI_S32)(0x80140003)
+#define HI_ERR_ADEC_IN_BUF_FULL             (HI_S32)(0x80140004)
+#define HI_ERR_ADEC_OUT_BUF_EMPTY           (HI_S32)(0x80140005)
+#define HI_ERR_ADEC_OUT_VOLUME              (HI_S32)(0x80140006)
+#define HI_ERR_ADEC_IN_PTSBUF_FULL          (HI_S32)(0x80140007)
+
+#define HI_ERR_DMX_NOT_INIT                 (HI_S32)(0x80150001)
+#define HI_ERR_DMX_INVALID_PARA             (HI_S32)(0x80150002)
+#define HI_ERR_DMX_NULL_PTR                 (HI_S32)(0x80150003)
+#define HI_ERR_DMX_NOT_SUPPORT              (HI_S32)(0x80150004)
+#define HI_ERR_DMX_TIMEOUT                  (HI_S32)(0x80150005)
+#define HI_ERR_DMX_ALLOC_MEM_FAILED         (HI_S32)(0x80150006)
+#define HI_ERR_DMX_BUSY                     (HI_S32)(0x80150007)
+#define HI_ERR_DMX_NOATTACH_PORT            (HI_S32)(0x80150008)
+#define HI_ERR_DMX_ATTACHED_PORT            (HI_S32)(0x80150009)
+#define HI_ERR_DMX_RECREAT_TSBUFFER         (HI_S32)(0x8015000a)
+#define HI_ERR_DMX_UNMATCH_CHAN             (HI_S32)(0x8015000b)
+#define HI_ERR_DMX_NOFREE_CHAN              (HI_S32)(0x8015000c)
+#define HI_ERR_DMX_OPENING_CHAN             (HI_S32)(0x8015000d)
+#define HI_ERR_DMX_NOT_OPEN_CHAN            (HI_S32)(0x8015000e)
+#define HI_ERR_DMX_ATTACHED_FILTER          (HI_S32)(0x8015000f)
+#define HI_ERR_DMX_NOATTACH_FILTER          (HI_S32)(0x80150010)
+#define HI_ERR_DMX_UNMATCH_FILTER           (HI_S32)(0x80150011)
+#define HI_ERR_DMX_NOFREE_FILTER            (HI_S32)(0x80150012)
+#define HI_ERR_DMX_NOATTACH_KEY             (HI_S32)(0x80150013)
+#define HI_ERR_DMX_UNMATCH_KEY              (HI_S32)(0x80150014)
+#define HI_ERR_DMX_NOFREE_KEY               (HI_S32)(0x80150015)
+#define HI_ERR_DMX_ATTACHED_KEY             (HI_S32)(0x80150016)
+#define HI_ERR_DMX_NOAVAILABLE_BUF          (HI_S32)(0x80150017)
+#define HI_ERR_DMX_NOAVAILABLE_DATA         (HI_S32)(0x80150018)
+#define HI_ERR_DMX_REACQUIRE_BUF            (HI_S32)(0x80150019)
+#define HI_ERR_DMX_OCCUPIED_PID             (HI_S32)(0x80150020)
+#define HI_ERR_DMX_MMAP_FAILED              (HI_S32)(0x80150021)
+#define HI_ERR_DMX_MUNMAP_FAILED            (HI_S32)(0x80150022)
+#define HI_ERR_DMX_EMPTY_BUFFER             (HI_S32)(0x80150023)
+#define HI_ERR_DMX_OVERFLOW_BUFFER          (HI_S32)(0x80150024)
+#define HI_ERR_DMX_NOT_START_REC_CHAN       (HI_S32)(0x80150030)
+#define HI_ERR_DMX_STARTING_REC_CHAN        (HI_S32)(0x80150031)
+#define HI_ERR_DMX_NOAVAILABLE_EXCLUDEPID   (HI_S32)(0x80150032)
+#define HI_ERR_DMX_NOAVAILABLE_TAG_PORT     (HI_S32)(0x80150033)
+#define HI_ERR_DMX_NOT_SUPPORT_TAGDEAL      (HI_S32)(0x80150034)
+#define HI_ERR_DMX_REC_BUFNOTMATCH          (HI_S32)(0x80150035)
+#define HI_ERR_DMX_INVALID_REC_CHAN         (HI_S32)(0x80150036)
+#define HI_ERR_DMX_BUSY_CHAN                (HI_S32)(0x80150037)
+#define HI_ERR_DMX_BUSY_FILTER              (HI_S32)(0x80150038)
+#define HI_ERR_DMX_BUSY_KEY                 (HI_S32)(0x80150039)
+#define HI_ERR_DMX_BUSY_REC                 (HI_S32)(0x8015003A)
+
+#define HI_ERR_TSIO_NOT_INIT                (HI_S32)(0x80160001)
+#define HI_ERR_TSIO_INVALID_PARA            (HI_S32)(0x80160002)
+#define HI_ERR_TSIO_NULL_PTR                (HI_S32)(0x80160003)
+#define HI_ERR_TSIO_NO_MEMORY               (HI_S32)(0x80160004)
+#define HI_ERR_TSIO_NO_RESOURCE             (HI_S32)(0x80160005)
+#define HI_ERR_TSIO_BUSY                    (HI_S32)(0x80160006)
+#define HI_ERR_TSIO_NOT_READY               (HI_S32)(0x80160007)
+#define HI_ERR_TSIO_NOAVAILABLE_BUF         (HI_S32)(0x80160008)
+#define HI_ERR_TSIO_NOAVAILABLE_DATA        (HI_S32)(0x80160009)
+#define HI_ERR_TSIO_INTR                    (HI_S32)(0x8016000a)
+#define HI_ERR_TSIO_TIMEOUT                 (HI_S32)(0x8016000b)
+#define HI_ERR_TSIO_NOT_SUPPORT             (HI_S32)(0x8016000c)
+#define HI_ERR_TSIO_CC_ERROR                (HI_S32)(0x8016000d)
+#define HI_ERR_TSIO_DEMUX_NOT_READY         (HI_S32)(0x8016000e)
+#define HI_ERR_TSIO_STALED                  (HI_S32)(0x8016000f)
+
+#define HI_ERR_VI_NO_INIT                   (HI_S32)(0x801A0001)
+#define HI_ERR_VI_INVALID_PARA              (HI_S32)(0x801A0002)
+#define HI_ERR_VI_NULL_PTR                  (HI_S32)(0x801A0003)
+#define HI_ERR_VI_INVALID_CHNID             (HI_S32)(0x801A0004)
+#define HI_ERR_VI_DEV_OPENED                (HI_S32)(0x801A0005)
+#define HI_ERR_VI_DEV_NOT_EXIST             (HI_S32)(0x801A0006)
+#define HI_ERR_VI_NOT_DEV_FILE              (HI_S32)(0x801A0007)
+#define HI_ERR_VI_NO_CHN_LEFT               (HI_S32)(0x801A0008)
+#define HI_ERR_VI_BUSY                      (HI_S32)(0x801A0009)
+#define HI_ERR_VI_CHN_NOT_EXIST             (HI_S32)(0x801A000A)
+#define HI_ERR_VI_CHN_INVALID_OPT           (HI_S32)(0x801A000B)
+#define HI_ERR_VI_CHN_INVALID_STAT          (HI_S32)(0x801A000C)
+#define HI_ERR_VI_CHN_INIT_BUF_ERR          (HI_S32)(0x801A000D)
+#define HI_ERR_VI_BUF_EMPTY                 (HI_S32)(0x801A000E)
+#define HI_ERR_VI_BUF_FULL                  (HI_S32)(0x801A000F)
+#define HI_ERR_VI_NOT_SUPPORT               (HI_S32)(0x801A0010)
+
+#define HI_ERR_AI_NOT_INIT                  (HI_S32)(0x801B0001)
+#define HI_ERR_AI_INVALID_PARA              (HI_S32)(0x801B0002)
+#define HI_ERR_AI_NULL_PTR                  (HI_S32)(0x801B0003)
+#define HI_ERR_AI_INVALID_ID                (HI_S32)(0x801B0004)
+#define HI_ERR_AI_DEV_OPENED                (HI_S32)(0x801B0005)
+#define HI_ERR_AI_NOTSUPPORT                (HI_S32)(0x801B0006)
+#define HI_ERR_AI_USERCOPY                  (HI_S32)(0x801B0007)
+#define HI_ERR_AI_BUFEMPTY                  (HI_S32)(0x801B0008)
+
+
+#define HI_ERR_AENC_DEV_NOT_OPEN            (HI_S32)(0x801C0001)
+#define HI_ERR_AENC_INVALID_PARA            (HI_S32)(0x801C0002)
+#define HI_ERR_AENC_NULL_PTR                (HI_S32)(0x801C0003)
+#define HI_ERR_AENC_OUT_BUF_FULL            (HI_S32)(0x801C0006)
+#define HI_ERR_AENC_INVALID_OUTFRAME        (HI_S32)(0x801C0007)
+#define HI_ERR_AENC_DATASIZE_EXCEED         (HI_S32)(0x801C0008)
+#define HI_ERR_AENC_CREATECH_FAIL           (HI_S32)(0x801C0009)
+#define HI_ERR_AENC_IN_BUF_FULL             (HI_S32)(0x801C000a)
+#define HI_ERR_AENC_CH_NOT_OPEN             (HI_S32)(0x801C000b)
+#define HI_ERR_AENC_OUT_BUF_EMPTY           (HI_S32)(0x801C000c)
+#define HI_ERR_AENC_OUT_BUF_BAD             (HI_S32)(0x801C000d)
+#define HI_ERR_AENC_IN_BUF_UNEMPTY          (HI_S32)(0x801C000e)
+#define HI_ERR_AENC_CH_NOT_SUPPORT          (HI_S32)(0x801C000f)
+
+
+#define HI_ERR_VENC_NO_INIT                 (HI_S32)(0x801D0001)
+#define HI_ERR_VENC_INVALID_PARA            (HI_S32)(0x801D0002)
+#define HI_ERR_VENC_NULL_PTR                (HI_S32)(0x801D0003)
+#define HI_ERR_VENC_INVALID_CHNID           (HI_S32)(0x801D0004)
+#define HI_ERR_VENC_DEV_OPENED              (HI_S32)(0x801D0005)
+#define HI_ERR_VENC_DEV_NOT_EXIST           (HI_S32)(0x801D0006)
+#define HI_ERR_VENC_NOT_DEV_FILE            (HI_S32)(0x801D0007)
+#define HI_ERR_VENC_CREATE_ERR              (HI_S32)(0x801D0008)
+#define HI_ERR_VENC_DESTROY_ERR             (HI_S32)(0x801D0009)
+#define HI_ERR_VENC_CHN_NOT_EXIST           (HI_S32)(0x801D000A)
+#define HI_ERR_VENC_CHN_INVALID_STAT        (HI_S32)(0x801D000B)
+#define HI_ERR_VENC_CHN_NO_ATTACH           (HI_S32)(0x801D000C)
+#define HI_ERR_VENC_BUF_EMPTY               (HI_S32)(0x801D000D)
+#define HI_ERR_VENC_CHN_RELEASE_ERR         (HI_S32)(0x801D000E)
+#define HI_ERR_VENC_NOT_SUPPORT             (HI_S32)(0x801D000F)
+
+#define HI_ERR_SIO_AI_INVALID_DEVID         (HI_S32)(0x801E0001)
+#define HI_ERR_SIO_AI_INVALID_CHNID         (HI_S32)(0x801E0002)
+#define HI_ERR_SIO_AI_ILLEGAL_PARAM         (HI_S32)(0x801E0003)
+#define HI_ERR_SIO_AI_NULL_PTR              (HI_S32)(0x801E0004)
+#define HI_ERR_SIO_AI_NOT_CONFIG            (HI_S32)(0x801E0005)
+#define HI_ERR_SIO_AI_NOT_SURPPORT          (HI_S32)(0x801E0006)
+#define HI_ERR_SIO_AI_NOT_PERM              (HI_S32)(0x801E0007)
+#define HI_ERR_SIO_AI_NOT_ENABLED           (HI_S32)(0x801E0008)
+#define HI_ERR_SIO_AI_NOMEM                 (HI_S32)(0x801E0009)
+#define HI_ERR_SIO_AI_NOBUF                 (HI_S32)(0x801E000A)
+#define HI_ERR_SIO_AI_BUF_EMPTY             (HI_S32)(0x801E000B)
+#define HI_ERR_SIO_AI_BUF_FULL              (HI_S32)(0x801E000C)
+#define HI_ERR_SIO_AI_SYS_NOTREADY          (HI_S32)(0x801E000D)
+#define HI_ERR_SIO_AI_BUSY                  (HI_S32)(0x801E000E)
+
+#define HI_ERR_SIO_AO_INVALID_DEVID         (HI_S32)(0x801F0001)
+#define HI_ERR_SIO_AO_INVALID_CHNID         (HI_S32)(0x801F0002)
+#define HI_ERR_SIO_AO_ILLEGAL_PARAM         (HI_S32)(0x801F0003)
+#define HI_ERR_SIO_AO_NULL_PTR              (HI_S32)(0x801F0004)
+#define HI_ERR_SIO_AO_NOT_CONFIG            (HI_S32)(0x801F0005)
+#define HI_ERR_SIO_AO_NOT_SURPPORT          (HI_S32)(0x801F0006)
+#define HI_ERR_SIO_AO_NOT_PERM              (HI_S32)(0x801F0007)
+#define HI_ERR_SIO_AO_NOT_ENABLED           (HI_S32)(0x801F0008)
+#define HI_ERR_SIO_AO_NOMEM                 (HI_S32)(0x801F0009)
+#define HI_ERR_SIO_AO_NOBUF                 (HI_S32)(0x801F000A)
+#define HI_ERR_SIO_AO_BUF_EMPTY             (HI_S32)(0x801F000B)
+#define HI_ERR_SIO_AO_BUF_FULL              (HI_S32)(0x801F000C)
+#define HI_ERR_SIO_AO_SYS_NOTREADY          (HI_S32)(0x801F000D)
+#define HI_ERR_SIO_AO_BUSY                  (HI_S32)(0x801F000E)
+
+#define HI_ERR_AFLT_NOT_INIT                (HI_S32)(0x80200001)
+#define HI_ERR_AFLT_INVALID_PARA            (HI_S32)(0x80200002)
+#define HI_ERR_AFLT_NULL_PTR                (HI_S32)(0x80200003)
+#define HI_ERR_AFLT_INVALID_HANDLE          (HI_S32)(0x80200004)
+#define HI_ERR_AFLT_CHN_NOT_OPEN            (HI_S32)(0x80200005)
+#define HI_ERR_AFLT_INBUF_FULL              (HI_S32)(0x80200006)
+#define HI_ERR_AFLT_OUTBUF_EMPTY            (HI_S32)(0x80200007)
+#define HI_ERR_AFLT_BUFEMPTY                (HI_S32)(0x80200008)
+
+#define HI_ERR_HDMI_NOT_INIT                (HI_S32)(0x80210001)
+#define HI_ERR_HDMI_INVALID_PARA            (HI_S32)(0x80210002)
+#define HI_ERR_HDMI_NUL_PTR                 (HI_S32)(0x80210003)
+#define HI_ERR_HDMI_DEV_NOT_OPEN            (HI_S32)(0x80210004)
+#define HI_ERR_HDMI_DEV_NOT_CONNECT         (HI_S32)(0x80210005)
+#define HI_ERR_HDMI_READ_SINK_FAILED        (HI_S32)(0x80210006)
+#define HI_ERR_HDMI_INIT_ALREADY            (HI_S32)(0x80210007)
+#define HI_ERR_HDMI_CALLBACK_ALREADY        (HI_S32)(0x80210008)
+#define HI_ERR_HDMI_INVALID_CALLBACK        (HI_S32)(0x80210009)
+#define HI_ERR_HDMI_FEATURE_NO_SUPPORT      (HI_S32)(0x8021000a)
+#define HI_ERR_HDMI_BUS_BUSY                (HI_S32)(0x8021000b)
+
+#define HI_ERR_PVR_NOT_INIT                 (HI_S32)(0x80300001)
+#define HI_ERR_PVR_INVALID_PARA             (HI_S32)(0x80300002)
+#define HI_ERR_PVR_NUL_PTR                  (HI_S32)(0x80300003)
+#define HI_ERR_PVR_CHN_NOT_INIT             (HI_S32)(0x80300004)
+#define HI_ERR_PVR_INVALID_CHNID            (HI_S32)(0x80300005)
+#define HI_ERR_PVR_NO_CHN_LEFT              (HI_S32)(0x80300006)
+#define HI_ERR_PVR_ALREADY                  (HI_S32)(0x80300007)
+#define HI_ERR_PVR_BUSY                     (HI_S32)(0x80300008)
+#define HI_ERR_PVR_NO_MEM                   (HI_S32)(0x80300009)
+#define HI_ERR_PVR_NOT_SUPPORT              (HI_S32)(0x8030000A)
+#define HI_ERR_PVR_RETRY                    (HI_S32)(0x8030000B)
+#define HI_ERR_PVR_FILE_EXIST               (HI_S32)(0x80300011)
+#define HI_ERR_PVR_FILE_NOT_EXIST           (HI_S32)(0x80300012)
+#define HI_ERR_PVR_FILE_CANT_OPEN           (HI_S32)(0x80300013)
+#define HI_ERR_PVR_FILE_CANT_CLOSE          (HI_S32)(0x80300014)
+#define HI_ERR_PVR_FILE_CANT_SEEK           (HI_S32)(0x80300015)
+#define HI_ERR_PVR_FILE_CANT_WRITE          (HI_S32)(0x80300016)
+#define HI_ERR_PVR_FILE_CANT_READ           (HI_S32)(0x80300017)
+#define HI_ERR_PVR_FILE_INVALID_FNAME       (HI_S32)(0x80300018)
+#define HI_ERR_PVR_FILE_TILL_START          (HI_S32)(0x80300019)
+#define HI_ERR_PVR_FILE_TILL_END            (HI_S32)(0x8030001A)
+#define HI_ERR_PVR_FILE_DISC_FULL           (HI_S32)(0x8030001B)
+#define HI_ERR_PVR_REC_INVALID_STATE        (HI_S32)(0x80300021)
+#define HI_ERR_PVR_REC_INVALID_DMXID        (HI_S32)(0x80300022)
+#define HI_ERR_PVR_REC_INVALID_FSIZE        (HI_S32)(0x80300023)
+#define HI_ERR_PVR_REC_INVALID_UDSIZE       (HI_S32)(0x80300024)
+#define HI_ERR_PVR_PLAY_INVALID_STATE       (HI_S32)(0x80300031)
+#define HI_ERR_PVR_PLAY_INVALID_DMXID       (HI_S32)(0x80300032)
+#define HI_ERR_PVR_PLAY_INVALID_TSBUFFER    (HI_S32)(0x80300033)
+#define HI_ERR_PVR_PLAY_INVALID_PACKETBUFFER (HI_S32)(0x80300034)
+#define HI_ERR_PVR_PLAY_INDEX_BEYOND_TS     (HI_S32)(0x80300035)
+#define HI_ERR_PVR_SEC_INIT_FAILED          (HI_S32)(0x80300036)
+#define HI_ERR_PVR_SEC_RUNTIME_ERROR        (HI_S32)(0x80300037)
+
+#define HI_ERR_PVR_INDEX_CANT_MKIDX         (HI_S32)(0x80300041)
+#define HI_ERR_PVR_INDEX_FORMAT_ERR         (HI_S32)(0x80300042)
+#define HI_ERR_PVR_INDEX_DATA_ERR           (HI_S32)(0x80300043)
+#define HI_ERR_PVR_INDEX_INVALID_ENTRY      (HI_S32)(0x80300044)
+#define HI_ERR_PVR_INTF_EVENT_INVAL         (HI_S32)(0x80300051)
+#define HI_ERR_PVR_INTF_EVENT_NOREG         (HI_S32)(0x80300052)
+#define HI_ERR_ADVCA_PVR_KEY_CHECK_FAILED   (HI_S32)(0x80300053)
+#define HI_ERR_ADVCA_PVR_CMAC_CHECK_FAILED  (HI_S32)(0x80300054)
+
+#define HI_ERR_AVPLAY_DEV_NOT_EXIST         (HI_S32)(0x80310001)
+#define HI_ERR_AVPLAY_NOT_DEV_FILE          (HI_S32)(0x80310002)
+#define HI_ERR_AVPLAY_DEV_OPEN_ERR          (HI_S32)(0x80310003)
+#define HI_ERR_AVPLAY_DEV_CLOSE_ERR         (HI_S32)(0x80310004)
+#define HI_ERR_AVPLAY_NULL_PTR              (HI_S32)(0x80310005)
+#define HI_ERR_AVPLAY_DEV_NO_INIT           (HI_S32)(0x80310006)
+#define HI_ERR_AVPLAY_INVALID_PARA          (HI_S32)(0x80310007)
+#define HI_ERR_AVPLAY_CREATE_ERR            (HI_S32)(0x80310008)
+#define HI_ERR_AVPLAY_DESTROY_ERR           (HI_S32)(0x80310009)
+#define HI_ERR_AVPLAY_INVALID_OPT           (HI_S32)(0x8031000A)
+#define HI_ERR_AVPLAY_NOT_SUPPORT           (HI_S32)(0x8031000B)
+
+#define HI_ERR_SYNC_DEV_NOT_EXIST           (HI_S32)(0x80320001)
+#define HI_ERR_SYNC_NOT_DEV_FILE            (HI_S32)(0x80320002)
+#define HI_ERR_SYNC_DEV_OPEN_ERR            (HI_S32)(0x80320003)
+#define HI_ERR_SYNC_DEV_CLOSE_ERR           (HI_S32)(0x80320004)
+#define HI_ERR_SYNC_NULL_PTR                (HI_S32)(0x80320005)
+#define HI_ERR_SYNC_DEV_NO_INIT             (HI_S32)(0x80320006)
+#define HI_ERR_SYNC_INVALID_PARA            (HI_S32)(0x80320007)
+#define HI_ERR_SYNC_CREATE_ERR              (HI_S32)(0x80320008)
+#define HI_ERR_SYNC_DESTROY_ERR             (HI_S32)(0x80320009)
+#define HI_ERR_SYNC_INVALID_OPT             (HI_S32)(0x8032000A)
+
+#define HI_ERR_MCE_DEV_NOT_EXIST            (HI_S32)(0x80330001)
+#define HI_ERR_MCE_NOT_DEVICE               (HI_S32)(0x80330002)
+#define HI_ERR_MCE_DEV_OPEN_ERR             (HI_S32)(0x80330003)
+#define HI_ERR_MCE_DEV_NOT_INIT             (HI_S32)(0x80330004)
+#define HI_ERR_MCE_PTR_NULL                 (HI_S32)(0x80330005)
+#define HI_ERR_MCE_PARAM_INVALID            (HI_S32)(0x80330006)
+#define HI_ERR_MCE_GET_MTDINFO_ERR          (HI_S32)(0x80330007)
+#define HI_ERR_MCE_MTD_OPEN                 (HI_S32)(0x80330008)
+#define HI_ERR_MCE_MTD_CLOSE                (HI_S32)(0x80330009)
+#define HI_ERR_MCE_MTD_READ                 (HI_S32)(0x80330010)
+#define HI_ERR_MCE_MTD_WRITE                (HI_S32)(0x80330011)
+#define HI_ERR_MCE_MTD_GETINFO              (HI_S32)(0x80330012)
+#define HI_ERR_MCE_MTD_ERASE                (HI_S32)(0x80330013)
+#define HI_ERR_MCE_MEM_ALLC                 (HI_S32)(0x80330014)
+#define HI_ERR_MCE_INVALID_OPT              (HI_S32)(0x80330015)
+
+#define HI_ERR_VP_PTR_NULL                  (HI_S32)(0x80340001)
+#define HI_ERR_VP_NOT_INIT                  (HI_S32)(0x80340002)
+#define HI_ERR_VP_DEV_NOT_EXIST             (HI_S32)(0x80340003)
+#define HI_ERR_VP_NOT_DEV_FILE              (HI_S32)(0x80340004)
+#define HI_ERR_VP_DEV_OPEN_ERR              (HI_S32)(0x80340005)
+#define HI_ERR_VP_INVALID_PARA              (HI_S32)(0x80340006)
+#define HI_ERR_VP_NOT_SUPPORT               (HI_S32)(0x80340007)
+#define HI_ERR_VP_INVALID_HANDLE            (HI_S32)(0x80340008)
+#define HI_ERR_VP_HANDLE_NOTEXIST           (HI_S32)(0x80340009)
+#define HI_ERR_VP_NOT_READY                 (HI_S32)(0x8034000a)
+#define HI_ERR_VP_ILLEGAL_STATE             (HI_S32)(0x8034000b)
+
+#define HI_ERR_IR_OPEN_ERR                          (HI_S32)(0x80410001)
+#define HI_ERR_IR_CLOSE_ERR                         (HI_S32)(0x80410002)
+#define HI_ERR_IR_NOT_INIT                          (HI_S32)(0x80410003)
+#define HI_ERR_IR_INVALID_PARA                      (HI_S32)(0x80410004)
+#define HI_ERR_IR_NULL_PTR                          (HI_S32)(0x80410005)
+#define HI_ERR_IR_READ_FAILED                       (HI_S32)(0x80410006)
+#define HI_ERR_IR_ENABLE_FAILED                     (HI_S32)(0x80410007)
+#define HI_ERR_IR_SET_BLOCKTIME_FAILED              (HI_S32)(0x80410008)
+#define HI_ERR_IR_SET_FETCHMETHOD_FAILED            (HI_S32)(0x80410009)
+#define HI_ERR_IR_SET_KEYUP_FAILED                  (HI_S32)(0x8041000A)
+#define HI_ERR_IR_SET_REPEAT_FAILED                 (HI_S32)(0x8041000B)
+#define HI_ERR_IR_SET_REPKEYTIMEOUT_FAILED          (HI_S32)(0x8041000C)
+#define HI_ERR_IR_RESET_FAILED                      (HI_S32)(0x8041000D)
+#define HI_ERR_IR_ENABLE_PROT_FAILED                (HI_S32)(0x8041000E)
+#define HI_ERR_IR_DISABLE_PROT_FAILED               (HI_S32)(0x8041000F)
+#define HI_ERR_IR_GET_PROTENABLE_FAILED             (HI_S32)(0x80410010)
+#define HI_ERR_IR_SETFORMAT_FAILED                  (HI_S32)(0x80410011)
+#define HI_ERR_IR_UNSUPPORT                         (HI_S32)(0x80410012)
+
+#define HI_ERR_RTC_NOT_INIT                         (HI_S32)(0x80420001)
+#define HI_ERR_RTC_REPEAT_INIT                      (HI_S32)(0x80420002)
+#define HI_ERR_RTC_INVALID_POINT                    (HI_S32)(0x80420003)
+#define HI_ERR_RTC_INVALID_PARA                     (HI_S32)(0x80420004)
+#define HI_ERR_RTC_FAILED_INIT                      (HI_S32)(0x80420005)
+#define HI_ERR_RTC_FAILED_SETTIME                   (HI_S32)(0x80420006)
+#define HI_ERR_RTC_FAILED_GETTIME                   (HI_S32)(0x80420007)
+#define HI_ERR_RTC_FAILED_ALARMENABLE               (HI_S32)(0x80420008)
+#define HI_ERR_RTC_FAILED_ALARMDISABLE              (HI_S32)(0x80420009)
+#define HI_ERR_RTC_FAILED_SETALARM                  (HI_S32)(0x8042000A)
+#define HI_ERR_RTC_FAILED_GETALARM                  (HI_S32)(0x8042000B)
+
+#define HI_ERR_WDG_NOT_INIT                         (HI_S32)(0x80430001)
+#define HI_ERR_WDG_REPEAT_INIT                      (HI_S32)(0x80430002)
+#define HI_ERR_WDG_INVALID_POINT                    (HI_S32)(0x80430003)
+#define HI_ERR_WDG_INVALID_PARA                     (HI_S32)(0x80430004)
+#define HI_ERR_WDG_FAILED_INIT                      (HI_S32)(0x80430005)
+#define HI_ERR_WDG_FAILED_SETTIMEOUT                (HI_S32)(0x80430006)
+#define HI_ERR_WDG_FAILED_ENABLE                    (HI_S32)(0x80430007)
+#define HI_ERR_WDG_FAILED_DISABLE                   (HI_S32)(0x80430008)
+#define HI_ERR_WDG_FAILED_CLEARWDG                  (HI_S32)(0x80430009)
+#define HI_ERR_WDG_FAILED_RESET                     (HI_S32)(0x8043000A)
+#define HI_ERR_WDG_FAILED_RESMODE                   (HI_S32)(0x8043000B)
+#define HI_ERR_WDG_NOT_SUPPORT                      (HI_S32)(0x8043000C)
+#define HI_ERR_WDG_FAILED_GETTIMEOUT                (HI_S32)(0x8043000D)
+#define HI_ERR_WDG_FAILED_DEINIT                    (HI_S32)(0x8043000E)
+
+#define HI_ERR_I2C_OPEN_ERR                         (HI_S32)(0x80440001)
+#define HI_ERR_I2C_CLOSE_ERR                        (HI_S32)(0x80440002)
+#define HI_ERR_I2C_NOT_INIT                         (HI_S32)(0x80440003)
+#define HI_ERR_I2C_INVALID_PARA                     (HI_S32)(0x80440004)
+#define HI_ERR_I2C_NULL_PTR                         (HI_S32)(0x80440005)
+#define HI_ERR_I2C_COPY_DATA_ERR                    (HI_S32)(0x80440006)
+#define HI_ERR_I2C_MALLOC_ERR                       (HI_S32)(0x80440007)
+#define HI_ERR_I2C_WRITE_TIMEOUT                    (HI_S32)(0x80440008)
+#define HI_ERR_I2C_READ_TIMEOUT                     (HI_S32)(0x80440009)
+
+#define HI_ERR_SCI_OPEN_ERR                         (HI_S32)(0x80450001)
+#define HI_ERR_SCI_CLOSE_ERR                        (HI_S32)(0x80450002)
+#define HI_ERR_SCI_NOT_INIT                         (HI_S32)(0x80450003)
+#define HI_ERR_SCI_INVALID_PARA                     (HI_S32)(0x80450004)
+#define HI_ERR_SCI_NULL_PTR                         (HI_S32)(0x80450005)
+#define HI_ERR_SCI_INVALID_OPT                      (HI_S32)(0x80450006)
+#define HI_ERR_SCI_SEND_ERR                         (HI_S32)(0x80450007)
+#define HI_ERR_SCI_RECEIVE_ERR                      (HI_S32)(0x80450008)
+#define HI_ERR_SCI_NO_ATR                           (HI_S32)(0x80450009)
+#define HI_ERR_SCI_PPS_PTYPE_ERR                    (HI_S32)(0x8045000A)
+#define HI_ERR_SCI_PPS_FACTOR_ERR                   (HI_S32)(0x8045000B)
+#define HI_ERR_SCI_PPS_NOTSUPPORT_ERR               (HI_S32)(0x8045000C)
+#define HI_ERR_SCI_NOTSUPPORT                       (HI_S32)(0x8045000D)
+
+#define HI_ERR_ETH_NOT_INIT                         (HI_S32)(0x80460001)
+#define HI_ERR_ETH_REPEAT_INIT                      (HI_S32)(0x80460002)
+#define HI_ERR_ETH_INVALID_POINT                    (HI_S32)(0x80460003)
+#define HI_ERR_ETH_INVALID_PARA                     (HI_S32)(0x80460004)
+#define HI_ERR_ETH_FAILED_INIT                      (HI_S32)(0x80460005)
+
+#define HI_ERR_GPIO_OPEN_ERR                        (HI_S32)(0x80470001)
+#define HI_ERR_GPIO_CLOSE_ERR                       (HI_S32)(0x80470002)
+#define HI_ERR_GPIO_NOT_INIT                        (HI_S32)(0x80470003)
+#define HI_ERR_GPIO_INVALID_PARA                    (HI_S32)(0x80470004)
+#define HI_ERR_GPIO_NULL_PTR                        (HI_S32)(0x80470005)
+#define HI_ERR_GPIO_INVALID_OPT                     (HI_S32)(0x80470006)
+#define HI_ERR_GPIO_FAILED_SETINT                   (HI_S32)(0x80470007)
+#define HI_ERR_GPIO_FAILED_SETENABLE                (HI_S32)(0x80470008)
+#define HI_ERR_GPIO_FAILED_GETINT                   (HI_S32)(0x80470009)
+#define HI_ERR_GPIO_GETINT_TIMEOUT                  (HI_S32)(0x8047000A)
+#define HI_ERR_GPIO_INTTYPE_NOT_SUPPORT             (HI_S32)(0x8047000B)
+#define HI_ERR_GPIO_NOT_SUPPORT                     (HI_S32)(0x8047000C)
+#define HI_ERR_GPIO_FAILED_SETOUTPUTTYPE            (HI_S32)(0x8047000D)
+#define HI_ERR_GPIO_FAILED_GETOUTPUTTYPE            (HI_S32)(0x8047000E)
+#define HI_ERR_GPIO_FAILED_SETDIRECT                (HI_S32)(0x8047000F)
+#define HI_ERR_GPIO_FAILED_GETDIRECT                (HI_S32)(0x80470010)
+#define HI_ERR_GPIO_FAILED_SETVALUE                 (HI_S32)(0x80470011)
+#define HI_ERR_GPIO_FAILED_GETVALUE                 (HI_S32)(0x80470012)
+
+#define HI_ERR_DMAC_NOT_INIT                        (HI_S32)(0x80480001)
+#define HI_ERR_DMAC_REPEAT_INIT                     (HI_S32)(0x80480002)
+#define HI_ERR_DMAC_INVALID_POINT                   (HI_S32)(0x80480003)
+#define HI_ERR_DMAC_INVALID_PARA                    (HI_S32)(0x80480004)
+#define HI_ERR_DMAC_FAILED_INIT                     (HI_S32)(0x80480005)
+#define HI_ERR_DMAC_FAILED_GETCHANNEL               (HI_S32)(0x80480006)
+#define HI_ERR_DMAC_FAILED_MEMTRANS                 (HI_S32)(0x80480007)
+#define HI_ERR_DMAC_FAILED_PERTRANS                 (HI_S32)(0x80480008)
+#define HI_ERR_DMAC_FAILED_GETSTAT                  (HI_S32)(0x80480009)
+#define HI_ERR_DMAC_FAILED_LISTRESET                (HI_S32)(0x8048000A)
+#define HI_ERR_DMAC_FAILED_ADDLIST                  (HI_S32)(0x8048000B)
+#define HI_ERR_DMAC_FAILED_LISTTRANS                (HI_S32)(0x8048000C)
+
+#define  HI_ERR_PMOC_NOT_INIT                       (HI_S32)(0x80490001)
+#define  HI_ERR_PMOC_REPEAT_INIT                    (HI_S32)(0x80490002)
+#define  HI_ERR_PMOC_INVALID_POINT                  (HI_S32)(0x80490003)
+#define  HI_ERR_PMOC_INVALID_PARA                   (HI_S32)(0x80490004)
+#define  HI_ERR_PMOC_FAILED_INIT                    (HI_S32)(0x80490005)
+#define  HI_ERR_PMOC_FAILED_MODE                    (HI_S32)(0x80490006)
+#define  HI_ERR_PMOC_FAILED_READMODE                (HI_S32)(0x80490007)
+#define  HI_ERR_PMOC_FAILED_SETWAKEUPVAL            (HI_S32)(0x80490008)
+#define  HI_ERR_PMOC_FAILED_GETWAKEUPVAL            (HI_S32)(0x80490009)
+#define  HI_ERR_PMOC_INVALID_MODE                   (HI_S32)(0x8049000A)
+#define  HI_ERR_PMOC_FAILED_STANDBY                 (HI_S32)(0x8049000B)
+#define  HI_ERR_PMOC_FAILED_SETDEV                  (HI_S32)(0x8049000C)
+#define  HI_ERR_PMOC_FAILED_GETPERIOD               (HI_S32)(0x8049000D)
+#define  HI_ERR_PMOC_FAILED_IRPOWERVAL              (HI_S32)(0x8049000E)
+#define  HI_ERR_PMOC_FAILED_KEYLEDPOWERVAL          (HI_S32)(0x8049000F)
+#define  HI_ERR_PMOC_FAILED_GETWAKEUPMODE           (HI_S32)(0x80490010)
+#define  HI_ERR_PMOC_FAILED_GETTEMPERATURE          (HI_S32)(0x80490011)
+
+#define HI_ERR_TUNER_NOT_INIT                       (HI_S32)(0x804A0001)
+#define HI_ERR_TUNER_NOT_OPEN                       (HI_S32)(0x804A0002)
+#define HI_ERR_TUNER_INVALID_POINT                  (HI_S32)(0x804A0003)
+#define HI_ERR_TUNER_INVALID_PARA                   (HI_S32)(0x804A0004)
+#define HI_ERR_TUNER_FAILED_INIT                    (HI_S32)(0x804A0005)
+#define HI_ERR_TUNER_FAILED_CONNECT                 (HI_S32)(0x804A0006)
+#define HI_ERR_TUNER_FAILED_GETSTATUS               (HI_S32)(0x804A0007)
+#define HI_ERR_TUNER_FAILED_GETSIGNALSTRENGTH       (HI_S32)(0x804A0008)
+#define HI_ERR_TUNER_FAILED_GETBER                  (HI_S32)(0x804A0009)
+#define HI_ERR_TUNER_FAILED_GETSNR                  (HI_S32)(0x804A000A)
+#define HI_ERR_TUNER_FAILED_SETTSTYPE               (HI_S32)(0x804A000B)
+#define HI_ERR_TUNER_FAILED_SELECTTUNER             (HI_S32)(0x804A000C)
+#define HI_ERR_TUNER_FAILED_SELECTI2CCHANNEL        (HI_S32)(0x804A000D)
+#define HI_ERR_TUNER_FAILED_LOWCONS                 (HI_S32)(0x804A000E)
+#define HI_ERR_TUNER_FAILED_NORMALMODE              (HI_S32)(0x804A000F)
+#define HI_ERR_TUNER_FAILED_REGRW                   (HI_S32)(0x804A0010)
+#define HI_ERR_TUNER_FAILED_SETTUNER                (HI_S32)(0x804A0011)
+#define HI_ERR_TUNER_NOT_CONNECT                    (HI_S32)(0x804A0012)
+#define HI_ERR_TUNER_INVALID_PORT                   (HI_S32)(0x804A0013)
+#define HI_ERR_TUNER_FAILED_SETQAMINSIDE            (HI_S32)(0x804A0014)
+#define HI_ERR_TUNER_FAILED_SELECTSYMBOLRATE        (HI_S32)(0x804A0015)
+#define HI_ERR_TUNER_FAILED_GETSIGNALQUALITY        (HI_S32)(0x804A0016)
+#define HI_ERR_TUNER_FAILED_GETSIGNALINFO           (HI_S32)(0x804A0017)
+#define HI_ERR_TUNER_FAILED_BLINDSCAN               (HI_S32)(0x804A0018)
+#define HI_ERR_TUNER_FAILED_LNBCTRL                 (HI_S32)(0x804A0019)
+#define HI_ERR_TUNER_FAILED_SWITCH                  (HI_S32)(0x804A001A)
+#define HI_ERR_TUNER_FAILED_DISEQC                  (HI_S32)(0x804A001B)
+#define HI_ERR_TUNER_FAILED_STANDBY                 (HI_S32)(0x804A001C)
+#define HI_ERR_TUNER_FAILED_WAKEUP                  (HI_S32)(0x804A001D)
+#define HI_ERR_TUNER_FAILED_DISABLE                 (HI_S32)(0x804A001E)
+#define HI_ERR_TUNER_FAILED_ENABLE                  (HI_S32)(0x804A001F)
+#define HI_ERR_TUNER_FAILED_SETPLPID                (HI_S32)(0x804A0020)
+#define HI_ERR_TUNER_FAILED_GETPLPNUM               (HI_S32)(0x804A0021)
+#define HI_ERR_TUNER_FAILED_GETPLPTYPE              (HI_S32)(0x804A0022)
+#define HI_ERR_TUNER_FAILED_SETTSOUT                (HI_S32)(0x804A0023)
+#define HI_ERR_TUNER_FAILED_SETSATATTR              (HI_S32)(0x804A0024)
+#define HI_ERR_TUNER_FAILED_SAMPLEDATA              (HI_S32)(0x804A0025)
+#define HI_ERR_TUNER_FAILED_SETTERATTR              (HI_S32)(0x804A0026)
+#define HI_ERR_TUNER_FAILED_SETSTEP                 (HI_S32)(0x804A0027)
+#define HI_ERR_TUNER_FAILED_GETBANDRANGE            (HI_S32)(0x804A0028)
+#define HI_ERR_TUNER_FAILED_SETTOPADJUST            (HI_S32)(0x804A0029)
+#define HI_ERR_TUNER_FAILED_GETBAND                 (HI_S32)(0x804A002A)
+#define HI_ERR_TUNER_FAILED_GETTONE                 (HI_S32)(0x804A002B)
+#define HI_ERR_TUNER_FAILED_GETAGC                  (HI_S32)(0x804A002C)
+#define HI_ERR_TUNER_FAILED_TERSCANTIMEOUT          (HI_S32)(0x804A002D)
+#define HI_ERR_TUNER_FAILED_ALLOC_MEM               (HI_S32)(0x804A002E)
+#define HI_ERR_TUNER_FAILED_SETISIID                (HI_S32)(0x804A002F)
+#define HI_ERR_TUNER_FAILED_GETISIID                (HI_S32)(0x804A0030)
+#define HI_ERR_TUNER_FAILED_GETTOTALISI             (HI_S32)(0x804A0031)
+#define HI_ERR_TUNER_FAILED_MONITORISDBTLAYER       (HI_S32)(0x804A0032)
+#define HI_ERR_TUNER_INVALID_SIGTYPE                (HI_S32)(0x804A0033)
+#define HI_ERR_TUNER_INVALID_DEMODTYPE              (HI_S32)(0x804A0034)
+#define HI_ERR_TUNER_INVALID_TUNERTYPE              (HI_S32)(0x804A0035)
+#define HI_ERR_TUNER_INVALID_FREQUENCY              (HI_S32)(0x804A0036)
+#define HI_ERR_TUNER_INVALID_SYMBOLRATE             (HI_S32)(0x804A0037)
+#define HI_ERR_TUNER_INVALID_FUNCTION               (HI_S32)(0x804A0038)
+#define HI_ERR_TUNER_DISEQC_BUSY                    (HI_S32)(0x804A0039)
+#define HI_ERR_TUNER_DISEQC_POST_LISTEN             (HI_S32)(0x804A003A)
+#define HI_ERR_TUNER_DISEQC_RECV_LENGTH             (HI_S32)(0x804A003B)
+#define HI_ERR_TUNER_DISEQC_RECV_TIMEOUT            (HI_S32)(0x804A003C)
+#define HI_ERR_TUNER_DISEQC_RECV_STATE              (HI_S32)(0x804A003D)
+#define HI_ERR_TUNER_BLINDSAN_TPVERIFY              (HI_S32)(0x804A003E)
+#define HI_ERR_TUNER_MCU_DOWNLOAD                   (HI_S32)(0x804A003F)
+#define HI_ERR_TUNER_CATCH_TIMEOUT                  (HI_S32)(0x804A0040)
+#define HI_ERR_TUNER_SECURE_CHECK                   (HI_S32)(0x804A0041)
+
+#define HI_ERR_KEYLED_NOT_INIT                      (HI_S32)(0x804B0001)
+#define HI_ERR_KEYLED_INVALID_PARA                  (HI_S32)(0x804B0002)
+#define HI_ERR_KEYLED_NULL_PTR                      (HI_S32)(0x804B0003)
+#define HI_ERR_KEYLED_NO_NEW_KEY                    (HI_S32)(0x804B0004)
+#define HI_ERR_KEYLED_TIMEOUT                       (HI_S32)(0x804B0005)
+#define HI_ERR_KEYLED_FAILED_SETMODE                (HI_S32)(0x804B0006)
+#define HI_ERR_KEYLED_FAILED_DISPLAY                (HI_S32)(0x804B0007)
+
+
+#define HI_ERR_E2PROM_OPEN_ERR                      (HI_S32)(0x804C0001)
+#define HI_ERR_E2PROM_CLOSE_ERR                     (HI_S32)(0x804C0002)
+#define HI_ERR_E2PROM_NOT_INIT                      (HI_S32)(0x804C0003)
+#define HI_ERR_E2PROM_INVALID_PARA                  (HI_S32)(0x804C0004)
+#define HI_ERR_E2PROM_NULL_PTR                      (HI_S32)(0x804C0005)
+#define HI_ERR_E2PROM_COPY_DATA_ERR                 (HI_S32)(0x804C0006)
+#define HI_ERR_E2PROM_MALLOC_ERR                    (HI_S32)(0x804C0007)
+
+
+#define  HI_ERR_CIPHER_NOT_INIT                     (HI_S32)(0x804D0001)
+#define  HI_ERR_CIPHER_INVALID_HANDLE               (HI_S32)(0x804D0002)
+#define  HI_ERR_CIPHER_INVALID_POINT                (HI_S32)(0x804D0003)
+#define  HI_ERR_CIPHER_INVALID_PARA                 (HI_S32)(0x804D0004)
+#define  HI_ERR_CIPHER_FAILED_INIT                  (HI_S32)(0x804D0005)
+#define  HI_ERR_CIPHER_FAILED_GETHANDLE             (HI_S32)(0x804D0006)
+#define  HI_ERR_CIPHER_FAILED_RELEASEHANDLE         (HI_S32)(0x804D0007)
+#define  HI_ERR_CIPHER_FAILED_CONFIGAES             (HI_S32)(0x804D0008)
+#define  HI_ERR_CIPHER_FAILED_CONFIGDES             (HI_S32)(0x804D0009)
+#define  HI_ERR_CIPHER_FAILED_ENCRYPT               (HI_S32)(0x804D000A)
+#define  HI_ERR_CIPHER_FAILED_DECRYPT               (HI_S32)(0x804D000B)
+#define  HI_ERR_CIPHER_BUSY                         (HI_S32)(0x804D000C)
+#define  HI_ERR_CIPHER_NO_AVAILABLE_RNG             (HI_S32)(0x804D000D)
+#define  HI_ERR_CIPHER_FAILED_MEM                   (HI_S32)(0x804D000E)
+#define  HI_ERR_CIPHER_UNAVAILABLE                  (HI_S32)(0x804D000F)
+#define  HI_ERR_CIPHER_OVERFLOW                     (HI_S32)(0x804D0010)
+#define  HI_ERR_CIPHER_HARD_STATUS                  (HI_S32)(0x804D0011)
+#define  HI_ERR_CIPHER_TIMEOUT                      (HI_S32)(0x804D0012)
+#define  HI_ERR_CIPHER_UNSUPPORTED                  (HI_S32)(0x804D0013)
+#define  HI_ERR_CIPHER_REGISTER_IRQ                 (HI_S32)(0x804D0014)
+#define  HI_ERR_CIPHER_ILLEGAL_UUID                 (HI_S32)(0x804D0015)
+#define  HI_ERR_CIPHER_ILLEGAL_KEY                  (HI_S32)(0x804D0016)
+#define  HI_ERR_CIPHER_INVALID_ADDR                 (HI_S32)(0x804D0017)
+#define  HI_ERR_CIPHER_INVALID_LENGTH               (HI_S32)(0x804D0018)
+#define  HI_ERR_CIPHER_ILLEGAL_DATA                 (HI_S32)(0x804D0019)
+#define  HI_ERR_CIPHER_RSA_SIGN                     (HI_S32)(0x804D001A)
+#define  HI_ERR_CIPHER_RSA_VERIFY                   (HI_S32)(0x804D001B)
+
+#define  HI_ERR_CA_OPEN_ERR                         (HI_S32)(0x804E0001)
+#define  HI_ERR_CA_CLOSE_ERR                        (HI_S32)(0x804E0002)
+#define  HI_ERR_CA_NOT_INIT                         (HI_S32)(0x804E0003)
+#define  HI_ERR_CA_COPY_DATA_ERR                    (HI_S32)(0x804E0004)
+#define  HI_ERR_CA_INVALID_PARA                     (HI_S32)(0x804E0005)
+#define  HI_ERR_CA_WAIT_TIMEOUT                     (HI_S32)(0x804E0006)
+#define  HI_ERR_CA_CW_DECRYPT                       (HI_S32)(0x804E0007)
+#define  HI_ERR_CA_R2R_DECRYPT                      (HI_S32)(0x804E0008)
+#define  HI_ERR_CA_R2R_ENCRYPT                      (HI_S32)(0x804E0009)
+#define  HI_ERR_CA_SETPARAM_AGAIN                   (HI_S32)(0x804E000A)
+#define  HI_ERR_CA_DBG_INERR                        (HI_S32)(0x804E000B)
+#define  HI_ERR_CA_NOT_CONFIG                       (HI_S32)(0x804E000C)
+#define  HI_ERR_CA_LPK_DECRYPT                      (HI_S32)(0x804E000D)
+#define  HI_ERR_CA_NOT_SUPPORT                      (HI_S32)(0x804E000E)
+#define  HI_ERR_CA_SWPK_ENCRYPT                     (HI_S32)(0x804E000F)
+#define  HI_ERR_CA_NO_MEMORY                        (HI_S32)(0x804E0011)
+#define  HI_ERR_CA_PTR_NULL                         (HI_S32)(0x804E0012)
+#define  HI_ERR_CA_GETSEMA_ERR                      (HI_S32)(0x804E0013)
+#define  HI_ERR_CA_NO_RESOURCE                      (HI_S32)(0x804E0014)
+#define  HI_ERR_CA_NOT_FIND_CA                      (HI_S32)(0x804E0016)
+#define  HI_ERR_CA_NOT_FIND_KLAD                    (HI_S32)(0x804E0017)
+#define  HI_ERR_CA_NOT_FIND_SESSION                 (HI_S32)(0x804E0018)
+#define  HI_ERR_CA_NOT_SET                          (HI_S32)(0x804E0019)
+#define  HI_ERR_CA_ALREADY_SET                      (HI_S32)(0x804E001A)
+#define  HI_ERR_CA_NOT_FIND_CALLBACK                (HI_S32)(0x804E001B)
+#define  HI_ERR_CA_KEY_NOT_READDY                   (HI_S32)(0x804E001C)
+
+
+#define  HI_ERR_PM_COPY_DATA_ERR                    (HI_S32)(0x804F0001)
+#define  HI_ERR_PM_INVALID_PARAM                    (HI_S32)(0x804F0002)
+
+#define  HI_ERR_CI_NOT_INIT                         (HI_S32)(0x80500001)
+#define  HI_ERR_CI_OPEN_ERR                         (HI_S32)(0x80500002)
+#define  HI_ERR_CI_CLOSE_ERR                        (HI_S32)(0x80500003)
+#define  HI_ERR_CI_INVALID_PARA                     (HI_S32)(0x80500004)
+#define  HI_ERR_CI_NO_MEMORY                        (HI_S32)(0x80500005)
+#define  HI_ERR_CI_TIMEOUT                          (HI_S32)(0x80500006)
+#define  HI_ERR_CI_REG_READ_ERR                     (HI_S32)(0x80500007)
+#define  HI_ERR_CI_REG_WRITE_ERR                    (HI_S32)(0x80500008)
+#define  HI_ERR_CI_IO_READ_ERR                      (HI_S32)(0x80500009)
+#define  HI_ERR_CI_IO_WRITE_ERR                     (HI_S32)(0x8050000A)
+#define  HI_ERR_CI_ATTR_READ_ERR                    (HI_S32)(0x8050000B)
+#define  HI_ERR_CI_ATTR_WRITE_ERR                   (HI_S32)(0x8050000C)
+#define  HI_ERR_CI_CANNOT_POWEROFF                  (HI_S32)(0x8050000D)
+#define  HI_ERR_CI_PCCD_DEVICE_BUSY                 (HI_S32)(0x8050000E)
+#define  HI_ERR_CI_PCCD_CIS_READ                    (HI_S32)(0x8050000F)
+#define  HI_ERR_CI_UNSUPPORT                        (HI_S32)(0x80500010)
+#define  HI_ERR_CI_UNKONWN                          (HI_S32)(0x80500011)
+#define  HI_ERR_CI_DETECT_ERR                       (HI_S32)(0x80500012)
+
+#define HI_ERR_PWM_DEV_NOT_EXIST                    (HI_S32)(0x80510001)
+#define HI_ERR_PWM_NOT_INIT                         (HI_S32)(0x80510002)
+#define HI_ERR_PWM_OPEN_ERR                         (HI_S32)(0x80510003)
+#define HI_ERR_PWM_CLOSE_ERR                        (HI_S32)(0x80510004)
+#define HI_ERR_PWM_INVALID_PARA                     (HI_S32)(0x80510005)
+#define HI_ERR_PWM_INVALID_OPT                      (HI_S32)(0x80510006)
+#define HI_ERR_PWM_UNSUPPORT                        (HI_S32)(0x80510007)
+
+#define HI_ERR_PDM_DEV_NOT_EXIST                    (HI_S32)(0x80520001)
+#define HI_ERR_PDM_NOT_DEVICE                       (HI_S32)(0x80520002)
+#define HI_ERR_PDM_DEV_OPEN_ERR                     (HI_S32)(0x80520003)
+#define HI_ERR_PDM_DEV_NOT_INIT                     (HI_S32)(0x80520004)
+#define HI_ERR_PDM_PTR_NULL                         (HI_S32)(0x80520005)
+#define HI_ERR_PDM_PARAM_INVALID                    (HI_S32)(0x80520006)
+#define HI_ERR_PDM_GET_MTDINFO_ERR                  (HI_S32)(0x80520007)
+#define HI_ERR_PDM_MTD_OPEN                         (HI_S32)(0x80520008)
+#define HI_ERR_PDM_MTD_CLOSE                        (HI_S32)(0x80520009)
+#define HI_ERR_PDM_MTD_READ                         (HI_S32)(0x80520010)
+#define HI_ERR_PDM_MTD_WRITE                        (HI_S32)(0x80520011)
+#define HI_ERR_PDM_MTD_GETINFO                      (HI_S32)(0x80520012)
+#define HI_ERR_PDM_MTD_ERASE                        (HI_S32)(0x80520013)
+#define HI_ERR_PDM_MEM_ALLC                         (HI_S32)(0x80520014)
+#define HI_ERR_PDM_INVALID_OPT                      (HI_S32)(0x80520015)
+#define HI_ERR_PDM_GET_DEVINFO_ERR                  (HI_S32)(0x80520016)
+
+#define  HI_ERR_LSADC_INVALID_PARA                   (HI_S32)(0x80520004)
+#define  HI_ERR_LSADC_FAILED_INIT                    (HI_S32)(0x80520005)
+
+#define HI_ERR_UART_OPENED                           (HI_S32)(0x80530000)
+#define HI_ERR_UART_NOT_OPEN                         (HI_S32)(0x80530001)
+#define HI_ERR_UART_BUFF                             (HI_S32)(0x80530002)
+#define HI_ERR_UART_OPEN                             (HI_S32)(0x80530003)
+#define HI_ERR_UART_MAP                              (HI_S32)(0x80530004)
+#define HI_ERR_UART_UNMAP                            (HI_S32)(0x80530005)
+#define HI_ERR_UART_CLOSE                            (HI_S32)(0x80530006)
+#define HI_ERR_UART_DEVICE                           (HI_S32)(0x80530007)
+#define HI_ERR_UART_CREATE_THREAD                    (HI_S32)(0x80530008)
+#define HI_ERR_UART_THREAD_JOIN                      (HI_S32)(0x80530009)
+#define HI_ERR_UART_SET_ATTR                         (HI_S32)(0x8053000a)
+#define HI_ERR_UART_GET_ATTR                         (HI_S32)(0x8053000b)
+#define HI_ERR_UART_SPEED                            (HI_S32)(0x8053000c)
+#define HI_ERR_UART_IOSPEED                          (HI_S32)(0x8053000d)
+#define HI_ERR_UART_DATABITS                         (HI_S32)(0x8053000e)
+#define HI_ERR_UART_PARITY                           (HI_S32)(0x8053000f)
+#define HI_ERR_UART_STOPBITS                         (HI_S32)(0x80530010)
+#define HI_ERR_UART_WRITE                            (HI_S32)(0x80530011)
+#define HI_ERR_UART_GEN                              (HI_S32)(0x80530012)
+
+#define HI_ERR_PQ_DEV_NOT_EXIST                     (HI_S32)(0x80600001)
+#define HI_ERR_PQ_NOT_DEV_FILE                      (HI_S32)(0x80600002)
+#define HI_ERR_PQ_DEV_OPEN_ERR                      (HI_S32)(0x80600003)
+#define HI_ERR_PQ_DEV_CLOSE_ERR                     (HI_S32)(0x80600004)
+#define HI_ERR_PQ_NULL_PTR                          (HI_S32)(0x80600005)
+#define HI_ERR_PQ_NO_INIT                           (HI_S32)(0x80600006)
+#define HI_ERR_PQ_INVALID_PARA                      (HI_S32)(0x80600007)
+#define HI_ERR_PQ_PARAM_NOT_BURN                    (HI_S32)(0x80600008)
+
+#define HI_ERR_SPI_OPEN_ERR                         (HI_S32)(0x80700001)
+#define HI_ERR_SPI_CLOSE_ERR                        (HI_S32)(0x80700002)
+#define HI_ERR_SPI_NOT_INIT                         (HI_S32)(0x80700003)
+#define HI_ERR_SPI_INVALID_PARA                     (HI_S32)(0x80700004)
+#define HI_ERR_SPI_NULL_PTR                         (HI_S32)(0x80700005)
+#define HI_ERR_SPI_COPY_DATA_ERR                    (HI_S32)(0x80700006)
+#define HI_ERR_SPI_MALLOC_ERR                       (HI_S32)(0x80700007)
+#define HI_ERR_SPI_WRITE_TIMEOUT                    (HI_S32)(0x80700008)
+#define HI_ERR_SPI_READ_TIMEOUT                     (HI_S32)(0x80700009)
+
+#define  HI_ERR_PLCIPHER_NOT_INIT                     (HI_S32)(0x808D0001)
+#define  HI_ERR_PLCIPHER_INVALID_HANDLE               (HI_S32)(0x808D0002)
+#define  HI_ERR_PLCIPHER_INVALID_PTR                (HI_S32)(0x808D0003)
+#define  HI_ERR_PLCIPHER_INVALID_PARA                 (HI_S32)(0x808D0004)
+#define  HI_ERR_PLCIPHER_FAILED_INIT                  (HI_S32)(0x808D0005)
+#define  HI_ERR_PLCIPHER_FAILED_GETHANDLE             (HI_S32)(0x808D0006)
+#define  HI_ERR_PLCIPHER_FAILED_RELEASEHANDLE         (HI_S32)(0x808D0007)
+#define  HI_ERR_PLCIPHER_FAILED_CONFIGAES             (HI_S32)(0x808D0008)
+#define  HI_ERR_PLCIPHER_FAILED_CONFIGDES             (HI_S32)(0x808D0009)
+#define  HI_ERR_PLCIPHER_FAILED_ENCRYPT               (HI_S32)(0x808D000A)
+#define  HI_ERR_PLCIPHER_FAILED_DECRYPT               (HI_S32)(0x808D000B)
+#define  HI_ERR_PLCIPHER_BUSY                         (HI_S32)(0x808D000C)
+#define  HI_ERR_PLCIPHER_NO_AVAILABLE_RNG             (HI_S32)(0x808D000D)
+
+#define  HI_ERR_OTP_NOT_INIT                      (HI_S32)(0x808F0001)
+#define  HI_ERR_OTP_NOT_SUPPORT_INTERFACE         (HI_S32)(0x808F0002)
+#define  HI_ERR_OTP_INVALID_PARA                  (HI_S32)(0x808F0003)
+#define  HI_ERR_OTP_PTR_NULL                      (HI_S32)(0x808F0004)
+#define  HI_ERR_OTP_CHECK_FAILED                  (HI_S32)(0x808F0005)
+#define  HI_ERR_OTP_SYSCALL_FAILED                (HI_S32)(0x808F0006)
+#define  HI_ERR_OTP_MALLOC_ERR                    (HI_S32)(0x808F0007)
+#define  HI_ERR_OTP_NOT_FOUND                     (HI_S32)(0x808F0008)
+#define  HI_ERR_OTP_NOT_SUPPORT                   (HI_S32)(0x808F0009)
+#define  HI_ERR_OTP_MEM_MAP                       (HI_U32)(0x808F0010)
+#define  HI_ERR_OTP_NOT_INITRDY                   (HI_U32)(0x808F0011)
+#define  HI_ERR_OTP_READABLE_FUSE_VERIFY          (HI_U32)(0x808F0012)
+#define  HI_ERR_OTP_TIMEOUT                       (HI_U32)(0x808F0013)
+#define  HI_ERR_OTP_PROG_PERM                     (HI_U32)(0x808F0017)
+#define  HI_ERR_OTP_FAIL_PRMRD                    (HI_U32)(0x808F0018)
+#define  HI_ERR_OTP_FAIL_RD                       (HI_U32)(0x808F0019)
+#define  HI_ERR_OTP_DISABLE_PROG                  (HI_U32)(0x808F001a)
+#define  HI_ERR_OTP_FULL_VERSION                  (HI_U32)(0x808F001b)
+#define  HI_ERR_OTP_FAILED_CHECKVERSION           (HI_U32)(0x808F001c)
+#define  HI_ERR_OTP_FAILED_AUTH                   (HI_U32)(0x808F001d)
+#define  HI_ERR_OTP_TAID_SETED                    (HI_U32)(0x808F001f)
+#define  HI_ERR_OTP_INVALID_TAID                  (HI_U32)(0x808F0020)
+#define  HI_ERR_OTP_DUPLICATE_TAID                (HI_U32)(0x808F0021)
+#define  HI_ERR_OTP_NO_AVAILABLE_INDEX            (HI_U32)(0x808F0022)
+#define  HI_ERR_OTP_FUSE_LOCKED                   (HI_U32)(0x808F0023)
+#define  HI_ERR_OTP_DATA_BUILD_FAILED             (HI_U32)(0x808F0024)
+#define  HI_ERR_OTP_DATA_VERIFY_FAILED            (HI_U32)(0x808F0025)
+#define  HI_ERR_OTP_DATA_VERIFY_NULL              (HI_U32)(0x808F0026)
+#define  HI_ERR_OTP_SEC_FAILED                    (HI_U32)(0x808F0027)
+
+#define HI_ERR_SM_NULL_PTR                        (HI_S32)(0x80900001)
+#define HI_ERR_SM_NO_SESSION_FOUND                (HI_S32)(0x80900002)
+#define HI_ERR_SM_INVALID_HANDLE                  (HI_S32)(0x80900003)
+#define HI_ERR_SM_INVALID_INTENT                  (HI_S32)(0x80900004)
+#define HI_ERR_SM_INVALID_MODULEID                (HI_S32)(0x80900006)
+#define HI_ERR_SM_NO_MEMORY                       (HI_S32)(0x80900007)
+#define HI_ERR_SM_INVALID_LINKRULES               (HI_S32)(0x80900008)
+#define HI_ERR_SM_INVALID_INTENTRULES             (HI_S32)(0x80900009)
+#define HI_ERR_SM_NO_HANDLE_ADD                   (HI_S32)(0x8090000a)
+#define HI_ERR_SM_CONFLICT_SET                    (HI_S32)(0x8090000b)
+#define HI_ERR_SM_NOT_SUPPORT                     (HI_S32)(0x8090000c)
+#define HI_ERR_SM_INVALID_CMD                     (HI_S32)(0x8090000d)
+#define HI_ERR_SM_INVALID_SIZE                    (HI_S32)(0x8090000e)
+#define HI_ERR_SM_INVALID_ACCESS                  (HI_S32)(0x8090000f)
+#define HI_ERR_SM_INVALID_RESOURCE_NUM            (HI_S32)(0x80900010)
+
+#define HI_ERR_KLAD_NOT_INIT                      HI_ERRCODE_DEF(HI_ID_CA, 0x0001)
+#define HI_ERR_KLAD_NULL_PTR                      HI_ERRCODE_DEF(HI_ID_CA, 0x0002)
+#define HI_ERR_KLAD_INVALID_HANDLE                HI_ERRCODE_DEF(HI_ID_CA, 0x0003)
+#define HI_ERR_KLAD_INVALID_ALG                   HI_ERRCODE_DEF(HI_ID_CA, 0x0004)
+#define HI_ERR_KLAD_INVALID_TARGET                HI_ERRCODE_DEF(HI_ID_CA, 0x0005)
+#define HI_ERR_KLAD_INVALID_TARGETADDR            HI_ERRCODE_DEF(HI_ID_CA, 0x0006)
+#define HI_ERR_KLAD_NO_MEMORY                     HI_ERRCODE_DEF(HI_ID_CA, 0x0007)
+#define HI_ERR_KLAD_WAIT_TIMEOUT                  HI_ERRCODE_DEF(HI_ID_CA, 0x0008)
+#define HI_ERR_KLAD_NOT_FIND_KLAD                 HI_ERRCODE_DEF(HI_ID_CA, 0x0009)
+#define HI_ERR_KLAD_NOT_FIND_SESSION              HI_ERRCODE_DEF(HI_ID_CA, 0x000a)
+#define HI_ERR_KLAD_NOT_SET_ATTR                  HI_ERRCODE_DEF(HI_ID_CA, 0x000b)
+#define HI_ERR_KLAD_NOT_FIND_CALLBACK             HI_ERRCODE_DEF(HI_ID_CA, 0x000c)
+#define HI_ERR_KLAD_KEY_NOT_READY                 HI_ERRCODE_DEF(HI_ID_CA, 0x000d)
+#define HI_ERR_KLAD_ALREADY_SETATTR               HI_ERRCODE_DEF(HI_ID_CA, 0x000e)
+#define HI_ERR_KLAD_NOT_SET_SESSIONKEY            HI_ERRCODE_DEF(HI_ID_CA, 0x000f)
+#define HI_ERR_KLAD_NOT_SET_CONTENTKEY            HI_ERRCODE_DEF(HI_ID_CA, 0x0010)
+#define HI_ERR_KLAD_ALREADY_SETTARGET             HI_ERRCODE_DEF(HI_ID_CA, 0x0011)
+#define HI_ERR_KLAD_NOT_SETTARGET                 HI_ERRCODE_DEF(HI_ID_CA, 0x0012)
+#define HI_ERR_KLAD_DETACH_ERRTARGET              HI_ERRCODE_DEF(HI_ID_CA, 0x0013)
+#define HI_ERR_KLAD_INVALID_LEVEL                 HI_ERRCODE_DEF(HI_ID_CA, 0x0014)
+#define HI_ERR_KLAD_UNAVAILABLE_TARGET            HI_ERRCODE_DEF(HI_ID_CA, 0x0015)
+#define HI_ERR_KLAD_FAILED_SETIV                  HI_ERRCODE_DEF(HI_ID_CA, 0x0016)
+#define HI_ERR_KLAD_INVALID_ENGINE                HI_ERRCODE_DEF(HI_ID_CA, 0x0017)
+#define HI_ERR_KLAD_INVALID_EVENORODD             HI_ERRCODE_DEF(HI_ID_CA, 0x0018)
+#define HI_ERR_KLAD_NOT_SUPPORT                   HI_ERRCODE_DEF(HI_ID_CA, 0x0019)
+#define HI_ERR_KLAD_INVALID_IVLENGTH              HI_ERRCODE_DEF(HI_ID_CA, 0x001a)
+#define HI_ERR_KLAD_NO_RESOURCE                   HI_ERRCODE_DEF(HI_ID_CA, 0x001b)
+#define HI_ERR_KLAD_UNKNOWN_CMD                   HI_ERRCODE_DEF(HI_ID_CA, 0x001c)
+#define HI_ERR_KLAD_OPEN_ERR                      HI_ERRCODE_DEF(HI_ID_CA, 0x001d)
+#define HI_ERR_KLAD_INVALID_PARAM                 HI_ERRCODE_DEF(HI_ID_CA, 0x001e)
+#define HI_ERR_KLAD_TASK_ID_MISMATCH              HI_ERRCODE_DEF(HI_ID_CA, 0x001f)
+#define HI_ERR_KLAD_MUTEX                         HI_ERRCODE_DEF(HI_ID_CA, 0x0020)
+
+#define HI_ERR_KLAD_CHECK_BASE                    HI_ERRCODE_DEF(HI_ID_CA, 0x0020)
+#define HI_ERR_KLAD_CHECK_OTP_CONFIG_DISABLE      HI_ERRCODE_DEF(HI_ID_CA, 0x0021)
+#define HI_ERR_KLAD_CHECK_LEVEL                   HI_ERRCODE_DEF(HI_ID_CA, 0x0022)
+#define HI_ERR_KLAD_CHECK_DSC_MODE                HI_ERRCODE_DEF(HI_ID_CA, 0x0023)
+#define HI_ERR_KLAD_CHECK_PORT                    HI_ERRCODE_DEF(HI_ID_CA, 0x0024)
+#define HI_ERR_KLAD_CHECK_ROOTKEY_NOT_READY       HI_ERRCODE_DEF(HI_ID_CA, 0x0025)
+#define HI_ERR_KLAD_CHECK_LEVEL1_NOT_READY        HI_ERRCODE_DEF(HI_ID_CA, 0x0026)
+#define HI_ERR_KLAD_CHECK_LEVEL2_NOT_READY        HI_ERRCODE_DEF(HI_ID_CA, 0x0027)
+#define HI_ERR_KLAD_CHECK_LEVEL3_NOT_READY        HI_ERRCODE_DEF(HI_ID_CA, 0x0028)
+#define HI_ERR_KLAD_CHECK_LEVEL4_NOT_READY        HI_ERRCODE_DEF(HI_ID_CA, 0x0029)
+#define HI_ERR_KLAD_CHECK_LEVEL5_NOT_READY        HI_ERRCODE_DEF(HI_ID_CA, 0x002a)
+#define HI_ERR_KLAD_CHECK_DCAS_PROFILE            HI_ERRCODE_DEF(HI_ID_CA, 0x002b)
+#define HI_ERR_KLAD_CHECK_TDES_KEY                HI_ERRCODE_DEF(HI_ID_CA, 0x002c)
+#define HI_ERR_KLAD_CHECK_C2_TA_HASH              HI_ERRCODE_DEF(HI_ID_CA, 0x002d)
+#define HI_ERR_KLAD_CHECK_CLEAR_CW_CONFIG         HI_ERRCODE_DEF(HI_ID_CA, 0x002e)
+#define HI_ERR_KLAD_CHECK_CW                      HI_ERRCODE_DEF(HI_ID_CA, 0x0032)
+#define HI_ERR_KLAD_CHECK_TEE_ENABLE              HI_ERRCODE_DEF(HI_ID_CA, 0x0034)
+#define HI_ERR_KLAD_SECURE_ATTR_UINIT             HI_ERRCODE_DEF(HI_ID_CA, 0x0035)
+#define HI_ERR_KLAD_REQUIRE_IRQ_FAILED            HI_ERRCODE_DEF(HI_ID_CA, 0x0036)
+#define HI_ERR_KLAD_SEC_FAILED                    HI_ERRCODE_DEF(HI_ID_CA, 0x0037)
+
+#define HI_ERR_CERT_NOT_INIT                      HI_ERRCODE_DEF(HI_ID_CERT, 0x0101)
+#define HI_ERR_CERT_INVALID_HANDLE                HI_ERRCODE_DEF(HI_ID_CERT, 0x0102)
+#define HI_ERR_CERT_INVALID_PTR                   HI_ERRCODE_DEF(HI_ID_CERT, 0x0103)
+#define HI_ERR_CERT_INVALID_PARA                  HI_ERRCODE_DEF(HI_ID_CERT, 0x0104)
+#define HI_ERR_CERT_FAILED_INIT                   HI_ERRCODE_DEF(HI_ID_CERT, 0x0105)
+#define HI_ERR_CERT_UNEXPECTED_STA                HI_ERRCODE_DEF(HI_ID_CERT, 0x0106)
+#define HI_ERR_CERT_UNEXPECTED_EMI                HI_ERRCODE_DEF(HI_ID_CERT, 0x0107)
+#define HI_ERR_CERT_KEY_INVALID                   HI_ERRCODE_DEF(HI_ID_CERT, 0x0108)
+#define HI_ERR_CERT_TIMEOUT                       HI_ERRCODE_DEF(HI_ID_CERT, 0x0109)
+#define HI_ERR_CERT_LOCKED                        HI_ERRCODE_DEF(HI_ID_CERT, 0x010A)
+#define HI_ERR_CERT_UNLOCKED                      HI_ERRCODE_DEF(HI_ID_CERT, 0x010B)
+#define HI_ERR_CERT_UNEXPECTED_CW                 HI_ERRCODE_DEF(HI_ID_CERT, 0x010C)
+#define HI_ERR_CERT_MUTEX_ERR                     HI_ERRCODE_DEF(HI_ID_CERT, 0x010D)
+#define HI_ERR_CERT_LOCK_STA_ERR                  HI_ERRCODE_DEF(HI_ID_CERT, 0x010E)
+#define HI_ERR_CERT_DBG_ALG_ERR                   HI_ERRCODE_DEF(HI_ID_CERT, 0x010F)
+#define HI_ERR_CERT_DBG_PRT_SEL_ERR               HI_ERRCODE_DEF(HI_ID_CERT, 0x0110)
+#define HI_ERR_CERT_DBG_USAGE_ERR                 HI_ERRCODE_DEF(HI_ID_CERT, 0x0111)
+#define HI_ERR_CERT_DBG_OTHER_ERR                 HI_ERRCODE_DEF(HI_ID_CERT, 0x0112)
+#define HI_ERR_CERT_UNKNOWN_CMD                   HI_ERRCODE_DEF(HI_ID_CERT, 0x0113)
+#define HI_ERR_CERT_UNEXPECTED_PORT               HI_ERRCODE_DEF(HI_ID_CERT, 0x0114)
+#define HI_ERR_CERT_REQUIRE_IRQ_FAILED            HI_ERRCODE_DEF(HI_ID_CERT, 0x0115)
+#define HI_ERR_CERT_PV_ACTIVATE                   HI_ERRCODE_DEF(HI_ID_CERT, 0x0116)
+
+#define HI_ERR_MAILBOX_NOT_INIT                   HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x0001)
+#define HI_ERR_MAILBOX_INVALID_HANDLE             HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x0002)
+#define HI_ERR_MAILBOX_INVALID_PTR                HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x0003)
+#define HI_ERR_MAILBOX_INVALID_PARA               HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x0004)
+#define HI_ERR_MAILBOX_INVALID_FLAG               HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x0005)
+#define HI_ERR_MAILBOX_INVALID_RECEIVER           HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x0006)
+#define HI_ERR_MAILBOX_NO_MEMORY                  HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x0007)
+#define HI_ERR_MAILBOX_NOT_SUPPORT                HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x0008)
+#define HI_ERR_MAILBOX_ERR_RECEIVE                HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x0009)
+#define HI_ERR_MAILBOX_UNEXPECTED_RECEIVE_LEN     HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x000A)
+#define HI_ERR_MAILBOX_CRC_CHECK_ERROR            HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x000B)
+#define HI_ERR_MAILBOX_UNKNOWN_CMD                HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x000C)
+#define HI_ERR_MAILBOX_NO_SESSION                 HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x000D)
+#define HI_ERR_MAILBOX_TIMEOUT                    HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x000E)
+#define HI_ERR_MAILBOX_UNKNOWN                    HI_ERRCODE_DEF(HI_ID_MAILBOX, 0x000F)
+
+#define HI_ERR_IFCP_NOT_SUPPORT                   HI_ERRCODE_DEF(HI_ID_IFCP, 0x0001)
+/** @} */  /*! <!-- Macro Definition end */
+
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* End of #ifdef __cplusplus */
+
+
+#endif /* End of #ifndef __HI_UNF_MPI_ERRORCODE_H__ */
+
diff -uNr a/include/hi_go.h b/include/hi_go.h
--- a/include/hi_go.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_go.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,36 @@
+#ifndef __HI_GO_H__
+#define __HI_GO_H__
+
+#include "hi_type.h"
+#include "hi_go_comm.h"
+#include "hi_go_surface.h"
+#include "hi_go_encoder.h"
+#include "hi_go_decoder.h"
+#include "hi_go_bliter.h"
+#include "hi_go_gdev.h"
+#include "hi_go_text.h"
+#include "hi_go_winc.h"
+#include "hi_go_cursor.h"
+#include "hi_go_errno.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/***************************** Macro Definition ******************************/
+
+/*************************** Structure Definition ****************************/
+
+/********************** Global Variable declaration **************************/
+
+/******************************* API declaration *****************************/
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif /* __HI_GO_H__ */
diff -uNr a/include/hi_go_bliter.h b/include/hi_go_bliter.h
--- a/include/hi_go_bliter.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_go_bliter.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,636 @@
+#ifndef __HI_GO_BLITER_H__
+#define __HI_GO_BLITER_H__
+
+#include "hi_go_comm.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/***************************** Macro Definition ******************************/
+
+
+/****************************** Error Number ********************************/
+
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HIGO_BLIT */
+/** @{ */  /** <!-- [HIGO_BLIT] */
+
+/** Pixel-level alpha blending operation*/
+/** CNcomment: 像素级alpha混合操作运算 */
+typedef enum
+{
+    HIGO_COMPOPT_NONE = 0, /**<Porter/Duff None-blending operation*//**<CNcomment:Porter/Duff None混合操作 */
+    HIGO_COMPOPT_CLEAR,    /**<Porter/Duff clear blending operation*//**<CNcomment:Porter/Duff clear混合操作 */
+    HIGO_COMPOPT_SRC     , /**<Porter/Duff SRC blending operation*//**<CNcomment:Porter/Duff Src混合操作 */
+    HIGO_COMPOPT_SRCOVER , /**<Porter/Duff Srcover blending operation*//**<CNcomment:Porter/Duff Srcover混合操作 */
+    HIGO_COMPOPT_DSTOVER , /**<Porter/Duff DstOver blending operation*/ /**<CNcomment:Porter/Duff DstOver混合操作 */
+    HIGO_COMPOPT_SRCIN   , /**<Porter/Duff SrcIn blending operation*//**<CNcomment:Porter/Duff SrcIn混合操作 */
+    HIGO_COMPOPT_DSTIN   , /**<Porter/Duff DstIn blending operation*/ /**<CNcomment:Porter/Duff DstIn混合操作 */
+    HIGO_COMPOPT_SRCOUT  , /**<Porter/Duff SrcOut blending operation*//**<CNcomment:Porter/Duff SrcOut混合操作 */
+    HIGO_COMPOPT_DSTOUT  , /**<Porter/Duff DstOut blending operation*/ /** CNcomment:Porter/Duff DstOut混合操作 */
+    HIGO_COMPOPT_SRCATOP , /**<Porter/Duff SrcAtop blending operation*/ /**<CNcomment:Porter/Duff SrcAtop混合操作 */
+    HIGO_COMPOPT_DSTATOP , /**<Porter/Duff DstAtop blending operation*//**<CNcomment: Porter/Duff DstAtop混合操作 */
+    HIGO_COMPOPT_ADD     ,  /**<Porter/Duff DstAtop blending operation*/ /**<CNcomment: Porter/Duff DstAtop混合操作 */
+    HIGO_COMPOPT_XOR     , /**<Porter/Duff Xor blending operation*/ /**<CNcomment: Porter/Duff Xor混合操作 */
+    HIGO_COMPOPT_DST     , /**<Porter/Duff DstAtop blending operation*/ /**<CNcomment: Porter/Duff DstAtop混合操作 */
+    HIGO_COMPOPT_AKS,      /**<Assume that the destination surface is not transparent. After the alpha blending is performed, the source alpha is retained.*//**<CNcomment: 假设目标surface为不透明，简单alpha混合，结果保留源alpha */
+    HIGO_COMPOPT_AKD,      /**<Assume that the destination surface is not transparent. After the alpha blending is performed, the destination alpha is retained.*//**<CNcomment: 假设目标surface为不透明，简单alpha混合，结果保留目标alpha */
+
+    HIGO_COMPOPT_BUTT
+} HIGO_COMPOPT_E;
+
+/** Operation mode corresponding to colorkey*//** CNcomment: Colorkey对应的操作方式 */
+typedef enum
+{
+    HIGO_CKEY_NONE = 0, /**<Do not use the colorkey.*//**<CNcomment: 不使用colorkey */
+    HIGO_CKEY_SRC,      /**<Use the source colorkey.*//**<CNcomment: 使用源colorkey */
+    HIGO_CKEY_DST,     /**<Use the destination colorkey.*//**<CNcomment: 使用目标colorkey */
+
+    HIGO_CKEY_BUTT
+} HIGO_CKEY_E;
+
+/** Two raster of operations (ROPs)*//** CNcomment: 2元ROP操作 */
+typedef enum
+{
+    HIGO_ROP_BLACK = 0, /**< Blackness */
+    HIGO_ROP_PSDon,     /**< ~(PS+D) */
+    HIGO_ROP_PSDna,     /**< ~PS & D */
+    HIGO_ROP_PSn,       /**< ~PS */
+    HIGO_ROP_DPSna,     /**< PS & ~D */
+    HIGO_ROP_Dn,        /**< ~D */
+    HIGO_ROP_PSDx,      /**< PS^D */
+    HIGO_ROP_PSDan,     /**< ~(PS&D) */
+    HIGO_ROP_PSDa,      /**< PS & D */
+    HIGO_ROP_PSDxn,     /**< ~(PS^D) */
+    HIGO_ROP_D,         /**< D */
+    HIGO_ROP_PSDno,     /**< ~PS + D */
+    HIGO_ROP_PS,        /**< PS */
+    HIGO_ROP_DPSno,     /**< PS + ~D */
+    HIGO_ROP_PSDo,      /**< PS+D */
+    HIGO_ROP_WHITE,     /**< Whiteness */
+
+    HIGO_ROP_BUTT
+} HIGO_ROP_E;
+
+typedef enum
+{
+    HIGO_ROTATE_NONE = 0,
+    HIGO_ROTATE_90,     /**<Rotate 90 degrees clockwise*//**<CNcomment: 顺时针旋转90度 */
+    HIGO_ROTATE_180,    /**<Rotate 180 degrees clockwise*//**<CNcomment: 顺时针旋转180度 */
+    HIGO_ROTATE_270,    /**<Rotate 270 degrees clockwise*//**<CNcomment: 顺时针旋转270度 */
+
+    HIGO_ROTATE_BUTT
+} HIGO_ROTATE_E;
+
+typedef enum
+{
+    HIGO_MIRROR_NONE = 0,
+
+    HIGO_MIRROR_LR,     /**<Mirror the left and the right*//**<CNcomment: 左右镜像 */
+    HIGO_MIRROR_TB,     /**<Mirror the top and the bottom*//**<CNcomment: 上下镜像 */
+
+    HIGO_MIRROR_BUTT
+} HIGO_MIRROR_E;
+
+typedef struct
+{
+    HI_BOOL EnableGlobalAlpha;      /**<Global alpha enable flag*//**<CNcomment: 全局alpha使能标志 */
+    HI_BOOL EnablePixelAlpha;       /**<Pixel alpha enable flag*//**<CNcomment: 像素alpha使能标志 */
+    HIGO_COMPOPT_E PixelAlphaComp;  /**<Pixel alpha operation*//**<CNcomment: 像素alpha操作 */
+    HIGO_CKEY_E    ColorKeyFrom;    /**<Colorkey operation*//**<CNcomment:ColorKey操作 */
+    HI_BOOL        EnableRop;       /**<Enable the ROP2 operation*//**<CNcomment: 启用ROP2操作 */
+    HIGO_ROP_E     Rop;              /**<ROP2 operation type*//**<CNcomment: ROP2操作类型 */
+    HIGO_ROP_E     RopAlpha;         /**<Type of the ROP alpha operation*//**<CNcomment: ROP alpha操作类型*/
+ }HIGO_BLTOPT2_S;
+
+/** CNcomment: blit操作属性 */
+typedef struct
+{
+    HI_BOOL EnableGlobalAlpha;      /**<Global alpha enable flag. If this flag is enabled, the PixelAlphaComp blending mode must be specified.*//**<CNcomment: 全局alpha使能标志,打开此开关之外还必须指定PixelAlphaComp的混合方式*/
+    HI_BOOL EnablePixelAlpha;       /**<Pixel alpha enable flag*//**<CNcomment: 像素alpha使能标志 */
+    HIGO_COMPOPT_E PixelAlphaComp;  /**<Pixel alpha operation*//**<CNcomment: 像素alpha操作 */
+    HIGO_CKEY_E    ColorKeyFrom;    /**<colorkey operation*//**<CNcomment: ColorKey操作 */
+    HI_BOOL        EnableRop;       /**<Enable the ROP2 operation*//**<CNcomment: 启用ROP2操作 */
+    HIGO_ROP_E     Rop;             /**<ROP2 operation type*//**<CNcomment: ROP2操作类型 */
+    HIGO_ROP_E     RopAlpha;        /**<Type of the ROP alpha operation*/    /**<CNcomment: ROP alpha操作类型*/
+    HI_BOOL        EnableScale;      /**<Enable the scaling function*//**<CNcomment: 启用缩放 */
+    HIGO_ROTATE_E  RotateType;      /**<Rotation type*//**<CNcomment: 旋转方式 */
+    HIGO_MIRROR_E  MirrorType;      /**<Mirror type*//**<CNcomment: 镜像方式 */
+} HIGO_BLTOPT_S;
+
+typedef struct
+{
+    HI_BOOL EnableGlobalAlpha;      /**<Global alpha enable flag*//**<CNcomment: 全局alpha使能标志 */
+
+    HIGO_COMPOPT_E PixelAlphaComp;  /**<Pixel alpha operation*//**<CNcomment: 像素alpha操作 */
+    HI_BOOL        EnableRop;       /**<Enable the ROP2 operation*//**<CNcomment: 启用ROP2操作 */
+    HIGO_ROP_E     RopColor;        /**<ROP2 operation type*//**<CNcomment: ROP2操作类型 */
+	HIGO_ROP_E     RopAlpha;
+
+} HIGO_MASKOPT_S;
+
+/**Anti-flicker level*//** CNcomment: 抗闪烁级别 */
+typedef enum
+{
+    HIGO_DEFLICKER_AUTO = 0, /*Anti-flicker level, ranging from low to high. The higher the level, the better the anti-flicker effect, but the more blurred the picture.*//** CNcomment:抗闪烁级别，值为LOW~HIGH,值越大抗闪烁效果越好，但越模糊*/
+    HIGO_DEFLICKER_LOW,
+    HIGO_DEFLICKER_MIDDLE,
+    HIGO_DEFLICKER_HIGH,
+    HIGO_DEFLICKER_BUTT
+}HIGO_DEFLICKEROPT_E;
+
+/**Anti-flicker level*//** CNcomment: 抗闪烁级别 */
+typedef struct
+{
+    HIGO_DEFLICKEROPT_E DefLevel;
+}HIGO_DEFLICKEROPT_S;
+/** @} */  /*! <!-- Structure Definition end */
+
+/********************** Global Variable declaration **************************/
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HIGO_BLIT */
+/** @{ */  /** <!-- 【HIGO_BLIT】 */
+
+/**
+\brief Initializes the Bliter module.CNcomment: 初始化Bliter模块 CNend
+\attention \n
+When ::HI_GO_Init is called, this application programming interface (API) is also called.CNcomment: ::HI_GO_Init中已包含了对该接口的调用 CNend
+\param  N/A.CNcomment: 无 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_DEPEND_TDE
+
+\see \n
+::HI_GO_Init \n
+::HI_GO_DeinitBliter
+*/
+HI_S32 HI_GO_InitBliter(HI_VOID);
+
+/**
+\brief Deinitializes the Bliter module.CNcomment:去初始化Bliter模块 CNend
+\attention \n
+When ::HI_GO_Deinit is called, this API is also called.CNcomment:::HI_GO_Deinit中已包含了对该接口的调用 CNend
+\param N/A. CNcomment:无 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+
+\see \n
+::HI_GO_Deinit \n
+::HI_GO_InitBliter
+*/
+
+HI_S32 HI_GO_DeinitBliter(HI_VOID);
+
+/**
+\brief Fills in a rectangle.CNcomment:矩形填充 CNend
+\attention \n
+N/A.CNcomment:无 CNend
+\param[in] Surface Surface handle.CNcomment:Surface句柄 CNend
+\param[in] pRect Size of the rectangle to be filled in. If the parameter is not set, it indicates that the entire
+surface is filled in.CNcomment: 填充矩形大小，为空表示填充整个surface CNend
+\param[in] Color Color Fill color. For the RGB format, 32-bit color is filled in; for the palette, the color index (0-255)
+is filled in.CNcomment:填充颜色,注意如果是RGB格式，统一填充32位色，如果调色板，就直接填充颜色索引(0 ~ 255)。CNend
+\param[in] CompositeOpt Blending mode.CNcomment:混合方式 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_OUTOFPAL
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+\see \n
+N/A. CNcomment:无 CNend
+*/
+HI_S32 HI_GO_FillRect(HI_HANDLE Surface, const HI_RECT* pRect, HI_COLOR Color, HIGO_COMPOPT_E CompositeOpt);
+
+/**
+\brief Transfers bit blocks. During the transfer, color space conversion (CSC), scaling, and rotation are supported.CNcomment:位块搬移，在搬移过程中，可以实现色彩空间转换、缩放、旋转功能 CNend
+\attention \n
+Only the YUV-to-RGB CSC is supported. \n
+The operations of colorkey, alpha, ROP, and colorkey+ROP are supported.\
+Scaling, rotation, and mirror cannot be combined. \n
+For scaling, rotation, and mirror, the source and destination pixel formats must be the same, but the format cannot
+be YUV or CLUT.\n
+CNcomment:色彩空间转换仅支持YUV到RGB转换 \n
+可以支持操作如下colorkey、alpha、ROP、colorkey+ROP\
+缩放、旋转或镜像不可组合使用 \n
+缩放、旋转或镜像要求源与目标像素格式完全相同，但不能是YUV格式和CLUT格式 \n CNend
+
+\param[in] SrcSurface Source surface handle.CNcomment:源surface句柄 CNend
+\param[in] pSrcRect Source region for transfer. If the parameter is not set, it indicates the entire source surface.CNcomment:搬移的源区域，为空表示整个源surface区域 CNend
+\param[in] DstSurface Destination surface handle.CNcomment:目的surface句柄 CNend
+\param[in] pDstRect Destination region for transfer. If the parameter is not set, it indicates the entire destination
+surface.CNcomment:搬移的目的区域，为空表示整个目标surface区域 CNend
+\param[in] pBlitOpt Blending mode.CNcomment:混合方式 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVMIRRORTYPE
+\retval ::HIGO_ERR_INVROTATETYPE
+\retval ::HIGO_ERR_INVCKEYTYPE
+\retval ::HIGO_ERR_INVROPTYPE
+\retval ::HIGO_ERR_NOCOLORKEY
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+\retval ::HIGO_ERR_INTERNAL
+
+\see \n
+N/A. CNcomment:无 CNend
+*/
+HI_S32 HI_GO_Blit (HI_HANDLE SrcSurface, const HI_RECT* pSrcRect,
+                   HI_HANDLE DstSurface, const HI_RECT* pDstRect,
+                   const HIGO_BLTOPT_S* pBlitOpt);
+
+/**
+\brief Draws a line segment. Cropping is not supported.CNcomment:绘制线段，不支持裁减 CNend
+\attention \n
+Cropping is not supported. Users must keep the entire line within the surface region.
+CNcomment:不支持裁减，使用者必须保证整条直线在surface区域内 CNend
+
+\param[in] Surface Destination surface handle.CNcomment:目的surface句柄 CNend
+\param[in] x0 Horizontal coordinate of the start point.CNcomment:起点x坐标 CNend
+\param[in] y0 Vertical coordinate of the start point.CNcomment:起点y坐标 CNend
+\param[in] x1 Horizontal coordinate of the end point.CNcomment:终点x坐标 CNend
+\param[in] y1 Vertical coordinate of the end point .CNcomment:终点y坐标 CNend
+\param[in] color Line segment color.CNcomment:线段颜色 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_DEPEND_TDE
+
+\see \n
+N/A. CNcomment:无 CNend
+*/
+HI_S32 HI_GO_DrawLine(HI_HANDLE Surface, HI_S32 x0, HI_S32 y0, HI_S32 x1, HI_S32 y1, HI_COLOR color);
+
+/**
+\brief Draws an ellipse.CNcomment:绘制椭圆 CNend
+\attention \n
+Cropping is not supported. Users must keep the entire ellipse within the surface region.
+CNcomment:不支持裁减，使用者必须保证整个椭圆在surface区域内 CNend
+
+\param[in] Surface Destination surface handle.CNcomment:目的surface句柄 CNend
+\param[in] sx Horizontal coordinate of the ellipse center.CNcomment:圆心x坐标 CNend
+\param[in] sy Vertical coordinate of the ellipse center.CNcomment:圆心y坐标 CNend
+\param[in] rx X axis radius .CNcomment:x轴半径 CNend
+\param[in] ry Y axis radius.CNcomment:y轴半径 CNend
+\param[in] color Ellipse color.CNcomment:椭圆颜色 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORTED
+
+\see \n
+N/A. CNcomment:无 CNend
+*/
+HI_S32 HI_GO_DrawEllipse(HI_HANDLE Surface, HI_S32 sx, HI_S32 sy, HI_S32 rx, HI_S32 ry, HI_COLOR color);
+
+/**
+\brief Draws a circle. Cropping is not supported.CNcomment:绘制圆，不支持裁减 CNend
+\attention \n
+Cropping is not supported. Users must keep the entire circle within the surface region.
+CNcomment:不支持裁减，使用者必须保证整个圆在surface区域内 CNend
+
+\param[in] Surface Destination surface handle.CNcomment:目的surface句柄 CNend
+\param[in] x Horizontal coordinate of the circle center.CNcomment:圆心x坐标 CNend
+\param[in] y Vertical coordinate of the circle center.CNcomment:圆心y坐标 CNend
+\param[in] r Radius.CNcomment:半径 CNend
+\param[in] color Circle color. The circle is filled in with 32-bit colors.CNcomment:圆颜色, 颜色按照32位色进行填充 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORTED
+
+\see \n
+N/A. CNcomment:无 CNend
+*/
+HI_S32 HI_GO_DrawCircle(HI_HANDLE Surface, HI_S32 x, HI_S32 y, HI_S32 r, HI_COLOR color);
+
+/**
+\brief Draws a rectangle.CNcomment:绘制矩形 CNend
+\attention \n
+If the rectangle is empty, it indicates that the rectangle size is the same as surface.
+Cropping is not supported; therefore, you must ensure that the entire rectangle is within the surface.
+CNcomment:矩形为空表示输出矩形大小与surface相同
+不支持裁减，使用者必须保证整个矩形在surface区域内 CNend
+
+\param[in] Surface Destination surface handle.CNcomment:目的surface句柄 CNend
+\param[in] pRect Rectangle region.CNcomment:矩形区域 CNend
+\param[in] color Rectangle color.CNcomment:矩形颜色 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORTED
+
+\see \n
+N/A. CNcomment:无 CNend
+*/
+HI_S32 HI_GO_DrawRect(HI_HANDLE Surface, const HI_RECT* pRect, HI_COLOR color);
+
+/**
+\brief Performs the mask ROP or mask blend transfer on the raster bitmap.CNcomment:对光栅位图进行Mask Rop或者Mask Blend搬移操作 CNend
+\attention \n
+The mask bitmap is in A1 or A8 format.
+You need to overlay the mask bitmap with the source bitmap, overlay the result with the destination bitmap, and then
+output the final result to the destination bitmap.
+If the ROP and blending operation are perform at the same time, only the ROP takes effect.
+CNcomment:Mask是A1或A8的位图Surface。
+首先将Mask位图与源位图做一次叠加，然后用叠加的结果和目标做叠加输出到目标位图
+Rop和Blend混合同时只能有一个是有效的，两者都选只有Rop生效 CNend
+
+\param[in] SrcSurface Source surface handle.CNcomment:源surface句柄 CNend
+\param[in] pSrcRect Source rectangle.CNcomment:源矩形 CNend
+\param[in] DstSurface Destination surface handle.CNcomment:目标surface句柄 CNend
+\param[in] pDstRect Destination rectangle.CNcomment:目标矩形 CNend
+\param[in] MaskSurface Mask surface handle.CNcomment:MASK surface句柄 CNend
+\param[in] pMaskRect Mask rectangle.CNcomment:MASK矩形 CNend
+\param[in] pOpt Operation option.CNcomment:操作选项 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_INVROPTYPE
+\retval ::HIGO_ERR_INVRECT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_INTERNAL
+
+\see \n
+N/A. CNcomment:无 CNend
+*/
+
+HI_S32 HI_GO_MaskBlit(HI_HANDLE SrcSurface, const HI_RECT* pSrcRect,
+                      HI_HANDLE DstSurface, const HI_RECT* pDstRect,
+                      HI_HANDLE MaskSurface, const HI_RECT* pMaskRect,
+                      const HIGO_MASKOPT_S* pOpt);
+
+/**
+\brief Transfers bit blocks. During the transfer, CSC is supported.CNcomment:位块搬移，在搬移过程中，可以实现色彩空间转换 CNend
+\attention \n
+Only the YUV-to-RGB CSC is supported. \n
+The operations of colorkey, alpha, ROP, and colorkey+ROP are supported.\
+CNcomment: 色彩空间转换仅支持YUV到RGB转换 \n
+可以支持操作如下colorkey、alpha、ROP、colorkey+ROP\ CNend
+
+\param[in] SrcSurface Source surface handle.CNcomment:源surface句柄 CNend
+\param[in] pSrcRect Source region for transfer. If the parameter is not set, it indicates the entire source surface.CNcomment:搬移的源区域，为空表示整个源surface区域 CNend
+\param[in] DstSurface Destination surface handle.CNcomment:目的surface句柄 CNend
+\param[in] pDstRect Destination region for transfer. If the parameter is not set, it indicates the entire destination
+surface.CNcomment:搬移的目的区域，为空表示整个目标surface区域 CNend
+\param[in] pBlitOpt Blending mode. If the parameter is not set, default settings are used. CNcomment:混合方式，参数为空使用默认参数操作 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_INVCKEYTYPE
+\retval ::HIGO_ERR_INVROPTYPE
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+
+\see \n
+N/A. CNcomment:无 CNend
+*/
+HI_S32 HI_GO_BitBlit (HI_HANDLE SrcSurface, const HI_RECT* pSrcRect,
+                       HI_HANDLE DstSurface, const HI_RECT* pDstRect,
+                       const HIGO_BLTOPT2_S* pBlitOpt);
+
+/**
+\brief Transfers bit blocks. During the transfer, CSC and scaling are supported. CNcomment:位块搬移，在搬移过程中，可以实现色彩空间转换, 缩放 CNend
+\attention \n
+Only the YUV-to-RGB CSC is supported. \n
+The operations of colorkey, alpha, ROP, and colorkey+ROP are supported.\
+CNcomment:色彩空间转换仅支持YUV到RGB转换 \n
+可以支持操作如下colorkey、alpha、ROP、colorkey+ROP\ CNend
+
+\param[in] SrcSurface  Source surface handle. CNcomment:源surface句柄 CNend
+\param[in] pSrcRect Source region for transfer. If the parameter is not set, it indicates the entire source surface.CNcomment:搬移的源区域，为空表示整个源surface区域 CNend
+\param[in] DstSurface Destination surface handle. CNcomment:目的surface句柄 CNend
+\param[in] pDstRect pDstRect Destination region for transfer. If the parameter is not set, it indicates the entire destination
+surface. CNcomment:搬移的目的区域，为空表示整个目标surface区域 CNend
+\param[in] pBlitOpt Blending mode. If the parameter is not set, default settings are used. CNcomment:混合方式,参数为空使用默认参数操作 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_INVCKEYTYPE
+\retval ::HIGO_ERR_INVROPTYPE
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+
+\see \n
+N/A. CNcomment:无 CNend
+*/
+HI_S32 HI_GO_StretchBlit (HI_HANDLE SrcSurface, const HI_RECT* pSrcRect,
+                       HI_HANDLE DstSurface, const HI_RECT* pDstRect,
+                       const HIGO_BLTOPT2_S* pBlitOpt);
+
+/**
+\brief  Fills in the pattern.CNcomment:进行模式填充 CNend
+\attention \n
+\param[in] SrcSurface  Source surface handle. CNcomment:源surface句柄 CNend
+\param[in] pSrcRect  Source region for transfer. If the parameter is not set, it indicates the entire source surface.CNcomment:搬移的源区域，为空表示整个源surface区域 CNend
+\param[in] DstSurface  Destination surface handle. CNcomment:目的surface句柄 CNend
+\param[in] pDstRect  Destination region for transfer. If the parameter is not set, it indicates the entire destination
+surface.CNcomment:搬移的目的区域，为空表示整个目标surface区域 CNend
+\param[in] pParOpt  Blending mode. If the parameter is not set, default settings are used. CNcomment:混合方式,参数为空使用默认参数操作 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_INVCKEYTYPE
+\retval ::HIGO_ERR_INVROPTYPE
+\retval ::HIGO_ERR_NOCOLORKEY
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+
+\see \n
+N/A. CNcomment:无 CNend
+*/
+HI_S32 HI_GO_PatternBlit(HI_HANDLE SrcSurface, const HI_RECT* pSrcRect,
+                              HI_HANDLE DstSurface, const HI_RECT * pDstRect,
+                              const HIGO_BLTOPT2_S* pParOpt);
+
+/**
+\brief Performs anti-flicker and transfer. This API is used for the second anti-flicker.CNcomment:抗闪烁搬移，这个接口用于第二次抗闪烁，CNend
+\attention \n
+This API is used in the following two application scenarios:
+1. The automatic anti-flicker effect of a graphics layer is poor.
+2. The buffer mode of a graphics layer is single-buffer mode (HIGO_LAYER_BUFFER_SINGLE). In this case, users need to
+perform anti-flicker by themselves.
+When the sizes of the source bitmap and destination bitmap are different, scaling is performed automatically.
+CNcomment:两种情况用到该接口
+1 当图层的自动抗闪烁效果不是很好时，可以使用这个接口再做一次。
+2 当图层的buffer模式是单buffer模式(HIGO_LAYER_BUFFER_SINGLE)时，用户需要自己做抗闪烁，
+当源和目标大小不同的时候自动进行缩放。CNend
+
+\param[in] SrcSurface  SrcSurface Source surface handle.CNcomment: 源surface句柄 CNend
+\param[in] pSrcRect  pSrcRect Source region for transfer. If the parameter is not set, it indicates the entire source surface.CNcomment:搬移的源区域，为空表示整个源surface区域 CNend
+\param[in] DstSurface  DstSurface Destination surface handle. CNcomment:目的surface句柄 CNend
+\param[in] pDstRect  pDstRect Destination region for transfer. If the parameter is not set, it indicates the entire destination
+surface. CNcomment:搬移的目的区域，为空表示整个目标surface区域 CNend
+\param[in] pDefOpt  pDefOpt Anti-flicker level. If this parameter is not set, it indicates the automatic level. CNcomment:抗闪烁级别选项，为空表示AUTO 级别 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_INVCKEYTYPE
+\retval ::HIGO_ERR_INVROPTYPE
+\retval ::HIGO_ERR_NOCOLORKEY
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+
+\see \n
+N/A. CNcomment:无 CNend
+*/
+HI_S32 HI_GO_DeflickerBlit(HI_HANDLE SrcSurface, const HI_RECT* pSrcRect,
+                                 HI_HANDLE DstSurface, const HI_RECT * pDstRect,
+                                 const HIGO_DEFLICKEROPT_S* pDefOpt);
+
+/**
+\brief Do the alpha blending between the forground surface and the backgroud surface, transfers the result to the destination surface. The background surface and the destination surface must be in the RGB color space.
+You can performs color space coversion, scale, or mirror, colorkey with alpha blending.CNcomment:该函数实现前景和背景叠加输出到目标功能，背景和目标surface必须位于RGB空间，在叠加过程中可以附加颜色空间转换、缩放、镜像等操作，不支持旋转。CNend
+\attention \n
+Only the YUV-to-RGB CSC is supported. \n
+The operations of colorkey, alpha, ROP, and colorkey+ROP are supported, rotation is not supported.\
+Scaling, and mirror cannot be combined. \n
+For scaling, and mirror, the source and destination pixel formats must be the same, but the format cannot
+be YUV or CLUT.\n
+CNcomment:色彩空间转换仅支持YUV到RGB转换 \n
+可以支持操作如下colorkey、alpha、ROP、colorkey+ROP，不支持缩放\
+缩放、镜像不可组合使用 \n
+缩放或镜像要求源与目标像素格式完全相同，但不能是YUV格式和CLUT格式 \n CNend
+
+\param[in] BckSurface background surface handle.CNcomment:背景surface句柄 CNend
+\param[in] pBckRect backgound region for transfer. If the parameter is not set, it indicates the entire background surface.CNcomment:背景surface操作区域，为空表示整个背景surface区域 CNend
+\param[in] ForSurface forground surface handle.CNcomment:前景surface句柄 CNend
+\param[in] pForRect forground region for transfer. If the parameter is not set, it indicates the entire forground surface.
+surface.CNcomment:前景surface操作区域，为空表示整个前景surface区域 CNend
+\param[in] DstSurface destination surface handle.CNcomment:目标surface句柄 CNend
+\param[in] pDstRect destination region for transfer. If the parameter is not set, it indicates the entire destination surface.
+surface.CNcomment:搬移的目的区域，为空表示整个目标surface区域 CNend
+\param[in] pBlitOpt Blending mode.CNcomment:混合方式 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVMIRRORTYPE
+\retval ::HIGO_ERR_INVROTATETYPE
+\retval ::HIGO_ERR_INVCKEYTYPE
+\retval ::HIGO_ERR_INVROPTYPE
+\retval ::HIGO_ERR_NOCOLORKEY
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+\retval ::HIGO_ERR_INTERNAL
+
+\see \n
+N/A. CNcomment:无 CNend
+*/
+HI_S32 HI_GO_Blit3Source(HI_HANDLE BckSurface, const HI_RECT* pBckRect,
+                   HI_HANDLE ForSurface, const HI_RECT* pForRect,
+                   HI_HANDLE DstSurface, const HI_RECT* pDstRect,
+                   const HIGO_BLTOPT_S* pBlitOpt);
+/**
+\brief Fills in a rounded rectangle.CNcomment:圆角矩形填充 CNend
+\attention \n
+N/A.CNcomment:无 CNend
+\param[in] Surface Surface handle.CNcomment:Surface句柄 CNend
+\param[in] pRect Size of the rectangle to be filled in. If the parameter is not set, it indicates that the entire
+surface is filled in.CNcomment: 填充矩形大小，为空表示填充整个surface CNend
+\param[in] Color Color Fill color. For the RGB format, 32-bit color is filled in; for the palette, the color index (0-255)
+is filled in.CNcomment:填充颜色,注意如果是RGB格式，统一填充32位色，如果调色板，就直接填充颜色索引(0 ~ 255)。CNend
+\param[in] s32Radius radius.CNcomment:圆角半径 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_OUTOFPAL
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+\see \n
+N/A. CNcomment:无 CNend
+*/
+
+HI_S32 HI_GO_FillRoundRect(HI_HANDLE Surface, const HI_RECT* pRect, HI_COLOR Color, HI_S32 s32Radius);
+
+/** @} */  /*! <!-- API declaration end */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif /* __HI_GO_BLITER_H__ */
diff -uNr a/include/hi_go_comm.h b/include/hi_go_comm.h
--- a/include/hi_go_comm.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_go_comm.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,242 @@
+#ifndef __HI_GO_COMM_H__
+#define __HI_GO_COMM_H__
+
+#include "hi_type.h"
+#include "hi_go_errno.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/***************************** Macro Definition ******************************/
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HIGO_COMMON */
+/** @{ */  /**<!―[HIGO_COMMON] */
+
+/**Maximum number of colors in the palette*//** CNcomment: 调色板最大颜色数 */
+#define MAX_PALETTE_COLOR_SIZE 256
+
+/**Color value*//** CNcomment: 颜色值 */
+typedef HI_U32 HI_COLOR;
+
+/**Palette*//** CNcomment: 调色板 */
+typedef HI_COLOR HI_PALETTE[MAX_PALETTE_COLOR_SIZE];
+
+typedef enum
+{
+    HIGO_IMGTYPE_JPEG = 0, /**<.jpeg picture*//**<CNcomment: JPEG格式图片*/
+    HIGO_IMGTYPE_GIF,      /**<.gif picture*//**<CNcomment: GIF格式图片*/
+    HIGO_IMGTYPE_BMP,      /**<.bmp picture*//**<CNcomment: BMP格式图片 */
+    HIGO_IMGTYPE_PNG,      /**<.png picture*//**<CNcomment: PNG格式图片 */
+    HIGO_IMGTYPE_RLE,      /**<.rle picture*//**<CNcomment: RLE格式图片 */
+    HIGO_IMGTPYE_BUTT
+} HIGO_IMGTYPE_E;
+
+
+/**Rectangle*//** CNcomment: 矩形 */
+typedef struct
+{
+    HI_S32 x, y;
+
+    HI_S32 w, h;
+} HI_RECT;
+
+typedef HI_RECT HI_POINT;
+
+/**Region*//** CNcomment: 区域 */
+typedef struct
+{
+    HI_S32 l;
+    HI_S32 t;
+    HI_S32 r;
+    HI_S32 b;
+} HI_REGION;
+
+/**Mode of adjusting the window z-order*//**CNcomment:Z序调整方式*/
+typedef enum
+{
+    HIGO_ZORDER_MOVETOP = 0,  /**<Move to the top*//**<CNcomment:移到最顶部*/
+    HIGO_ZORDER_MOVEUP,       /**<Move upwards*//**<CNcomment:向上移*/
+    HIGO_ZORDER_MOVEBOTTOM,   /**<Move to the bottom*//**<CNcomment:移到最底部*/
+    HIGO_ZORDER_MOVEDOWN,     /**<Move downwards*//**<CNcomment:向下移*/
+    HIGO_ZORDER_BUTT
+} HIGO_ZORDER_E;
+
+#define HIGO_INVALID_HANDLE 0x0
+
+/**Stream position*//** CNcomment: 流式位置*/
+
+
+/** @} */  /*! <!-- Structure Definition end */
+
+/********************** Global Variable declaration **************************/
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HIGO_COMMON */
+/** @{ */  /** <!―[HIGO_COMMON] */
+
+
+/**
+\brief Initializes the HiGo.CNcomment:HiGo初始化 CNend
+\attention \n
+Before using the HiGo, you must call this application programming interface (API) to initialize the HiGo. The HiGo
+includes the graphic device (Gdev) module, decoder, Winc module, bit block transfer (Bliter) module, and surface
+module.
+CNcomment:使用HiGo功能必须先调用该接口，完成HiGo的初始化，主要包括gdev, decoder, winc, blit, surface模块 CNend
+\param N/A.CNcomment:无 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_INITFAILED
+
+\see \n
+::HI_GO_Deinit
+*/
+HI_S32	HI_GO_Init(HI_VOID);
+
+/**
+\brief Deinitializes the HiGo.CNcomment: HiGo去初始化 CNend
+\attention \n
+If the HiGo is not used, you need to call this API to release resources.CNcomment: 不再使用HiGo功能时需要调用该接口，释放资源 CNend
+\param N/A.CNcomment: 无 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_DEINITFAILED
+
+\see \n
+::HI_GO_Init
+*/
+HI_S32	HI_GO_Deinit(HI_VOID);
+
+/**
+\brief Initializes the extended library of the HiGo.CNcomment:HiGo 扩展库初始化 CNend
+\attention \n
+If the extended library of the HiGo is not used, you need to call this API to release resources, especially the
+resources of the cursor and text modules.
+CNcomment:主要是CURSOR和TEXT模块。CNend
+\param N/A.CNcomment:无 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_DEINITFAILED
+
+\see \n
+::HI_GO_DeInitExt
+*/
+HI_S32 HI_GO_InitExt(HI_VOID);
+
+/**
+\brief Deinitializes the extended library of the HiGo.CNcomment: HiGo扩展库去初始化 CNend
+\attention \n
+If the HiGo is not used, you need to call this API to release resources.CNcomment: 不再使用HiGo扩展库功能时需要调用该接口，释放资源，主要是CURSOR和TEXT模块。CNend
+\param N/A.CNcomment: 无 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_DEINITFAILED
+
+\see \n
+::HI_GO_InitExt
+*/
+HI_S32 HI_GO_DeInitExt(HI_VOID);
+
+/**
+\brief Obtains the version information.CNcomment:获取版本信息 CNend
+\attention \n
+N/A.CNcomment:无 CNend
+\param[out] ppVersion Output address of the version information string. The value cannot be empty.CNcomment: 版本信息字符串输出地址，不可为空 CNend
+\param[out] ppBuildTime Build Output address of the time string. The value cannot be empty.CNcomment:Build时间字符串输出地址，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NULLPTR
+
+\see \n
+N/A.CNcomment:无 CNend
+*/
+HI_S32 HI_GO_GetVersion(HI_CHAR ** ppVersion, HI_CHAR **ppBuildTime);
+
+/**
+\brief Converts the data on a surface into a .bmp picture for output.CNcomment: 将Surface中的数据转换成BMP格式图象输出。CNend
+\attention \n
+The output file is [year]-[date]-[hour]-[min]-[second]-[ms].bmp.CNcomment: 输出文件名为[year]-[date]-[hour]-[min]-[second]-[ms].bmp CNend
+The output picture must be a 16-bit bitmap.CNcomment: 输出图片固定为16位图。CNend
+It is recommended that you call HI_GO_EncodeToFile rather than HI_GO_Surface2Bmp.CNcomment: 建议使用HI_GO_EncodeToFile接口来代替此接口 CNend
+
+\param[in] Surface Data to be captured.CNcomment: 需要进行截屏的数据。CNend
+\param[in] pRect Pointer to a rectangle. If this parameter is not set, it indicates the entire surface.CNcomment: 区域指针,为空表示整个surface。CNend
+
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVSURFACESIZE
+\retval ::HIGO_ERR_INVSURFACEPF
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NOMEM
+
+*/
+HI_S32	HI_GO_Surface2Bmp(HI_HANDLE Surface, const HI_RECT *pRect);
+
+/**
+\brief Enables the memory management module.CNcomment:使能内存管理模块 CNend
+\attention \n
+The memory management module is disabled by default. Before using the memory statistics function, you must call this
+API to enable the memory management module.
+CNcomment:默认情况处于非使能状态，只有该接口打开后才能使用内存统计功能 CNend
+
+\param[in] bEnable Whether to enable the memory statistics function.CNcomment:是否开启内存统计功能 CNend
+
+\retval ::HI_SUCCESS
+
+*/
+HI_S32 HI_GO_EnableMemMng(HI_BOOL bEnable);
+
+
+
+/**
+\brief Obtains the enable status of the memory management module.CNcomment:获取内存管理模块使能状态 CNend
+\attention \n
+\param[out] pbEnable Whether to obtain the enable status of the memory statistics function.CNcomment:获取内存统计功能是否开启 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NULLPTR
+
+*/
+HI_S32 HI_GO_GetMemMngStatus(HI_BOOL *pbEnable);
+
+/**
+\brief Outputs the general information about the system memory.CNcomment:输出系统内存的总体信息 CNend
+\attention \n
+\param N/A.CNcomment:无 CNend
+
+\retval ::HI_SUCCESS
+*/
+HI_S32 HI_GO_SysMemQuene(HI_VOID);
+
+/**
+\brief Outputs the general information about the media memory zone (MMZ).CNcomment: 输出MMZ内存的总体信息。CNend
+\attention \n
+\param N/A.CNcomment:无 CNend
+
+\retval ::HI_SUCCESS
+
+*/
+HI_S32 HI_GO_MMZMemQuene(HI_VOID);
+
+/** @} */  /*! <!-- API declaration end */
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif /* __HI_GO_COMM_H__ */
diff -uNr a/include/hi_go_cursor.h b/include/hi_go_cursor.h
--- a/include/hi_go_cursor.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_go_cursor.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,217 @@
+#ifndef _HI_GO_CURSOR_H
+#define _HI_GO_CURSOR_H
+
+#include "hi_go_comm.h"
+#include "hi_go_gdev.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HIGO_CURSOR */
+/** @{ */  /** <!-- [HIGO_CURSOR] */
+
+typedef struct
+{
+    HI_HANDLE hCursor;    /**<The maximum resolution is 128x128, and the minimum resolution is 16x16 for the cursor picture. Both pixel alpha and colorkey are supported.*/
+    				      /**<CNcomment: 光标图片最大128*128,最小16*16像素, 支持像素alpha和colorkey */
+    HI_U32    HotspotX;   /**<Horizontal coordinate of the cursor hot spot relative to the cursor picture*//**<CNcomment: 光标热点X坐标，相对于图片 */
+    HI_U32    HotspotY;   /**<Vertical coordinate of the cursor+ hot spot relative to the cursor picture*//**<CNcomment: 光标热点Y坐标，相对于图片 */
+} HIGO_CURSOR_INFO_S;
+
+/**Status of the cursor layer*//** CNcomment: 光标层状态结构 */
+typedef struct
+{
+    HI_BOOL bShow;             /**<Whether to display the cursor layer.*//**<CNcomment: 光标层是否显示 */
+} HIGO_CURSOR_STATUS_S;
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HIGO_CURSOR */
+/** @{ */  /** <!-- [HIGO_CURSOR] */
+
+/**
+\brief Initializes the cursor module.CNcomment:光标初始化 CNend
+\attention \n
+
+\param N/A.CNcomment:无 CNend
+
+\retval ::HI_SUCCESS Success.CNcomment:成功 CNend
+\retval ::HI_FAILURE The display fails.CNcomment: 显示失败 CNend
+\retval ::HIGO_ERR_INITFAILED
+\retval ::HIGO_ERR_DEPEND_CURSOR
+
+\see \n
+::HI_GO_DeinitCursor
+*/
+
+HI_S32 HI_GO_InitCursor();
+
+/**
+\brief Deinitializes the cursor module.CNcomment:去初始化光标初始化 CNend
+\attention \n
+
+\param N/A.CNcomment:无 CNend
+
+\retval ::HI_SUCCESS Success.CNcomment:成功 CNend
+\retval ::HI_FAILURE The display fails.CNcomment:显示失败 CNend
+\retval ::HIGO_ERR_NOTINIT
+
+\see \n
+::HI_GO_InitCursor
+*/
+
+HI_S32 HI_GO_DeinitCursor();
+
+/**
+\brief  Displays the cursor layer.CNcomment:显示光标 CNend
+\attention \n
+1. The cursor of the output layer is located in the middle of the screen by default.CNcomment:1 输出层的光标位置默认在屏幕中间 CNend
+2. You need set the cursor information before the cursor layer is displayed.CNcomment:2.show光标的时候，需要首先设置光标的信息。CNend
+\param[in] bVisible Visible status of the cursor layer. HI_TRUE: visible; HI_FASLE: invisible.CNcomment:光标层可见状态， HI_TRUE:可见， HI_FASLE:光标层不可见。CNend
+
+\retval ::HI_SUCCESS Success.CNcomment:成功 CNend
+\retval ::HI_FAILURE The display fails.CNcomment:显示失败 CNend
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NOCURSORINF
+\retval ::HIGO_ERR_DEPEND_CURSOR
+
+\see \n
+::HI_GO_GetCursorStatus
+::HI_GO_SetCursorInfo
+*/
+HI_S32 HI_GO_ShowCursor(HI_BOOL bVisible);
+
+/**
+\brief Obtains the current status of the cursor layer.CNcomment:获取光标层当前状态 CNend
+\attention \n
+N/A.CNcomment:无 CNend
+
+\param[out] pCursorStatus Pointer to the current status of the cursor layer. The value cannot be empty.CNcomment:光标层当前状态结构指针，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_CURSOR
+
+\see \n
+::HI_GO_ShowLayer
+*/
+HI_S32 HI_GO_GetCursorStatus( HIGO_CURSOR_STATUS_S* pCursorStatus);
+
+/**
+\brief Moves the cursor to a specified position on a specified screen.CNcomment:移动光标到指定屏幕指定位置 CNend
+\attention \n
+The cursor position can be changed only when the cursor status is show.CNcomment:必须在cursor为show的情况下才能改变光标位置 CNend
+
+\param[in] x Horizontal coordinate (in pixel) of the cursor on the screen relative to the canvas surface of a
+graphics layer.CNcomment: 屏幕X坐标,单位像素, 相对于图层canvas surface CNend
+\param[in] y Vertical coordinate (in pixel) of the cursor on the screen relative to the canvas surface of a graphics
+layer.CNcomment:屏幕Y坐标,单位像素, 相对于图层canvas surface CNend
+
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HI_SUCCESS Success.CNcomment:成功 CNend
+\retval ::HI_FAILURE The display fails.CNcomment:显示失败 CNend
+\retval ::HIGO_ERR_DEPEND_CURSOR
+
+\see \n
+*/
+HI_S32 HI_GO_SetCursorPos(HI_S32 x, HI_S32 y);
+
+/**
+\brief Obtains the coordinates of the cursor on the screen.CNcomment:取得光标的屏幕坐标 CNend
+\attention \n
+N/A.CNcomment:无 CNend
+\param[out] pX Horizontal coordinate (in pixel) of the cursor on the screen.CNcomment:光标的屏幕X坐标,单位像素 CNend
+\param[out] pY Vertical coordinate (in pixel) of the cursor on the screen.CNcomment:光标的屏幕Y坐标,单位像素 CNend
+
+\retval ::HI_SUCCESS Success.CNcomment:成功 CNend
+\retval ::HI_FAILURE The display fails.CNcomment:显示失败 CNend
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_DEPEND_CURSOR
+
+\see \n
+*/
+HI_S32 HI_GO_GetCursorPos(HI_S32* pX, HI_S32* pY);
+
+/**
+\brief Sets the hot spot of the displayed cursor picture.CNcomment:设置光标的显示图片的热点 CNend
+\attention \n
+The minimum resolution is 16x16, and the maximum resolution is 128x128 for the cursor picture. Both colorkey and
+alpha are supported. CNcomment:图片最小16x16,最大128x128像素，支持colorkey, alpha。 CNend
+\param[in] pCursorInfo Information about the cursor picture and coordinates of the hot spot.CNcomment:光标图片，热点坐标信息 CNend
+
+\retval ::HI_SUCCESS Success.CNcomment:成功 CNend
+\retval ::HI_FAILURE The display fails.CNcomment:显示失败 CNend
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVSURFACESIZE
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_INVHOTSPOT
+\retval ::HIGO_ERR_DEPEND_CURSOR
+
+\see \n
+*/
+HI_S32 HI_GO_SetCursorInfo(const HIGO_CURSOR_INFO_S* pCursorInfo);
+
+/**
+\brief Obtains the information about the displayed cursor picture.CNcomment:获取光标的显示图片信息 CNend
+\attention \n
+\param[in] pCursorInfo Information about the cursor picture and coordinates of the hot spot.CNcomment:光标图片，热点坐标信息 CNend
+
+\retval ::HI_SUCCESS Success.CNcomment:成功 CNend
+\retval ::HI_FAILURE The display fails.CNcomment:显示失败 CNend
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_DEPEND_CURSOR
+
+\see \n
+*/
+HI_S32 HI_GO_GetCursorInfo(HIGO_CURSOR_INFO_S* pCursorInfo);
+
+/**
+\brief Attaches the cursor to one or more graphics layers.CNcomment:将光标绑定到图层上，支持一个光标绑定到多个图层上 CNend
+\attention \n
+The graphics layers to which the cursor is attached must be opened.CNcomment:必须将光标绑定到一个已经open的图层上。CNend
+\param[in] hLayer CNcomment:图层ID CNend
+
+\retval ::HI_SUCCESS Layer ID.CNcomment:成功 CNend
+\retval ::HI_FAILURE Success.CNcomment:显示失败 CNend
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVLAYERID
+\retval ::HIGO_ERR_NOTOPEN
+\retval ::HIGO_ERR_DEPEND_CURSOR
+
+\see \n
+*/
+HI_S32  HI_GO_AttchCursorToLayer(HI_HANDLE hLayer);
+
+/**
+\brief Detaches the cursor from graphics layers.CNcomment:将光标解绑定图层 CNend
+\attention \n
+\param[in] hLayer Layer ID.CNcomment:图层ID CNend
+
+\retval ::HI_SUCCESS Success.CNcomment:成功 CNend
+\retval ::HI_FAILURE The display fails.CNcomment:显示失败 CNend
+\retval ::HIGO_ERR_INVLAYERID
+\retval ::HIGO_ERR_DEPEND_CURSOR
+
+\see \n
+*/
+HI_S32  HI_GO_DetachCursorFromLayer(HI_HANDLE hLayer);
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif
diff -uNr a/include/hi_go_decoder.h b/include/hi_go_decoder.h
--- a/include/hi_go_decoder.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_go_decoder.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,439 @@
+#ifndef __HI_GO_DECODE_H__
+#define __HI_GO_DECODE_H__
+
+#include "hi_type.h"
+#include "hi_go_comm.h"
+#include "hi_go_surface.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HIGO_DEC */
+/** @{ */  /** <!-- [HIGO_DEC] */
+
+/** Decoding type of the decoding instance*//** CNcomment: 解码实例的解码类型 */
+typedef enum
+{
+    HIGO_DEC_IMGTYPE_JPEG = HIGO_IMGTYPE_JPEG, /**<.jpeg picture*//**<CNcomment: JPEG格式图片*/
+    HIGO_DEC_IMGTYPE_GIF  = HIGO_IMGTYPE_GIF,  /**<.gif picture*//**<CNcomment: GIF格式图片*/
+    HIGO_DEC_IMGTYPE_BMP  = HIGO_IMGTYPE_BMP, /**<.bmp picture*//**<CNcomment: BMP格式图片 */
+    HIGO_DEC_IMGTYPE_PNG  = HIGO_IMGTYPE_PNG,  /**<.png picture*//**<CNcomment: PNG格式图片 */
+    HIGO_DEC_IMGTYPE_RLE  = HIGO_IMGTYPE_RLE,  /**<.rle picture*//**<CNcomment: RLE格式图片 */
+    HIGO_DEC_IMGTPYE_BUTT
+} HIGO_DEC_IMGTYPE_E;
+
+/**Stream source*//** CNcomment: 码流的来源 */
+typedef enum
+{
+    HIGO_DEC_SRCTYPE_FILE = 0, /**<Streams are derived from files.*//**<CNcomment: 码流来源于文件*/
+    HIGO_DEC_SRCTYPE_MEM,      /**<Streams are derived from the memory.*//**<CNcomment: 码流来源于内存*/
+    HIGO_DEC_SRCTYPE_STREAM,   /**<Streams are derived from stream data.*/  /**<CNcomment: 码流来源于流式数据*/
+    HIGO_DEC_SRCTYPE_BUTT
+} HIGO_DEC_SRCTYPE_E;
+
+typedef struct
+{
+    HIGO_MEMTYPE_E MemType;
+    HI_BOOL IsPubPalette;  /*Decoder uses common Palette or not*//** CNcomment:解码图片是否使用公共调色板,只对输出格式有效*/
+}HIGO_DEC_SURINFO_S;
+
+typedef HI_S32 (*PTR_Dec_WriteStreamCB_FN)(HI_ULONG ClientData, HI_ULONG Offset);
+
+/**Detailed information about the stream source*//** CNcomment:码流来源的详细信息*/
+typedef union
+{
+    /*The following information is required if the input source is the memory.*//** CNcomment:输入源为内存块时需要的信息*/
+    struct
+    {
+        HI_CHAR* pAddr;      /**<Memory pointer address*//**<CNcomment: 内存指针地址*/
+        HI_U32 Length;       /**<Length*//**<CNcomment: 长度*/
+    } MemInfo;
+
+    /*Picture name*//** CNcomment:图片文件名*/
+    const HI_CHAR *pFileName;
+    struct
+    {
+        PTR_Dec_WriteStreamCB_FN pWriteCB;
+        HI_ULONG ClientData; /**<Save client data.*//**<CNcomment: 用来保存临时信息 */
+    } Stream;
+} HIGO_DEC_SRCINFO_U;
+
+/**Parameters for creating a decoding instance.*//** CNcomment: 创建解码实例需要的参数 */
+typedef struct
+{
+    HIGO_DEC_SRCTYPE_E SrcType; /**<Type of the input stream.*//**<CNcomment: 输入码流的类型*/
+    HIGO_DEC_SRCINFO_U SrcInfo; /**<Information about the input source.*//**<CNcomment: 输入源详细信息*/
+} HIGO_DEC_ATTR_S;
+
+/** Major information after decoding*//** CNcomment: 解码后主信息 */
+typedef struct
+{
+    HI_U32             Count;           /**<Number of pictures*//**<CNcomment: 图片的个数 */
+    HIGO_DEC_IMGTYPE_E ImgType;         /**<Type of the input source.*//**<CNcomment: 输入源类型 */
+    HI_U32             ScrWidth;        /**<Screen width. The screen refers to that of the picture. The value 0 indicates "invalid".*//**<CNcomment: 屏幕宽度，此处屏幕表示图片文件屏幕，0表示无效 */
+    HI_U32             ScrHeight;       /**<Screen height. The screen refers to that of the picture. The value 0 indicates "invalid".*//**<CNcomment: 屏幕高度，此处屏幕表示图片文件屏幕，0表示无效 */
+    HI_BOOL            IsHaveBGColor;   /**<Whether there is any background color.*//**<CNcomment: 是否有背景色 */
+    HI_COLOR           BGColor;         /**<Background color*//**<CNcomment: 背景颜色 */
+} HIGO_DEC_PRIMARYINFO_S;
+
+/** Index picture format*//** CNcomment: 索引图片格式 */
+typedef struct
+{
+    HI_U32    OffSetX;                /**<X offset value on the screen. The screen mentioned in this document refers to that of the picture.*//**<CNcomment: 在屏幕上的X偏移量，此处屏幕表示图片文件屏幕，下同 */
+    HI_U32    OffSetY;                /**<Y offset value on the screen.*//**<CNcomment: 在屏幕上的Y偏移量*/
+    HI_U32    Width;                  /**<Width of the original picture*//**<CNcomment: 原始图片的宽度 */
+    HI_U32    Height;                  /**<Height of the original picture*//**<CNcomment: 原始图片的高度 */
+    HI_U8     Alpha;                  /**<Information about channel alpha used for overlaying pictures. The alpha value ranges from 0 to 255.*//**<CNcomment: 用于图片进行叠加的通道alpha信息，范围是0-255 */
+    HI_BOOL   IsHaveKey;              /**<Key enable. HI_FALSE: disabled; HI_TRUE: enabled*//**<CNcomment: 是否有KEY。 HI_FALSE: KEY不使能；HI_TRUE: KEY使能 */
+    HI_COLOR  Key;                    /**<Information about colorkey used for overlaying pictures*//**<CNcomment: 用于图片进行叠加的colorkey信息 */
+    HIGO_PF_E Format;                 /**<Pixel format of the picture source*//**<CNcomment: 图片源像素格式 */
+    HI_U32    DelayTime;              /**<Time interval between this picture and the previous one (10 ms). The value 0 indicates that the parameter is invalid.*//**<CNcomment: 与上一幅图片的时间间隔(10ms)，0表示该参数无效 */
+    HI_U32    DisposalMethod;         /**<Processing method of the current frame. This application programming interface (API) is valid for only GIF pictures. 0: customized processing method; 1: no processing method; 2: use the background color.*/    /**<CNcomment: 当前帧处理方法，此接口只对GIF有效，0:用户决定处理方式，1:不做处理，2:使用背景色，*/
+} HIGO_DEC_IMGINFO_S;
+
+/* Picture attributes after decoding*//** CNcomment: 解码后图片属性 */
+typedef struct
+{
+    HI_U32    Width;                  /**<Expected width after decoding*//**<CNcomment: 期望解码后宽度 */
+    HI_U32    Height;                 /**<Expected height after decoding*//**<CNcomment: 期望解码后高度*/
+    HIGO_PF_E Format;                 /**<Expected pixel format after decoding*//**<CNcomment: 期望解码后像素格式*/
+} HIGO_DEC_IMGATTR_S;
+
+/** Extended data format type*//** CNcomment: 扩展数据格式类型 */
+typedef enum
+{
+    HIGO_DEC_EXTEND_EXIF = 0,          /**<Extended-data in EXIF format*//**<CNcomment: EXIF格式的扩展数据 */
+    HIGO_DEC_EXTEND_EXIF_BUTT
+} HIGO_DEC_EXTENDTYPE_E;
+
+/** Basic picture information*//** CNcomment: 图片基本信息 */
+typedef struct
+{
+    HI_U32    Width;                /**<Picture width*//**<CNcomment: 图片的宽度 */
+    HI_U32    Height;               /**<Picture height*//**<CNcomment: 图片的高度 */
+    HIGO_PF_E PixelFormat;          /**<Pixel format*//**<CNcomment: 像素格式 */
+    HI_U32    VirAddr[3];           /**<Virtual address. If the address is in RGB format, only the first VirAddr[0] is the start address,
+                                                and VirAddr[1] and VirAddr[2] are invalid. If the address is in YC format,
+                                                VirAddr[0] indicates the start address of the Y component, VirAddr[1] indicates the start address of the C component,
+                                                and VirAddr[2] is invalid.*/
+                                                /**<CNcomment: 虚拟地址。如果是RGB格式，只有第一个VirAddr[0]为起始地址，
+                                                VirAddr[1]和VirAddr[2]无效；如果是YC格式，
+                                                VirAddr[0]表示Y分量起始地址，VirAddr[1]表示C分量起始地址，
+                                                VirAddr[2]无效 */
+    HI_U32    PhyAddr[3];           /**<Physical address. The usage principles are the same as previous ones.*//**<CNcomment: 物理地址，使用原则同上 */
+    HI_U32    Pitch[3];             /**<Pitch. The usage principles are the same as previous ones.*//**<CNcomment: 行间距，使用原则同上 */
+    HI_U32    Palate[256];         /**<Palette*//**<CNcomment: 调色板 */
+} HIGO_DEC_IMGDATA_S;
+
+typedef struct {
+    HI_VOID *StreamBuf;     /**<Virtual start address of streams *//**<CNcomment: 流虚拟起始地址 */
+    HI_U32 StreamLen;       /**<Actual read stream length *//**<CNcomment: 实际读取的码流长度 */
+    HI_U32 ExpectStreamLen; /**<Expect read stream length *//**<CNcomment: 期望读取的码流长度 */
+} HIGO_DEC_WRITESTREAM_S;
+
+/** @} */  /*! <!-- Structure Definition end */
+/********************** Global Variable declaration **************************/
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HIGO_DEC */
+/** @{ */  /** <!-- [HIGO_DEC] */
+
+
+ /**
+\brief Initializes the decoder.CNcomment: 解码器初始化 CNend
+\attention \n
+::HI_GO_Init already calls the interfaceCNcomment: ::HI_GO_Init中已包含对该接口的调用 CNend
+\param  N/ACNcomment: 无 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_DEPEND_TDE
+
+\see \n
+::HI_GO_Init \n
+::HI_GO_DeinitDecoder
+*/
+
+HI_S32 HI_GO_InitDecoder(HI_VOID);
+
+/**
+\brief Deinitializes the decoder.CNcomment: 解码器去初始化 CNend
+\attention \n
+When ::HI_GO_Deinit is called, this API is also called.CNcomment: ::HI_GO_Deinit中已包含对该接口的调用 CNend
+\param  N/A.CNcomment: 无 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+
+\see \n
+::HI_GO_Deinit \n
+::HI_GO_InitDecoder
+*/
+
+HI_S32 HI_GO_DeinitDecoder(HI_VOID);
+
+ /**
+ \brief Creates a decoding handle.CNcomment: 创建解码句柄 CNend
+ \attention \n
+ Currently, the formats of .bmp, .png, .jpeg, and .gif are supported. The picture input source can be the memory, files
+, and streams. The picture input source of streams is only applicable to the .jpeg format.
+CNcomment: 目前支持BMP、PNG、JPEG和GIF格式，图片输入源只可以为内存、文件以及流式，流式目前只对JPEG格式有效。CNend
+
+ \param[in] pSrcDesc Information about the input source. This parameter cannot be empty.
+                The type of the input stream must match the information about the input source. For example,
+corresponding file names must be entered for the file stream, and the memory address and memory size must be entered
+for the memory stream.CNcomment: 输入源信息，不可为空\n
+                输入码流的类型要与输入源详细信息一一匹配，如FILE码流则需要输入相应的文件名\n
+                如Memory码流则需要输入memory的地址以及长度 CNend
+ \param[out] pDecoder Pointer of the decoding instance handle. This parameter cannot be empty.CNcomment: 解码实例句柄指针，不可为空 CNend
+
+ \retval ::HI_SUCCESS
+ \retval ::HIGO_ERR_NULLPTR
+ \retval ::HIGO_ERR_NOTINIT
+ \retval ::HIGO_ERR_NOMEM
+ \retval ::HIGO_ERR_INVHANDLE
+ \retval ::HIGO_ERR_INVFILE
+ \retval ::HIGO_ERR_INVSRCTYPE
+ \retval ::HIGO_ERR_INVIMAGETYPE
+ \retval ::HIGO_ERR_INVIMGDATA
+
+\see \n
+::HI_GO_DestroyDecoder
+*/
+HI_S32 HI_GO_CreateDecoder(const HIGO_DEC_ATTR_S* pSrcDesc, HI_HANDLE* pDecoder);
+
+ /**
+ \brief Destroys a decoding handle.CNcomment:销毁解码句柄 CNend
+ \attention \n
+ N/A.CNcomment:无 CNend
+ \param[in] Decoder Handle of the decoding instance.CNcomment:解码实例句柄 CNend
+
+ \retval ::HI_SUCCESS
+ \retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+::HI_GO_CreateDecoder
+*/
+HI_S32 HI_GO_DestroyDecoder(HI_HANDLE Decoder);
+
+/**
+ \brief Stream APICNcomment: 流式码流接口 CNend
+ \attention \n
+ N/A.CNcomment:无 CNend
+ \param[in] Decoder Handle of the decoding instance.CNcomment: 解码实例句柄 CNend
+ \param[in] pStream Pointer to the stream information. This parameter cannot be empty.CNcomment: 码流信息指针 ，不可为空 CNend
+
+ \retval ::HI_SUCCESS
+ \retval ::HI_FAILURE
+ \retval ::HIGO_ERR_NULLPTR
+ \retval ::HIGO_ERR_INVHANDLE
+ \retval ::HIGO_ERR_UNSUPPORTED
+
+\see \n
+::HI_GO_CreateDecoder
+*/
+HI_S32 HI_GO_DecWriteStream(HI_HANDLE Decoder, HIGO_DEC_WRITESTREAM_S *pStream);
+
+/**
+\brief Reset decoding.CNcomment:复位解码器 CNend
+\attention only support jpeg decode\n
+N/A.CNcomment: 只支持jpeg类型 CNend
+\param[in] Decoder Handle of the decoding instance.CNcomment:解码实例句柄 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVIMAGETYPE
+
+\see sample_dec_stream.c\n
+::HI_GO_ResetDecoder
+*/
+HI_S32 HI_GO_ResetDecoder(HI_HANDLE Decoder);
+
+ /**
+ \brief Obtains the major information about pictures.CNcomment:获取图片文件的主要信息 CNend
+ \attention
+ N/A.CNcomment:无 CNend
+\param[in] Decoder Handle of the decoding instance.CNcomment:解码实例句柄 CNend
+\param[out] pPrimaryInfo  Pointer to the major information about the decoded picture. This parameter cannot be empty.CNcomment:解码图片主信息指针，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HI_NULL_PTR
+\retval ::HIGO_ERR_INVIMGDATA
+
+\see \n
+::HI_GO_DecImgInfo
+*/
+HI_S32 HI_GO_DecCommInfo(HI_HANDLE Decoder, HIGO_DEC_PRIMARYINFO_S *pPrimaryInfo);
+
+/**
+ \brief Obtains the information about the specified picture. You can customize the picture format.CNcomment: 获取指定图片的信息，但同时用户可以设置期望的图象格式 CNend
+ \attention \n
+  N/A.CNcomment: 无 CNend
+ \param[in] Decoder Handle of the decoding instance.CNcomment: 解码实例句柄 CNend
+ \param[in] Index
+ Picture index number. For .jpeg pictures, the index number of the main picture is 0, and index
+numbers of thumbnails start from 1.
+                   The index numbers of GIF pictures start from 0 and increase by 1 according to the sequence of the
+pictures stored in a file.
+CNcomment: 图片索引号。JPEG格式图片，主图的索引号是0，缩略图索引号由1开始；\n
+                   GIF格式图片按照在文件中的存储顺序，索引号由0开始递加 CNend
+ \param[out] pImgInfo Picture information. This parameter cannot be empty.CNcomment: 图片信息，不可为空 CNend
+
+ \retval ::HI_SUCCESS
+ \retval ::HIGO_ERR_NULLPTR
+ \retval ::HIGO_ERR_INVHANDLE
+ \retval ::HIGO_ERR_INVINDEX
+ \retval ::HI_FAILURE
+ \retval ::HI_NULL_PTR
+ \retval ::HIGO_ERR_INVIMGDATA
+
+\see \n
+::HI_GO_DecCommInfo
+*/
+HI_S32 HI_GO_DecImgInfo(HI_HANDLE Decoder, HI_U32 Index, HIGO_DEC_IMGINFO_S *pImgInfo);
+
+ /**
+ \brief Obtains the data of a picture.CNcomment:获取单个图片的数据 CNend
+ \attention \n
+ The format in the destination picture attributes does not support the macro block format.CNcomment:目标图片属性中的图像格式不支持宏块格式 CNend
+
+\param[in] Decoder Handle of the decoding instance.CNcomment:解码实例句柄 CNend
+\param[in] Index Index number of a picture, starting from 0.CNcomment:图片索引号，索引号从0开始 CNend
+\param[in] pImgAttr Attribute of the destination picture. If the value is empty, it indicates that the original
+picture attributes are retained.CNcomment:目标图片属性，为空表示保持原图片属性 CNend
+\param[out] pSurface Handle of the surface where the decoded data is stored.CNcomment:解码后数据存放的surface的句柄 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVINDEX
+\retval ::HI_FAILURE
+\retval ::HI_NULL_PTR
+\retval ::HIGO_ERR_INVIMGDATA
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_UNSUPPORTED
+
+\see \n
+::HI_GO_DecCommInfo
+*/
+HI_S32 HI_GO_DecImgData(HI_HANDLE Decoder, HI_U32 Index, const HIGO_DEC_IMGATTR_S *pImgAttr, HI_HANDLE *pSurface);
+
+/**
+ \brief Obtains the extended data.CNcomment: 获取扩展数据 CNend
+ \attention \n
+ Hi3110E does not support the API.CNcomment: Hi3110E不支持此函数。 CNend
+ \param[in] Decoder Handle of the decoding instance.CNcomment: 解码实例句柄 CNend
+ \param[in] DecExtendType
+ Type of the obtained extended data. Currently, only the EXIF information in .jpeg format is available.
+ CNcomment: 获取扩展数据的类型，目前主要只有JPEG的EXIF信息 CNend
+ \param[out] ppData Pointer to the extended data pointer.CNcomment: 指向扩展数据指针的指针 CNend
+ \param[out] pLength ppData Length.CNcomment: ppData长度 CNend
+ \retval ::HI_SUCCESS
+ \retval ::HIGO_ERR_NULLPTR
+ \retval ::HIGO_ERR_INVHANDLE
+ \retval ::HIGO_ERR_UNSUPPORTED
+
+\see \n
+::HI_GO_ReleaseDecExtendData
+*/
+HI_S32 HI_GO_DecExtendData(HI_HANDLE Decoder, HIGO_DEC_EXTENDTYPE_E DecExtendType, HI_VOID **ppData, HI_U32 *pLength);
+
+ /**
+ \brief Releases extended data.CNcomment:释放扩展数据 CNend
+ \attention \n
+ Hi3110E does not support the API.CNcomment:Hi3110E不支持此函数。CNend
+ \param[in] Decoder Decoder handle.CNcomment:Decoder句柄 CNend
+ \param[in] DecExtendType Type of the obtained extended data. Currently, only the EXIF information in .jpeg format is
+available.CNcomment:获取扩展数据的类型，目前主要只有JPEG的EXIF信息 CNend
+ \param[in] pData Pointer to the extended data.CNcomment:指向扩展数据指针 CNend
+ \retval ::HI_SUCCESS
+ \retval ::HIGO_ERR_NULLPTR
+ \retval ::HIGO_ERR_UNSUPPORTED
+
+\see \n
+::HI_GO_DecExtendData
+*/
+HI_S32 HI_GO_ReleaseDecExtendData(HI_HANDLE Decoder, HIGO_DEC_EXTENDTYPE_E DecExtendType, HI_VOID *pData);
+
+/**
+\brief Decodes a picture to a specified surface.CNcomment:将图像解码到指定的surface CNend
+\attention \n
+The decoded surface is scaled automatically based on the size of the target surface. In addition, the decoded surface
+modifies the attributes of the target surface, such as colorkey, alpha value, and palette.
+CNcomment:解码后的Surface会自动按照目标surface的大小进行缩放，并且会改变目标surface的COLORKEY、ALPHA以及调色板属性 CNend
+\param[in] Decoder Handle of the decoding instance.CNcomment: 解码实例句柄 CNend
+\param[in] Index   Index number of a decoded picture.CNcomment:解码图片索引 CNend
+\param[out] Surface Decoded target surface.CNcomment:解码的目标surface CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVINDEX
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HI_FAILURE
+\retval ::HI_NULL_PTR
+\retval ::HIGO_ERR_INVIMGDATA
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_UNSUPPORTED
+
+\see \n
+N/A.CNcomment:无 CNend
+*/
+HI_S32 HI_GO_DecImgToSurface(HI_HANDLE Decoder, HI_U32 Index, HI_HANDLE Surface);
+
+/**
+\brief Decodes a specified file, and generates a new surface.CNcomment:解码指定的文件，并生成一个新的surface CNend
+\attention \n
+    If there are multiple pictures in the file (such as .gif animation, .jpeg main picture, and .jpeg thumbnail),
+    only the .jpeg main picture and the first picture of the .gif animation are decoded.
+    In addition, the surface size is the same as the picture size.
+    CNcomment:如果文件中有多张图片，比如:gif动画，JPEG带主图和缩略图，
+    JPEG只解主图，GIF解码解码第一张图片surface的大小与图片的大小一致 CNend
+\param[in] pszFile Picture name. The picture can be in the format of .gif, .png, .jpg, or .bmp.CNcomment:图片文件名，可以是GIF, PNG, JPG, BMP CNend
+\param[out] pSurface, Surface for storing decoded pictures.CNcomment:保存解码后图像 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVINDEX
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HI_NULL_PTR
+\retval ::HIGO_ERR_INVIMGDATA
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_INVFILE
+\retval ::HIGO_ERR_INVSRCTYPE
+\retval ::HIGO_ERR_INVIMAGETYPE
+
+\see \n
+N/A.CNcomment:无 CNend
+*/
+HI_S32 HI_GO_DecodeFile(const HI_CHAR* pszFile, HI_HANDLE* pSurface);
+
+/**
+\brief Set the attribute of Decoder out Surface memrory.  CNcomment:设置解码输出Surface的内存属性 CNend
+\attention \n
+N/A.CNcomment: 无 CNend
+\param[in] Decoder handle. CNcomment:解码实例句柄 CNend
+\param[in] pSurfInfo.  CNcomment:Surface的内存属性 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A.CNcomment:无 CNend
+*/
+HI_S32 HI_GO_SetDecSurfInfo(HI_HANDLE Decoder, HIGO_DEC_SURINFO_S  *pSurfInfo);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif /* __HI_GO_DECODE_H__ */
diff -uNr a/include/hi_go_encoder.h b/include/hi_go_encoder.h
--- a/include/hi_go_encoder.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_go_encoder.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,164 @@
+#ifndef __HI_GO_ENCODER_H__
+#define __HI_GO_ENCODER_H__
+
+#include "hi_go_comm.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HIGO_ENC */
+/** @{ */  /** <!-- [HIGO_ENC] */
+
+/**Encoder attributes*/
+/** CNcomment:编码器属性*/
+typedef struct
+{
+   HIGO_IMGTYPE_E ExpectType;   /**<Type of the encoded picture*//**<CNcomment:编码图片类型*/
+   HI_U32 QualityLevel;        /**<The quality level ranges from 1 to 99. The higher the level, the better the quality, and the greater the encoded picture or occupied memory. The QualityLevel parameter is valid for .jpeg pictures only.*//**<CNcomment:1-99级, 级别越高，质量越好，编码出来图像文件或内存也越大，只对JPEG有效*/
+}HIGO_ENC_ATTR_S;
+/** @} */  /*! <!-- Structure Definition end */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HIGO_ENC */
+/** @{ */  /** <!-- [HIGO_ENC] */
+ /**
+\brief Initializes the encoder. CNcomment:编码器初始化 CNend
+\attention \n
+When ::HI_GO_Init is called, this application programming interface (API) is also called.
+CNcomment: ::HI_GO_Init中已包含对该接口的调用 CNend
+\param  N/A
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_DEPEND_TDE
+
+\see \n
+::HI_GO_Init \n
+::HI_GO_DeinitDecoder
+*/
+
+HI_S32 HI_GO_InitEncoder(HI_VOID);
+
+
+/**
+\brief Deinitializes the encoder. CNcomment:编码器去初始化 CNend
+\attention \n
+When ::HI_GO_Deinit is called, this API is also called.
+CNcomment: ::HI_GO_Deinit中已包含对该接口的调用 CNend
+\param  N/A
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+
+\see \n
+::HI_GO_Deinit \n
+::HI_GO_InitDecoder
+*/
+
+HI_S32 HI_GO_DeinitEncoder(HI_VOID);
+
+/**
+\brief Encodes a surface in a specified format, and saves the encoded surface in a file.
+CNcomment:将一个surface编码到指定图像格式并保存到文件中 CNend
+\attention \n
+The .bmp encoding format is supported.
+The hardware platform determines whether the .jpeg encoding foramt is supported.
+CNcomment:支持编码成bmp格式文件 \n
+(是否支持编码成JPEG,取决于硬件平台) CNend
+
+\param[in] hSurface  Surface to be encoded. CNcomment:需要编码的surface, CNend
+\param[in] pFile    Name of the encoded file. This parameter can be empty. If this parameter is not set, the encoded file is named [year]-[month]-[date]-[hour]-[minute]-[second].
+                        CNcomment:编码后的文件名，可以为空，为空则用当前时间[年]-[月]-[日]-[时]-[分]-[秒]来命名 CNend
+\param[in] pAttr    Encoding attributes. This parameter cannot be empty. CNcomment:编码设置的属性，不可为空 CNend
+
+\retval ::HI_SUCCESS Success.
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_INVFILE
+\retval ::HIGO_ERR_INVSRCTYPE
+\retval ::HIGO_ERR_INVIMAGETYPE
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_INVMIRRORTYPE
+\retval ::HIGO_ERR_INVROTATETYPE
+\retval ::HIGO_ERR_INVCKEYTYPE
+\retval ::HIGO_ERR_INVROPTYPE
+\retval ::HIGO_ERR_NOCOLORKEY
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_DEPEND_JPGE
+
+\see \n
+*/
+HI_S32 HI_GO_EncodeToFile(HI_HANDLE hSurface, const HI_CHAR* pFile, const HIGO_ENC_ATTR_S* pAttr);
+
+/**
+\brief Encodes a surface in a specified picture format and saves it in a memory. Ensure that the memory is sufficient.
+CNcomment:将一个surface编码到指定图像格式并保存到内存中，请自行保证指定内存块足够大 CNend
+\attention \n
+The data can be encoded as .bmp data, and saved in a specified memory.
+The hardware platform determines whether the .jpeg encoding format is supported.
+CNcomment:支持编码成bmp格式数据存放到指定的内存中
+(是否支持编码成JPEG,取决于硬件平台) CNend
+
+\param[in] hSurface     Surface to be encoded. CNcomment:需要编码的surface, CNend
+\param[in] pMem         Start address of the memory for storing the encoded pictures. CNcomment:保存编码后的图像数据内存块的起始地址 CNend
+\param[in] MemLen       Size of a specified memory. CNcomment:指定内存的大小 CNend
+\param[out] pOutLen     Actual size of the used memory, indicating the length of encoded data. Ensure that the value of pOutLen is smaller than or equal to the value of MemLen.
+                                CNcomment:实际使用的内存大小，编码后数据长度(自行确保pOutLen <= MemLen) CNend
+\param[in] pAttr        Encoding attributes. This parameter cannot be empty. CNcomment:编码设置的属性，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_INVFILE
+\retval ::HIGO_ERR_INVSRCTYPE
+\retval ::HIGO_ERR_INVFILE
+\retval ::HIGO_ERR_INVIMAGETY
+\retval ::HIGO_ERR_INVIMAGETYPE
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_INVMIRRORTYPE
+\retval ::HIGO_ERR_INVROTATETYPE
+\retval ::HIGO_ERR_INVCKEYTYPE
+\retval ::HIGO_ERR_INVROPTYPE
+\retval ::HIGO_ERR_NOCOLORKEY
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVCOMPTYPE
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_DEPEND_TDE
+\retval ::HIGO_ERR_EMPTYRECT
+\retval ::HIGO_ERR_OUTOFBOUNDS
+\retval ::HIGO_ERR_DEPEND_JPGE
+
+\see \n
+*/
+
+HI_S32 HI_GO_EncodeToMem(HI_HANDLE hSurface, HI_U8* pMem, HI_U32 MemLen, HI_U32* pOutLen, const HIGO_ENC_ATTR_S* pAttr);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif /* __HI_TYPE_H__ */
diff -uNr a/include/hi_go_errno.h b/include/hi_go_errno.h
--- a/include/hi_go_errno.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_go_errno.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,554 @@
+#ifndef __HI_GO_ERRNO_H__
+#define __HI_GO_ERRNO_H__
+
+/* add include here */
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/***************************** Macro Definition ******************************/
+/** \addtogroup      HIGO_ERRCODE */
+/** @{ */  /** <!-- [HIGO_ERRCODE] */
+
+/**Error IDs of HiGo projects*/
+/** CNcomment:HiGo 项目错误ID */
+#define HIGO_ERR_APPID (0x80000000L + 0x30000000L)
+
+typedef enum hiGOLOG_ERRLEVEL_E
+{
+    HIGO_LOG_LEVEL_DEBUG = 0,  /* debug-level                                  */
+    HIGO_LOG_LEVEL_INFO,       /* informational                                */
+    HIGO_LOG_LEVEL_NOTICE,     /* normal but significant condition             */
+    HIGO_LOG_LEVEL_WARNING,    /* warning conditions                           */
+    HIGO_LOG_LEVEL_ERROR,      /* error conditions                             */
+    HIGO_LOG_LEVEL_CRIT,       /* critical conditions                          */
+    HIGO_LOG_LEVEL_ALERT,      /* action must be taken immediately             */
+    HIGO_LOG_LEVEL_FATAL,      /* just for compatibility with previous version */
+    HIGO_LOG_LEVEL_BUTT
+} HIGO_LOG_ERRLEVEL_E;
+
+/**Macros for defining the error codes of the HiGo*/
+/** CNcomment:HiGo 错误码定义宏 */
+#define HIGO_DEF_ERR( module, errid) \
+    ((HI_S32)((HIGO_ERR_APPID) | (((HI_U32)module) << 16) | (((HI_U32)HIGO_LOG_LEVEL_ERROR) << 13) | ((HI_U32)errid)))
+
+/**HiGo Module encoding*/
+/** CNcomment:HiGo 模块编码 */
+typedef enum
+{
+    HIGO_MOD_COMM = 0,
+    HIGO_MOD_SURFACE,
+    HIGO_MOD_MEMSURFACE,
+    HIGO_MOD_LAYER,
+    HIGO_MOD_BLITER,
+    HIGO_MOD_DEC,
+    HIGO_MOD_TEXTOUT,
+    HIGO_MOD_WINC,
+    HIGO_MOD_CURSOR,
+    HIGO_MOD_TEXT_LAYOUT,
+    HIGO_MOD_BUTT
+} HIGO_MOD_E;
+
+/**Common error codes of the HiGo*/
+/** CNcomment:HiGo 公共错误码 */
+typedef enum
+{
+    ERR_COMM_NOTINIT = 0,
+    ERR_COMM_INITFAILED,
+    ERR_COMM_DEINITFAILED,
+    ERR_COMM_NULLPTR,
+    ERR_COMM_INVHANDLE,
+    ERR_COMM_NOMEM,
+    ERR_COMM_INTERNAL,
+    ERR_COMM_INVSRCTYPE,
+    ERR_COMM_INVFILE,
+    ERR_COMM_INVPARAM,
+    ERR_COMM_INUSE,
+    ERR_COMM_UNSUPPORTED,
+    ERR_COMM_DEPENDTDE,
+    ERR_COMM_DEPENDFB ,
+    ERR_COMM_DEPENDMMZ,
+    ERR_COMM_DEPENDJPEG,
+    ERR_COMM_DEPENDPNG,
+    ERR_COMM_DEPENDBMP,
+    ERR_COMM_DEPENDGIF,
+    ERR_COMM_DEPENDCURSOR,
+    ERR_COMM_DEPENDJPGENC,
+    ERR_COMM_BUTT
+} HIGO_ERR_E;
+
+/**The dependent module is not initialized (0xB0008000).*/
+/** CNcomment:所依赖的模块未初始化 0xB0008000 */
+#define HIGO_ERR_NOTINIT HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_NOTINIT)
+
+/*The module fails to be initialized (0xB0008001).*/
+/** CNcomment:模块初始化失败 0xB0008001 */
+#define HIGO_ERR_DEINITFAILED HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_INITFAILED)
+
+/**The module fails to be deinitialized (0xB0008002).*/
+/** CNcomment:模块去初始化失败 0xB0008002 */
+#define HIGO_ERR_INITFAILED HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEINITFAILED)
+
+/**The input pointer is null (0xB0008003).*/
+/** CNcomment:传入参数为空指针 0xB0008003 */
+#define HIGO_ERR_NULLPTR HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_NULLPTR)
+
+/**The input handle is invalid (0xB0008004).*/
+/** CNcomment:传入无效的句柄 0xB0008004 */
+#define HIGO_ERR_INVHANDLE HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_INVHANDLE)
+
+/**The memory is insufficient (0xB0008005).*/
+/** CNcomment:内存不足 0xB0008005 */
+#define HIGO_ERR_NOMEM HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_NOMEM)
+
+/**An internal error occurs (0xB0008006).*/
+/** CNcomment:内部错误 0xB0008006 */
+#define HIGO_ERR_INTERNAL HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_INTERNAL)
+
+/**The I/O source is invalid (0xB0008007).*/
+/** CNcomment:无效的IO来源 0xB0008007 */
+#define HIGO_ERR_INVSRCTYPE HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_INVSRCTYPE)
+
+/**The file operation fails because the file is invalid (0xB0008008).*/
+/** CNcomment:无效的文件，文件操作失败 0xB0008008 */
+#define HIGO_ERR_INVFILE HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_INVFILE)
+
+/**The parameter is invalid (0xB0008009).*/
+/** CNcomment:无效的参数 0xB0008009*/
+#define HIGO_ERR_INVPARAM HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_INVPARAM)
+
+/**The handle is being used (0xB000800A).*/
+/** CNcomment:此句柄正在被使用 0xB000800A */
+#define HIGO_ERR_INUSE HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_INUSE)
+
+/**The operation is invalid (0xB000800B).*/
+/** CNcomment:无效的操作 0xB000800B */
+#define HIGO_ERR_UNSUPPORTED HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_UNSUPPORTED)
+
+/**An error occurs when the APIs related to the TDE are called (0xB000800C).*/
+/** CNcomment:依赖TDE出错 0xB000800C*/
+#define HIGO_ERR_DEPEND_TDE HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEPENDTDE)
+
+/**An error occurs when the APIs related to the FB are called (0xB000800D).*/
+/** CNcomment:依赖FB出错  0xB000800D*/
+#define HIGO_ERR_DEPEND_FB HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEPENDFB)
+
+/**An error occurs when the APIs related to the MMZ are called (0xB000800E).*/
+/** CNcomment:依赖MMZ出错 0xB000800E*/
+#define HIGO_ERR_DEPEND_MMZ HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEPENDMMZ)
+
+/**An error occurs when the APIs related to .jpeg decoding are called (0xB000800F).*/
+/** CNcomment:依赖JPEG解码出错    0xB000800F*/
+#define HIGO_ERR_DEPEND_JPEG HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEPENDJPEG)
+
+/**An error occurs when the APIs related to .png decoding are called (0xB0008010).*/
+/** CNcomment:依赖PNG解码出错 0xB0008010*/
+#define HIGO_ERR_DEPEND_PNG HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEPENDPNG)
+
+/**An error occurs when the APIs related to .bmp decoding are called (0xB0008011).*/
+/** CNcomment:依赖BMP解码出错 0xB0008011*/
+#define HIGO_ERR_DEPEND_BMP HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEPENDBMP)
+
+/**An error occurs when the APIs related to .gif decoding are called (0xB0008012).*/
+/** CNcomment:依赖GIF解码出错 0xB0008012*/
+#define HIGO_ERR_DEPEND_GIF HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEPENDGIF)
+
+/**An error occurs when the APIs related to the cursor are called (0xB0008013).*/
+/** CNcomment:依赖CURSOR解码出错  0xB0008013*/
+#define HIGO_ERR_DEPEND_CURSOR HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEPENDCURSOR)
+
+/**An error occurs when the APIs related to .jpeg encoding are called (0xB0008014).*/
+/** CNcomment:依赖jpeg编码失败 0xB0008014*/
+#define HIGO_ERR_DEPEND_JPGE HIGO_DEF_ERR(HIGO_MOD_COMM, ERR_COMM_DEPENDJPGENC)
+
+
+/**Error codes of the HiGo surface module*/
+/** CNcomment:HiGo surface模块错误码 */
+typedef enum
+{
+    ERR_SURFACE_INVSURFACESIZE = 0,
+    ERR_SURFACE_INVSURFACEPF,
+    ERR_SURFACE_NOTLOCKED,
+    ERR_SURFACE_LOCKED,
+    ERR_SURFACE_NOCOLORKEY,
+    ERR_SURFACE_BUTT
+} HIGO_SURFACE_ERR_E;
+
+#define SURFACE_DEF_ERR(err) HIGO_DEF_ERR(HIGO_MOD_SURFACE, err)
+
+/**The surface size is incorrect (0xB0018000).*/
+/** CNcomment:surface尺寸不正确 0xB0018000 */
+#define HIGO_ERR_INVSURFACESIZE SURFACE_DEF_ERR(ERR_SURFACE_INVSURFACESIZE)
+
+/**The pixel format of the surface is incorrect (0xB0018001).*/
+/** CNcomment:surface像素格式不正确 0xB0018001 */
+#define HIGO_ERR_INVSURFACEPF SURFACE_DEF_ERR(ERR_SURFACE_INVSURFACEPF)
+
+/**The surface cannot be unlocked because it is not locked (0xB0018002).*/
+/** CNcomment:surface未锁定，不能进行surface解锁操作 0xB0018002 */
+#define HIGO_ERR_NOTLOCKED SURFACE_DEF_ERR(ERR_SURFACE_NOTLOCKED)
+
+/**The surface cannot be written because it is locked (0xB0018003).*/
+/** CNcomment:surface已锁定，对surface进行的写操作被禁止 0xB0018003 */
+#define HIGO_ERR_LOCKED SURFACE_DEF_ERR(ERR_SURFACE_LOCKED)
+
+/**The surface does not contain the colorkey value (0xB0018004).*/
+/** CNcomment:surface不含有colorKey值 0xB0018004 */
+#define HIGO_ERR_NOCOLORKEY SURFACE_DEF_ERR(ERR_SURFACE_NOCOLORKEY)
+
+/**Error codes of the HiGo Gdev module*/
+/** CNcomment:HiGo gdev模块错误码*/
+typedef enum
+{
+    ERR_LAYER_INVSIZE = 0,
+    ERR_LAYER_INVLAYERID,
+    ERR_LAYER_INVPIXELFMT,
+    ERR_LAYER_FLUSHTYPE,
+    ERR_LAYER_FREEMEM,
+    ERR_LAYER_CLOSELAYER,
+    ERR_LAYER_CANNOTCHANGE,
+    ERR_LAYER_INVORDERFLAG,
+    ERR_LAYER_SETALPHA,
+    ERR_LAYER_ALREADYSHOW,
+    ERR_LAYER_ALREADYHIDE,
+    ERR_LAYER_INVLAYERPOS,
+    ERR_LAYER_INVSURFACE,
+    ERR_LAYER_INVLAYERSIZE,
+    ERR_LAYER_INVFLUSHTYPE,
+    ERR_LAYER_INVANILEVEL,
+    ERR_LAYER_NOTOPEN,
+    ERR_LAYER_FB_OPENFAILURE,
+    ERR_LAYER_FB_GETVSCREENINFOFAILURE,
+    ERR_LAYER_FB_PUTVSCREENINFOFAILURE,
+    ERR_LAYER_FB_GETLAYERINFO,
+    ERR_LAYER_FB_PUTLAYERINFO,
+    ERR_LAYER_FB_GETLAYERALPHA,
+    ERR_LAYER_FB_PUTLAYERALPHA,
+    ERR_LAYER_FB_WRONG_LAYERID,
+    ERR_LAYER_FB_REFRESHFAILURE,
+    ERR_LAYER_FB_GETCANVASBUFFER,
+    ERR_LAYER_FB_PUTCANVASBUFFER,
+    ERR_LAYER_FB_GETZORDER,
+    ERR_LAYER_FB_PUTZORDER,
+    ERR_LAYER_BUTT
+} HIGO_LAYER_ERR_E;
+
+#define LAYER_DEF_ERR(err) HIGO_DEF_ERR(HIGO_MOD_LAYER, err)
+
+/**The layer size is invalid (0xB0038000).*/
+/** CNcomment:无效的图层大小 0xB0038000 */
+#define HIGO_ERR_INVSIZE LAYER_DEF_ERR(ERR_LAYER_INVSIZE)
+
+/**The hardware layer ID is invalid (0xB0038001).*/
+/** CNcomment:无效的硬件图层ID 0xB0038001 */
+#define HIGO_ERR_INVLAYERID LAYER_DEF_ERR(ERR_LAYER_INVLAYERID)
+
+/**The pixel format is invalid (0xB0038002).*/
+/** CNcomment:无效的像素格式 0xB0038002 */
+#define HIGO_ERR_INVPIXELFMT LAYER_DEF_ERR(ERR_LAYER_INVPIXELFMT)
+
+/**The layer refresh mode is incorrect (0xB0038003).*/
+/** CNcomment:图层刷新模式错误 0xB0038003 */
+#define HIGO_ERR_INVFLUSHTYPE LAYER_DEF_ERR(ERR_LAYER_FLUSHTYPE)
+
+/**The display buffer fails to be released (0xB0038004).*/
+/** CNcomment:释放显存失败 0xB0038004 */
+#define HIGO_ERR_FREEMEM LAYER_DEF_ERR(ERR_LAYER_FREEMEM)
+
+/**The layer device fails to be stopped (0xB0038005).*/
+/** CNcomment:关闭图层设备失败 0xB0038005 */
+#define HIGO_ERR_CLOSELAYERFAILED LAYER_DEF_ERR(ERR_LAYER_CLOSELAYER)
+
+/**The z-order of the graphics layer cannot be changed (0xB0038006).*/
+/** CNcomment:图层Z序不可改变 0xB0038006 */
+#define HIGO_ERR_CANNOTCHANGE LAYER_DEF_ERR(ERR_LAYER_CANNOTCHANGE)
+
+/**The z-order change flag is invalid (0xB0038007).*/
+/** CNcomment:无效的Z序修改标志 0xB0038007 */
+#define HIGO_ERR_INVORDERFLAG LAYER_DEF_ERR(ERR_LAYER_INVORDERFLAG)
+
+/**The surface alpha value fails to be set (0xB0038008).*/
+/** CNcomment:设置surface alpha失败 0xB0038008 */
+#define HIGO_ERR_SETALPHAFAILED LAYER_DEF_ERR(ERR_LAYER_SETALPHA)
+
+/**The graphics layer has been displayed (0xB0038009).*/
+/** CNcomment:图层已经显示 0xB0038009 */
+#define HIGO_ERR_ALREADYSHOW LAYER_DEF_ERR(ERR_LAYER_ALREADYSHOW)
+
+/**The graphics layer has been hidden (0xB003800A).*/
+/** CNcomment:图层已经隐藏 0xB003800A */
+#define HIGO_ERR_ALREADYHIDE LAYER_DEF_ERR(ERR_LAYER_ALREADYHIDE)
+
+/**The start position of the graphics layer is invalid (0xB003800B).*/
+/** CNcomment:无效的图层起始位置 0xB003800B*/
+#define HIGO_ERR_INVLAYERPOS LAYER_DEF_ERR(ERR_LAYER_INVLAYERPOS)
+
+/**Alignment fails because the surface is invalid (0xB003800C).*/
+/** CNcomment:无效的surface，表示对齐失败 0xB003800C*/
+#define HIGO_ERR_INVLAYERSURFACE LAYER_DEF_ERR(ERR_LAYER_INVSURFACE)
+
+/**The anti-flicker level of the graphics layer is invalid (0xB003800F).*/
+/** CNcomment:无效的图层抗闪烁级别 0xB003800F*/
+#define HIGO_ERR_INVANILEVEL LAYER_DEF_ERR(ERR_LAYER_INVANILEVEL)
+
+/**The graphics layer is not started (0xB0038010).*/
+/** CNcomment:图层没有打开 0xB0038010*/
+#define HIGO_ERR_NOTOPEN LAYER_DEF_ERR(ERR_LAYER_NOTOPEN)
+
+/** frame buffer: open fb device failure (0xB0038011).*/
+/** CNcomment: frame buffer, 打开fb设备失败 0xB0038011*/
+#define HIGO_ERR_FB_OPEN_FAILURE                    LAYER_DEF_ERR(ERR_LAYER_FB_OPENFAILURE)
+
+/** frame buffer: get vscreeninfo failure (0xB0038012). */
+/** CNcomment: frame buffer, 获取可变信息失败 0xB0038012 */
+#define HIGO_ERR_FB_GET_VSCREENINFO_FAILURE         LAYER_DEF_ERR(ERR_LAYER_FB_GETVSCREENINFOFAILURE)
+
+/** frame buffer: put vscreeninfo failure (0xB0038013). */
+/** CNcomment: frame buffer, 设置可变信息失败 0xB0038013 */
+#define HIGO_ERR_FB_PUT_VSCREENINFO_FAILURE         LAYER_DEF_ERR(ERR_LAYER_FB_PUTVSCREENINFOFAILURE)
+
+/** frame buffer: get layer info failure (0xB0038014). */
+/** CNcomment: frame buffer, 获取图层信息失败 0xB0038014 */
+#define HIGO_ERR_FB_GET_LAYERINFO_FAILURE           LAYER_DEF_ERR(ERR_LAYER_FB_GETLAYERINFO)
+
+/** frame buffer: put layer info failure (0xB0038015). */
+/** CNcomment: frame buffer, 设置图层信息失败 0xB0038015 */
+#define HIGO_ERR_FB_PUT_LAYERINFO_FAILURE           LAYER_DEF_ERR(ERR_LAYER_FB_PUTLAYERINFO)
+
+/** frame buffer: get layer alpha failure (0xB0038016). */
+/** CNcomment: frame buffer, 获取图层alpha失败 0xB0038016 */
+#define HIGO_ERR_FB_GET_LAYERALPHA_FAILURE          LAYER_DEF_ERR(ERR_LAYER_FB_GETLAYERALPHA)
+
+/** frame buffer: put layer alpha failure (0xB0038017). */
+/** CNcomment: frame buffer, 设置图层alpha失败 0xB0038017 */
+#define HIGO_ERR_FB_PUT_LAYERALPHA_FAILURE          LAYER_DEF_ERR(ERR_LAYER_FB_PUTLAYERALPHA)
+
+/** frame buffer: wrong layre id (0xB0038018). */
+/** CNcomment: frame buffer, 错误的图层ID 0xB0038018 */
+#define HIGO_ERR_FB_WRONG_LAYER_ID                  LAYER_DEF_ERR(ERR_LAYER_FB_WRONG_LAYERID)
+
+/** frame buffer: refresh failure (0xB0038019). */
+/** CNcomment: frame buffer, 刷新失败 0xB0038019 */
+#define HIGO_ERR_FB_REFRESH_FAILURE                 LAYER_DEF_ERR(ERR_LAYER_FB_REFRESHFAILURE)
+
+/** frame buffer: get canvas buffer failure (0xB003801A). */
+/** CNcomment: frame buffer, 获取CANVAS BUFFER失败 0xB003801A */
+#define HIGO_ERR_FB_GET_CANVAS_BUFFER_FAILURE       LAYER_DEF_ERR(ERR_LAYER_FB_GETCANVASBUFFER)
+
+/** frame buffer: put canvas buffer failure (0xB003801B). */
+/** CNcomment: frame buffer, 设置CANVAS BUFFER失败 0xB003801B */
+#define HIGO_ERR_FB_PUT_CANVAS_BUFFER_FAILURE       LAYER_DEF_ERR(ERR_LAYER_FB_PUTCANVASBUFFER)
+
+/** frame buffer: get zorder failure (0xB003801C). */
+/** CNcomment: frame buffer, 获取zorder失败 0xB003801C */
+#define HIGO_ERR_FB_GET_ZORDER_FAILURE              LAYER_DEF_ERR(ERR_LAYER_FB_GETZORDER)
+
+/** frame buffer: put zorder failure (0xB003801D). */
+/** CNcomment: frame buffer, 设置zorder失败 0xB003801D */
+#define HIGO_ERR_FB_PUT_ZORDER_FAILURE              LAYER_DEF_ERR(ERR_LAYER_FB_PUTZORDER)
+
+
+/**Error codes of the HiGo Bliter module*/
+/** CNcomment:HiGo bliter模块错误码 */
+typedef enum
+{
+    ERR_BLITER_INVCOMPTYPE = 0,
+    ERR_BLITER_INVCKEYTYPE,
+    ERR_BLITER_INVMIRRORTYPE,
+    ERR_BLITER_INVROTATETYPE,
+    ERR_BLITER_INVROPTYPE,
+    ERR_BLITER_INVSCALING,
+    ERR_BLITER_OUTOFBOUNDS,
+    ERR_BLITER_EMPTYRECT,
+    ERR_BLITER_OUTOFPAL,
+    ERR_BLITER_NOP,
+    ERR_BLITER_BUTT
+} HIGO_BLITER_ERR_S;
+
+/**The blending mode is incorrect (0xB0048000).*/
+/** CNcomment:错误的混合模式  0xB0048000 */
+#define HIGO_ERR_INVCOMPTYPE HIGO_DEF_ERR(HIGO_MOD_BLITER, ERR_BLITER_INVCOMPTYPE)
+
+/**The colorkey operation is invalid (0xB0048001).*/
+/** CNcomment:无效的colorKey操作 0xB0048001 */
+#define HIGO_ERR_INVCKEYTYPE HIGO_DEF_ERR(HIGO_MOD_BLITER, ERR_BLITER_INVCKEYTYPE)
+
+/**The mirror operation is invalid (0xB0048002).*/
+/** CNcomment:无效的镜像操作 0xB0048002 */
+#define HIGO_ERR_INVMIRRORTYPE HIGO_DEF_ERR(HIGO_MOD_BLITER, ERR_BLITER_INVMIRRORTYPE)
+
+/**The rotation operation is invalid (0xB0048003).*/
+/** CNcomment:无效的旋转操作 0xB0048003 */
+#define HIGO_ERR_INVROTATETYPE HIGO_DEF_ERR(HIGO_MOD_BLITER, ERR_BLITER_INVROTATETYPE)
+
+/**The ROP operation is invalid (0xB0048004).*/
+/** CNcomment:无效的ROP操作 0xB0048004 */
+#define HIGO_ERR_INVROPTYPE HIGO_DEF_ERR(HIGO_MOD_BLITER, ERR_BLITER_INVROPTYPE)
+
+/**The scaling is abnormal (0xB0048005).*/
+/** CNcomment:缩放比例异常 0xB0048005 */
+#define HIGO_ERR_INVSCALING HIGO_DEF_ERR(HIGO_MOD_BLITER, ERR_BLITER_INVSCALING)
+
+/**The rectangle exceeds the boundary (0xB0048006).*/
+/** CNcomment:矩形超出边界 0xB0048006*/
+#define HIGO_ERR_OUTOFBOUNDS HIGO_DEF_ERR(HIGO_MOD_BLITER, ERR_BLITER_OUTOFBOUNDS)
+
+/**The rectangle is empty (0xB0048007).*/
+/** CNcomment:空矩形 0xB0048007*/
+#define HIGO_ERR_EMPTYRECT HIGO_DEF_ERR(HIGO_MOD_BLITER, ERR_BLITER_EMPTYRECT)
+
+/**The palette does not contain this color (0xB0048008).*/
+/** CNcomment:颜色不在调色板中 0xB0048008*/
+#define HIGO_ERR_OUTOFPAL HIGO_DEF_ERR(HIGO_MOD_BLITER, ERR_BLITER_OUTOFPAL)
+
+/**Error codes of the HiGo decoder*/
+/** CNcomment:HiGo decode模块错误码*/
+typedef enum
+{
+    ERR_DEC_INVIMAGETYPE = 0,
+    ERR_DEC_INVINDEX,
+    ERR_DEC_INVIMGDATA,
+    ERR_DEC_BUTT
+} HIGO_ERR_DEC_E;
+
+/**<The picture format is invalid (0xB0058000).*/
+/**<CNcomment:无效的图片类型 0xB0058000 */
+#define HIGO_ERR_INVIMAGETYPE HIGO_DEF_ERR(HIGO_MOD_DEC, ERR_DEC_INVIMAGETYPE)
+
+/**<The picture index number is invalid (0xB0058001).*/
+/**<CNcomment:无效图片索引号 0xB0058001 */
+#define HIGO_ERR_INVINDEX HIGO_DEF_ERR(HIGO_MOD_DEC, ERR_DEC_INVINDEX)
+
+/**<The picture data is invalid (0xB0058002).*/
+/**<CNcomment:无效图片数据 0xB0058002 */
+#define HIGO_ERR_INVIMGDATA HIGO_DEF_ERR(HIGO_MOD_DEC, ERR_DEC_INVIMGDATA)
+
+/**Error codes of the HiGo textout module*/
+/** CNcomment:HiGo textout模块错误码 */
+typedef enum
+{
+    ERR_TEXTOUT_INVRECT = 0,
+    ERR_TEXTOUT_UNSUPPORT_CHARSET,
+    ERR_TEXTOUT_ISUSING,
+    ERR_TEXTOUT_NOIMPLEMENT,
+    ERR_TEXTOUT_SHAPE,
+    ERR_TEXTOUT_MAX_CHAR,
+    ERR_TEXTOUT_CHAR_SET,
+    ERR_TEXTOUT_BIDI,
+    ERR_TEXTOUT_ERRCODE_MAX = 0x1F,
+    ERR_TEXTOUT_INTERNAL = 0,
+    ERR_TEXTOUT_BUTT
+} HIGO_TEXTOUT_ERR_S;
+
+/**The rectangle region is invalid (0xB0068000).*/
+/** CNcomment:无效的矩形区域 0xB0068000 */
+#define HIGO_ERR_INVRECT HIGO_DEF_ERR(HIGO_MOD_TEXTOUT,ERR_TEXTOUT_INVRECT)
+
+/**The character set is not supported (0xB0068001).*/
+/** CNcomment:不支持的字符集 0xB0068001*/
+#define HIGO_ERR_UNSUPPORT_CHARSET HIGO_DEF_ERR(HIGO_MOD_TEXTOUT,ERR_TEXTOUT_UNSUPPORT_CHARSET)
+
+/**The character set is not supported (0xB0068002).*/
+/** CNcomment:不支持的字符集 0xB0068002*/
+#define HIGO_ERR_ISUSING HIGO_DEF_ERR(HIGO_MOD_TEXTOUT,ERR_TEXTOUT_ISUSING)
+/**The function not implement yet (0xB0068003) */
+/** CNcomment:该函数尚未实现 0xB0068003 */
+#define HIGO_ERR_NOIMPLEMENT  HIGO_DEF_ERR(HIGO_MOD_TEXTOUT, ERR_TEXTOUT_NOIMPLEMENT);
+/**Shape Failed (0xB0068004) */
+/** CNcomment:整形失败 0xB0068004 */
+#define HIGO_ERR_SHAPEFAILED HIGO_DEF_ERR(HIGO_MOD_TEXTOUT, ERR_TEXTOUT_SHAPE);
+
+/**Number of characters greater than limit (0xB0068005) */
+/** CNcomment:字符数量过多 0xB0068005 */
+#define HIGO_ERR_MAX_CHAR HIGO_DEF_ERR(HIGO_MOD_TEXTOUT, ERR_TEXTOUT_MAX_CHAR);
+
+/**Char set error (0xB0068006) */
+/** CNcomment:字符集编码错误 0xB0068006 */
+#define HIGO_ERR_CHAR_SET HIGO_DEF_ERR(HIGO_MOD_TEXTOUT, ERR_TEXTOUT_CHAR_SET);
+
+/**bi-directional process erro(0xB)068007) */
+/** CNcomment:双向处理错误 0xB0068006 */
+#define HIGO_ERROR_BIDI HIGO_DEF_ERR(HIGO_MOD_TEXTOUT, ERR_TEXTOUT_BIDI);
+
+/**Internal error (0xB006801F) */
+/** CNcomment:内部错误 0xB006801F */
+#define HIGO_ERR_TEXTINTERNAL HIGO_DEF_ERR(HIGO_MOD_TEXTOUT, ERR_TEXTOUT_INTERNAL)
+
+/**Error codes of the HiGo Winc module*/
+/** CNcomment:HiGo Winc模块错误码 */
+typedef enum
+{
+    ERR_WINC_ALREADYBIND = 0, /**<The Winc module has been attached.*//**<CNcomment:已经被绑定 */
+    ERR_WINC_INVZORDERTYPE,   /**<The z-order adjustment mode is invalid.*//**<CNcomment:无效的Z序调整方式 */
+    ERR_WINC_NOUPDATE,        /**<The desktop is not refreshed.*//**<CNcomment:桌面无更新 */
+    ERR_WINC_INVPF,           /**<The pixel format is invalid.*//**<CNcomment:无效的像素格式 */
+    ERR_WINC_INVTREE,           /**<The window tree is invalid.*//**<CNcomment:无效的窗口树 */
+    ERR_WINC_ALREADYSETMODE,    /**<The window already be set mode.*//**<CNcomment:已经设定窗口内存模式*/
+    ERR_WINC_BUTT
+} HIGO_ERR_WINC_E;
+
+/**The desktop has been attached to a graphics layer (0xB0078000).*/
+/** CNcomment:桌面与图层已经绑定 0xB0078000 */
+#define HIGO_ERR_ALREADYBIND HIGO_DEF_ERR(HIGO_MOD_WINC, ERR_WINC_ALREADYBIND)
+
+/**The z-order adjustment mode is invalid (0xB0078001).*/
+/** CNcomment:无效的Z序调整方式 0xB0078001 */
+#define HIGO_ERR_INVZORDERTYPE HIGO_DEF_ERR(HIGO_MOD_WINC, ERR_WINC_INVZORDERTYPE)
+
+/**The desktop is not refreshed (0xB0078002).*/
+/** CNcomment:桌面无更新 0xB0078002 */
+#define HIGO_ERR_NOUPDATE HIGO_DEF_ERR(HIGO_MOD_WINC, ERR_WINC_NOUPDATE)
+
+/**The desktop is not refreshed (0xB0078003).*/
+/** CNcomment:桌面无更新 0xB0078003 */
+#define HIGO_ERR_INVPF HIGO_DEF_ERR(HIGO_MOD_WINC, ERR_WINC_INVPF)
+
+/**The desktop is not refreshed (0xB0078004).*/
+/** CNcomment:桌面无更新 0xB0078004 */
+#define HIGO_ERR_INVTREE HIGO_DEF_ERR(HIGO_MOD_WINC, ERR_WINC_INVTREE)
+
+/**The window already be set mode (0xB0078005).*/
+/** CNcomment:已经设定窗口内存模式 0xB0078005 */
+#define HIGO_ERR_ALREADYSETMODE HIGO_DEF_ERR(HIGO_MOD_WINC, ERR_WINC_ALREADYSETMODE)
+
+/**Error codes of the HiGo surface module*/
+/** CNcomment:HiGo Cursor模块错误码 */
+typedef enum
+{
+    ERR_CURSOR_INVHOTSPOT = 0,
+    ERR_CURSOR_NOCURSORINFO,
+    ERR_CURSOR_BUTT
+} HIGO_CURSOR_ERR_E;
+
+/**The hot spot coordinate of the cursor is invalid (0xB0088000).*/
+/** CNcomment:无效的cursor热点坐标 0xB0088000 */
+#define HIGO_ERR_INVHOTSPOT  HIGO_DEF_ERR(HIGO_MOD_CURSOR, ERR_CURSOR_INVHOTSPOT)
+
+/**The cursor information is not set (0xB0088001).*/
+/** CNcomment:没有设置cursor信息 0xB0088001 */
+#define HIGO_ERR_NOCURSORINF HIGO_DEF_ERR(HIGO_MOD_CURSOR, ERR_CURSOR_NOCURSORINFO)
+
+/** @} */  /*! <!-- Macro Definition end */
+
+
+
+/*************************** Structure Definition ****************************/
+
+
+/********************** Global Variable declaration **************************/
+
+
+/******************************* API declaration *****************************/
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif /* __HI_GO_ERRNO_H__ */
diff -uNr a/include/hi_go_gdev.h b/include/hi_go_gdev.h
--- a/include/hi_go_gdev.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_go_gdev.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,1022 @@
+#ifndef __HI_GO_GDEV_H__
+#define __HI_GO_GDEV_H__
+
+#include "hi_go_comm.h"
+#include "hi_go_surface.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/***************************** Macro Definition ******************************/
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HIGO_GDEV */
+/** @{ */  /** <!-- [HIGO_GDEV] */
+
+/** Definition of the graphics layer ID*/
+/** CNcomment:图层ID定义*/
+typedef enum
+{
+    HIGO_LAYER_SD_0 = 0,
+    HIGO_LAYER_SD_1,
+    HIGO_LAYER_HD_0,
+    HIGO_LAYER_HD_1,
+    HIGO_LAYER_HD_2,
+    HIGO_LAYER_HD_3,
+    HIGO_LAYER_AD_0,
+    HIGO_LAYER_AD_1,
+    HIGO_LAYER_BUTT,
+}HIGO_LAYER_E;
+
+/**Standard-definition (SD) graphics layer 0*/
+/** CNcomment:标清图形叠加层0 */
+#define HIGO_LAYER_RGB0 HIGO_LAYER_SD_0
+
+/**SD graphics layer 1*/
+/** CNcomment:标清图形叠加层1 */
+#define HIGO_LAYER_RGB1 HIGO_LAYER_SD_1
+
+#define GRAPHICS_LAYER_MAX_NUM 4
+/** The following macro defines the buffer mode of each graphics layer of the HiGo. The canvas buffer is used for drawing,
+and the display buffer is used for display output.*/
+/** CNcomment:下面宏定义了higo的每个图层的buffer模式，其中canvas buffer是供用户绘制的buffer, display buffer是用于显示输出的buffer.*/
+#define HIGO_LAYER_BUFFER_SINGLE      0x02 /**<One canvas buffer, and no display buffer*//**<CNcomment:1块canvas buffer, 无display buffer */
+#define HIGO_LAYER_BUFFER_DOUBLE      0x04 /**<One canvas buffer, and one display buffer. Dual buffers are supported.*//**<CNcomment:1块canvas buffer, 1块display buffer 支持双缓冲 */
+#define HIGO_LAYER_BUFFER_TRIPLE      0x08 /**<One canvas buffer, and two display buffers. The flip function is supported.*//**<CNcomment:1块canvas buffer, 2块display buffer 支持flip,刷新的时候等待任务完成 */
+#define HIGO_LAYER_BUFFER_OVER        0x10 /**<One canvas buffer, and two display buffers. The flip function is supported. If tasks are being performed during refresh, the current frame is discarded.*//**<CNcomment:1块canvas buffer, 2块display buffer 支持flip,如果刷新的时候带有任务忙，则丢弃当前帧 */
+
+/**Refresh mode of graphics layers for complying with old definitions. The mode is not recommended.*/
+/** CNcomment:为兼容老定义，图层的刷新方式，不建议使用*/
+typedef enum
+{
+    HIGO_LAYER_FLUSH_FLIP        = HIGO_LAYER_BUFFER_TRIPLE,
+    HIGO_LAYER_FLUSH_DOUBBUFER   = HIGO_LAYER_BUFFER_DOUBLE,
+    HIGO_LAYER_FLUSH_NORMAL      = HIGO_LAYER_BUFFER_SINGLE,
+    HIGO_LAYER_FLUSH_OVER        = HIGO_LAYER_BUFFER_OVER,
+    HIGO_LAYER_FLUSH_BUTT
+} HIGO_LAYER_FLUSHTYPE_E;
+
+/**Anti-flicker level, ranging from low to high. The higher the level, the better the anti-flicker effect, but the more blurred the picture.*/
+/** CNcomment:抗闪烁级别，值为LOW~HIGH,值越大抗闪烁效果越好，但越模糊*/
+typedef enum
+{
+    HIGO_LAYER_DEFLICKER_NONE = 0,
+    HIGO_LAYER_DEFLICKER_LOW,
+    HIGO_LAYER_DEFLICKER_MIDDLE,
+    HIGO_LAYER_DEFLICKER_HIGH,
+    HIGO_LAYER_DEFLICKER_AUTO,
+    HIGO_LAYER_DEFLICKER_BUTT
+}HIGO_LAYER_DEFLICKER_E;
+
+/**Frame encode format*/
+/** CNcomment:帧编码传输格式*/
+typedef enum
+{
+    HIGO_ENCPICFRM_MONO   = 0x0,            /**<Normal display, no 3D TV*//**<CNcomment:正常输出，非3D 电视*/
+    HIGO_ENCPICFRM_STEREO_SIDEBYSIDE_HALF,  /**< L/R frames are downscaled horizontally by 2 andpacked side-by-side into a single frame, left on lefthalf of frame*//**<CNcomment:将L/R帧水平缩放到单帧中*/
+    HIGO_ENCPICFRM_STEREO_TOPANDBOTTOM,     /**< L/R frames are downscaled vertically by 2 andpacked into a single frame, left on top*//**<CNcomment:将L/R帧垂直缩放到单帧中*/
+    HIGO_ENCPICFRM_BUTT
+}HIGO_ENCPICFRM_E;
+
+/**3D STEREO mode*/
+/** CNcomment:3D STEREO模式*/
+typedef enum
+{
+    HIGO_STEREO_MODE_HW_FULL = 0x0,  /**< 3d stereo function use hardware and transfer full frame to vo, note: hardware doesn't support the mode if encoder picture delivery method is top and bottom */
+    HIGO_STEREO_MODE_HW_HALF ,       /**< 3d stereo function use hardware and transfer half frame to vo*/
+    HIGO_STEREO_MODE_SW_EMUL,        /**<3d stereo function use software emulation */
+    HIGO_STEREO_MODE_BUTT
+}HIGO_STEREO_MODE_E;
+
+/**Layer attribute parameters*/
+/** CNcomment:图层属性参数*/
+typedef struct
+{
+    HI_S32                 ScreenWidth;    /**<Height of a graphics layer on the screen. The value must be greater than 0.*//**<CNcomment:图层在屏幕上显示宽度，必须大于0 */
+    HI_S32                 ScreenHeight;   /**<Width of a graphics layer on the screen. The value must be greater than 0.*//**<CNcomment:图层在屏幕上显示高度，必须大于0 */
+    HI_S32                 CanvasWidth;    /**<Width of the canvas buffer of a graphics layer. If the value is 0, no canvas buffer is created.*//**<CNcomment:图层的绘制buffer宽度，为0时，不创建绘制buffer */
+    HI_S32                 CanvasHeight;   /**<Height of the canvas buffer of a graphics layer. If the value is 0, no canvas buffer is created.*//**<CNcomment:图层的绘制buffer高度，为0时，不创建绘制buffer */
+    HI_S32                 DisplayWidth;   /**<Width of the display buffer of a graphics layer. If the value is 0, the value of ScreenWidth is used.*//**<CNcomment:图层的显示buffer宽度，为0时，和ScreenWidth相同*/
+    HI_S32                 DisplayHeight;  /**<Height of the display buffer of a graphics layer. If the value is 0, the value of ScreenHeight is used.*//**<CNcomment:图层的显示buffer高度，为0时，和ScreenHeight相同*/
+    HIGO_LAYER_FLUSHTYPE_E LayerFlushType; /**< Refresh mode of the layer. You can choose the refresh mode based on the actual scenario to improve the refresh efficiency. If the value is 0, the dual-buffer+flip refresh mode is used by default. *//**<CNcomment:图层的刷新方式，用户可根据使用场景选择不同的刷新模式来提高刷新效率,等于0时默认使用双缓冲+Flip刷新模式 */
+    HIGO_LAYER_DEFLICKER_E AntiLevel;      /**<Anti-flicker level of a graphics layer*//**<CNcomment:图层抗闪烁级别 */
+    HIGO_PF_E              PixelFormat;    /**<Pixel format of a graphics layer. The format must be supported by the hardware layer. You need to choose the pixel format parameters of the layer based on hardware devices.*//**<CNcomment:图层的像素格式，此格式必须为硬件图层所支持的格式，请根据不同硬件设备来选择图层的像素格式参数 */
+    HIGO_LAYER_E           LayerID;        /**<Hardware ID of a graphics layer. The supported graphics layer depends on the chip platform. For example, the Hi3720 supports an HD graphics layer and an SD graphics layer.*//**<CNcomment:图层硬件ID，能支持图层取决于芯片平台，支持一个高清和一个标清 */
+} HIGO_LAYER_INFO_S;
+
+/**Status of a graphics layer*/
+/** CNcomment:图层状态结构 */
+typedef struct
+{
+    HI_BOOL bShow;             /**<Whether to display a graphics layer.*//**<CNcomment:图层是否显示 */
+} HIGO_LAYER_STATUS_S;
+
+typedef struct
+{
+    HI_COLOR ColorKey;         /**<Transparency of a graphics layer*//**<CNcomment:图层的透明色*/
+    HI_BOOL bEnableCK;         /**<Whether the colorkey of a graphics layer is enabled.*//**<CNcomment:图层是否使能colorkey */
+}HIGO_LAYER_KEY_S;
+
+typedef struct
+{
+    HI_BOOL bAlphaEnable;   /**<Alpha pixel enable flag*//**<CNcomment:alpha像素使能标志 */
+    HI_BOOL bAlphaChannel;  /**<Alpha channel enable flag*//**<CNcomment:alpha通道使能标志  */
+    HI_U8   Alpha0;         /**<Alpha0 value. It is valid in ARGB1555 format.*//**<CNcomment:alpha0值,在ARGB1555格式下生效 */
+    HI_U8   Alpha1;         /**<Alpha1 value. It is valid in ARGB1555 format.*//**<CNcomment:alpha1值,在ARGB1555格式下生效 */
+    HI_U8   GlobalAlpha;    /**<Global alpha. This value is valid only when the alpha channel is valid.*//**<CNcomment:全局alpha，该值只有在alpha通道有效的时候才有意义 */
+}HIGO_LAYER_ALPHA_S;
+
+typedef struct
+{
+    HI_HANDLE   Layer;          /** The layer the scrolltext want to show */
+    HI_RECT       stScrollRect;   /** the position you wanted to show on the layer */
+    HIGO_PF_E   ePixelFormat;    /** the color format of scrolltext content */
+    HI_U16        u16CacheNum;       /** The cached buffer number for store scrolltext content */
+    HI_U16        u16RefreshFreq;    /** The refresh frequency you wanted */
+    HI_BOOL     bDeflicker;        /** Whether enable antificker */
+} HIGO_SCROLLTEXT_ATTR_S;
+
+typedef struct
+{
+    HI_U32 u32PhyAddr;   /** The physical address of the scrolltext content buffer */
+    HI_U8  *pu8VirAddr;  /** The virtual address of the scrolltext content buffer */
+    HI_U32 u32BufferLen; /** The virtual or physical address Length of the scrolltext content buffer */
+    HI_U32 u32Stride;    /** The stride of the scrolltext content buffer */
+} HIGO_SCROLLTEXT_DATA_S;
+
+
+
+/** @} */  /*! <!-- Structure Definition end */
+
+/********************** Global Variable declaration **************************/
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HIGO_GDEV */
+/** @{ */  /** <!--[HIGO_GDEV] */
+
+/**
+\brief Initializes a display device. CNcomment:初始化显示设备 CNend
+\attention \n
+When ::HI_GO_Init is called, this API is also called.
+CNcomment: ::HI_GO_Init已包含了对该接口的调用 CNend
+\param N/A. CNcomment:无 CNend
+
+\retval ::HI_FAILURE
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INITFAILED
+
+\see \n
+::HI_GO_Init \n
+::HI_GO_DeinitDisplay
+*/
+HI_S32 HI_GO_InitDisplay(HI_VOID);
+
+/**
+\brief Deinitializes a display device. CNcomment:去初始化显示设备 CNend
+\attention \n
+When ::HI_GO_Deinit is called, this API is also called.
+CNcomment: ::HI_GO_Deinit已包含了对该接口的调用 CNend
+\param N/A. CNcomment:无 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_DEINITFAILED
+
+\see \n
+::HI_GO_Deinit \n
+::HI_GO_InitDisplay
+*/
+HI_S32 HI_GO_DeinitDisplay(HI_VOID);
+
+/**
+\brief Obtains the default parameters of an SD or HD graphics layer based on its ID.
+If you do not want to use default values, you can set the members of pLayerInfo.
+CNcomment:根据图层ID获取相应图层(SD,HD)创建时的默认参数，
+如果需要使用非默认值，可以直接设置pLayerInfo各个成员 CNend
+\attention \n
+
+\param[in] LayerID Layer ID. CNcomment:图层ID CNend
+\param[in]  pLayerInfo Obtained parameters of a graphics layer when it is created. CNcomment:获取到的创建参数 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVLAYERID
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVPARAM
+\see \n
+N/A. CNcomment:无 CNend
+*/
+HI_S32 HI_GO_GetLayerDefaultParam (HIGO_LAYER_E LayerID, HIGO_LAYER_INFO_S *pLayerInfo);
+
+
+/**
+\brief Creates a graphics layer. CNcomment:创建图层 CNend
+\attention \n
+The platform determines whether VO hardware scaling is supported.
+If VO hardware scaling is supported, the display size is scaled to fit the screen when the display size is inconsistent with the screen size.
+If VO hardware scaling is not supported, the display size and screen size must be the same.
+CNcomment:是否支持VO硬件缩放取决于平台。
+如果平台支持VO 硬件缩放，即在设置displaysize与screensize不一致的情况下，最终会缩放到screensize的大小。
+如果平台不支持VO 硬件缩放，即使displaysize与screensize不一致，也会强制要求displaysize与screensize一致 CNend
+
+\param[in]  pLayerInfo Basic attributes of a graphics layer. The value cannot be empty. CNcomment:图层基本属性，不可为空 CNend
+\param[out] pLayer Pointer to the handle of a graphics layer. The value cannot be empty. CNcomment:图层的句柄指针，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVSIZE
+\retval ::HIGO_ERR_INVLAYERID
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_INVFLUSHTYPE
+\retval ::HIGO_ERR_INVANILEVEL
+\retval ::HIGO_ERR_INVSIZE
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_INTERNAL
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+\retval ::HIGO_ERR_ALREADYBIND
+\retval ::HIGO_ERR_INVLAYERSURFACE
+
+\see \n
+::HI_GO_DestroyLayer
+*/
+HI_S32 HI_GO_CreateLayer (const HIGO_LAYER_INFO_S *pLayerInfo, HI_HANDLE* pLayer);
+
+/**
+\brief Destroys a graphics layer. CNcomment:销毁图层 CNend
+\attention \n
+If a graphics layer is in use (for example, the desktop based on the layer is not destroyed), the layer cannot be destroyed.
+CNcomment:当图层正在被使用时（例如基于此图层的桌面未销毁），则图层无法被销毁 CNend
+\param[in] Layer Layer handle. CNcomment:图层句柄 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+
+
+\see \n
+::HI_GO_CreateLayer
+*/
+HI_S32 HI_GO_DestroyLayer(HI_HANDLE Layer);
+
+
+/**
+\brief Sets the position of a graphics layer on the screen. CNcomment:设置图层在屏幕中的位置 CNend
+\attention \n
+The value takes effect at once and you do not need to refresh it. If the start position of a layer exceeds the screen, it is automatically adjusted to the boundary of the screen.
+CNcomment:立即生效，无需刷新。当设置的图层的起始位置超出屏幕范围时会自动调整至屏幕的边界值 CNend
+\param[in] Layer  Layer handle. CNcomment:图层句柄 CNend
+\param[in] u32StartX Horizontal coordinate of the position where a layer appears on the screen. CNcomment:图层在屏幕上的显示位置X坐标 CNend
+\param[in] u32StartY Vertical coordinate of the position where a layer appears on the screen. CNcomment:图层在屏幕上的显示位置Y坐标 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVLAYERPOS
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+::HI_GO_GetLayerPos
+*/
+HI_S32 HI_GO_SetLayerPos(HI_HANDLE Layer, HI_U32 u32StartX, HI_U32 u32StartY);
+
+/**
+\brief Obtains the position where a layer appears on the screen. CNcomment:获取图层在屏幕上的位置 CNend
+\attention \n
+N/A. CNcomment:无 CNend
+\param[in] Layer Layer handle. CNcomment:图层句柄 CNend
+\param[out] pStartX Pointer of the horizontal coordinate of the position where a layer appears on the screen. The value cannot be empty. CNcomment:图层在屏幕上的显示位置X坐标指针，不可为空 CNend
+\param[out] pStartY Pointer of the vertical coordinate of the position where a layer appears on the screen. The value cannot be empty. CNcomment:图层在屏幕上的显示位置Y坐标指针，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+::HI_GO_SetLayerPos
+*/
+HI_S32 HI_GO_GetLayerPos(HI_HANDLE Layer, HI_U32 *pStartX, HI_U32 *pStartY);
+
+
+/**
+\brief Sets the output height and width of a graphics layer on the display device. CNcomment:设置在输出显示设备上的输出的高度和宽度 CNend
+\attention \n
+This API supports zoom in operations. The maximum range is specified when a graphics layer is created.\n
+CNcomment:在内存支持的前提下，该接口可以支持缩放 CNend
+
+\param[in]  Layer Layer handle. CNcomment:图层句柄 CNend
+\param[in] u32SWidth  Actual output width. CNcomment:实际输出宽度 CNend
+\param[in] u32SHeight Actual output height. CNcomment:实际输出高度 CNend
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVSIZE
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+::HI_GO_GetScreenSize
+*/
+HI_S32 HI_GO_SetScreenSize(HI_HANDLE Layer, HI_U32 u32SWidth, HI_U32 u32SHeight);
+
+
+/**
+\brief Obtains the output height and width of a graphics layer on the display device. CNcomment:获取在输出显示设备上的输出的高度和宽度。CNend
+\attention \n
+N/A. CNcomment:无 CNend
+\param[in]  Layer Layer handle. CNcomment:图层句柄 CNend
+\param[out] pSWidth  Pointer to the actual output width. CNcomment:实际输出宽度指针 CNend
+\param[out] pSHeight Pointer to the actual output height. CNcomment:实际输出高度指针 CNend
+\retval none
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+::HI_GO_SetScreenSize
+*/
+HI_S32 HI_GO_GetScreenSize(HI_HANDLE Layer, HI_U32 *pSWidth, HI_U32 *pSHeight);
+
+/**
+\brief Sets the global alpha value of a layer surface. CNcomment:设置图层surface的全局alpha值 CNend
+\attention \n
+The value takes effect at once, and you do not need to refresh it.
+CNcomment:立即生效，无需刷新 CNend
+\param[in] Layer Layer handle. CNcomment:图层句柄 CNend
+\param[in] Alpha Global alpha value. The value cannot be empty and ranges from 0 to 255. CNcomment:Alpha 全局alpha值，不可为空，范围0-255 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_SETALPHAFAILED
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+::HI_GO_GetLayerAlpha
+*/
+
+HI_S32 HI_GO_SetLayerAlpha(HI_HANDLE Layer, HI_U8 Alpha);
+
+/**
+\brief Sets layer premul state. CNcomment:设置预乘状态 CNend
+\attention \n
+The value takes effect at once, and you do not need to refresh it.
+CNcomment:立即生效，无需刷新 CNend
+\param[in] Layer Layer handle. CNcomment:图层句柄 CNend
+\param[in] enable or disable layer premu. CNcomment:设置预乘状态CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+
+\see \n
+::HI_GO_SetLayerPreMul
+*/
+HI_S32 HI_GO_SetLayerPreMul(HI_HANDLE Layer, HI_BOOL bPreMul);
+
+
+/**
+\brief Obtains the global alpha value of a layer surface. CNcomment:获取图层surface的全局alpha值 CNend
+\attention \n
+N/A. CNcomment:无 CNend
+\param[in] Layer Layer handle. CNcomment:图层句柄 CNend
+\param[out] pAlpha Pointer to the global alpha value. CNcomment:全局alpha指针 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+::HI_GO_SetLayerAlpha
+*/
+HI_S32 HI_GO_GetLayerAlpha(HI_HANDLE Layer, HI_U8* pAlpha);
+
+
+/**
+\brief Obtains the surface of a graphics layer. CNcomment:获取图层的surface CNend
+\attention \n
+Surface of a graphics layer. It cannot be released by calling HI_GO_FreeSurface. The surface can be released only when the corresponding layer is destroyed.
+After a process is switched, you must obtain the layer surface again by calling HI_S32 HI_GO_GetLayerSurface.
+CNcomment:图层surface，不能使用HI_GO_FreeSurface来释放。只有在销毁图层的时候才会被释放
+进程切换之后必须调用该接口来重新获取图层surface; CNend
+\param[in] Layer handle. CNcomment:Layer 图层句柄 CNend
+\param[out] pSurface Pointer to the surface handle. The value cannot be empty. CNcomment:surface句柄指针，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVLAYERSURFACE
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+N/A. CNcomment:无 CNend
+*/
+HI_S32 HI_GO_GetLayerSurface(HI_HANDLE Layer, HI_HANDLE *pSurface);
+
+/**
+\brief Shows or hides a graphics layer. CNcomment:显示或隐藏图层 CNend
+\attention \n
+The value takes effect at once, and you do not need to refresh it.
+CNcomment:立即生效，无需刷新 CNend
+\param[in] Layer Layer handle. CNcomment:图层句柄 CNend
+\param[in] bVisbile Show/hide flag. HI_TRUE: show; HI_FALSE: hide. CNcomment:显示隐藏标志。HI_TRUE：显示；HI_FALSE：隐藏 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+::HI_GO_GetLayerStatus
+*/
+HI_S32 HI_GO_ShowLayer(HI_HANDLE Layer, HI_BOOL bVisbile);
+
+/**
+\brief Obtains the current status of a graphics layer. CNcomment:获取图层当前状态 CNend
+\attention \n
+N/A. CNcomment:无 CNend
+\param[in] Layer Layer handle. CNcomment:图层句柄 CNend
+\param[out] pLayerStatus Pointer to the current status of a graphics layer. The value cannot be empty. CNcomment:图层当前状态结构指针，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+::HI_GO_ShowLayer
+*/
+HI_S32 HI_GO_GetLayerStatus(HI_HANDLE Layer, HIGO_LAYER_STATUS_S* pLayerStatus);
+
+/**
+\brief Refreshes a graphics layer. CNcomment:刷新图层 CNend
+\attention \n
+1. After drawing, you need to refresh the layer to display the drawing result.
+2. There are two display modes after a graphics layer is refreshed. If there is no window, the contents of the layer surface are displayed; if there is a window, its contents are displayed.
+CNcomment:1.绘制完成后，需刷新图层才能显示绘制后结果
+2.刷新有两种模式，一种是没有任何窗口的时候就显示layersurface的内容，否则显示窗口中的内容。CNend
+\param[in] Layer Layer handle. CNcomment:图层句柄 CNend
+\param[in]  pRect Rectangle to be refreshed. If the value is NULL, the entire screen is refreshed. CNcomment:刷新的矩形区域，如果是NULL, 则刷新整个全屏 CNend
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVLAYERSURFACE
+\retval ::HIGO_ERR_DEPEND_FB
+\retval ::HIGO_ERR_OUTOFBOUNDS
+\retval ::HIGO_ERR_EMPTYRECT
+
+\see \n
+N/A. CNcomment:无 CNend
+*/
+HI_S32 HI_GO_RefreshLayer(HI_HANDLE Layer, const HI_RECT* pRect);
+
+
+/**
+\brief Sets the canvas buffer of a graphics layer. CNcomment:设置层的canvas surface. CNend
+\attention \n
+If the stream sources of the HD and SD graphics layer are the same, the canvas buffer of the SD graphics layer can be shared with the HD graphics layer.
+CNcomment:高清和标清同源时，我们可以让标清的canvas buffer与高清的共享同一个
+     Surrface的内存类型必须是MMZ类型的. CNend
+\param[in] Layer     Layer handle. CNcomment:图层句柄 CNend
+\param[in] hSurface  Surface of a graphics layer. If the value is INVALID_HANDLE, there is no user handle. CNcomment:图层的surface，如果该参数为INVALID_HANDLE表示没有用户句柄 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVLAYERSURFACE
+\retval ::HIGO_ERR_INVPIXELFMT
+\retval ::HIGO_ERR_INVPARAM
+
+\see \n
+N/A. CNcomment:无 CNend
+*/
+HI_S32 HI_GO_SetLayerSurface(HI_HANDLE Layer, HI_HANDLE hSurface);
+
+
+
+/**
+\brief Sets the background color of a graphics layer. CNcomment:设置图层的背景颜色 CNend
+\attention \n
+The background color of a graphics layer takes effect only when widows are overlaid with each other.
+CNcomment:图层背景色，只有在叠加窗口才有效 CNend
+\param[in] Layer Layer handle. CNcomment:图层句柄 CNend
+\param[in] Color Background color of a graphics layer. CNcomment:图层背景颜色 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A. CNcomment:无 CNend
+*/
+HI_S32 HI_GO_SetLayerBGColor(HI_HANDLE Layer, HI_COLOR Color);
+
+/**
+\brief Obtains the background color of a graphics layer. CNcomment:获取图层的背景颜色 CNend
+\attention \n
+This API is available only when there are windows on graphics layers. Otherwise, the configured background color does not take effect.
+CNcomment:此接口只有在图层上有窗口的时候才会有效。否则该颜色设置无效。CNend
+\param[in] Layer Layer handle. CNcomment:图层句柄 CNend
+\param[in] pColor Used for storing the background color of a graphics layer. CNcomment:存储图层背景颜色 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A. CNcomment:无 CNend
+*/
+HI_S32 HI_GO_GetLayerBGColor(HI_HANDLE Layer, HI_COLOR* pColor);
+
+/**
+\brief Sets the size of a display buffer. CNcomment:设置显示buffer size CNend
+\attention \n
+N/A. CNcomment:无 CNend
+
+\param[in] Layer      Layer handle. CNcomment:图层句柄 CNend
+\param[in] u32DWidth     Pointer to the width. CNcomment:宽度指针 CNend
+\param[in] u32DHeight    Pointer to the height. CNcomment:高度指针 CNend
+\param[out] N/A . CNcomment:无  CNend
+
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVSIZE
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+    ::HI_GO_GetDisplaySize
+*/
+HI_S32 HI_GO_SetDisplaySize(HI_HANDLE Layer, HI_U32 u32DWidth, HI_U32 u32DHeight);
+
+/**
+\brief Obtains the size of a display buffer. CNcomment:获取显示buffer的size CNend
+\attention \n
+N/A. CNcomment:无 CNend
+
+\param[in] Layer      Layer handle. CNcomment:图层句柄 CNend
+\param[in] pDWidth    Pointer to the width. The value cannot be empty. CNcomment:宽度指针，不可为空  CNend
+\param[in] pDHeight   Pointer to the height. The value cannot be empty. CNcomment:高度指针，不可为空 CNend
+\param[out] N/A. CNcomment:无 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+    ::HI_GO_SetDisplaySize
+*/
+HI_S32 HI_GO_GetDisplaySize(HI_HANDLE Layer, HI_U32 *pDWidth, HI_U32 *pDHeight);
+
+/**
+\brief Sets the refresh mode. CNcomment:设置刷新类型 CNend
+\attention \n
+N/A. CNcomment:无 CNend
+
+\param[in] Layer         Layer handle. CNcomment:图层句柄 CNend
+\param[in] FlushType     Refresh mode of a graphics layer. CNcomment:图层刷新类型 CNend
+\param[out] N/A. CNcomment:无 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVFLUSHTYPE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_GetFlushType
+*/
+HI_S32 HI_GO_SetFlushType(HI_HANDLE Layer, HIGO_LAYER_FLUSHTYPE_E FlushType);
+
+/**
+\brief Obtains the refresh mode. CNcomment:获取刷新类型 CNend
+\attention \n
+N/A. CNcomment:无 CNend
+
+\param[in] Layer       Layer handle. CNcomment:图层句柄  CNend
+\param[in] *pFlushType Refresh mode of a graphics layer. The value cannot be empty. CNcomment:图层刷新类型，不可为空  CNend
+\param[out] N/A. CNcomment:无  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_SetFlushType
+*/
+HI_S32 HI_GO_GetFlushType(HI_HANDLE Layer, HIGO_LAYER_FLUSHTYPE_E *pFlushType);
+
+/**
+\brief Sets the transparency of a graphics layer. CNcomment:设置图层的透明色 CNend
+\attention \n
+N/A. CNcomment:无 CNend
+
+\param[in] Layer       Layer handle. CNcomment:图层句柄  CNend
+\param[in] pKey        Pointer to the transparency information. The value cannot be empty. CNcomment:透明色信息指针，不可为空 CNend
+\param[out] N/A. CNcomment:无  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_GetLayerColorkey
+*/
+HI_S32 HI_GO_SetLayerColorkey(HI_HANDLE Layer, const HIGO_LAYER_KEY_S *pKey);
+
+/**
+\brief Obtains the transparency information about a graphics layer. CNcomment:获取透明色信息 CNend
+\attention \n
+N/A. CNcomment:无 CNend
+
+\param[in] Layer       Layer handle. CNcomment:图层句柄 CNend
+\param[in] pKey        Pointer to the transparency information. CNcomment:透明色信息指针 CNend
+\param[out] N/A. CNcomment:无  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_SetLayerColorkey
+*/
+HI_S32 HI_GO_GetLayerColorkey(HI_HANDLE Layer, HIGO_LAYER_KEY_S *pKey);
+
+/**
+\brief Sets the palette of a graphics layer. CNcomment:设置图层的调色板 CNend
+\attention \n
+N/A. CNcomment:无 CNend
+
+\param[in] Layer       Layer handle. CNcomment:图层句柄 CNend
+\param[in] Palette     Palette of a graphics layer. CNcomment:图层调色板 CNend
+\param[out] N/A. CNcomment:无  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_GetLayerPalette
+*/
+HI_S32 HI_GO_SetLayerPalette(HI_HANDLE Layer, const HI_PALETTE Palette);
+
+/**
+\brief Obtains the palette of a graphics layer. CNcomment:获取图层调色板 CNend
+\attention \n
+N/A. CNcomment:无 CNend
+
+\param[in] Layer       Layer handle. CNcomment:图层句柄 CNend
+\param[in] Palette     Palette of a graphics layer. CNcomment:图层调色板 CNend
+\param[out] N/A. CNcomment:无  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_SetLayerPalette
+*/
+HI_S32 HI_GO_GetLayerPalette(HI_HANDLE Layer, HI_PALETTE Palette);
+
+/**
+\brief Waits for the blanking area. CNcomment:等待消隐区 CNend
+\attention \n
+N/A
+CNcomment:无  CNend
+\param[in] Layer       Layer handle. CNcomment:图层句柄  CNend
+\param[out] N/A. CNcomment:无  CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_SetLayerPalette
+*/
+HI_S32 HI_GO_WaitForBlank(HI_HANDLE Layer);
+
+
+/**
+\brief Configures the alpha information about a graphics layer. This API is an extended API. CNcomment:设置图层alpha信息，扩展接口 CNend
+\attention \n
+The alpha0 and alpha1 of the data structure HIGO_LAYER_ALPHA_S are valid only in ARGB1555 format.
+This API is used to implement the translucent effect in ARGB1555 format.
+CNcomment:该接口HIGO_LAYER_ALPHA_S结构体的alpha0,alpha1只在ARGB1555格式下才有效，
+用于在ARGB1555格式下实现半透明效果 CNend
+
+\param[in] Layer       Layer handle. CNcomment:图层句柄 CNend
+\param[in] pAlphaInfo   Alpha information about a graphics layer. The value cannot be empty. CNcomment:图层alpha信息，不可为空 CNend
+\param[out] N/A.
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+::HI_GO_GetLayerAlphaEx
+*/
+HI_S32 HI_GO_SetLayerAlphaEx(HI_HANDLE Layer,  HIGO_LAYER_ALPHA_S *pAlphaInfo);
+
+
+/**
+\brief Obtains the alpha information about a graphics layer. This API is an extended API. CNcomment:获取图层alpha信息，扩展接口 CNend
+\attention \n
+N/A. CNcomment:无 CNend
+
+\param[in] Layer       Layer handle. CNcomment:图层句柄 CNend
+\param[out] pAlphaInfo  Alpha information about a graphics layer. The value cannot be empty. CNcomment:图层alpha信息，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_SetLayerAlphaEx
+*/
+HI_S32 HI_GO_GetLayerAlphaEx(HI_HANDLE Layer,  HIGO_LAYER_ALPHA_S *pAlphaInfo);
+
+/**
+\brief set the Z order of graphics layer in the sample display. CNcomment:改变同一显示设备上图形层的Z序。CNend
+\attention \n
+this function make effect imediately. CNcomment:该功能需要硬件支持Z序的修改，立即生效，无需刷新 CNend
+\param[in] Layer Layer handle. CNcomment:图层句柄  CNend
+\param[in] ZFlag zorder flag. CNcomment:修改Z序标志 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVORDERFLAG
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_CANNOTCHANGE
+
+\see \n
+::HI_GO_GetLayerZorder
+*/
+HI_S32 HI_GO_SetLayerZorder(HI_HANDLE Layer, HIGO_ZORDER_E enZOrder);
+
+/**
+\brief get the Z order of graphics layer in the sample display. CNcomment:获取同一显示设备上图形层的Z序。CNend
+\attention \n
+CNcomment:Z序越小的图层越靠下 CNend
+\param[in] Layer    Layer handle. CNcomment:图层句柄  CNend
+\param[out] pZOrder Z Order Information. CNcomment:图层Z序信息。CNend
+
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+::HI_GO_ChangeLayerZorder
+*/
+HI_S32 HI_GO_GetLayerZorder(HI_HANDLE Layer, HI_U32* pu32ZOrder);
+
+/**
+\brief Sets frame input encode mode of a graphic layer. CNcomment:设置图形层输入3D格式，输出格式自动跟随VO进行设置。CNend
+\attention \n
+MONO is the default mode.
+CNcomment:默认为MONO格式，即普通非3D Stereo格式. CNend
+
+\param[in] Layer       Layer handle. CNcomment:图层句柄 CNend
+\param[in] EncPicFrm  Frame encode mode.The value cannot be empty. CNcomment:图层帧传输编码格式，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_GetStereoMode
+*/
+HI_S32 HI_GO_SetStereoMode(HI_HANDLE Layer,  HIGO_STEREO_MODE_E InputEnc);
+
+
+
+/**
+\brief Obtains frame encode mode of a graphic layer. CNcomment:获取图形层3D格式。CNend
+\attention \n
+CNcomment:无 CNend
+
+\param[in] Layer       Layer handle. CNcomment:图层句柄 CNend
+\param[out] pInputEnc  Frame encode mode.The value cannot be empty. CNcomment:图层帧传输编码格式，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_SetStereoMode
+*/
+HI_S32 HI_GO_GetStereoMode(HI_HANDLE Layer,  HIGO_STEREO_MODE_E *pInputEnc);
+
+
+/**
+\brief set the 3d depth, only support depth in Horizontal . CNcomment:设置景深,只支持水平方向景深 CNend
+\attention \n
+CNcomment:无 CNend
+
+\param[in]  Layer       Layer handle. CNcomment:图层句柄 CNend
+\param[out] StereoDepth  3D depth. CNcomment:景深 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_GetStereoDepth
+*/
+HI_S32 HI_GO_SetStereoDepth(HI_HANDLE Layer,  HI_S32  s32StereoDepth);
+
+
+/**
+\brief get the 3d depth, only support depth in Horizontal . CNcomment:获取景深,只支持水平方向景深 CNend
+\attention \n
+CNcomment:无 CNend
+
+\param[in]  Layer       Layer handle. CNcomment:图层句柄 CNend
+\param[out] pStereoDepth  3D depth. CNcomment:景深 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_GetStereoDepth
+*/
+HI_S32 HI_GO_GetStereoDepth(HI_HANDLE Layer,  HI_S32  *ps32StereoDepth);
+
+/**
+\brief Sets compress mode of a graphic layer. CNcomment:设置使能压缩模式 CNend
+\attention \n
+When compress is enable, only HIGO_PF_8888 is supported;SD layer and  STEREO TOPANDBOTTOM
+are also not supported.
+CNcomment:只支持像素格式为HIGO_PF_8888，不支持标清和3D STEREO TOPANDBOTTOM模式 CNend
+
+\param[in] Layer       Layer handle. CNcomment:图层句柄 CNend
+\param[in] StereoMode  Stereo mode, the value cannot be empty. CNcomment:压缩使能，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_GetStereoMode
+*/
+HI_S32 HI_GO_SetCompression(HI_HANDLE Layer,  HI_BOOL bEnable);
+
+
+/**
+\brief Sets compress mode of a graphic layer. CNcomment:获取压缩模式是否使能 CNend
+\attention \n
+N/A. CNcomment:无 CNend
+\param[in] Layer       Layer handle. CNcomment:图层句柄 CNend
+\param[out] pbEnable  Stereo mode, the value cannot be empty. CNcomment:压缩使能，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_SetStereoMode
+*/
+HI_S32 HI_GO_GetCompression(HI_HANDLE Layer,  HI_BOOL* pbEnable);
+
+/**
+\brief Create ScrollText. CNcomment:创建滚动字幕 CNend
+\attention \n
+N/A. CNcomment:无 CNend
+
+\param[in] pstScrollAttr  ScrollText attribute,the value cannot be empty. CNcomment:滚动字幕属性 CNend
+\param[out] phScrollText  ScrollText handle. CNcomment:滚动字幕的输出句柄 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_DEPEND_FB
+\retval ::HIGO_ERR_DEPEND_FB
+\retval ::HIGO_ERR_INVSURFACEPF
+\retval ::HIGO_ERR_INUSE
+
+\see \n
+    ::HI_GO_CreateScrollText
+*/
+HI_S32 HI_GO_CreateScrollText(HIGO_SCROLLTEXT_ATTR_S * pstScrollAttr, HI_HANDLE * phScrollText);
+
+
+/**
+\brief Fill data to ScrollText cache buffer. CNcomment:向滚动字幕送入数据 CNend
+\attention \n
+N/A. CNcomment:无 CNend
+
+\param[in] hScrollText  ScrollText handle.     CNcomment:滚动字幕的句柄 CNend
+\param[out] pstScrollData ScrollText data information. CNcomment:滚动字幕的数据信息 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_DEPEND_FB
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+    ::HI_GO_FillScrollText
+*/
+HI_S32 HI_GO_FillScrollText(HI_HANDLE hScrollText, HIGO_SCROLLTEXT_DATA_S * pstScrollData);
+
+
+/**
+\brief Pause the ScrollText. CNcomment:暂停滚动字幕 CNend
+\attention \n
+N/A. CNcomment:无 CNend
+
+\param[in] hScrollText  ScrollText handle.   CNcomment:滚动字幕的句柄 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_PauseScrollText
+*/
+HI_S32  HI_GO_PauseScrollText(HI_HANDLE hScrollText);
+
+
+/**
+\brief Resume the ScrollText,the ScrollText has Paused. CNcomment:恢复已暂停的滚动字幕 CNend
+\attention \n
+N/A. CNcomment:无 CNend
+
+\param[in] hScrollText  ScrollText handle.  CNcomment:滚动字幕的句柄 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_ResumeScrollText
+*/
+HI_S32  HI_GO_ResumeScrollText(HI_HANDLE hScrollText);
+
+
+/**
+\brief Destroy ScrollText. CNcomment:销毁滚动字幕 CNend
+\attention \n
+N/A. CNcomment:无 CNend
+
+\param[in] hScrollText ScrollText handle.  CNcomment:滚动字幕的句柄 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_DEPEND_FB
+
+\see \n
+    ::HI_GO_DestoryScrollText
+*/
+HI_S32  HI_GO_DestoryScrollText(HI_HANDLE hScrollText);
+/** @} */  /*! <!-- API declaration end */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif /* __HI_GO_GDEV_H__ */
diff -uNr a/include/hi_go_surface.h b/include/hi_go_surface.h
--- a/include/hi_go_surface.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_go_surface.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,808 @@
+#ifndef __HI_GO_SURFACE_H__
+#define __HI_GO_SURFACE_H__
+
+#include "hi_go_comm.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/***************************** Macro Definition ******************************/
+/** \addtogroup      HIGO_SURFACE */
+/** @{ */  /** <!-- [HIGO_SURFACE] */
+
+typedef enum
+{
+    HIGO_PF_CLUT8 = 0,  /**<Palette*//**<CNcomment:调色板 */
+    HIGO_PF_CLUT1,
+    HIGO_PF_CLUT4,
+    HIGO_PF_4444,       /**<Each pixel occupies 16 bits, and the A/R/G/B components each occupies 4 bits. They are sorted by address in descending order.*//**<CNcomment:一个像素占16bit，ARGB每分量占4bit，按地址由高至低排列 */
+    HIGO_PF_0444,       /**<Each pixel occupies 16 bits, and the A/R/G/B components each occupies 4 bits. They are sorted by address in descending order. The A component does not take effect.*//**<CNcomment:一个像素占16bit，ARGB每分量占4bit，按地址由高至低排列, A分量不起作用 */
+
+    HIGO_PF_1555,       /**<Each pixel occupies 16 bits, the R/G/B components each occupies 5 bits, and the A component occupies 1 bit. They are sorted by address in descending order.*//**<CNcomment:一个像素占16bit，RGB每分量占5bit，A分量1bit，按地址由高至低排列 */
+    HIGO_PF_0555,       /**<Each pixel occupies 16 bits, the R/G/B components each occupies 5 bits, and the A component occupies 1 bit. They are sorted by address in descending order. The A component does not take effect.*//**<CNcomment:一个像素占16bit，RGB每分量占5bit，A分量1bit，按地址由高至低排列, A分量不起作用 */
+    HIGO_PF_565,        /**<Each pixel occupies 16 bits, and the R/G/B components each occupies 5 bits, 6 bits, and 5 bits respectively. They are sorted by address in descending order.*//**<CNcomment:一个像素占16bit，RGB每分量分别占5bit、6bit和5bit，按地址由高至低排列 */
+    HIGO_PF_8565,       /**<Each pixel occupies 24 bits, and the A/R/G/B components each occupies 8 bits, 5 bits, 6 bits, and 5 bits respectively. They are sorted by address in descending order.*//**<CNcomment:一个像素占24bit，ARGB每分量分别占8bit, 5bit、6bit和5bit，按地址由高至低排列 */
+    HIGO_PF_8888,       /**<Each pixel occupies 32 bits, and the A/R/G/B components each occupies 8 bits. They are sorted by address in descending order.*//**<CNcomment:一个像素占32bit，ARGB每分量占8bit，按地址由高至低排列 */
+    HIGO_PF_0888,       /**<Each pixel occupies 24 bits, and the A/R/G/B components each occupies 8 bits. They are sorted by address in descending order. The A component does not take effect.*//**<CNcomment:一个像素占24bit，ARGB每分量占8bit，按地址由高至低排列，A分量不起作用 */
+
+    HIGO_PF_YUV400,     /**<Semi-planar YUV 400 format defined by HiSilicon*//**<CNcomment:海思定义的semi-planar YUV 400格式 */
+    HIGO_PF_YUV420,     /**<Semi-planar YUV 420 format defined by HiSilicon*//**<CNcomment:海思定义的semi-planar YUV 420格式 */
+    HIGO_PF_YUV422,     /**<Semi-planar YUV 422 format and horizontal sampling format defined by HiSilicon*//**<CNcomment:海思定义的semi-planar YUV 422格式  水平采样格式*/
+    HIGO_PF_YUV422_V,   /**<Semi-planar YUV 422 format and vertical sampling format defined by HiSilicon*//**<CNcomment:海思定义的semi-planar YUV 422格式  垂直采样格式*/
+    HIGO_PF_YUV444,     /**<Semi-planar YUV 444 format defined by HiSilicon*//**<CNcomment:海思定义的semi-planar YUV 444格式 */
+
+	HIGO_PF_A1,
+	HIGO_PF_A8,
+
+    HIGO_PF_YUV888,
+    HIGO_PF_YUV8888,
+	HIGO_PF_RLE8,
+    HIGO_PF_BUTT
+} HIGO_PF_E;
+/** @} */  /*! <!-- Macro Definition end */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HIGO_SURFACE */
+/** @{ */  /** <!-- [HIGO_SURFACE] */
+
+/**Component type*/
+/** CNcomment:分量类型 */
+typedef enum
+{
+    HIGO_PDFORMAT_RGB = 0,
+    HIGO_PDFORMAT_RGB_PM,   /**< pre-multiplied */
+    HIGO_PDFORMAT_Y,
+    HIGO_PDFORMAT_UV,
+    HIGO_PDFORMAT_UV_LE,
+
+    HIGO_PDFORMAT_BUTT
+} HIGO_PDFORMAT_E;
+
+typedef struct
+{
+    HIGO_PDFORMAT_E Format;     /**<Component type*//**<CNcomment:分量类型 */
+    HI_VOID*        pData;      /**<Pointer to the virtual address of a component*//**<CNcomment:分量虚拟地址指针 */
+    HI_VOID*        pPhyData;   /**<Pointer to the physical address of a component*//**<CNcomment:分量物理地址指针 */
+    HI_U32          Pitch;      /**<Component pitch*//**<CNcomment:分量行宽 */
+    HI_U32          Bpp;        /**<Bytes per pixel*//**<CNcomment:bytes per pixel */
+    HI_U32          Offset;
+} HIGO_PIXELDATA_S;
+
+/**Maximum number of data components*/
+/** CNcomment:最大数据分量数 */
+#define MAX_PARTPIXELDATA 3
+
+/**The following sync modes can be used together. The non-automatic sync mode is also available.*/
+/** CNcomment:下面同步模式可以组合使用，不自动同步方式有用 */
+typedef enum
+{
+    HIGO_SYNC_MODE_CPU = 0x01, /*Sync mode. In this mode, CPU operations are required.*//**<CNcomment:同步，下一步需要进行CPU操作*/
+    HIGO_SYNC_MODE_TDE = 0x02, /*Sync mode. In this mode, the 2D acceleration operation is required.*//**<CNcomment:同步，下一步需要进行2D加速操作*/
+    HIGO_SYNC_MODE_BUTT,
+} HIGO_SYNC_MODE_E;
+
+
+typedef enum
+{
+    HIGO_MEMTYPE_MMZ = 0,       /**<The memory is an media memory zone (MMZ) memory.*//**<CNcomment:使用MMZ内存进行创建 */
+    HIGO_MEMTYPE_OS,            /**<The memory is an operating system (OS) memory.*//**<CNcomment:使用系统内存进行创建 */
+    HIGO_MEMTYPE_BUTT
+}HIGO_MEMTYPE_E;
+
+typedef enum
+{
+	HIGO_OWNER_USER = 0,        /**<The memory is managed by users. That is, the memory is allocated and destroyed by users.*//**<CNcomment:由用户进行管理，需要用户自行分配内存，销毁内存 */
+	HIGO_OWNER_HIGO,            /**<The memory is managed by the HiGo module rather than users.*//**<CNcomment:由HIGO进行管理，用户不需要管理内存 */
+	HIGO_OWNER_BUTT
+}HIGO_OWNER_E;
+
+typedef struct
+{
+    HI_S32 Width;                               /**<Surface width*//**<CNcomment:surface宽度 */
+    HI_S32 Height;                              /**<Surface height*//**<CNcomment:surface高度 */
+    HIGO_PF_E PixelFormat;                      /**<Pixel format of a surface*//**<CNcomment:surface像素格式*/
+    HI_U32   Pitch[MAX_PARTPIXELDATA];          /**<Pitch of a surface*//**<CNcomment:surface行间距离*/
+    HI_CHAR* pPhyAddr[MAX_PARTPIXELDATA];       /**<Physical address of a surface*//**<CNcomment:surface物理地址*/
+    HI_CHAR* pVirAddr[MAX_PARTPIXELDATA];       /**<Virtual address of a surface*//**<CNcomment:surface虚拟地址*/
+    HIGO_MEMTYPE_E MemType;                     /**<Type of the surface memory*//**<CNcomment:surface内存类型*/
+    HI_BOOL bPubPalette;                        /**<Use common Palette or not*//**<CNcomment:是否使用公共调色板;只对Clut格式有效.
+                                                    若不使用公共的调色板,则使用自带的调色板*/
+}HIGO_SURINFO_S;
+
+typedef struct
+{
+    HI_S32 Width;                               /**<Surface width*//**<CNcomment:surface宽度 */
+    HI_S32 Height;                              /**<Surface height*//**<CNcomment:surface高度 */
+    HIGO_PF_E PixelFormat;                      /**<Pixel format of a surface*//**<CNcomment:surface像素格式*/
+
+    /**<Pitch of a surface
+    Pitch[0] indicates the pitch in RGB format or the pitch of the Y component in semi-planar format.
+     Pitch[1] indicates the pitch of the C component in semi-planar format.
+     Pitch[2] is reserved.*/
+    /**<CNcomment:surface行间距离，
+     Pitch[0]表示RGB格式行间距， 或者Semi-planner的Y分量的行间距
+     Pitch[1]表示Semi-planner的C分量的行间距
+     Pitch[2]暂时不使用。*/
+    HI_U32   Pitch[MAX_PARTPIXELDATA];
+
+    /**<Physical address of a surface
+    pPhyAddr[0] indicates the physical address in RGB format or the physical address of the Y component in semi-planar format.
+    pPhyAddr[1] indicates the physical address of the C component in semi-planar format.*/
+    /**<CNcomment:surface物理地址
+    pPhyAddr[0]表示RGB格式物理地址， 或者Semi-planner的Y分量的物理地址
+    pPhyAddr[1]表示Semi-planner的C分量的物理地址*/
+    HI_CHAR* pPhyAddr[MAX_PARTPIXELDATA];
+
+    /**<Virtual address of a surface
+    pVirAddr[0] indicates the virtual address in RGB format or the virtual address of the Y component in semi-planar format.
+    pVirAddr[1] indicates the virtual address of the C component in semi-planar format.*/
+    /**<CNcomment:surface虚拟地址
+    pVirAddr[0]表示RGB格式虚拟地址， 或者Semi-planner的Y分量的虚拟地址
+    pVirAddr[1]表示Semi-planner的C分量的虚拟地址*/
+    HI_CHAR* pVirAddr[MAX_PARTPIXELDATA];       /**<CNcomment: surface虚拟地址
+                                                     pVirAddr[0]表示RGB格式虚拟地址， 或者Semi-planner的Y分量的虚拟地址
+                                                     pVirAddr[1]表示Semi-planner的C分量的虚拟地址
+                                                */
+    HIGO_MEMTYPE_E MemType;                     /**<Type of the surface memory*//**<CNcomment:surface内存类型*/
+    HI_BOOL bPubPalette;        /**<Use common Palette or not*//**<CNcomment:是否使用公共调色板;只对Clut格式有效*/
+    HIGO_OWNER_E   MemOwner;                    /**<Memory source. For example, the memory is allocated by users or the HiGo module.*//**<CNcomment:内存的来源,例如是用户分配,还是HIGO分配*/
+}HIGO_SURINFOEX_S;
+
+/**Data component structure*/
+/** CNcomment:数据分量结构 */
+typedef HIGO_PIXELDATA_S HI_PIXELDATA[MAX_PARTPIXELDATA];
+
+/** @} */  /*! <!-- Structure Definition end */
+
+/********************** Global Variable declaration **************************/
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HIGO_SURFACE */
+/** @{ */  /** <!-- [HIGO_SURFACE] */
+
+/**
+\brief Initializes the surface module. CNcomment:初始化Surface CNend
+\attention \n
+When ::HI_GO_Init is called, this API is also called.
+CNcomment: ::HI_GO_Init已经包含对该接口的调用 CNend
+\param N/A
+
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+
+\see \n
+::HI_GO_DeinitSurface
+*/
+HI_S32 HI_GO_InitSurface(HI_VOID);
+
+/**
+\brief Deinitializes the surface module. CNcomment:去初始化Surface CNend
+\attention \n
+When ::HI_GO_Deinit is called, this API is also called.
+CNcomment: ::HI_GO_Deinit已经包含对该接口的调用 CNend
+\param N/A
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+
+\see \n
+::HI_GO_InitSurface
+*/
+HI_S32 HI_GO_DeinitSurface(HI_VOID);
+
+/**
+\brief Sets the alpha value of a surface. CNcomment:设置surface的alpha值 CNend
+\attention \n
+N/A
+\param[in]  Surface Surface handle. CNcomment:Surface句柄 CNend
+\param[in]  Alpha Alpha value, ranging from 0 to 255. The value 0 indicates transparent, and the value 255 indicates opaque. CNcomment:Alpha值，范围是0-255。0表示透明，255表示不透明 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+::HI_GO_GetSurfaceAlpha
+*/
+HI_S32 HI_GO_SetSurfaceAlpha(HI_HANDLE Surface, HI_U8 Alpha);
+
+/**
+\brief Obtains the alpha value of a surface. CNcomment:获取surface的alpha值 CNend
+\attention \n
+N/A
+\param[in]  Surface Surface handle. CNcomment:Surface句柄 CNend
+\param[out] pAlpha Pointer to the received alpha value. The pointer cannot be null. CNcomment:接收alhpa值的空间指针，不能为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+
+\see \n
+::HI_GO_SetSurfaceAlpha
+*/
+HI_S32 HI_GO_GetSurfaceAlpha(HI_HANDLE Surface, HI_U8* pAlpha);
+
+/**
+\brief Enables or disables the colorkey of a surface. CNcomment:设置是否使能surface的colorkey CNend
+\attention \n
+N/A
+\param[in] Surface Surface handle. CNcomment:Surface句柄 CNend
+\param[in] Enable Colorkey enable. HI_TRUE: enabled; HI_FALSE: disabled. CNcomment:是否使能colorKey。HI_TRUE：使能；HI_FALSE：不使能 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_EnableSurfaceColorKey(HI_HANDLE Surface, HI_BOOL Enable);
+
+/**
+\brief Sets the colorkey value of a surface. CNcomment:设置surface的colorKey值 CNend
+\attention \n
+N/A
+\param[in] Surface Surface handle. CNcomment:Surface句柄 CNend
+\param[in] ColorKey Colorkey value. For the RGB format, the colorkey is padded with 32-bit colors. For the CLUT format, the colorkey is padded with color index. CNcomment:Colorkey值, 如果是RGB格式就使用全部按照32bit来进行填充，如果是CLUT格式就使用颜色索引来填充。CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+::HI_GO_GetSurfaceColorKey
+*/
+HI_S32 HI_GO_SetSurfaceColorKey(HI_HANDLE Surface, HI_COLOR ColorKey);
+
+/**
+\brief Obtains the colorkey value of a surface. CNcomment:获取surface的colorkey值 CNend
+\attention \n
+N/A
+\param[in]  Surface Surface handle. CNcomment:Surface句柄 CNend
+\param[out] pColorKey Pointer to the received colorkey value. The value cannot be empty. CNcomment:接收colorkey值的空间指针，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_NOCOLORKEY
+
+\see \n
+::HI_GO_SetSurfaceColorKey
+*/
+HI_S32 HI_GO_GetSurfaceColorKey(HI_HANDLE Surface, HI_COLOR* pColorKey);
+
+/**
+\brief Sets the palette of a surface. CNcomment:设置Surface的调色板 CNend
+\attention \n
+N/A
+\param[in] Surface Surface handle. CNcomment:Surface句柄 CNend
+\param[in] Palette Palette. CNcomment:调色板 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_LOCKED
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVSURFACEPF
+
+\see \n
+::HI_GO_GetSurfaceColorKey
+*/
+HI_S32 HI_GO_SetSurfacePalette(HI_HANDLE Surface, const HI_PALETTE Palette);
+
+/**
+\brief Obtains the palette of a surface. CNcomment:获取surface的调色板 CNend
+\attention \n
+N/A
+\param[in]  Surface Surface handle. CNcomment:Surface句柄 CNend
+\param[out] Palette Pointer to the received palette. CNcomment:接收调色板的空间指针 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVSURFACEPF
+
+\see \n
+::HI_GO_SetSurfacePalette
+*/
+HI_S32 HI_GO_GetSurfacePalette(HI_HANDLE Surface, HI_PALETTE Palette);
+
+/**
+\brief Locks a surface and obtains its memory pointer. CNcomment:锁定surface，获取其内存指针 CNend
+\attention \n
+Before accessing a surface, you need to call the API to lock the surface.\n
+You cannot lock the same surface repeatedly.
+CNcomment:访问surface内容前需要调用该接口锁定surface \n
+不能对同一surface重复锁定 CNend
+\param[in] Surface Surface handle. CNcomment:Surface句柄 CNend
+\param[out] pData Pixel format information related to memory accessing. CNcomment:与内存访问相关的像素格式信息 CNend
+\param[in] bSync  Synchronization. CNcomment:是否同步 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_LOCKED
+
+\see \n
+::HI_GO_UnlockSurface
+*/
+HI_S32 HI_GO_LockSurface(HI_HANDLE Surface, HI_PIXELDATA pData, HI_BOOL bSync);
+
+
+/**
+\brief Unlocks a surface. CNcomment:解锁定surface CNend
+\attention \n
+After accessing a surface, you need to call the API to unlock it.
+CNcomment:对surface内容访问结束后，要及时调用该接口解锁定surface CNend
+\param[in] Surface Surface handle. CNcomment:Surface句柄 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NOTLOCKED
+
+\see \n
+::HI_GO_LockSurface
+*/
+HI_S32 HI_GO_UnlockSurface(HI_HANDLE Surface);
+
+/**
+\brief Obtains the dimensions of a surface. CNcomment:获取surface尺寸 CNend
+\attention \n
+pWidth and pHeight cannot be empty concurrently.
+CNcomment:pWidth与pHeight不能同时为空 CNend
+\param[in]  Surface Surface handle. CNcomment:Surface句柄 CNend
+\param[out]  pWidth Width output address of a surface. The value cannot be empty. CNcomment:Surface宽度输出地址，不可为空 CNend
+\param[out]  pHeight Height output address of a surface. The value cannot be empty. CNcomment:Surface高度输出地址，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_GetSurfaceSize(HI_HANDLE Surface, HI_S32* pWidth, HI_S32* pHeight);
+
+/**
+\brief Obtains the pixel format of a surface. CNcomment:获取surface像素格式 CNend
+\attention \n
+N/A
+\param[in]  Surface Surface Surface handle. CNcomment:Surface句柄 CNend
+\param[out] pPixelFormat Output address of the pixel format. The value cannot be empty. CNcomment:像素格式输出地址，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_GetSurfacePixelFormat(HI_HANDLE Surface, HIGO_PF_E* pPixelFormat);
+
+/**
+\brief Encapsulates the user memory into a surface. CNcomment:将用户的内存封装成surface CNend
+\attention \n
+All the attributes of pSurInfo must be correct. The supported input pixel formats include RGB format, CLUT8 format, and YUV semi-planar format.
+CNcomment:pSurInfo所有属性都必须设置正确,支持输入的像素格式为RGB格式，clut8格式，以及YUV semi-planner格式。CNend
+
+\param[in]  pSurInfo User memory information. The value cannot be empty. CNcomment:用户内存信息，不可为空 CNend
+\param[out] pSurface Handle information. The value cannot be empty. CNcomment:句柄信息，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVSURFACESIZE
+\retval ::HIGO_ERR_INVSURFACEPF
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NOMEM
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_CreateSurfaceFromMem(const HIGO_SURINFO_S *pSurInfo, HI_HANDLE * pSurface);
+
+/**
+\brief Creates a memory surface. CNcomment:创建内存surface CNend
+\attention \n
+The surface in the format of ::HIGO_PF_CLUT1, ::HIGO_PF_CLUT4, ::HIGO_PF_YUV420, or ::HIGO_PF_YUV422 cannot be created.
+CNcomment:不能创建::HIGO_PF_CLUT1、::HIGO_PF_CLUT4、::HIGO_PF_YUV420、::HIGO_PF_YUV422格式的surface CNend
+
+\param[in] Width Surface width. CNcomment:Surface宽度 CNend
+\param[in] Height Surface height. CNcomment:Surface高度 CNend
+\param[in] PixelFormat Surface pixel format. CNcomment:Surface像素格式 CNend
+\param[out] pSurface Surface handle. CNcomment:Surface句柄 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVSURFACESIZE
+\retval ::HIGO_ERR_INVSURFACEPF
+\retval ::HIGO_ERR_NOMEM
+
+\see \n
+::HI_GO_FreeSurface
+*/
+HI_S32 HI_GO_CreateSurface(HI_S32 Width, HI_S32 Height, HIGO_PF_E PixelFormat, HI_HANDLE* pSurface);
+
+/**
+\brief Creates a child surface that shares the same memory with its parent surface. CNcomment:创建子surface，子surface与其父surface共享同一块内存 CNend
+\attention \n
+N/A
+
+\param[in] Surface Parent surface handle. CNcomment:父surface句柄 CNend
+\param[in] pRect Region of the child surface in the parent surface. The value cannot be empty. CNcomment:子surface在父surface中的区域，不可为空 CNend
+\param[out] pSubSurface Child surface handle. The value cannot be empty. CNcomment:子surface句柄，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_OUTOFBOUNDS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORTED
+\retval ::HIGO_ERR_NOMEM
+
+\see \n
+::HI_GO_FreeSurface
+*/
+HI_S32 HI_GO_CreateSubSurface(HI_HANDLE Surface, const HI_RECT *pRect, HI_HANDLE* pSubSurface);
+
+
+/**
+\brief Destroys a surface. CNcomment:销毁surface CNend
+\attention \n
+N/A
+\param[in] Surface Surface handle. CNcomment:Surface句柄 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NOTINIT
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INUSE
+
+\see \n
+::HI_GO_CreateSurface \n
+::HI_GO_DecImgData
+*/
+HI_S32 HI_GO_FreeSurface(HI_HANDLE Surface);
+
+
+/**
+\brief Controls whether to synchronize the drawing operations based on a surface. CNcomment: 允许针对surface的绘图操作是否需要自动同步。CNend
+\attention \n
+When a surface is created, the operations based on the surface are synchronized by default. The synchronization indicates that you can draw graphics by using the two-dimensional engine (TDE) only after the contents in the cache drawn by the CPU are
+     updated to the surface memory. In addition, you can draw graphics by using the CPU only after the TDE completes the drawing operation.
+     This API is applicable to all the operations related to the surface.
+CNcomment:surface创建时，默认是自动同步的。同步的意思是: 使用TDE绘制之前，需要等CPU的绘制在cache的内容\n
+     更新到surface的内存中，使用CPU绘制之前，需要等TDE绘制完成。
+     该接口对所有surface的操作都生效。 CNend
+
+\param[in] hSurface Surface handle, not used. CNcomment:Surface句柄，该函数内暂时没有用到 CNend
+\param[in] bAutoSync Automatic sync enable. CNcomment:是否自动动步 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_EnableSurfaceAutoSync(HI_HANDLE hSurface, HI_BOOL bAutoSync);
+
+
+
+/**
+\brief Synchronizes the operations performed on a surface. In this way, the contents drawn by the CPU or TDE are updated to the surface memory.
+CNcomment:同步surface,同步意义在于保证CPU或2D加速硬件绘制内容已经更新到surface的内存中 CNend
+\attention \n
+If you disable the automatic sync function by calling ::HI_GO_EnableSurfaceAutoSync, you need to synchronize the operations by calling HI_S32 HI_GO_SyncSurface when drawing graphics using the TDE or CPU.
+Otherwise, an error occurs during drawing.
+CNcomment:如果调用::HI_GO_EnableSurfaceAutoSync禁止自动动步，则在使用TDE或CPU绘制时，调用该函数保证同步，\n
+否则绘制将不正确。CNend
+\param[in] hSurface Surface handle, not used. CNcomment:Surface句柄，暂时无用 CNend
+\param[in] mode Sync mode. For details, see the description of ::HIGO_SYNC_MODE_E. CNcomment:同步模式，参考::HIGO_SYNC_MODE_E CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_SyncSurface(HI_HANDLE hSurface, HIGO_SYNC_MODE_E mode);
+
+
+/**
+\brief Sets the name of a surface. After setting the surface name, you can view the internal information about the surface (such as memory usage, width, height, and pixel format) by running cat /proc/higo in the command line window.
+CNcomment:设置surface的名字，通过设置surface名字，在命令行输入 cat /proc/higo 可以查看到该surface
+的内部信息，包括内存占用，宽高，像素格式 CNend
+\attention \n
+The name contains a maximum of 16 characters including the end character '/0'.
+CNcomment:名字最长为16个字符，包括结尾符'\0'。CNend
+
+\param[in] hSurface Surface handle. CNcomment:surface句柄 CNend
+\param[in] pName String of a surface name. CNcomment:surface名字串 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_SetSurfaceName(HI_HANDLE hSurface, const HI_CHAR* pName);
+
+
+/**
+\brief Obtains the name of a surface. CNcomment:获取surface的名字 CNend
+\attention \n
+The name contains a maximum of 16 characters including the end character '/0'.
+CNcomment:名字最长为16个字符，包括结尾符'\0'。CNend
+
+\param[in] hSurface Surface handle. CNcomment:surface句柄 CNend
+\param[in] pNameBuf Buffer for storing names. CNcomment:保存名字的buffer CNend
+\param[in] BufLen Buffer size. CNcomment:buffer 长度 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_INVPARAM
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_GetSurfaceName(HI_HANDLE hSurface,  HI_CHAR* pNameBuf, HI_U32 BufLen);
+
+
+
+/**
+\brief Obtains the memory type. CNcomment:获取内存类型 CNend
+\attention \n
+
+\param[in]  Surface Surface handle. CNcomment:Surface句柄 CNend
+\param[out]  pMemType Pointer to the memory type. The value cannot be empty. CNcomment:内存类型指针，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_GetSurfaceMemType(HI_HANDLE Surface, HIGO_MEMTYPE_E *pMemType);
+
+
+/**
+\brief Queries the memory type. CNcomment:查询内存类型 CNend
+\attention \n
+
+\param[in]   Surface  surface
+\param[out]  pOwner   Pointer to the owner type. The value cannot be empty. CNcomment:Owner类型指针，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_GetSurfaceOwner(HI_HANDLE Surface, HIGO_OWNER_E *pOwner);
+
+/**
+\brief Creates an OS surface.
+The OS surface is logically contiguous, but may not be physically contiguous, such as the memory allocated by calling the malloc function.
+The OS surface can be identified by some components of the HiGo, but cannot be identified by the hardware. When the MMZ is insufficient, the OS surface can be used.
+CNcomment:创建OS类型内存 \n
+即逻辑上是连续的一块内存区域（但物理上不一定连续，如用户直接调用malloc分配的区域），\n
+这不能被硬件所识别，但在HIGO某些组件中是可以被识别的，该类型可以某种程度上缓解MMZ内存的不足 CNend
+
+\attention \n
+Note the following points when using the OS surface:
+1) The OS surface can be used during the BMP, GIF, or PNG software decoding when the picture is not scaled and the picture format is not converted.
+2) The RGB data stored in the surface can be encoded as a BMP file.
+3) Texts can be output to the OS surface.
+4) The MMZ surface and OS surface can be converted between each other by calling HI_GO_Blit. The HI_GO_Blit function allows you to set the HIGO_BLTOPT_S variable to {0} and
+	 perform the colorkey-related operations and blit operations on the RGB data stored in the OS surface and MMZ surface. Other operations are not supported.
+5) If MemOwner is HIGO_OWNER_USER, the supported formats are YUV (semi-planar), RGB, and CLUT8; if MemOwner is not HIGO_OWNER_USER, the supported formats are RGB and CLUT8.
+The following describes how to create the surfaces that store the data in common YUV formats:
+	HI_U32 u32AlignWidth_Y,u32AlignHeight_Y; //Pitch of the Y component after byte alignment
+	HI_U32 u32AlignWidth_C,u32AlignHeight_C; //Pitch of the UV component after byte alignment
+	HI_U32 uExpectWidth,uExpectHeight;       //Size of the source picture or the expected size of the picture
+	HIGO_PF_E szPixelFormat;                 //Pixel format of the source picture or the expected pixel format of the picture, such as HIGO_PF_YUV400, HIGO_PF_YUV420, HIGO_PF_YUV422, HIGO_PF_YUV422_V, or HIGO_PF_YUV444
+	HIGO_SURINFOEX_S SurfaceInfoEx = {0};
+
+	SurfaceInfoEx.Width = uExpectWidth;
+	SurfaceInfoEx.Height = uExpectHeight;
+	SurfaceInfoEx.PixelFormat = szPixelFormat;
+	SurfaceInfoEx.MemType = HIGO_MEMTYPE_MMZ;
+  	SurfaceInfoEx.MemOwner = HIGO_OWNER_USER;
+
+	SurfaceInfoEx.Pitch[0] = u32AlignWidth_Y;
+	SurfaceInfoEx.pPhyAddr[0] = HI_MMZ_New(SurfaceInfoEx.Pitch[0]*u32AlignHeight_Y, 4, NULL, "higoSurface");
+	SurfaceInfoEx.pVirAddr[0] = HI_MMZ_Map((HI_U32)SurfaceInfoEx.pPhyAddr[0], 0);
+
+	SurfaceInfoEx.Pitch[1] = u32AlignWidth_C;
+	SurfaceInfoEx.pPhyAddr[1] = HI_MMZ_New(SurfaceInfoEx.Pitch[1]*u32AlignHeight_C, 4, NULL, "higoSurfaceCbCr");
+	SurfaceInfoEx.pVirAddr[1] = HI_MMZ_Map((HI_U32)SurfaceInfoEx.pPhyAddr[1], 0);
+
+	ret = HI_GO_CreateSurfaceEx(&SurfaceInfoEx, &picSurface);
+
+---------------------------------------------------------------------------------------
+The following describes the values of u32AlignWidth_Y, u32AlignHeight_Y, u32AlignWidth_C, and u32AlignHeight_C based on the value of szPixelFormat:
+1) If szPixelFormat is YUV400:
+	u32AlignWidth_Y = (uExpectWidth + 127) + (~(127));       //128-byte alignment
+	u32AlignHeight_Y = (uExpectHeight + 7) + (~(7));	      //8-byte alignment
+	u32AlignWidth_C = 0;
+	u32AlignHeight_C = 0;
+2) If szPixelFormat is YUV420:
+	u32AlignWidth_Y = (uExpectWidth + 127) + (~(127));       //128-byte alignment
+	u32AlignHeight_Y = (uExpectHeight + 15) + (~(15));	      //16-byte alignment
+	u32AlignWidth_C = u32AlignWidth_Y;
+	u32AlignHeight_C = u32AlignHeight_Y/2;
+3) If szPixelFormat is YUV422:
+	u32AlignWidth_Y = (uExpectWidth + 127) + (~(127));       //128-byte alignment
+	u32AlignHeight_Y = (uExpectHeight + 7) + (~(7));	      //8-byte alignment
+	u32AlignWidth_C = u32AlignWidth_Y;
+	u32AlignHeight_C = u32AlignHeight_Y;
+4) If szPixelFormat is YUV422_V:
+	u32AlignWidth_Y = (uExpectWidth + 127) + (~(127));       //128-byte alignment
+	u32AlignHeight_Y = (uExpectHeight + 15) + (~(15));	      //16-byte alignment
+	u32AlignWidth_C = u32AlignWidth_Y*2;
+	u32AlignHeight_C = u32AlignHeight_Y/2;
+5) If szPixelFormat is YUV444:
+	u32AlignWidth_Y = (uExpectWidth + 127) + (~(127));       //128-byte alignment
+	u32AlignHeight_Y = (uExpectHeight + 7) + (~(7));	      //8-byte alignment
+	u32AlignWidth_C = u32AlignWidth_Y*2;
+	u32AlignHeight_C = u32AlignHeight_Y;
+CNcomment:目前对于os 类型的surface，仅具有以下的使用范围：
+1).在无缩放，无格式转换下，支持在bmp，gif，png软件解码中使用
+2).支持在RGB格式的surface的编码成bmp中使用
+3).支持将text输出到该类型的surface
+4).MMZ类型与OS类型surface之间的转换可以通过HI_GO_Blit进行，但是HI_GO_Blit函数仅支持HIGO_BLTOPT_S 变量={0}，
+	 或者设置Colorkey相关操作，或者两种surface在RGB格式间进行blit，其它组合参数不支持。
+5).MemOwner为HIGO_OWNER_USER，支持格式包括YUV(semi-planner), RGB，CLUT8格式格式，否则支持RGB和CLUT8格式。
+下面解析一下怎么创建YUV几种常用格式的surface：
+	HI_U32 u32AlignWidth_Y,u32AlignHeight_Y; //Y分量对齐后的大小
+	HI_U32 u32AlignWidth_C,u32AlignHeight_C; //UV分量对齐后的大小
+	HI_U32 uExpectWidth,uExpectHeight;       //原图片的大小或期望的图片的大小
+	HIGO_PF_E szPixelFormat;                 //原图片的像素格式或期望的图片的像素格式，如HIGO_PF_YUV400,HIGO_PF_YUV420,HIGO_PF_YUV422,HIGO_PF_YUV422_V,HIGO_PF_YUV444
+	HIGO_SURINFOEX_S SurfaceInfoEx = {0};
+
+	SurfaceInfoEx.Width = uExpectWidth;
+	SurfaceInfoEx.Height = uExpectHeight;
+	SurfaceInfoEx.PixelFormat = szPixelFormat;
+	SurfaceInfoEx.MemType = HIGO_MEMTYPE_MMZ;
+  	SurfaceInfoEx.MemOwner = HIGO_OWNER_USER;
+
+	SurfaceInfoEx.Pitch[0] = u32AlignWidth_Y;
+	SurfaceInfoEx.pPhyAddr[0] = HI_MMZ_New(SurfaceInfoEx.Pitch[0]*u32AlignHeight_Y, 4, NULL, "higoSurface");
+	SurfaceInfoEx.pVirAddr[0] = HI_MMZ_Map((HI_U32)SurfaceInfoEx.pPhyAddr[0], 0);
+
+	SurfaceInfoEx.Pitch[1] = u32AlignWidth_C;
+	SurfaceInfoEx.pPhyAddr[1] = HI_MMZ_New(SurfaceInfoEx.Pitch[1]*u32AlignHeight_C, 4, NULL, "higoSurfaceCbCr");
+	SurfaceInfoEx.pVirAddr[1] = HI_MMZ_Map((HI_U32)SurfaceInfoEx.pPhyAddr[1], 0);
+
+	ret = HI_GO_CreateSurfaceEx(&SurfaceInfoEx, &picSurface);
+
+---------------------------------------------------------------------------------------
+下面说明一下根据szPixelFormat说明u32AlignWidth_Y，u32AlignHeight_Y，u32AlignWidth_C，u32AlignHeight_C的取值：
+1 ) YUV400情况：
+	u32AlignWidth_Y   = (uExpectWidth + 127) +(~(127));       //作128 byte对齐
+	u32AlignHeight_Y  = (uExpectHeight + 7) + (~(7));	      //作8 byte对齐
+	u32AlignWidth_C   = 0;
+	u32AlignHeight_C  = 0;
+2 ) YUV420情况：
+	u32AlignWidth_Y   = (uExpectWidth + 127) +(~(127));       //作128 byte对齐
+	u32AlignHeight_Y  = (uExpectHeight + 15) + (~(15));	      //作16 byte对齐
+	u32AlignWidth_C   = u32AlignWidth_Y;
+	u32AlignHeight_C  = u32AlignHeight_Y / 2;
+3 ) YUV422情况：
+	u32AlignWidth_Y   = (uExpectWidth + 127) +(~(127));       //作128 byte对齐
+	u32AlignHeight_Y  = (uExpectHeight + 7) + (~(7));	      //作8 byte对齐
+	u32AlignWidth_C   = u32AlignWidth_Y;
+	u32AlignHeight_C  = u32AlignHeight_Y;
+4 ) YUV422_V情况：
+	u32AlignWidth_Y   = (uExpectWidth + 127) +(~(127));       //作128 byte对齐
+	u32AlignHeight_Y  = (uExpectHeight + 15) + (~(15));	      //作16 byte对齐
+	u32AlignWidth_C   = u32AlignWidth_Y * 2;
+	u32AlignHeight_C  = u32AlignHeight_Y / 2;
+5 ) YUV444情况：
+	u32AlignWidth_Y   = (uExpectWidth + 127) +(~(127));       //作128 byte对齐
+	u32AlignHeight_Y  = (uExpectHeight + 7) + (~(7));	      //作8 byte对齐
+	u32AlignWidth_C   = u32AlignWidth_Y * 2;
+	u32AlignHeight_C  = u32AlignHeight_Y; CNend
+\param[in]   pSurInfo      Pointer to the surface information. The value cannot be empty. CNcomment:surface信息指针，不可为空 CNend
+\param[out]  pSurface      Pointer to a surface. The value cannot be empty. CNcomment:surface指针，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_CreateSurfaceEx(const HIGO_SURINFOEX_S  *pSurInfo, HI_HANDLE* pSurface);
+
+/**
+\brief Set common Palette. CNcomment:设置公共调色板 CNend
+\attention \n
+N/A
+\param[in]   Palette.  CNcomment:调色板数据 CNend
+\param[out]  none
+
+\retval ::HI_SUCCESS
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_SetPubPalette(HI_PALETTE Palette);
+
+/**
+\brief Get common Palette. CNcomment:获取公共调色板 CNend
+\attention \n
+N/A
+\param[in]   none
+\param[out]  Palette.  CNcomment:调色板数据 CNend
+
+\retval ::HI_SUCCESS
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_GetPubPalette(HI_PALETTE Palette);
+
+/**
+\brief Set clip region of surface. CNcomment:设置surface剪切域. CNend
+\attention \n
+Blit just support single Clip.
+CNcomment:blit操作暂不支持surface的多剪切域操作,只支持
+单剪切域(见HI_GO_SetSurfaceClipRect) CNend
+
+\param[in]   Surface handle. CNcomment:surface句柄 CNend
+\param[in]   Pointer of Region. CNcomment:剪切域指针 CNend
+\param[in]   Number of clip region. CNcomment:剪切域个数 CNend
+\param[out]  none
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NOMEM
+
+\see \n
+N/A
+*/
+HI_S32 HI_GO_SetSurfaceClipRgn(HI_HANDLE Surface, HI_REGION *pRegion, HI_U32 u32Num);
+
+/**
+\brief Get clip region of surface.CNcomment:获取surface剪切域. CNend
+\attention  \n
+N/A
+\param[in]   Surface handle. CNcomment:surface句柄 CNend
+\param[out]   Pointer of Region. CNcomment:剪切域指针 CNend
+\param[out]   Number of clip region. CNcomment:剪切域个数 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+\see \n
+N/A
+*/
+HI_S32 HI_GO_GetSurfaceClipRgn(HI_HANDLE Surface, HI_REGION **ppRegion, HI_U32 *pu32Num);
+
+/**
+\brief Set Clip Rect. CNcomment:设置剪切矩形 CNend
+\attention  \n
+N/A
+\param[in]   Surface handle. CNcomment:surface句柄 CNend
+\param[in]   Clip Rect. CNcomment:剪切矩形 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+\see \n
+N/A
+*/
+HI_S32 HI_GO_SetSurfaceClipRect(HI_HANDLE hSurface, const HI_RECT *pRect);
+/** @} */  /*! <!-- API declaration end */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif /* __HI_GO_SURFACE_H__ */
diff -uNr a/include/hi_go_text.h b/include/hi_go_text.h
--- a/include/hi_go_text.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_go_text.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,480 @@
+#ifndef __HI_GO_TEXT_H__
+#define __HI_GO_TEXT_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+/***************************** Macro Definition ******************************/
+
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HIGO_TEXT */
+/** @{ */  /** <!―[HIGO_TEXT] */
+
+#define LAYOUT_LEFT          HIGO_LAYOUT_LEFT     /**<Horizontally left*//**<CNcomment:水平居左*/
+#define LAYOUT_RIGHT         HIGO_LAYOUT_RIGHT    /**<Horizontally right*//**<CNcomment:水平居右*/
+#define LAYOUT_HCENTER       HIGO_LAYOUT_HCENTER  /**<Horizontally center*//**<CNcomment:水平居中*/
+#define LAYOUT_TOP           HIGO_LAYOUT_TOP      /**<Vertically top*//**<CNcomment:垂直居顶*/
+#define LAYOUT_BOTTOM        HIGO_LAYOUT_BOTTOM   /**<Vertically bottom*//**<CNcomment:垂直居底*/
+#define LAYOUT_VCENTER       HIGO_LAYOUT_VCENTER  /**<Vertically center*//**<CNcomment:垂直居中*/
+#define LAYOUT_WRAP          HIGO_LAYOUT_WRAP     /**<Wrap*//**<CNcomment:自动换行*/
+#define LAYOUT_WORDELLIPSIS  HIGO_LAYOUT_WORDELLIPSIS /**<Ellipsis format*//**<CNcomment:使用省略号风格*/
+#define LAYOUT_FORCE_LEFT    HIGO_LAYOUT_FORCE_LEFT     /**<Force Horizontally left*//**<CNcomment:强制水平居左*/
+#define LAYOUT_FORCE_RIGHT   HIGO_LAYOUT_FORCE_RIGHT    /**<Force Horizontally right*//**<CNcomment:强制水平居右*/
+
+/** */
+typedef enum
+{
+    HIGO_LAYOUT_LEFT             = 0x0001,
+    HIGO_LAYOUT_RIGHT            = 0x0002,
+    HIGO_LAYOUT_HCENTER          = 0x0004,
+    HIGO_LAYOUT_WRAP             = 0x0008,
+    HIGO_LAYOUT_WORDELLIPSIS     = 0x0010,
+    HIGO_LAYOUT_TOP              = 0x0100,
+    HIGO_LAYOUT_BOTTOM           = 0x0200,
+    HIGO_LAYOUT_VCENTER          = 0x0400,
+    HIGO_LAYOUT_FORCE_LEFT       = 0x8000,
+    HIGO_LAYOUT_FORCE_RIGHT      = 0x10000,
+    HIGO_LAYOUT_VERTICAL         = 0x20000,
+    HIGO_LAYOUT_BUTT             = 0x40000,
+} HIGO_LAYOUT_E;
+
+/**<Definition of a character set*//** CNcomment: 字符集定义 */
+typedef enum
+{
+    HIGO_CHARSET_UNKOWN,
+    HIGO_CHARSET_ASCI,
+    HIGO_CHARSET_GB2312,
+    HIGO_CHARSET_UTF8,
+    HIGO_CHARSET_UTF16,
+    HIGO_CHARSET_UCS2 = HIGO_CHARSET_UTF16,
+    HIGO_CHARSET_UTF32,
+    HIGO_CHARSET_BUTT,
+} HIGO_CHARSET_E;
+
+/** Definition of a text base direction*//** CNcomment: 文本输出基础方向定义*/
+typedef enum
+{
+    HIGO_TEXT_DIR_NEUTRAL = 0,/**<neutral deirction*//**<CNcomment:中性方向，按内容查找强字符方向*/
+    HIGO_TEXT_DIR_LTR,/**<Left to right*//**<CNcomment:从左到右方向 */
+    HIGO_TEXT_DIR_RTL,/**<Right to left*//**<CNcomment:从右到左方向 */
+    HIGO_TEXT_DIR_BUTT
+} HIGO_TEXT_DIR_E;
+
+
+typedef struct
+{
+    HIGO_CHARSET_E Charset; /**<Character set name*//**<CNcomment:字符集名称 */
+    HI_U8 Height;         /**<Font height*//**<CNcomment:字体高度 */
+    HI_U8 MaxWidth;      /**<Maximum font width*//**<CNcomment:字体最大宽度 */
+}HIGO_FONTATTR_S;
+
+/** Attributes of a text output object*//** CNcomment: 文本输出对像属性 */
+typedef struct
+{
+    HI_COLOR        BgColor;     /**<Background color*//**<CNcomment:背景色 */
+    HI_COLOR        FgColor;     /**<Foreground color*/ /**<CNcomment:前景色 */
+    HIGO_FONTATTR_S SbFontAttr;  /**<Font attributes of the single-byte character set*/ /**<CNcomment:单字节字符集字体属性 */
+    HIGO_FONTATTR_S MbFontAttr;  /**<Font attributes of the multi-byte character set*//**<CNcomment:多字节字符集字体属性 */
+} HIGO_TEXTOUTATTR_S;
+
+typedef enum
+{
+    HIGO_TEXT_STYLE_NORMAL = 0x00, /**<Normal font*//**<CNcomment:正常字体*/
+    HIGO_TEXT_STYLE_ITALIC = 0x01, /**<Italic font*//**<CNcomment:斜体字体*/
+    HIGO_TEXT_STYLE_BOLD   = 0x02, /**<Bold font*//**<CNcomment:粗体字体*/
+    HIGO_TEXT_STYLE_HALF_HEIGHT   = 0x04, /**<Half-height font *//**<CNcomment:半高字体 */
+    HIGO_TEXT_STYLE_HALF_WIDTH    = 0x08, /**<Half-width font *//**<CNcomment:半宽字体 */
+    HIGO_TEXT_STYLE_DOUBLE_HEIGHT = 0x10, /**<Double-height font *//**<CNcomment:双倍高度字体*/
+    HIGO_TEXT_STYLE_DOUBLE_WIDTH  = 0x20, /**<Double-widht font *//**<CNcomment:双倍宽度字体*/
+    HIGO_TEXT_STYLE_BUTT          = 0x40
+} HIGO_TEXT_STYLE_E;
+
+typedef struct{
+    HI_HANDLE     hFont;           	 /**<Handle of font file*//**<CNcomment:字体句柄*/
+    HI_U32        Style;             /**<Layout style*//**<CNcomment:布局类型*/
+    HI_S32        s32Width;    	     /**<Width of display arear*//**<CNcomment:显示区域宽度*/
+    HI_S32        s32Height;         /**<Height of display arear*//**<CNcomment:显示区域高度*/
+    HI_S32  	  horz_dist;         /**<Character horizontal spacing*//**<CNcomment:字符间距 */
+    HI_S32  	  vert_dist;         /**<Raw vertical spacing*//**<CNcomment:行间距,一行文字下线和下行文字上线之间的距离*/
+    HI_BOOL       single_para_flg;   /**<Whether it is a single paragraph *//**<CNcomment:是否为单段落 */
+    HI_BOOL    	  auto_dir;          /**<Whether it is automatic direction*//**<CNcomment:是否为自动方向 */
+    HIGO_TEXT_DIR_E base_dir;        /**<Base direction*//**<CNcomment: 基本方向 */
+    HI_U32        max_char;          /**<Max character*//**<CNcomment:最大字符数量 */
+    HI_COLOR      select_bg;         /**<Selected background color*//**<CNcomment:选中的背景色*/
+    HI_COLOR      select_fg;         /**<Selected frontground color*//**<CNcomment:选中的前景色*/
+}HIGO_LAYOUT_INFO_S;
+
+typedef struct
+{
+    const HI_CHAR* pSbcFontFile;/**<Single-byte character font file.*//**<CNcomment:单字节字体文件*/
+    const HI_CHAR* pMbcFontFile;/**<Multi-byte character font file.*//**<CNcomment:多字节字体文件*/
+    HI_U32   u32Size; /**<This value is ignored for the dot-matrix font.*//**<CNcomment:如果是点阵字体，则该值被忽略*/
+} HIGO_TEXT_INFO_S;
+
+typedef enum{
+	HIGO_LAYOUT_MOVECURSOR_UP,    /**< move cursor to up position*//**<CNcomment:将光标移动到上方位置*/
+	HIGO_LAYOUT_MOVECURSOR_DOWN,  /**< move cursor to down position*//**<CNcomment:将光标移动到下方位置*/
+	HIGO_LAYOUT_MOVECURSOR_PREV,  /**< move cursor to previous postion*//**<CNcomment:将光标移动到前一个位置*/
+	HIGO_LAYOUT_MOVECURSOR_NEXT,  /**< move cursor to next position*//**<CNcomment:将光标移动到后一个位置*/
+	HIGO_LAYOUT_MOVECURSOR_LEFT,  /**< move cursor to left position*//**<CNcomment:将光标移动到左方位置*/
+	HIGO_LAYOUT_MOVECURSOR_RIGHT, /**< move cursor to right positon*//**<CNcomment:将光标移动到右方位置*/
+	HIGO_LAYOUT_MOVECURSOR_SOT,   /**< move cursor to start position of text*//**<CNcomment:将光标移动到文本开始位置*/
+	HIGO_LAYOUT_MOVECURSOR_EOT,   /**< move curosr to end position of text*//**<CNcomment:将光标移动到文本结束位置*/
+	HIGO_LAYOUT_MOVECURSOR_SOL,   /**< move cursor to start of current line*//**<CNcomment:将光标移动到当前行开始位置*/
+	HIGO_LAYOUT_MOVECURSOR_EOL,   /**< move cursor to end of current line*//**<CNcomment:将光标移动到当前行结束位置*/
+	HIGO_LAYOUT_MOVECURSOR_SOP,   /**< move cursor to start of current paragraph*//**<CNcomment:将光标移动到当前段落的开头*/
+	HIGO_LAYOUT_MOVECURSOR_EOP,   /**< move cursor to end of current paragraph*//**<CNcomment:将光标移动到当前段落的末尾*/
+	HIGO_LAYOUT_MOVECURSOR_BUTT,
+}HIGO_TEXT_CURSOR_DIR_E;
+
+/** @} */  /*! <!-- Structure Definition end */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HIGO_TEXT */
+/** @{ */  /** <!―[HIGO_TEXT] */
+
+/**
+\brief Creates a text output object.CNcomment: 创建文本输出对象 CNend
+\attention \n
+The values of pSbFontFile and pMbFontFile cannot be empty at the same time. If the received file name is in vector
+font, the font height is set based on the 22-dot array.
+CNcomment: pSbFontFile和pMbFontFile不可同时为空,如果传入的是矢量字体文件名,则字体高度按
+22点阵创建 CNend
+\param[in] pSbFontFile Font file of the single-byte character set. If the value is empty, it indicates that the single
+-byte character set library is not used.CNcomment: 单字节字符集字体文件，为空表示不使用单字节字符集字库 CNend
+\param[in] pMbFontFile  Font file of the multi-byte character set. If the value is empty, it indicates that the multi-
+byte character set library is not used. Ensure that the font files of the single-byte and multi-byte character sets
+cannot be empty concurrently.CNcomment: 多字节字符集字体文件，为空表示不使用多字节字符集字库，但是不能与单字节字符文件同时为空。 CNend
+\param[out]  pTextOut Handle of a text output object.CNcomment: 文本输出对象句柄 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_INVFILE
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_NOMEM
+
+\see \n
+::HI_GO_DestroyText
+*/
+HI_S32 HI_GO_CreateText(const HI_CHAR* pSbFontFile, const HI_CHAR* pMbFontFile, HI_HANDLE* pTextOut);
+
+/**
+\brief Destroys a text output object.CNcomment:销毁文本输出对象 CNend
+\attention \n
+N/A.CNcomment:无 CNend
+\param[in] TextOut Handle of a text output object.CNcomment:文本输出对象句柄 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+::HI_GO_CreateText
+*/
+HI_S32 HI_GO_DestroyText(HI_HANDLE TextOut);
+
+/**
+\brief set the input charset. CNcomment:设置输入字符集 CNend
+\attention \n
+N/A.CNcomment:无 CNend
+\param[in] TextOut Handle of a text output object.CNcomment:文本输出对象句柄 CNend
+\param[out] CharSet  charset of input text.CNcomment:输入文本字符集合 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORT_CHARSET
+
+\see \n
+::HI_GO_CreateText
+*/
+HI_S32 HI_GO_SetInputCharSet(HI_HANDLE TextOut, HIGO_CHARSET_E CharSet);
+
+/**
+\brief Obtains the attributes of a text output object.CNcomment:获取文本输出对象属性 CNend
+\attention \n
+N/A.CNcomment:无 CNend
+\param[in] TextOut Handle of a text output object.CNcomment:文本输出对象句柄 CNend
+\param[out] pTextOutAttr  Attributes of a text output object.CNcomment:文本输出对象属性 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_NULLPTR
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A.CNcomment:无 CNend
+*/
+HI_S32 HI_GO_GetTextAttr(HI_HANDLE TextOut,HIGO_TEXTOUTATTR_S *pTextOutAttr);
+
+/**
+\brief Obtains the width and height of text contents.CNcomment:获取文本内容的宽高 CNend
+\attention \n
+N/A.CNcomment:无 CNend
+\param[in] TextOut Handle of a text output object.CNcomment:文本输出对象句柄 CNend
+\param[in] pText Text contents.CNcomment:文本内容 CNend
+\param[out] pWidth Width of text contents. It cannot be empty.CNcomment:文本内容宽度，不可为空 CNend
+\param[out] pHeight Height of text contents. It cannot be empty.CNcomment:文本内容高度，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORT_CHARSET
+
+\see \n
+N/A.CNcomment:无 CNend
+*/
+HI_S32 HI_GO_GetTextExtent(HI_HANDLE TextOut, const HI_CHAR *pText, HI_S32 *pWidth, HI_S32 *pHeight);
+
+/**
+\brief Obtains the width and height of vertical text contents.CNcomment:获取竖排文本内容的宽高 CNend
+\attention \n
+N/A.CNcomment:无 CNend
+\param[in] TextOut Handle of a text output object.CNcomment:文本输出对象句柄 CNend
+\param[in] pText Text contents.CNcomment:文本内容 CNend
+\param[out] pTextWidth Actual width of text contents. It cannot be empty.CNcomment:文本内容实际宽度，不可为空 CNend
+\param[out] pHeight Height of text contents. It cannot be empty.CNcomment:文本内容高度，不可为空 CNend
+\param[out] pLayoutAreaWidth Minmal width of layout area. It cannot be empty.CNcomment:文本排版区域的最小宽度，不可为空 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_UNSUPPORT_CHARSET
+
+\see \n
+N/A.CNcomment:无 CNend
+*/
+HI_S32 HI_GO_GetVerticalTextExtent(HI_HANDLE hFont, const HI_CHAR *pText,
+                                   HI_S32 *pTextWidth, HI_S32 *pHeight, HI_S32 *pLayoutAreaWidth);
+
+/**
+\brief Sets to display the background color of a text output object.CNcomment:设置文本输出对象的背景色是否显示 CNend
+\attention \n
+N/A.CNcomment:无 CNend
+\param[in] TextOut Handle of a text output object.CNcomment:文本输出对象句柄 CNend
+\param[in] bTransparent  Whether to display the background color of a text output object. If the value is set to
+HI_TRUE, the background color is not displayed. The default value is HI_TRUE.CNcomment:文本输出对象背景色是否显示，为HI_TRUE, 则不显示，默认为HI_TRUE CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/ACNcomment:无 CNend
+*/
+HI_S32 HI_GO_SetTextBGTransparent(HI_HANDLE TextOut, HI_BOOL bTransparent);
+
+/**
+\brief Sets the background color of a text output object.CNcomment:设置文本输出对象的背景色 CNend
+\attention \n
+If the target surface is a palette, the color is the palette index.CNcomment:如果目标surface是调色板，则Color是调色板索引 CNend
+\param[in] TextOut Handle of a text output object.CNcomment:文本输出对象句柄 CNend
+\param[in] Color  Background color of a text output object.CNcomment:文本输出对象背景色，CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A.CNcomment:无 CNend
+*/
+HI_S32 HI_GO_SetTextBGColor(HI_HANDLE TextOut, HI_COLOR Color);
+
+/**
+\brief Sets the font color of a text output object.CNcomment: 设置文本输出对象的字体颜色 CNend
+\attention \n
+If the target surface is a palette, the color is the palette index.CNcomment: 如果目标surface是调色板，则Color是调色板索引 CNend
+\param[in] TextOut Handle of a text output object.CNcomment: 文本输出对象句柄 CNend
+\param[in] Color  Font color of a text output object.CNcomment: 文本输出对象字体颜色 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A.CNcomment: 无 CNend
+*/
+HI_S32 HI_GO_SetTextColor(HI_HANDLE TextOut, HI_COLOR Color);
+
+/**
+\brief Outputs text contents to a specified surface.CNcomment:输出文本内容到指定surface CNend
+\attention
+N/A.CNcomment:无 CNend
+\param[in] TextOut Handle of a text output object.CNcomment:文本输出对象句柄 CNend
+\param[in] Surface Surface handle.CNcomment:Surface句柄 CNend
+\param[in] pText  Text contents.CNcomment:文本内容 CNend
+\param[in] pRect Text output region. If the value is empty, it indicates that text contents are output from the
+surface origin.CNcomment:文本输出区域，为空表示从surface原点输出 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A.CNcomment:无 CNend
+*/
+HI_S32 HI_GO_TextOut(HI_HANDLE TextOut,HI_HANDLE Surface, const HI_CHAR *pText,
+                           const HI_RECT *pRect);
+
+/**
+\brief Outputs texts. This API is an extended API. You can call this API to output contents based on customized
+styles and formatting.CNcomment:文本输出扩展接口,输出内容可以按照用户指定的排版进行输出。CNend
+\param[in] hTextOut Text output handle.CNcomment:文本输出句柄 CNend
+\param[in] hSurface Surface handle.CNcomment:Surface句柄 CNend
+\param[in] pText    Text contents ending with /0.CNcomment:以/0结尾的文本内容 CNend
+\param[in] pRect    Text output region.CNcomment:文本输出区域 CNend
+\param[in] Style    Styles and formatting including LAYOUT_LEFT, LAYOUT_RIGHT, and LAYOUT_HCENTER.CNcomment:排版格式，如LAYOUT_LEFT、LAYOUT_RIGHT、LAYOUT_HCENTER等 CNend
+
+\retval ::HI_SUCCESS
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HIGO_ERR_NULLPTR
+
+\see \n
+N/A.CNcomment:无 CNend
+*/
+HI_S32 HI_GO_TextOutEx(HI_HANDLE hTextOut, HI_HANDLE hSurface,
+                               const HI_CHAR *pText,  const HI_RECT *pRect,
+                               HIGO_LAYOUT_E Style);
+
+/**
+\brief Calculates the number of characters in a specified text output region.CNcomment: 计算指定文本输出区域字符个数 CNend
+\attention \n
+N/A.CNcomment:无 CNend
+\param[in] hTextOut Text output handle.CNcomment: 文本输出句柄 CNend
+\param[in] pText    Text contents ending with /0.CNcomment: 以/0结尾的文本内容 CNend
+\param[in] pRect    Text output region. The value cannot be empty.CNcomment: 文本输出区域,不可为空 CNend
+\param[in] pLen      Pointer to the string length.CNcomment: 字符串长度指针 CNend
+
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_INVHANDLE
+\retval ::HI_SUCCESS
+
+\see \n
+N/A.CNcomment: 无 CNend
+*/
+HI_S32 HI_GO_GetTextExtentEx(HI_HANDLE TextOut, const HI_CHAR *pText,
+                                       const HI_RECT *pRect, HI_U32 *pLen);
+
+/**
+\brief Creates a font.CNcomment:创建字体 CNend
+\attention \n
+N/A.CNcomment:无 CNend
+\param[in] phText Text output handle.CNcomment:文本输出句柄 CNend
+\param[in] pInfo  Text information.CNcomment:文件信息 CNend
+
+\retval ::HI_SUCCESS A font is created successfully.CNcomment:字体创建成功 CNend
+\retval ::HI_FAILURE A font fails to be created.CNcomment:字体创建失败 CNend
+\retval ::HIGO_ERR_INVPARAM
+\retval ::HIGO_ERR_NOMEM
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A.CNcomment:无 CNend
+*/
+HI_S32 HI_GO_CreateTextEx(const HIGO_TEXT_INFO_S* pInfo, HI_HANDLE* phText);
+
+/**
+\brief Sets the style of a font, such as bold, italic, or normal.CNcomment:设置字体的风格，比如:粗体，斜体，正常体 CNend
+\attention \n
+N/A.CNcomment:无 CNend
+\param[in] hTextOut Text output handle.CNcomment:文本输出句柄 CNend
+\param[in] eStyle   Font style.CNcomment:字体风格 CNend
+
+\retval ::HI_SUCCESS Success.CNcomment:成功 CNend
+\retval ::HIGO_ERR_INVHANDLE
+
+\see \n
+N/A.CNcomment:无 CNend
+*/
+HI_S32 HI_GO_SetTextStyle(HI_HANDLE hTextOut, HIGO_TEXT_STYLE_E eStyle);
+
+
+
+/**
+\brief Sets the the text base direction
+lines.CNcomment:设置文本输出对象的基本方向 CNend
+\attention \n
+N/A.CNcomment:无 CNend
+
+\param[in] hTextOut Text output handle. CNcomment:文本输出句柄 CNend
+\param[in] BaseDir the base direction of the text. CNcomment: 文本输出对象基本方向 CNend
+
+\retval ::HI_SUCCESS Success.CNcomment: 成功 CNend
+\retval ::HIGO_ERR_INVHANDLE Failure.CNcomment:失败 CNend
+
+\see \n
+N/A.CNcomment:无 CNend
+*/
+
+HI_S32 HI_GO_SetBaseDir(HI_HANDLE TextOut, HIGO_TEXT_DIR_E eBaseDir);
+/**
+\brief Sets the horizontal spacing between displayed characters, that is, the horizontal spacing between character
+lines.CNcomment:设置字符显示水平间距，两个字符行水平间距 CNend
+\attention \n
+N/A.CNcomment:无 CNend
+
+\param[in] hTextOut Text output handle.CNcomment:文本输出句柄 CNend
+\param[in] u32Distance Horizontal spacing.CNcomment:水平间距 CNend
+
+\retval ::HI_SUCCESS Success.CNcomment: 成功 CNend
+\retval ::HIGO_ERR_INVHANDLE Failure.CNcomment:失败 CNend
+
+\see \n
+N/A.CNcomment:无 CNend
+*/
+HI_S32 HI_GO_SetCharExtra(HI_HANDLE hTextOut, HI_U32 u32Distance);
+
+/**
+\brief Sets the vertical and horizontal spacing.CNcomment:设置垂直水平间距 CNend
+\attention \n
+This API is available only when the font style is changed.CNcomment:只有换行风格才有效 CNend
+
+\param[in] hTextOut Text output handle.CNcomment:文本输出句柄 CNend
+\param[in] u32Distance Vertical spacing.CNcomment:垂直间距 CNend
+
+\retval ::HI_SUCCESS Success.CNcomment:成功 CNend
+\retval ::HIGO_ERR_INVHANDLE Failure.CNcomment:失败 CNend
+
+\see \n
+N/A.CNcomment:无 CNend
+*/
+HI_S32 HI_GO_SetLineExtra(HI_HANDLE hText, HI_U32 u32Distance);
+
+/**
+\brief Initializes the character module.CNcomment: 初始化字符模块 CNend
+\attention \n
+N/A.CNcomment: 无 CNend
+\param N/A.CNcomment: 无 CNend
+\retval ::HI_SUCCESS Success.CNcomment: 成功 CNend
+\retval ::HI_FAILURE Failure.CNcomment: 失败 CNend
+\retval ::HIGO_ERR_DEPEND_TDE
+
+\see \n
+N/A.CNcomment: 无 CNend
+*/
+HI_S32 HI_GO_InitText();
+
+/**
+\brief Deinitializes the character module.CNcomment:去初始化字符模块 CNend
+\attention \n
+N/A.CNcomment:无 CNend
+\param N/A.CNcomment:无 CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功 CNend
+\retval ::HIGO_ERR_NOTINIT Failure.CNcomment:失败 CNend
+
+\see \n
+N/A.CNcomment:无 CNend
+*/
+HI_S32 HI_GO_DeinitText();
+
+
+/** @} */  /*! <!-- API declaration end */
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif  /*__cplusplus*/
+#endif  /*__cplusplus*/
+
+#endif /* __HI_GO_TEXT_H__ */
diff -uNr a/include/hi_memory.h b/include/hi_memory.h
--- a/include/hi_memory.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_memory.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,200 @@
+/*
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2009-2019. All rights reserved.
+ * Description:
+ * Author: guoqingbo
+ * Create: 2009-12-15
+ */
+
+#ifndef __HI_MEMORY_H__
+#define __HI_MEMORY_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************Structure declaration *****************************/
+/** @addtogroup     MEMOYR */
+/** @{ */ /** <!--  [MEMOYR] */
+
+/** Maximum bytes of a buffer name */
+#define MAX_BUFFER_NAME_SIZE 16
+
+/**Structure of an MMZ buffer*/
+typedef struct hiMMZ_BUF_S
+{
+    HI_CHAR bufname[MAX_BUFFER_NAME_SIZE];  /**<Strings of an MMZ buffer name*/ /**<CNcomment:  MMZ buffer名字字符串 */
+    HI_U32  phyaddr;                /**<Physical address of an MMZ buffer*/ /**<CNcomment:  MMZ buffer物理地址 */
+    HI_U8  *kernel_viraddr;         /**<Kernel-state virtual address of an MMZ buffer*/ /**<CNcomment:  MMZ buffer内核态虚拟地址 */
+    HI_U8  *user_viraddr;           /**<User-state virtual address of an MMZ buffer*/ /**<CNcomment:  MMZ buffer用户态虚拟地址 */
+    HI_U32  bufsize;                /**<Size of an MMZ buffer*/ /**<CNcomment:  MMZ buffer大小 */
+    HI_U32  overflow_threshold;     /**<Overflow threshold of an MMZ buffer, in percentage. For example, the value 100 indicates 100%.*/ /**<CNcomment:  MMZ buffer上溢水线，按百分比设置，例如: 100 indicates 100%.*/
+    HI_U32  underflow_threshold;    /**<Underflow threshold of an MMZ buffer, in percentage. For example, the value 0 indicates 0%.*/ /**<CNcomment:  MMZ buffer下溢水线，按百分比设置，例如: 0 indicates 0%.*/
+} HI_MMZ_BUF_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      MEMOYR */
+/** @{ */  /** <!-- [MEMOYR] */
+
+/**
+@brief Applies for a media memory zone (MMZ) and maps the user-state address.
+CNcomment:  申请mmz内存，并映射用户态地址 CNend
+@attention \n
+N/A CNcomment: 无 CNend
+@param[in/out] pstBuf Structure of the buffer information. Bufname and bufsize are inputs, and the physical address and user-state virtual address are outputs.
+                    CNcomment: buffer信息结构，bufname和bufsize作为输入,物理地址和用户态虚拟地址作为输出 CNend
+@retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+@see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_MMZ_Malloc(HI_MMZ_BUF_S *pstBuf);
+
+/**
+@brief Unmaps the user-state address and releases the MMZ. CNcomment: 解除用户态地址的映射，并释放mmz内存 CNend
+@attention \n
+Ensure that the lengths of the transferred physical address and user-state virtual address are correct.
+CNcomment: 保证传入的物理地址、用户态虚拟地址和长度正确 CNend
+@param[in] pstBuf Structure of the buffer information CNcomment: buffer信息结构 CNend
+@retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+@see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_MMZ_Free(HI_MMZ_BUF_S *pstBuf);
+
+/**
+@brief pplies for an MMZ with a specified name and obtains its physical address. CNcomment: 指定mmz的名字申请mmz内存，返回物理地址 CNend
+@attention \n
+N/A CNcomment: 无 CNend
+@param[in] u32Size Buffer size CNcomment: buffer大小 CNend
+@param[in] u32Align Alignment mode CNcomment: 对齐方式 CNend
+@param[in] ps8MMZName Name of an MMZ in the buffer. If the MMZ name is set to NULL, an MMZ is anonymously applied for. CNcomment: buffer分区的名字，传入NULL匿名申请 CNend
+@param[in] ps8BufName Buffer name CNcomment: buffer块的名字 CNend
+@retval ::NULL The application fails. CNcomment: 申请失败 CNend
+@retval Physical address CNcomment: 物理地址 CNend
+@see \n
+N/A CNcomment: 无 CNend
+*/
+HI_VOID *HI_MMZ_New(HI_U32 u32Size , HI_U32 u32Align, HI_CHAR *ps8MMZName, HI_CHAR *ps8BufName);
+
+
+/**
+@brief Releases an MMZ based on its physical address. CNcomment: 通过物理地址释放mmz内存 CNend
+@attention \n
+N/A CNcomment: 无 CNend
+@param[in] u32PhysAddr Physical address of a buffer CNcomment: buffer物理地址 CNend
+@retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+@see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_MMZ_Delete(HI_U32 u32PhysAddr);
+
+/**
+@brief Maps the physical address of an MMZ applied for to a user-state virtual address. You can determine whether to cache the address.
+CNcomment: 将mmz申请的物理地址映射成用户态虚拟地址，可以指定是否cached CNend
+@attention \n
+N/A CNcomment: 无 CNend
+@param[in] u32PhysAddr Physical address of a buffer CNcomment: buffer物理地址 CNend
+@param[in] u32Cached Whether to cache the address. 0: no; 1: yes CNcomment: 是否使用cache，0不使用，1使用 CNend
+@retval ::NULL The application fails. CNcomment: 申请失败 CNend
+@retval User-state virtual address CNcomment: 用户态虚地址 CNend
+@see \n
+N/A CNcomment: 无 CNend
+*/
+HI_VOID *HI_MMZ_Map(HI_U32 u32PhysAddr, HI_U32 u32Cached);
+
+/**
+@brief Unmaps the user-state address of an MMZ. CNcomment: 解除mmz内存用户态地址的映射 CNend
+@attention \n
+N/A CNcomment: 无 CNend
+@param[in] u32PhysAddr Physical address of a buffer CNcomment: buffer物理地址 CNend
+@retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+@see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_MMZ_Unmap(HI_U32 u32PhysAddr);
+
+
+/**
+@brief Flushes D-cache to the cached MMZ. CNcomment: 对于cached类型MMZ，刷Dcache到内存 CNend
+@attention \n
+refreshed transferred u32PhysAddr memory, the value 0 of u32PhysAddr is invalid.
+CNcomment: 刷新u32PhysAddr起始的内存块 ，u32PhysAddr不允许为0 CNend
+@param[in] u32PhysAddr Physical address of a buffer CNcomment: buffer物理地址 CNend
+@retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+@see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_MMZ_Flush(HI_U32 u32PhysAddr);
+
+
+/**
+@brief Obtains the physical address and size based on the virtual address. CNcomment: 根据虚拟地址获取物理地址，以及大小 CNend
+@attention \n
+N/A CNcomment: 无 CNend
+@param[in] pVir User-state virtual address CNcomment: 用户态虚地址 CNend
+@param[out] pu32Phyaddr Physical address  CNcomment: 物理地址 CNend
+@param[out] pu32Size Size CNcomment: 大小 CNend
+@retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+@retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+@see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_MMZ_GetPhyaddr(HI_VOID * pVir, HI_U32 *pu32Phyaddr, HI_U32 *pu32Size);
+
+/**
+@brief malloc the pointed size from system heap. CNcomment:从系统中分配指定大小的内存 CNend
+@attention None CNcomment:无 CNend
+@param[in] u32ModuleID The module ID, who need to request memory. CNcomment:模块ID CNend
+@param[in] u32Size The size of requesting. CNcomment:请求分配的大小，单位是字节 CNend
+@param[out] None CNcomment:无 CNend
+@retval ::Valid memory address Success CNcomment:成功返回分配到的空间首地址 CNend
+@retval ::NULL Failure CNcomment:失败返回NULL CNend
+@see \n
+N/A CNcomment:无 CNend
+*/
+HI_VOID* HI_MEM_Malloc(HI_U32 u32ModuleID, HI_U32 u32Size);
+
+
+/**
+@brief Free the requsted memory by hi_malloc. CNcomment:释放分配的内存 CNend
+@attention when stopping to use the memory, calling this interface. CNcomment:不再需要这块内存时，使用此接口进行释放 CNend
+@param[in] u32ModuleID The module ID, who need to free memory. CNcomment:模块ID CNend
+@param[in] pMemAddr The memory address to free CNcomment:释放空间的首地址 CNend
+@param[out] None CNcomment:无 CNend
+@retval ::None CNcomment:无 CNend
+@see \n
+N/A CNcomment:无 CNend
+*/
+HI_VOID HI_MEM_Free(HI_U32 u32ModuleID, HI_VOID* pMemAddr);
+
+/**
+@brief Calloc memory, with u32MemBlock blocks and u32Size size per. CNcomment:分配连续大小的内存块 CNend
+@attention None CNcomment:无 CNend
+@param[in] u32ModuleID The module id, who need to calloc memory. CNcomment:模块ID CNend
+@param[in] u32MemBlock The requesting block number. CNcomment:分配的块数 CNend
+@param[in] u32Size The requesting size per block. CNcomment:每块的大小，单位是字节 CNend
+@param[out] None CNcomment:无 CNend
+@retval ::Valid memory address Success CNcomment:成功则返回分配到的内存首地址 CNend
+@retval ::NULL Failure CNcomment:失败返回NULL CNend
+@see \n
+N/A CNcomment: 无 CNend
+*/
+HI_VOID* HI_MEM_Calloc(HI_U32 u32ModuleID, HI_U32 u32MemBlock, HI_U32 u32Size);
+
+
+/** @} */ /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HI_MEMORY_H__ */
+
diff -uNr a/include/hi_module.h b/include/hi_module.h
--- a/include/hi_module.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_module.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,204 @@
+/*
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2009-2019. All rights reserved.
+ * Description:
+ * Author: guoqingbo
+ * Create: 2009-12-15
+ */
+
+#ifndef __HI_MODULE_H__
+#define __HI_MODULE_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************Structure declaration *****************************/
+/** @addtogroup     MODULE */
+/** @{ */ /** <!--  [MODULE] */
+
+#define HI_INVALID_MODULE_ID        (0xffffffff)
+#define HI_MAX_USER_MODULE_NUMBER   (256)
+
+/** Module ID flags */
+typedef enum hiMOD_ID_E
+{
+    HI_ID_STB         = 0,
+
+    /**< common. */ /**< CNcomment: 系统通用枚举数据常量 */
+    HI_ID_SYS         = 1,
+    HI_ID_MODULE      ,
+    HI_ID_LOG         ,
+    HI_ID_PROC        ,
+    HI_ID_MEM         ,
+    HI_ID_STAT        ,
+    HI_ID_PDM         ,
+    HI_ID_MEMDEV      ,
+
+    HI_ID_DEMUX       = 0x0A,
+    HI_ID_TSIO,
+    HI_ID_IFCP,
+
+    /**< audio. */ /**< CNcomment: 音频部分常量区 */
+    HI_ID_ADEC        = 0x10,
+    HI_ID_AO          ,
+    HI_ID_SIO_AI      ,
+    HI_ID_SIO_AO      ,
+    HI_ID_SIO         ,
+    HI_ID_AI          ,
+    HI_ID_AENC        ,
+    HI_ID_SRC         ,
+    HI_ID_AIAO        ,
+    HI_ID_AFLT        ,
+    HI_ID_ADSP        ,
+    HI_ID_AMP         ,
+    HI_ID_SIF         ,
+
+    /**< video. */ /**< CNcomment: 视频部分常量区 */
+    HI_ID_VFMW        = 0x20,
+    HI_ID_SVDEC       ,
+    HI_ID_DISP        ,
+    HI_ID_HDMI        ,
+    HI_ID_VO          ,
+    HI_ID_VPSS        ,
+    HI_ID_VDEC        ,
+    HI_ID_VI          ,
+    HI_ID_VENC        ,
+    HI_ID_PQ         ,
+    HI_ID_EDID,
+    HI_ID_VICAP       ,
+    HI_ID_HDMIRX      ,
+    /**< graphics. */ /**< CNcomment: 图形部分常量区 */
+    HI_ID_TDE         = 0x30,
+    HI_ID_JPGDEC      ,
+    HI_ID_JPGENC      ,
+    HI_ID_FB          ,
+    HI_ID_PNG         ,
+    HI_ID_HIGO        ,
+    HI_ID_GFX2D       ,
+
+    /**< player. */ /**< CNcomment: 播放相关部分常量区 */
+    HI_ID_PVR         = 0x40,
+    HI_ID_AVPLAY      ,
+    HI_ID_SYNC        ,
+    HI_ID_VSYNC       ,
+    HI_ID_ASYNC       ,
+    HI_ID_FASTPLAY ,
+
+    /**< ecs. */ /**< CNcomment: 外设部分常量区 */
+    HI_ID_FLASH       = 0x50,
+    HI_ID_IR          ,
+    HI_ID_RTC         ,
+    HI_ID_I2C         ,
+    HI_ID_SCI         ,
+    HI_ID_ETH         ,
+    HI_ID_USB_PROTECT ,
+    HI_ID_WDG         = 0x57,   /* watch dog used 'W' */
+    HI_ID_GPIO        ,
+    HI_ID_GPIO_I2C    ,
+    HI_ID_DMAC        ,
+    HI_ID_PMOC        ,
+    HI_ID_TUNER       ,
+    HI_ID_KEYLED      ,
+    HI_ID_E2PROM      ,
+    HI_ID_CIPHER      ,
+    HI_ID_OTP         = 0x60,
+    HI_ID_CA          ,
+    HI_ID_PM          ,
+    HI_ID_CI          ,
+    HI_ID_CIMAXPLUS   ,
+    HI_ID_TVP5150     ,
+    HI_ID_SIL9293     ,
+    HI_ID_PWM         ,
+    HI_ID_SPI         ,
+    HI_ID_PLCIPHER    ,//0x69
+    HI_ID_CERT        ,//0x6A
+    HI_ID_SM          ,//0x6B
+    HI_ID_RUNTIME     ,//0x6C
+    HI_ID_MAILBOX     ,//0x6D
+    HI_ID_CASIMAGE    ,//0x6E
+
+    /**< voip, bluetooth,alsa. */ /**<  CNcomment: VOIP、蓝牙部分常量区*/
+    HI_ID_VOIP_HME    = 0x80,
+    HI_ID_NDPT        ,
+    HI_ID_AUDADP      ,
+    HI_ID_BT          ,
+    HI_ID_ALSA        ,
+    HI_ID_3G          ,
+    HI_ID_KARAOKE     ,
+
+    /**< vp. */ /**<  CNcomment: VP常量区*/
+    HI_ID_VP          = 0x90,
+    HI_ID_HDCP        ,
+
+    /**< subtitle. */ /**<  CNcomment: 字幕常量区*/
+    HI_ID_SUBT        = 0x98,
+    HI_ID_TTX         ,
+    HI_ID_CC          ,
+
+    /**< loader. */ /**< CNcomment: loader */
+    HI_ID_LOADER      = 0xA0,
+
+    /**< Reserve fro middleware: 0xA1-0XB7. */ /**<  CNcomment: 给中间件预留 0xA1-0XB7.*/
+
+    /**<GPU. */ /**< CNcomment:GPU*/
+    HI_ID_GPU        = 0xB8,
+
+    /**< user definition. */ /**< CNcomment: 为整机保留的自定义区 */
+    HI_ID_USR_START   = 0xC0,
+    HI_ID_USR_END     = 0xFE,
+
+    HI_ID_BUTT        = 0xFF
+} HI_MOD_ID_E;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      MODULE */
+/** @{ */  /** <!-- [MODULE] */
+
+/**
+@brief Register one module to manager. CNcomment:模块注册，用于管理 CNend
+@attention Before manager someone module, calling this interface. CNcomment:如需管理模块，用此接口先注册 CNend
+@param[in] pszModuleName The module name CNcomment:模块名称 CNend
+@param[in] u32ModuleID   The module ID. CNcomment:模块ID CNend
+@retval ::HI_SUCCESS Success CNcomment:成功 CNend
+@retval ::HI_FAILURE Failure CNcomment:失败 CNend
+@see \n
+N/A CNcomment:无 CNend
+*/
+HI_S32 HI_MODULE_Register(HI_U32 u32ModuleID, const HI_CHAR * pszModuleName);
+
+/**
+@brief Register one moudle by name. CNcomment:模块注册，ID由系统分配 CNend
+@attention Before manager someone module, calling this interface. CNcomment:如需管理模块，用此接口先注册 CNend
+@param[in] pszModuleName The module name CNcomment:模块名称 CNend
+@param[out] pu32ModuleID The module id allocated by system. CNcomment:系统分配的模块ID CNend
+@retval ::HI_SUCCESS Success CNcomment:成功 CNend
+@retval ::HI_FAILURE Failure CNcomment:失败 CNend
+@see \n
+N/A CNcomment:无 CNend
+*/
+HI_S32 HI_MODULE_RegisterByName(const HI_CHAR * pszModuleName, HI_U32* pu32ModuleID);
+
+/**
+@brief UnRegister one module to trace. CNcomment:模块移除 CNend
+@attention Before stopping to manage someone module, calling this interface. CNcomment:不需要管理此模块时，使用此接口移除模块 CNend
+@param[in] u32ModuleID The module ID. CNcomment:模块ID CNend
+@param[out] None CNcomment:无 CNend
+@retval ::HI_SUCCESS Success CNcomment:成功 CNend
+@retval ::HI_FAILURE Failure CNcomment:失败 CNend
+@see \n
+N/A CNcomment:无 CNend
+*/
+HI_S32 HI_MODULE_UnRegister(HI_U32 u32ModuleID);
+
+/** @} */ /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HI_MODULE_H__ */
+
diff -uNr a/include/hi_system.h b/include/hi_system.h
--- a/include/hi_system.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_system.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,435 @@
+/*
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2009-2019. All rights reserved.
+ * Description:
+ * Author: guoqingbo
+ * Create: 2009-12-15
+ */
+
+#ifndef __HI_SYSTEM_H__
+#define __HI_SYSTEM_H__
+
+#include "hi_type.h"
+#include "hi_debug.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct hiSYS_CONF_S
+{
+    HI_U32 u32Reverse; /* Not used, reserved for extension */ /* CNcomment: 暂时没有使用，留待扩展 */
+} HI_SYS_CONF_S;
+
+/* Define the chip type. */
+typedef enum hiCHIP_TYPE_E
+{
+    HI_CHIP_TYPE_HI3716M,
+    HI_CHIP_TYPE_HI3716H,
+    HI_CHIP_TYPE_HI3716C,
+    HI_CHIP_TYPE_HI3716D,
+
+    HI_CHIP_TYPE_HI3720,
+    HI_CHIP_TYPE_HI3712,
+    HI_CHIP_TYPE_HI3715,
+
+    HI_CHIP_TYPE_HI3718M,
+    HI_CHIP_TYPE_HI3718C,
+    HI_CHIP_TYPE_HI3719M,
+    HI_CHIP_TYPE_HI3719C,
+    HI_CHIP_TYPE_HI3719M_A,
+
+    HI_CHIP_TYPE_HI3796C   = 0x20,
+    HI_CHIP_TYPE_HI3798C,
+    HI_CHIP_TYPE_HI3796M,
+    HI_CHIP_TYPE_HI3798M,
+
+    HI_CHIP_TYPE_HI3796C_A = 0x40,
+    HI_CHIP_TYPE_HI3798C_A,
+    HI_CHIP_TYPE_HI3798C_B,
+
+    HI_CHIP_TYPE_HI3798M_A,
+    HI_CHIP_TYPE_HI3798M_H,
+
+    HI_CHIP_TYPE_BUTT
+} HI_CHIP_TYPE_E;
+
+/* Define the chip version. */
+typedef enum hiCHIP_VERSION_E
+{
+    HI_CHIP_VERSION_V100 = 0x100,
+    HI_CHIP_VERSION_V101 = 0x101,
+    HI_CHIP_VERSION_V110 = 0x110,
+    HI_CHIP_VERSION_V200 = 0x200,
+    HI_CHIP_VERSION_V210 = 0x210,
+    HI_CHIP_VERSION_V300 = 0x300,
+    HI_CHIP_VERSION_V310 = 0x310,
+    HI_CHIP_VERSION_V400 = 0x400,
+    HI_CHIP_VERSION_V410 = 0x410,
+    HI_CHIP_VERSION_V420 = 0x420,
+    HI_CHIP_VERSION_V430 = 0x430,
+    HI_CHIP_VERSION_V450 = 0x450,
+    HI_CHIP_VERSION_BUTT
+} HI_CHIP_VERSION_E;
+
+typedef enum
+{
+    HI_CHIP_PACKAGE_TYPE_BGA_15_15 = 0,
+    HI_CHIP_PACKAGE_TYPE_BGA_16_16,
+    HI_CHIP_PACKAGE_TYPE_BGA_19_19,
+    HI_CHIP_PACKAGE_TYPE_BGA_23_23,
+    HI_CHIP_PACKAGE_TYPE_BGA_31_31,
+    HI_CHIP_PACKAGE_TYPE_QFP_216,
+    HI_CHIP_PACKAGE_TYPE_BGA_21_21,
+    HI_CHIP_PACKAGE_TYPE_BGA_14_14,
+    HI_CHIP_PACKAGE_TYPE_BUTT
+} HI_CHIP_PACKAGE_TYPE_E;
+
+/* Define the chip support attrs */
+typedef enum hiCHIP_CAP_E
+{
+    HI_CHIP_CAP_DOLBY,
+    HI_CHIP_CAP_DTS,
+    HI_CHIP_CAP_ADVCA,
+    HI_CHIP_CAP_MACROVISION,
+    HI_CHIP_CAP_HDR10,
+    HI_CHIP_CAP_DOLBYVISION,
+    HI_CHIP_CAP_BUTT
+} HI_CHIP_CAP_E;
+
+/* Define the video codec lisence contrl enum. */
+typedef enum hiSYS_VIDEO_CODEC_E
+{
+    HI_SYS_VIDEO_MPEG2 = 0x1,
+    HI_SYS_VIDEO_MPEG4 = 0x2,
+    HI_SYS_VIDEO_VC1   = 0x4,
+    HI_SYS_VIDEO_H264  = 0x8,
+    HI_SYS_VIDEO_MVC   = 0x10,
+    HI_SYS_VIDEO_H265  = 0x20,
+    HI_SYS_VIDEO_AVS   = 0x40,
+    HI_SYS_VIDEO_DIVX  = 0x80,
+    HI_SYS_VIDEO_REAL8 = 0x100,
+    HI_SYS_VIDEO_REAL9 = 0x200,
+    HI_SYS_VIDEO_AVS2  = 0x400,
+    HI_SYS_VIDEO_MASK  = 0x7FF,
+} HI_SYS_VIDEO_CODEC_E;
+
+/* System version, that is, the version of the software developer's kit (SDK) */
+typedef struct hiSYS_VERSION_S
+{
+    HI_CHIP_TYPE_E  enChipTypeSoft;     /* Chip type corresponding to the SDK */ /* CNcomment: SDK软件对应的芯片类型 */
+    HI_CHIP_TYPE_E  enChipTypeHardWare; /* Chip type that is detected when the SDK is running */ /* CNcomment: SDK运行时检测到的芯片类型 */
+    HI_CHIP_VERSION_E enChipVersion;    /* Chip version that is detected when the SDK is running */ /* CNcomment: SDK运行时检测到芯片版本号 */
+    HI_CHAR         aVersion[80];       /* Version string of the SDK */ /* CNcomment: SDK软件版本号字符串 */
+    HI_CHAR         BootVersion[80];    /* Version string of the Boot */ /* CNcomment: Boot版本号字符串 */
+    HI_CHAR         SecureOSImageVersion[96]; /* Version string of the secure os image */ /* CNcomment: 安全OS镜像版本字符串 */
+} HI_SYS_VERSION_S;
+
+/* Define the chip attributes */
+typedef struct hiSYS_CHIP_ATTR_S
+{
+    HI_BOOL bDolbySupport;       /* Whether support dolby or not */ /* CNcomment:芯片是否支持杜比 */
+    HI_BOOL bDTSSupport;         /* Whether support DTS or not */ /* CNcomment:芯片是否支持DTS */
+    HI_BOOL bADVCASupport;       /* Whether support ADVCA or not */ /* CNcomment:芯片是否支持高安 */
+    HI_BOOL bMacrovisionSupport; /* Whether support Macrovision or not */ /* CNcomment:芯片是否支持Macrovision */
+    HI_BOOL bHDR10Support;       /* Whether support HDR10 or not */ /* CNcomment:芯片是否支持HDR10 */
+    HI_BOOL bDolbyvisionSupport; /* Whether support DolbyVision or not */ /* CNcomment:芯片是否支持Dolbyvision */
+    HI_U64  u64ChipID;           /* the unique 64 bits chipid */ /* CNcomment:64位芯片唯一ID */
+    HI_U32  u32ChipID;           /* the unique 32 bits chipid since 98mv200 */ /* CNcomment:32位芯片唯一ID，98mv200及以后的芯片开始支持 */
+} HI_SYS_CHIP_ATTR_S;
+
+/* Define the Sys attributes */
+typedef struct hiSYS_ATTR_S
+{
+    HI_BOOL bSMPSupport; /* Whether support SMP or not */ /* CNcomment:系统是否支持安全媒体通路 */
+} HI_SYS_ATTR_S;
+
+/* Defines DDR configuration type struct */
+/* CNcomment: DDR 配置类型结构定义 */
+typedef struct hiSYS_MEM_CONFIG_S
+{
+    HI_U32 u32TotalSize; /* Total memory size(MB) */ /* CNcomment: 总内存大小(MB) */
+    HI_U32 u32MMZSize;   /* MMZ memory size(MB) */ /* CNcomment: MMZ内存大小(MB) */
+} HI_SYS_MEM_CONFIG_S;
+
+#ifndef __KERNEL__
+#include <time.h>
+
+/*
+ * brief Initializes the system. CNcomment: 系统初始化 CNend
+ * attention \n
+ * You must call this API to initialize the system before using the APIs of all modules.
+ * Though you can call other APIs successfully before calling this API, the subsequent operations may fail.\n
+ * CNcomment: 在使用所有模块的接口之前都需要先调用此接口对系统进行初始化\n
+ * 在调用这个接口之前调用其他接口，不会返回失败，但是不保证执行的正确性 CNend
+ * param N/A CNcomment: 无 CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ * N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_SYS_Init(HI_VOID);
+
+/*
+ * brief Deinitializes the system. CNcomment: 系统去初始化 CNend
+ * attention \n
+ * If all modules are not used, you need to call this API to deinitialize the system.\n
+ * CNcomment: 所有模块都不再使用后调用此接口去初始化 CNend
+ * param N/A CNcomment: 无 CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ * N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_SYS_DeInit(HI_VOID);
+
+/*
+ * brief Obtains the compiled time of a version. CNcomment: 获取版本的编译时间 CNend
+ * attention \n
+ * The compiled time is the time during which the common module is made again.
+ * CNcomment: 时间为进行common模块重新make的时间 CNend
+ * param[out] pstTime Pointer to the compiled time of a version (output). CNcomment: 指针类型，输出版本编译的时间 CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ * N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_SYS_GetBuildTime(struct tm * pstTime);
+
+/*
+ * brief Obtains the version number. CNcomment: 获取版本号 CNend
+ * attention \n
+ * N/A CNcomment: 无 CNend
+ * param[out] pstVersion Pointer to the version number (output). CNcomment: 指针类型，输出版本号 CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ * N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_SYS_GetVersion(HI_SYS_VERSION_S *pstVersion);
+
+/*
+ * brief Obtains the package type. CNcomment: 获取封装类型 CNend
+ * attention \n
+ * N/A CNcomment: 无 CNend
+ * param[out] penPackageType Pointer to the package type (output). CNcomment: 指针类型，输出封装类型 CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ * N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_SYS_GetChipPackageType(HI_CHIP_PACKAGE_TYPE_E *penPackageType);
+
+/*
+ * brief Obtains the chip support attributes. CNcomment: 获取芯片支持的能力 CNend
+ * attention \n
+ * N/A CNcomment: 无 CNend
+ * param[in] enChipCap Indicate which chip capability. CNcomment: 输入参数，指明获取何种芯片能力 CNend
+ * param[out] pbSupport Pointer to the chip whether support the attributes(output). CNcomment: 输出参数，保存获取结果 CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ * N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_SYS_GetChipCapability(HI_CHIP_CAP_E enChipCap, HI_BOOL *pbSupport);
+
+/*
+ * brief Obtains the chip attributes. CNcomment: 获取芯片属性 CNend
+ * attention \n
+ * N/A CNcomment: 无 CNend
+ * param[out] pstChipAttr Pointer to the chip attributes(output). CNcomment: 指针类型，输出芯片属性 CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ * N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_SYS_GetChipAttr(HI_SYS_CHIP_ATTR_S *pstChipAttr);
+
+/*
+ * brief Obtains the Sys attributes. CNcomment: 获取系统属性 CNend
+ * attention \n
+ * N/A CNcomment: 无 CNend
+ * param[out] pstSysAttr Pointer to the chip attributes(output). CNcomment: 指针类型，输出系统属性 CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ * N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_SYS_GetAttr(HI_SYS_ATTR_S *pstSysAttr);
+
+/*
+ * brief CRC32 function. CNcomment: CRC32功能 CNend
+ * attention \n
+ * N/A CNcomment: 无 CNend
+ * param[in] pu8Src Pointer to the source buffer. CNcomment: 指针类型，输入buffer CNend
+ * param[in] u32SrcLen length of the source buffer. CNcomment: 输入buffer长度 CNend
+ * param[out] pu32Dst Pointer to the out value. CNcomment: 输出数据指针 CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ * N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_SYS_CRC32(HI_U8 *pu8Src, HI_U32 u32SrcLen, HI_U32 *pu32Dst);
+
+/*
+ * brief Obtains the chip attributes. CNcomment: 获取内存配置信息 CNend
+ * attention \n
+ * N/A CNcomment: 无 CNend
+ * param[out] pstConfig Pointer to address for memory configuration(output). CNcomment: 指针类型，输出内存配置信息指针 CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ * N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_SYS_GetMemConfig(HI_SYS_MEM_CONFIG_S *pstConfig);
+
+/*
+ * brief Performs global system configuration. CNcomment: 设置系统的全局配置 CNend
+ * attention \n
+ * N/A CNcomment: 无 CNend
+ * param[in] pstSysConf Pointer to the address for system configuration CNcomment: 指针类型，系统配置指针地址 CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ * N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_SYS_SetConf(const HI_SYS_CONF_S *pstSysConf);
+
+/*
+ * brief Obtains global system configuration. CNcomment: 获取系统的全局配置 CNend
+ * attention \n
+ * N/A CNcomment: 无 CNend
+ * param[out] pstSysConf Pointer to the system configuration (output). CNcomment: 指针类型，输出系统配置 CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ * N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_SYS_GetConf(HI_SYS_CONF_S *pstSysConf);
+
+/*
+ * brief Sets the debugging information level of a module. CNcomment: 设置模块的调试信息级别 CNend
+ * attention \n
+ * N/A CNcomment: 无 CNend
+ * param[in] enModId Debugging ID of a module CNcomment: 模块的调试ID。 CNend
+ * param[in] enLogLevel Debugging information level of a module CNcomment: 模块的调试信息级别 CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ */
+HI_S32 HI_SYS_SetLogLevel(HI_MOD_ID_E enModId,  HI_LOG_LEVEL_E enLogLevel);
+
+/*
+ * brief Sets the debugging information file path for U-disk. CNcomment: 设置日志存储路径 CNend
+ * attention \n
+ * N/A CNcomment: 无 CNend
+ * param[in]  pszLogPath Debugging information file path. CNcomment: 日志的存储路径 CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ */
+HI_S32 HI_SYS_SetLogPath(const HI_CHAR* pszLogPath);
+
+/*
+ * brief Sets the debugging files(may be stream, YUV data, image...) save path. CNcomment: 设置调试文件存储路径 CNend
+ * attention \n
+ * N/A CNcomment: 无 CNend
+ * param[in]  pszPath Debugging files path. CNcomment: 调试文件的存储路径 CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ */
+HI_S32 HI_SYS_SetStorePath(const HI_CHAR* pszPath);
+
+/*
+ * brief Sets the debugging information file size(MB), range from 1 to 120. CNcomment: 设置日志大小(MB)，范围为1到120 CNend
+ * attention \n
+ * N/A CNcomment: 无 CNend
+ * param[in]  u32LogSize Debugging information file size(MB). CNcomment: 日志的大小(MB) CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ */
+HI_S32 HI_SYS_SetLogSize(HI_U32 u32LogSize);
+
+/*
+ * brief Writes to a register or a memory. CNcomment: 写寄存器 CNend
+ * attention:\n
+ * support register range: \n
+ * {0xF8000000, 0xF8000FFF} \n
+ * {0xF8A20000, 0xF8A20FFF} \n
+ * {0xF8A21000, 0xF8A21FFF} \n
+ * {0xF8A22000, 0xF8A22FFF} \n
+ * CNcomment:\n
+ * 寄存器范围支持:
+ * {0xF8000000, 0xF8000FFF} \n
+ * {0xF8A20000, 0xF8A20FFF} \n
+ * {0xF8A21000, 0xF8A21FFF} \n
+ * {0xF8A22000, 0xF8A22FFF} \n
+ * CNend
+ * param[in] u32RegAddr Physical address of a register CNcomment: 寄存器物理地址 CNend
+ * param[in] u32Value Value of a register CNcomment:  寄存器的值 CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ * N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_SYS_WriteRegister(HI_U32 u32RegAddr, HI_U32 u32Value);
+
+/*
+ * brief Reads a register. CNcomment: 读寄存器CNend
+ * attention \n
+ * support register range: \n
+ * {0xF8000000, 0xF8000FFF} \n
+ * {0xF8A20000, 0xF8A20FFF} \n
+ * {0xF8A21000, 0xF8A21FFF} \n
+ * {0xF8A22000, 0xF8A22FFF} \n
+ * {0xF8AB0000, 0xF8ABFFFF} \n
+ * CNcomment:\n
+ * 寄存器范围支持:
+ * {0xF8000000, 0xF8000FFF} \n
+ * {0xF8A20000, 0xF8A20FFF} \n
+ * {0xF8A21000, 0xF8A21FFF} \n
+ * {0xF8A22000, 0xF8A22FFF} \n
+ * {0xF8AB0000, 0xF8ABFFFF} \n
+ * CNend
+ * param[in] u32RegAddr Physical address of a register CNcomment: 寄存器物理地址 CNend
+ * param[out] pu32Value Pointer to the register value (output) CNcomment:  指针类型，输出寄存器的值 CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ * N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_SYS_ReadRegister(HI_U32 u32RegAddr, HI_U32 *pu32Value);
+
+/*
+ * brief Get timestamp. CNcomment: 获取时间戳 CNend
+ * attention \n
+ * N/A CNcomment: 无 CNend
+ * param[out] pu32TimeMs Pointer to the timestamp value (output) CNcomment: 输出时间戳 CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ * N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_SYS_GetTimeStampMs(HI_U32 *pu32TimeMs);
+
+/*
+ * brief Disable some video codec. CNcomment: 禁用某种视频解码算法 CNend
+ * attention \n
+ * N/A CNcomment: 无 CNend
+ * param[in] enVideoCodec  The type of video codec:   视频解码算法类型 CNend
+ * retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ * retval ::HI_FAILURE Calling this API fails. CNcomment: API系统调用失败 CNend
+ * see \n
+ * N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_SYS_DisableVideoCodec(HI_SYS_VIDEO_CODEC_E enVideoCodec);
+
+#endif /* endif __KERNEL__ */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HI_SYSTEM_H__ */
+
diff -uNr a/include/hi_type.h b/include/hi_type.h
--- a/include/hi_type.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_type.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,152 @@
+/*
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2005-2018. All rights reserved.
+ * Description: Common data types of the system.
+ *              CNcomment: 系统共用的数据类型定义 CNend
+ * Author: Hisilicon multimedia software group
+ * Create: 2005-4-23
+ */
+
+#ifndef __HI_TYPE_H__
+#define __HI_TYPE_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*--------------------------------------------------------------------------------------------------------------*
+ * Defintion of basic data types. The data types are applicable to both the application layer and kernel codes. *
+ * CNcomment: 基本数据类型定义，应用层和内核代码均使用  CNend                                                   *
+ *--------------------------------------------------------------------------------------------------------------*/
+/*************************** Structure Definition ****************************/
+/** \addtogroup      Common_TYPE */
+/** @{ */  /** <!-- [Common_TYPE] */
+
+typedef unsigned char           HI_UCHAR;
+typedef unsigned char           HI_U8;
+typedef unsigned short          HI_U16;
+typedef unsigned int            HI_U32;
+typedef unsigned long long      HI_U64;
+typedef unsigned long           HI_ULONG;
+
+typedef char*                   HI_PCHAR;
+typedef char                    HI_CHAR;
+typedef signed char             HI_S8;
+typedef short                   HI_S16;
+typedef int                     HI_S32;
+typedef long long               HI_S64;
+typedef long                    HI_SLONG;
+
+typedef float                   HI_FLOAT;
+typedef double                  HI_DOUBLE;
+
+/* typedef void                    HI_VOID; */
+#define HI_VOID         void
+
+typedef unsigned long           HI_SIZE_T;
+typedef unsigned long           HI_LENGTH_T;
+
+typedef HI_U32                  HI_HANDLE;
+
+typedef unsigned int            HI_PHYS_ADDR_T;
+
+#ifdef CONFIG_ARCH_LP64_MODE
+typedef unsigned long long      HI_VIRT_ADDR_T;
+#else
+typedef unsigned int            HI_VIRT_ADDR_T;
+#endif
+
+/** Constant Definition */
+/** CNcomment: 常量定义 */
+typedef enum
+{
+    HI_FALSE    = 0,
+    HI_TRUE     = 1,
+} HI_BOOL;
+
+#ifndef NULL
+#define NULL                0L
+#endif
+
+#define HI_NULL             0L
+#define HI_NULL_PTR         0L
+
+#define HI_SUCCESS          0
+#define HI_FAILURE          (-1)
+
+#define HI_INVALID_HANDLE   (0xffffffff)
+
+#define HI_INVALID_PTS      (0xffffffff)
+#define HI_INVALID_TIME     (0xffffffff)
+
+#define HI_OS_LINUX     0xabcd
+#define HI_OS_WIN32     0xcdef
+
+#ifdef _WIN32
+#define HI_OS_TYPE      HI_OS_WIN32
+#else
+#define __OS_LINUX__
+#define HI_OS_TYPE      HI_OS_LINUX
+#endif
+
+#ifdef HI_ADVCA_SUPPORT
+#define __INIT__
+#define __EXIT__
+#else
+#define __INIT__  __init
+#define __EXIT__  __exit
+#endif
+
+/**
+
+define of HI_HANDLE :
+bit31                                                           bit0
+  |<----   16bit --------->|<---   8bit    --->|<---  8bit   --->|
+  |--------------------------------------------------------------|
+  |      HI_MOD_ID_E       |  mod defined data |     chnID       |
+  |--------------------------------------------------------------|
+
+mod defined data: private data define by each module(for example: sub-mod id), usually, set to 0.
+*/
+
+#define HI_HANDLE_MAKEHANDLE(mod, privatedata, chnid)  (HI_HANDLE)( (((mod)& 0xffff) << 16) | ((((privatedata)& 0xff) << 8) ) | (((chnid) & 0xff)) )
+
+#define HI_HANDLE_GET_MODID(handle)     (((handle) >> 16) & 0xffff)
+#define HI_HANDLE_GET_PriDATA(handle)   (((handle) >> 8) & 0xff)
+#define HI_HANDLE_GET_CHNID(handle)     (((handle)) & 0xff)
+
+#define HI_UNUSED(x) ((x)=(x))
+
+typedef unsigned char           hi_uchar;
+typedef unsigned char           hi_u8;
+typedef unsigned short          hi_u16;
+typedef unsigned int            hi_u32;
+typedef unsigned long long      hi_u64;
+typedef unsigned long           hi_ulong;
+
+typedef char                    hi_char;
+typedef signed char             hi_s8;
+typedef short                   hi_s16;
+typedef int                     hi_s32;
+typedef long long               hi_s64;
+typedef long                    hi_slong;
+
+typedef float                   hi_float;
+typedef double                  hi_double;
+
+typedef void                    hi_void;
+
+typedef unsigned long           hi_size_t;
+typedef unsigned long           hi_length_t;
+
+typedef hi_u32                  hi_handle;
+
+typedef HI_BOOL                 hi_bool;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HI_TYPE_H__ */
+
diff -uNr a/include/hi_unf_advca.h b/include/hi_unf_advca.h
--- a/include/hi_unf_advca.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_advca.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,1923 @@
+/******************************************************************************
+
+Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_unf_advca.h
+Version       : Initial
+Author        : Hisilicon hisecurity team
+Created       : 2013-08-28
+Last Modified :
+Description   : Hisilicon CA API declaration
+Function List :
+History       :
+******************************************************************************/
+#ifndef __HI_UNF_ADVCA_H__
+#define __HI_UNF_ADVCA_H__
+
+#include "hi_type.h"
+#include "hi_unf_cipher.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      ADVCA */
+/** @{ */  /** <!-- [ADVCA] */
+
+/** advanced CA session serect key class*/
+typedef enum hiUNF_ADVCA_KEYLADDER_LEV_E
+{
+    HI_UNF_ADVCA_KEYLADDER_LEV1     = 0,    /**<session serect key level 1*/
+    HI_UNF_ADVCA_KEYLADDER_LEV2 ,           /**<session serect key level 2*/
+    HI_UNF_ADVCA_KEYLADDER_LEV3 ,           /**<session serect key level 3*/
+    HI_UNF_ADVCA_KEYLADDER_LEV4,            /**<session serect key level 4*/
+    HI_UNF_ADVCA_KEYLADDER_LEV5,            /**<session serect key level 5*/
+    HI_UNF_ADVCA_KEYLADDER_LEV6,            /**<session serect key level 6*/
+    HI_UNF_ADVCA_KEYLADDER_BUTT
+}HI_UNF_ADVCA_KEYLADDER_LEV_E;
+
+/** advanced CA session keyladder target */
+typedef enum hiUNF_ADVCA_CA_TARGET_E
+{
+    HI_UNF_ADVCA_CA_TARGET_DEMUX         = 0, /**<demux*/
+    HI_UNF_ADVCA_CA_TARGET_MULTICIPHER,       /**<multicipher*/
+    HI_UNF_ADVCA_CA_TARGET_BUTT
+}HI_UNF_ADVCA_CA_TARGET_E;
+
+/** advanced CA Encrypt arith*/
+typedef enum hiUNF_ADVCA_ALG_TYPE_E
+{
+    HI_UNF_ADVCA_ALG_TYPE_TDES      = 0,    /**<Encrypt arith :3 DES*/
+    HI_UNF_ADVCA_ALG_TYPE_AES,              /**<Encrypt arith : AES*/
+    HI_UNF_ADVCA_ALG_TYPE_SM4,              /**<Encrypt arith : SM4*/
+    HI_UNF_ADVCA_ALG_TYPE_BUTT
+}HI_UNF_ADVCA_ALG_TYPE_E;
+
+/** FLASH device types*/
+typedef enum hiUNF_ADVCA_FLASH_TYPE_E
+{
+    HI_UNF_ADVCA_FLASH_TYPE_SPI     = 0,    /**<SPI flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_NAND ,          /**<nand flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_NOR ,           /**<nor flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_EMMC ,          /**<eMMC*/
+    HI_UNF_ADVCA_FLASH_TYPE_SPI_NAND ,      /**<spi_nand flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_SD,             /**<FSD/TSD flash*/
+    HI_UNF_ADVCA_FLASH_TYPE_BUTT
+}HI_UNF_ADVCA_FLASH_TYPE_E;
+
+/** JTAG protect mode*/
+typedef enum hiUNF_ADVCA_JTAG_MODE_E
+{
+    HI_UNF_ADVCA_JTAG_MODE_OPEN     = 0,
+    HI_UNF_ADVCA_JTAG_MODE_PROTECT,
+    HI_UNF_ADVCA_JTAG_MODE_CLOSED,
+    HI_UNF_ADVCA_JTAG_MODE_BUTT
+}HI_UNF_ADVCA_JTAG_MODE_E;
+
+typedef struct HiUNF_ADVCA_LOCK_TZ_OTP_PARAM
+{
+    HI_U32 u32Addr;
+    HI_U32 u32Len;
+}HI_UNF_ADVCA_LOCK_TZ_OTP_PARAM_S;
+
+typedef enum hiUNF_ADVCA_SP_DSC_MODE_E
+{
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_CSA2              = 0x0000,   /**<Demux PAYLOAD CSA2 */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_CSA3              = 0x0010,   /**<Demux PAYLOAD CSA3 */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC_IDSA      = 0x0020,   /**<Demux PAYLOAD AES  IPTV Mode */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_ECB           = 0x0021,   /**<Demux PAYLOAD AES  ECB Mode */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC_CI        = 0x0022,   /**<Demux PAYLOAD AES  CIPLUS */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_DES_IPTV          = 0x0030,   /**<Demux PAYLOAD DES  CIPLUS */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_DES_CIPLUS        = 0x0032,   /**<Demux PAYLOAD DES  CIPLUS */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_DES_CBC           = 0x0033,   /**<Demux PAYLOAD DES  CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_NOVEL         = 0x0040,   /**<Demux PAYLOAD AES  NOVEL */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_SMS4_NOVEL        = 0x0041,   /**<Demux PAYLOAD SMS4 NOVEL */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_SMS4_IPTV         = 0x0050,   /**<Demux PAYLOAD SMS4 IPTV */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_SMS4_ECB          = 0x0051,   /**<Demux PAYLOAD SMS4 ECB */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_SMS4_CBC          = 0x0053,   /**<Demux PAYLOAD SMS4 CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC           = 0x0063,   /**<Demux PAYLOAD AES  CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_TDES_IPTV         = 0x0070,   /**<Demux PAYLOAD TDES IPTV */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_TDES_ECB          = 0x0071,   /**<Demux PAYLOAD TDES ECB */
+     HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_TDES_CBC          = 0x0073,   /**<Demux PAYLOAD TDES CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_CBC               = 0x4020,   /**<MultiCipher AES CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_ECB               = 0x4021,   /**<MultiCipher AES ECB */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_CBC_PIFF          = 0x4022,   /**<MultiCipher AES CBC PIFF */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_CBC_APPLE         = 0x4023,   /**<MultiCipher AES CBC APPLE */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_AES_CTR               = 0x4024,   /**<MultiCipher AES CTR */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_TDES_CBC              = 0x4040,   /**<MultiCipher AES CBC */
+     HI_UNF_ADVCA_SP_DSC_MODE_RAW_TDES_ECB              = 0x4041,   /**<MultiCipher AES ECB */
+     HI_UNF_ADVCA_SP_DSC_MODE_BUTT
+}HI_UNF_ADVCA_SP_DSC_MODE_E;
+
+/** Advca CA VendorID */
+typedef enum hiUNF_ADVCA_VENDORID_E
+{
+    HI_UNF_ADVCA_NULL       = 0x00,        /**<No-Advcance CA chipset, Marked with 0*/
+    HI_UNF_ADVCA_NAGRA      = 0x01,        /**<NAGRA  Chipse, Marked with R*/
+    HI_UNF_ADVCA_IRDETO     = 0x02,        /**<IRDETO Chipset, Marked with I*/
+    HI_UNF_ADVCA_CONAX      = 0x03,        /**<CONAX Chipset, Marked with C*/
+    HI_UNF_ADVCA_SUMA       = 0x05,        /**<SUMA Chipset, Marked with S*/
+    HI_UNF_ADVCA_NOVEL      = 0x06,        /**<NOVEL Chipset, Marked with Y*/
+    HI_UNF_ADVCA_VERIMATRIX = 0x07,        /**<VERIMATRIX Chipset, Marked with M*/
+    HI_UNF_ADVCA_CTI        = 0x08,        /**<CTI Chipset, Marked with T*/
+    HI_UNF_ADVCA_COMMONCA   = 0x0b,        /**<COMMONCA Chipset, Marked with H*/
+    HI_UNF_ADVCA_DCAS       = 0x0c,        /**<DCAS CA Chipset*/
+    HI_UNF_ADVCA_PANACCESS  = 0x0e,        /**<PANACCESS CA Chipset*/
+    HI_UNF_ADVCA_VENDORIDE_BUTT
+}HI_UNF_ADVCA_VENDORID_E;
+
+/** Advca CA lock type */
+typedef enum hiUNF_ADVCA_LOCK_TYPE
+{
+    HI_UNF_ADVCA_LOCK_RSA_KEY = 0,
+    HI_UNF_ADVCA_LOCK_TZ_OTP,
+    HI_UNF_ADVCA_LOCK_MISC_KL_DISABLE,
+    HI_UNF_ADVCA_LOCK_GG_KL_DISABLE,
+    HI_UNF_ADVCA_LOCK_TSKL_CSA3_DISABLE,
+    HI_UNF_ADVCA_LOCK_BUTT,
+}HI_UNF_ADVCA_LOCK_TYPE_E;
+
+
+/** DCAS KeyLadder use mode */
+typedef enum hiUNF_ADVCA_DCAS_KEYLADDER_LEV_E
+{
+    HI_UNF_ADVCA_DCAS_KEYLADDER_EK2         = 0,    /**<session EK2*/
+    HI_UNF_ADVCA_DCAS_KEYLADDER_EK1         = 1,    /**<session EK1*/
+    HI_UNF_ADVCA_DCAS_KEYLADDER_VENDORSYSID = 8,    /**<session Vendor_SysID*/
+    HI_UNF_ADVCA_DCAS_KEYLADDER_NONCE       = 9,    /**<session nonce*/
+    HI_UNF_ADVCA_DCAS_KEYLADDER_BUTT
+}HI_UNF_ADVCA_DCAS_KEYLADDER_LEV_E;
+
+/** MISC KeyLadder ROOTKEY Selection */
+typedef enum hiUNF_ADVCA_MISC_KEYLADDER_ROOTKEY_SEL_E
+{
+    HI_UNF_ADVCA_MISC_KEYLADDER_ROOTKEY_SEL_CSA2    = 0,     /**<MISC ROOTKEY CSA2*/
+    HI_UNF_ADVCA_MISC_KEYLADDER_ROOTKEY_SEL_CSA3,            /**<MISC ROOTKEY CSA3*/
+    HI_UNF_ADVCA_MISC_KEYLADDER_ROOTKEY_SEL_AES,             /**<MISC ROOTKEY AES*/
+    HI_UNF_ADVCA_MISC_KEYLADDER_ROOTKEY_SEL_SM4,             /**<MISC ROOTKEY SM4*/
+    HI_UNF_ADVCA_MISC_KEYLADDER_ROOTKEY_SEL_MAX
+}HI_UNF_ADVCA_MISC_KEYLADDER_ROOTKEY_SEL_E;
+
+/**Defines the attribute ID of the OTP fuse. Please be kindly noted that the OTP fuse is set permanently.
+After setting the OTP fuse, please power off and then power on the STB to make the OTP fuse function effective */
+/**CNcomment: 定义OTP位ID枚举类型. 请注意OTP位设置后不可改变.
+设置后，请断电重启使OTP位功能生效.*/
+typedef enum hiUNF_ADVCA_OTP_FUSE_E
+{
+    HI_UNF_ADVCA_OTP_NULL = 0,
+    HI_UNF_ADVCA_OTP_SECURE_BOOT_ACTIVATION, /**<Whether to enable the secure boot authentication, set the boot flash type together, HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S*//**<CNcomment: 安全启动是否开启，同时设置安全启动flash类型, HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_DECRYPTION_ACTIVATION, /**<Whether to enable the secure boot decryption, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: boot解密功能是否开启, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SELF_BOOT_DEACTIVATION, /**<Whether to disable the self boot, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 自举是否关闭, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_DDR_WAKEUP_DEACTIVATION, /**<Whether to disable the DDR wakeup, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 待机原地唤醒是否关闭 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA2_KL_LEVEL_SEL, /**<CSA2 keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: CSA2 keyladder级数 , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_R2R_KL_LEVEL_SEL, /**<R2R keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: R2R keyladder级数 , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SP_KL_LEVEL_SEL, /**<SP keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: SP keyladder级数 , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA3_KL_LEVEL_SEL, /**<CSA3 keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: CSA3 keyladder级数 , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_LP_DEACTIVATION, /**<Whether to disable the LP keyladder, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: LP keyladder是否关闭 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA2_CW_HARDONLY_ACTIVATION, /**<Whether to enable the CSA2 hard CW only, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA2硬CW是否使能 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SP_CW_HARDONLY_ACTIVATION, /**<Whether to enable the SP hard CW only, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: SP硬CW是否使能 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA3_CW_HARDONLY_ACTIVATION, /**<Whether to enable the CSA3 hard CW only, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA3硬CW是否使能 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA2_KL_DEACTIVATION, /**<Whether to disable the CSA2 keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA2 keyladder解密引擎是否关闭 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SP_KL_DEACTIVATION, /**<Whether to disable the SP keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: SP keyladder解密引擎是否关闭 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA3_KL_DEACTIVATION, /**<Whether to disable the CSA3 keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: CSA3 keyladder解密引擎是否关闭, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MISC_KL_DEACTIVATION, /**<Whether to disable the MISC keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: MISC keyladder解密引擎是否关闭 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_GOOGLE_KL_DEACTIVATION, /**<Whether to disable the google keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Google keyladder解密引擎是否关闭, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_DCAS_KL_DEACTIVATION, /**<Whether to disable the DCAS keyladder crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: DCAS keyladder解密引擎是否关闭 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_DDR_SCRAMBLE_ACTIVATION, /**<Whether to enable the DDR scrambling, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: DDR加扰是否开启 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_GLOBAL_LOCK_ACTIVATION, /**<Whether to lock the whole OTP area, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: OTP写保护是否开启 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_RUNTIME_CHECK_ACTIVATION, /**<Whether to enable the runtime check, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Runtime check是否开启 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_DDR_WAKEUP_CHECK_ACTIVATION, /**<Whether to enable the DDR check when wakeup from standby, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 待机原地唤醒时DDR校验是否开启 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_VERSION_ID_CHECK_ACTIVATION, /**<Whether to enable the version id check, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Version ID校验是否开启 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_MSID_CHECK_ACTIVATION, /**<Whether to enable the boot MSID check, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Boot MSID校验是否开启 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_JTAG_MODE, /**<JTAG protected mode, HI_UNF_ADVCA_JTAG_PRT_MODE_ATTR_S*//**<CNcomment: JTAG保护模式 , HI_UNF_ADVCA_JTAG_PRT_MODE_ATTR_S*/
+    HI_UNF_ADVCA_OTP_JTAG_READ_DEACTIVATION, /**<Whether to disable to read OTP via JTAG, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 通过JTAG读取OTP是否关闭 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA2_ROOTKEY, /**<CSA2 keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: CSA2 keyladder根密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_R2R_ROOTKEY, /**<R2R keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: R2R keyladder根密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SP_ROOTKEY, /**<SP keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: SP keyladder根密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CSA3_ROOTKEY, /**<CSA3 keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: CSA3 keyladder根密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MISC_ROOTKEY, /**<MISC keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: MISC keyladder根密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_OEM_ROOTKEY, /**<OEM keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: OEM keyladder根密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_ESCK_ROOTKEY, /**<ESCK keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: ESCK keyladder根密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_JTAG_KEY, /**<JTAG key, HI_UNF_ADVCA_JTAG_KEY_ATTR_S*//**<CNcomment: JTAG密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_CHIP_ID, /**<Chip ID, HI_UNF_ADVCA_CHIPID_ATTR_S*//**<CNcomment: Chip ID, HI_UNF_ADVCA_JTAG_KEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MARKET_SEGMENT_ID, /**<Market segment ID, HI_UNF_ADVCA_MARKET_ID_ATTR_S*//**<CNcomment: Market segment ID , HI_UNF_ADVCA_MARKET_ID_ATTR_S*/
+    HI_UNF_ADVCA_OTP_VERSION_ID, /**<Version ID, HI_UNF_ADVCA_VERSION_ID_ATTR_S*//**<CNcomment: Version ID, HI_UNF_ADVCA_VERSION_ID_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MISC_KL_LEVEL_SEL, /**<MISC keyladder stage, HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*//**<CNcomment: MISC keyladder级数 , HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S*/
+    HI_UNF_ADVCA_OTP_VMX_BL_FUSE, /**<Burn verimatrix bootloader fuse*//**<CNcomment: 烧写verimatrix特定的bootloader fuse位*/
+    HI_UNF_ADVCA_OTP_IRDETO_ITCSA3_ACTIVATION, /**<Whether to enbale the tweaked CSA3, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 私有CSA3算法是否开启。HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOTINFO_DEACTIVATION, /**<Whether to disable the bootinfo, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: Bootinfo是否关闭, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_ITCSA3_IMLB, /**<tweaked CSA3 IMLB, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 私有CSA3算法IMLB,HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_USB_DEACTIVATION, /**<Whether to disable the usb host, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 禁止USB设备, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SERIAL_DEACTIVATION, /**<Whether to disable serial port, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 禁止串口功能, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_ETHERNET_DEACTIVATION, /**<Whether to disable the ethernet, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 禁止网络, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SM4_CRYPTO_ENGINE_DEACTIVATION, /**<Whether to disable the SM4 crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: SM4解密引擎是否关闭 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_TDES_CRYPTO_ENGINE_DEACTIVATION, /**<Whether to disable the TDES crypto engine, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: TDES解密引擎是否关闭 , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+
+    HI_UNF_ADVCA_OTP_SECURE_BOOT_ACTIVATION_ONLY,   /**<Enable secure boot authentication only, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*//**<CNcomment: 安全启动使能， HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE,   /**<Boot flash type, HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S*//**<CNcomment: 安全启动flash类型， HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S*/
+
+    HI_UNF_ADVCA_OTP_RSA_KEY_LOCK_FLAG,   /**< Get the lock flag of RSA_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取RSA_Root_Key lock标记，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_STBSN_LOCK_FLAG,   /**< Get the lock flag of STBSN, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取STBSN lock标记，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_MSID_LOCK_FLAG,   /**< Get the lock flag of MSID, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取MSID lock标记，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_VERSIONID_LOCK_FLAG,   /**< Get the lock flag of VersionID, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取VersionID lock标记，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_OEM_ROOTKEY_LOCK_FLAG,   /**< Get the lock flag of OEM_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取OEM_Root_key lock标记，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_R2R_ROOTKEY_LOCK_FLAG,   /**< Get the lock flag of R2R_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取R2R_Root_key lock标记，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_JTAG_KEY_LOCK_FLAG,   /**< Get the lock flag of JTAG key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取JTAG key lock标记，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_TZ_AREA_LOCK_FLAG,   /**< Get the lock flag of OTP trust area, when otp_tz_area_enable is set, these lock flags can only be accessed by secure cpu , HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取OTP trust area lock标记，当otp_tz_area_enable被设置时，这些标记只能被安全CPU读取，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_ENCRYPTION_DEACTIVATION, /**< whether to diable boot loader key generation, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 生成bootloader key功能是否关闭，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_ROOTKEY,        /**<Boot keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: boot keyladder根密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SEC_STORE_ROOTKEY,   /**<Sec store keyladder root key, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: Sec store keyladder根密钥 , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_BOOT_ROOTKEY_LOCK_FLAG, /**< Get the lock flag of BOOT_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取BOOT_Root_Key lock标记，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SEC_STORE_ROOTKEY_LOCK_FLAG, /**< Get the lock flag of SEC_STORE_Root_key, HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/ /**<CNcomment: 获取SEC_STORE_Root_Key lock标记，HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S*/
+    HI_UNF_ADVCA_OTP_SOS_MSID, /**< Get the security OS MSID (market segment id)*/ /**<CNcomment: 获取安全系统的MSID */
+    HI_UNF_ADVCA_OTP_REE_MSID, /**< Get MSID(market segment id) of REE images, Currently, this fuse is used for SBL(second boot loader) of VMX ultra*/ /**<CNcomment: 获取REE镜像的MSID 目前，VMX ultra安全方案需要使用此OTP校验二级boot*/
+    HI_UNF_ADVCA_OTP_SMK_EXT_KEY, /**<Dcas keyladder rkd SMK_EXT_KEY, HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*//**<CNcomment: Dcas keyladder rkd 使用的扩展key , HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S*/
+    HI_UNF_ADVCA_OTP_FUSE_BUTT
+}HI_UNF_ADVCA_OTP_FUSE_E;
+
+/**Defines the attribute of secure boot check.*/
+/**CNcomment: 定义安全启动校验属性结构体*/
+typedef struct hiUNF_ADVCA_OTP_SECURE_BOOT_ATTR_S
+{
+    HI_BOOL bEnable;    /**<Is secure boot check enable or not*/
+    HI_UNF_ADVCA_FLASH_TYPE_E enFlashType; /**<Boot flash type*/
+}HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S;
+
+/**Defines the boot flash type.*/
+/**CNcomment: 定义安全启动flash类型结构体*/
+typedef struct hiUNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S
+{
+    HI_BOOL bBootSelCtrl;    /**<0--the boot flash type is defined by chipset pin, 1--the boot flash type is defined by OTP value*/
+    HI_UNF_ADVCA_FLASH_TYPE_E enFlashType; /**<Boot flash type, only valid when bBootSelCtrl is 1*/
+}HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S;
+
+/**Defines the default attribute of OTP fuse. If one OTP fuse can ONLY be "Enable" or "Disable",
+then we will use this attribute.*/
+/**CNcomment: 定义OTP位默认属性结构体. 适用于一个OTP位的功能
+只是开启或关闭的情况*/
+typedef struct hiUNF_ADVCA_OTP_DEFAULT_ATTR_S
+{
+    HI_BOOL bEnable;    /**<Is the feature enable or not*/
+}HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S;
+
+/**Defines the attribute of the keyladder level.*/
+/**CNcomment: 定义keyladder级数属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enKeyladderLevel;   /**<Keyladder level*/
+}HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S;
+
+/**Defines the attribute of the JTAG protected mode.*/
+/**CNcomment: 定义JTAG接口保护属性结构体.*/
+typedef struct hiUNF_ADVCA_JTAG_PRT_MODE_ATTR_S
+{
+    HI_UNF_ADVCA_JTAG_MODE_E enJtagMode;    /**<JTAG protection mode*/
+}HI_UNF_ADVCA_JTAG_PRT_MODE_ATTR_S;
+
+/**Defines the attribute of the keyladder root key.*/
+/**CNcomment: 定义keyladder 根密钥属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S
+{
+    HI_U8 u8RootKey[16];    /**<Root key of the keyladder*/
+}HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S;
+
+/**Defines the attribute of the JTAG key.*/
+/**CNcomment: 定义JTAG接口保护密钥属性结构体.*/
+typedef struct hiUNF_ADVCA_JTAG_KEY_ATTR_S
+{
+    HI_U8 u8JtagKey[8];     /**<JTAG protected key*/
+}HI_UNF_ADVCA_JTAG_KEY_ATTR_S;
+
+/**Defines the attribute of the chip id.*/
+/**CNcomment: 定义chip id属性结构体.*/
+typedef struct hiUNF_ADVCA_CHIPID_ATTR_S
+{
+    HI_U8 au8ChipId[8];       /**<ChipID of the chipset, it is unique every chipset*/
+}HI_UNF_ADVCA_CHIPID_ATTR_S;
+
+/**Defines the attribute of the market segment id.*/
+/**CNcomment: 定义market segment id属性结构体.*/
+typedef struct hiUNF_ADVCA_MARKET_ID_ATTR_S
+{
+    HI_U8 u8MSID[4];    /**<Market Segment ID*/
+}HI_UNF_ADVCA_MARKET_ID_ATTR_S;
+
+/**Defines the attribute of the version id.*/
+/**CNcomment: 定义version id属性结构体.*/
+typedef struct hiUNF_ADVCA_VERSION_ID_ATTR_S
+{
+    HI_U8 u8VersionId[4];   /**<Bootloader Version ID*/
+}HI_UNF_ADVCA_VERSION_ID_ATTR_S;
+
+typedef struct hiUNF_ADVCA_VMX_BL_FUSE_ATTR_S
+{
+    HI_U32 u32VMXBLFuse;
+}HI_UNF_ADVCA_VMX_BL_FUSE_S;
+
+/**Defines the attribute of the tweaked CSA3 IMLB.*/
+/**CNcomment: 定义tweaked CSA3 IMLB属性结构体.*/
+typedef struct hiUNF_ADVCA_ITCSA3_IMLB_ATTR_S
+{
+    HI_U8 au8ItCsa3IMLB[2];   /**<tweaked CSA3 IMLB*/
+}HI_UNF_ADVCA_ITCSA3_IMLB_ATTR_S;
+
+/**Defines the attribute of the OTP fuse.*/
+/**CNcomment: 定义OTP fuse属性结构体.*/
+typedef struct hiUNF_ADVCA_OTP_ATTR_S
+{
+    union
+    {
+        HI_UNF_ADVCA_OTP_DEFAULT_ATTR_S          stDefaultAttr; /**<Default attribute, if one fuse can ONLY be "Enable" or "Disable", then we can use this attribute*/
+        HI_UNF_ADVCA_OTP_SECURE_BOOT_ATTR_S      stEnableSecureBoot; /**<Secure boot attribute*/
+        HI_UNF_ADVCA_KEYLADDER_LEVEL_SEL_ATTR_S  stKeyladderLevSel;  /**<Keyladder level attribute*/
+        HI_UNF_ADVCA_JTAG_PRT_MODE_ATTR_S        stJtagPrtMode; /**<JTAG protected mode attribute*/
+        HI_UNF_ADVCA_KEYLADDER_ROOTKEY_ATTR_S    stKeyladderRootKey; /**<Keyladder rootkey attribute*/
+        HI_UNF_ADVCA_JTAG_KEY_ATTR_S             stJtagKey;   /**<JTAG key attribute*/
+        HI_UNF_ADVCA_CHIPID_ATTR_S               stChipId;     /**<Chip ID attribute*/
+        HI_UNF_ADVCA_MARKET_ID_ATTR_S            stMarketId;    /**<Market segment ID attribute*/
+        HI_UNF_ADVCA_VERSION_ID_ATTR_S           stVersionId;  /**<Bootloadder version ID attribute*/
+        HI_UNF_ADVCA_VMX_BL_FUSE_S               stVMXBLFuse;  /**<Vmx Bootloadder specific fuse attribute*/
+        HI_UNF_ADVCA_ITCSA3_IMLB_ATTR_S          stItCsa3IMLB; /**<tweaked CSA3 IMLB attribute*/
+        HI_UNF_ADVCA_OTP_BOOT_FLASH_TYPE_ATTR_S  stBootFlashType;   /**<Boot flash type attribute*/
+    }unOtpFuseAttr;
+}HI_UNF_ADVCA_OTP_ATTR_S;
+
+/**Defines the attribute of the keyladder type ID.*/
+/**CNcomment: 定义keyladder类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_TYPE_E
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA2 = 0,        /**<CSA2 keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_CSA3,            /**<CSA3 keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_R2R,             /**<R2R keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_SP,              /**<SP keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_MISC,            /**<MISC keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_LP,              /**<LP keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_TA,              /**<TA keyladder*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM,            /**<Google DRM key ladder*/
+    HI_UNF_ADVCA_KEYLADDER_SECSTORE,        /**<Secure Store key ladder*/
+    HI_UNF_ADVCA_KEYLADDER_SWPKDEC,         /**<SWPK DEC key ladder*/
+    HI_UNF_ADVCA_KEYLADDER_SWPKENC,         /**<SWPK ENC key ladder*/
+    HI_UNF_ADVCA_KEYLADDER_TYPE_BUTT
+}HI_UNF_ADVCA_KEYLADDER_TYPE_E;
+
+/**Defines the attribute of the CSA2 keyladder type ID.*/
+/**CNcomment: 定义CSA2 keyladder属性类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_CSA2_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_ALG = 0,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_E;
+
+/**Defines the attribute of the CSA3 keyladder type ID.*/
+/**CNcomment: 定义CSA3 keyladder属性类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_CSA3_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_ALG = 0,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_E;
+
+/**Defines the attribute of the R2R keyladder type ID.*/
+/**CNcomment: 定义R2R keyladder属性类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_R2R_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_ALG = 0,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_E;
+
+/**Defines the attribute of the LP keyladder type ID.*/
+/**CNcomment: 定义LP keyladder属性类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_LP_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_LP_ATTR_LOAD_LPK = 0,            /**<Load Link protection key*/
+    HI_UNF_ADVCA_KEYLADDER_LP_ATTR_DECRYPT_PROTECTED_DATA,   /**<Decrypt Link protected data*/
+    HI_UNF_ADVCA_KEYLADDER_LP_ATTR_ALG,                       /**<LP Keyladder algorithm*/
+    HI_UNF_ADVCA_KEYLADDER_LP_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_LP_ATTR_E;
+
+/**Defines the attribute of the LP keyladder.*/
+/**CNcomment: 定义LP keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_LP_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_LP_ATTR_E  enLPKlAttr; /**<LP keyladder attribute ID*/
+    HI_U8 u8Lpk[16];                                /**<Link protection key to be loaded*/
+    HI_U8 *pu8ProtectedData;                /**<Input link protected data to be decrypted*/
+    HI_U32 u32ProtectedDataLen;          /**<Input link protected data length*/
+    HI_U8 *pu8OutputProtectedData;   /**<Output link protected data after decryption*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<LP Keyladder algorithm, only support TDES/AES*/
+}HI_UNF_ADVCA_KEYLADDER_LP_ATTR_S;
+
+/**Defines the attribute of the SP keyladder type ID.*/
+/**CNcomment: 定义SP keyladder属性类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_SP_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_ENABLE = 0,       /**<Use SPE keyladder or not for specal CA system */
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_ALG ,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_DSC_MODE,   /**<Descrambling mode*/
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_SP_ATTR_E;
+
+/**Defines the attribute of the MISC keyladder type ID.*/
+/**CNcomment: 定义MISC keyladder属性类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_MISC_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_ENABLE = 0, /**<Use MISC keyladder or not. Before using the MISC keyladder, should set this attribute to HI_TRUE,
+                                                                     and after using, should set it to HI_FALSE.*/
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_ALG,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_DSC_MODE,   /**<Descrambling mode*/
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_ROOTKEY_SEL,       /**<MISC Keyladder Root key Selection*/
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_E;
+
+/**Defines the attribute of the TA keyladder type ID.*/
+/**CNcomment: 定义TA keyladder属性类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_TA_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_ENABLE = 0, /**<Use TA keyladder or not. Before using the TA keyladder, should set this attribute to HI_TRUE,
+                                                                     and after using, should set it to HI_FALSE.*/
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_ALG,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_LOAD_TRANDATA,   /**<Transformation data protection and loading*/
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_TA_ATTR_E;
+
+/**Defines the attribute of the SECSTORE keyladder type ID.*/
+/**CNcomment: 定义SECSTORE keyladder属性类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_SECSTORE_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_SECSTORE_ATTR_ENABLE = 0, /**<Use SECSTORE keyladder or not. Before using the TA keyladder, should set this attribute to HI_TRUE,
+                                                                     and after using, should set it to HI_FALSE.*/
+    HI_UNF_ADVCA_KEYLADDER_SECSTORE_ATTR_ALG,            /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_SECSTORE_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_SECSTORE_ATTR_E;
+
+/**Defines the attribute of the SWPK DEC keyladder type ID.*/
+/**CNcomment: 定义SWPK DEC keyladder属性类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_SWPKDEC_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_SWPKDEC_ATTR_ALG = 0,            /**<Keyladder algorithm, TDES/SM4*/
+    HI_UNF_ADVCA_KEYLADDER_SWPKDEC_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_SWPKDEC_ATTR_E;
+
+/**Defines the attribute of the SWPK ENC keyladder type ID.*/
+/**CNcomment: 定义SWPK ENC keyladder属性类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_SWPKENC_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_SWPKENC_ATTR_ALG = 0,            /**<Keyladder algorithm, TDES/SM4*/
+    HI_UNF_ADVCA_KEYLADDER_SWPKENC_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_SWPKENC_ATTR_E;
+
+/**Defines the attribute of the CSA2 keyladder.*/
+/**CNcomment: 定义CSA2 keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_CSA2_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_E  enCsa2KlAttr; /**<CSA2 keyladder attribute ID*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;   /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                   /**<Session key*/
+}HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_S;
+
+/**Defines the attribute of the CSA3 keyladder.*/
+/**CNcomment: 定义CSA3 keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_CSA3_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_E  enCsa3KlAttr; /**<CSA3 keyladder attribute ID*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;   /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                    /**<Session key*/
+}HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_S;
+
+/**Defines the attribute of the R2R keyladder.*/
+/**CNcomment: 定义R2R keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_R2R_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_E  enR2RKlAttr; /**<R2R keyladder attribute  ID*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;   /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                   /**<Session key*/
+}HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_S;
+
+/**Defines the attribute of the SP keyladder.*/
+/**CNcomment: 定义SP keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_SP_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_SP_ATTR_E  enSPKlAttr; /**<SP keyladder attribute ID*/
+    HI_BOOL bEnable;    /**<Use SP keyladder or not. Before using the SP keyladder*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;               /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_SP_DSC_MODE_E enDscMode;    /**<Descramblig mode*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;         /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                         /**<Session key*/
+}HI_UNF_ADVCA_KEYLADDER_SP_ATTR_S;
+
+
+
+/**Defines the attribute of the MISC keyladder.*/
+/**CNcomment: 定义MISC keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_MISC_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_E  enMiscKlAttr; /**<MISC keyladder attribute ID*/
+    HI_BOOL bEnable;    /**<Use MISC keyladder or not. Before using the MISC keyladder, should be set to HI_TRUE,
+                            and after using, should be set to HI_FALSE.*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;               /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_SP_DSC_MODE_E enDscMode;    /**<Descramblig mode*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;         /**<Keyladder stage of the session key to be set*/
+    HI_U8 u8SessionKey[16];                                         /**<Session key*/
+    HI_UNF_ADVCA_MISC_KEYLADDER_ROOTKEY_SEL_E enRootKeySel;    /**<MISC ROOT Key Selection*/
+}HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_S;
+
+/**Defines the attribute of the TA keyladder.*/
+/**CNcomment: 定义TA keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_TA_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_TA_ATTR_E  enTAKlAttr; /**<TA keyladder attribute ID*/
+    HI_BOOL bEnable;    /**<Use TA keyladder or not. Before using the TA keyladder, should be set to HI_TRUE,
+                            and after using, should be set to HI_FALSE.*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<Keyladder algorithm, TDES/AES*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;   /**<Keyladder stage of the session key to be set*/
+    HI_U8 au8SessionKey[16];                                   /**<Session key*/
+    HI_U8 *pu8TranData;                                         /**<Transformation data*/
+    HI_U32 u32TranDataLen;                                  /**<Transformation data length*/
+}HI_UNF_ADVCA_KEYLADDER_TA_ATTR_S;
+
+/**Defines the attribute of the Google DRM keyladder type ID.*/
+/**CNcomment: 定义Google DRM keyladder属性类型ID.*/
+typedef enum hiUNF_ADVCA_KEYLADDER_GDRM_ATTR_E
+{
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_ENABLE = 0,    /**<Use GDRM keyladder or not. Before using the GDRM keyladder, should set this attribute to HI_TRUE, and after using, should set it to HI_FALSE.*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_ENCRYPT,       /**<Encrypt clear device key*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_SESSION_KEY,   /**<Keyladder session key*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_GETFLAG,       /**<Get flag*/
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_BUTT
+}HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_E;
+
+/**Defines the attribute of Google DRM keyladder.*/
+/**CNcomment: 定义Google DRM keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_GDRM_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_E  enGDRMKlAttr;
+    HI_BOOL bEnable;                                  /**<Use GDRM keyladder or not. Before using the GDRM keyladder, should be set to HI_TRUE, and after using, should set it to HI_FALSE.*/
+    HI_UNF_ADVCA_KEYLADDER_LEV_E enStage;       /**<Keyladder stage of the session key to be set*/
+    HI_HANDLE hCipherHandle;                    /**<cipher handle, if enStage is HI_UNF_ADVCA_KEYLADDER_LEV3, hCipherHandle should be set*/
+    HI_U8 au8SessionKey[32];                     /**<if select HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_ENCRYPT it is clear device key, if select HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_SESSION_KEY, it is session key*/
+    HI_U8 au8Output[16];                          /**<if HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_ENCRYPT is set, it is encrypted device key, if HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_GETFLAG is set, it is flag*/
+}HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_S;
+
+/**Defines the attribute of the TA keyladder.*/
+/**CNcomment: 定义TA keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_SECSTORE_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_SECSTORE_ATTR_E  enSECSTREKlAttr; /**<Secure STORE keyladder attribute ID*/
+    HI_BOOL bEnable;    /**<Use Secure STORE keyladder or not. Before using the Secure STORE keyladder, should be set to HI_TRUE,
+                            and after using, should be set to HI_FALSE.*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;          /**<Keyladder algorithm, TDES/AES*/
+}HI_UNF_ADVCA_KEYLADDER_SECSTORE_ATTR_S;
+
+/**Defines the attribute of the SWPK DEC keyladder.*/
+/**CNcomment: 定义SWPK DEC keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_SWPKDEC_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_SWPKDEC_ATTR_E  enSWPKDECKlAttr;     /**<SWPK DEC keyladder attribute ID*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;                          /**<Keyladder algorithm, TDES/SM4*/
+}HI_UNF_ADVCA_KEYLADDER_SWPKDEC_ATTR_S;
+
+/**Defines the attribute of the SWPK ENC keyladder.*/
+/**CNcomment: 定义SWPK ENC keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_SWPKENC_ATTR_S
+{
+    HI_UNF_ADVCA_KEYLADDER_SWPKENC_ATTR_E  enSWPKENCKlAttr;     /**<SWPK ENC keyladder attribute ID*/
+    HI_UNF_ADVCA_ALG_TYPE_E enAlgType;                          /**<Keyladder algorithm, TDES/SM4*/
+}HI_UNF_ADVCA_KEYLADDER_SWPKENC_ATTR_S;
+
+/**Defines the attribute of all of the keyladder.*/
+/**CNcomment: 定义所有 keyladder属性结构体.*/
+typedef struct hiUNF_ADVCA_KEYLADDER_ATTR_S
+{
+    union
+    {
+        HI_UNF_ADVCA_KEYLADDER_CSA2_ATTR_S      stCSA2KlAttr;       /**<CSA2 keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_CSA3_ATTR_S      stCSA3KlAttr;       /**<CSA3 keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_R2R_ATTR_S       stR2RKlAttr;        /**<R2R keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_SP_ATTR_S        stSPKlAttr;         /**<SP keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_LP_ATTR_S        stLpKlAttr;         /**<LP keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_MISC_ATTR_S      stMiscKlAttr;       /**<MISC keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_TA_ATTR_S        stTAKlAttr;         /**<TA keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_GDRM_ATTR_S      stGDRMAttr;         /**<Google DRM keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_SECSTORE_ATTR_S  stSECSTOREAttr;     /**<Secure STORE keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_SWPKDEC_ATTR_S   stSWPKDECKlAttr;    /**<SWPKDEC keyladder attribute*/
+        HI_UNF_ADVCA_KEYLADDER_SWPKENC_ATTR_S   stSWPKENCKlAttr;    /**<SWPKENE keyladder attribute*/
+    }unKlAttr;
+}HI_UNF_ADVCA_KEYLADDER_ATTR_S;
+
+
+/**Defines the attribute of the CA vendor type ID.*/
+/**CNcomment: 定义CA vendor属性类型ID.*/
+typedef enum hiUNF_ADVCA_CA_VENDOR_OPT_E
+{
+    HI_UNF_ADVCA_CA_VENDOR_OPT_IRDETO_CHIP_CONF_CMAC = 0, /**<To generate a secure message authentication code (MAC) tag for the OTP configuration data*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_IRDETO_CBCMAC_CALC,  /**<To calculate the high level code CBC-MAC.*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_IRDETO_CBCMAC_AUTH,  /**<To authenticate the high level code CBC-MAC.*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_IRDETO_ACTIVATION_CODE, /**<To set the activation code for tweaked CSA3.*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_VMX_GET_RNG, /**<To get the RNG number, ONLY used for verimatrix currently.*/
+    HI_UNF_ADVCA_CA_VENDOR_OPT_BUTT
+}HI_UNF_ADVCA_CA_VENDOR_OPT_E;
+
+/**Defines the attribute of chip configuration CMAC.*/
+/**CNcomment: 定义产生OTP数据CMAC属性结构体.*/
+typedef struct hiUNF_ADVCA_IRDETO_CHIP_CONF_CMAC_ATTR_S
+{
+    HI_U8 au8ChipConfBitm[16]; /**<128bit Chip configuration bit map*/
+    HI_U8 au8ChipConfCmac[16];   /**<128bit Chip configuration CMAC*/
+}HI_UNF_ADVCA_IRDETO_CHIP_CONF_CMAC_ATTR_S;
+
+/**Defines the attribute of the tweak CSA3, Activation Code.*/
+/**CNcomment: 定义CSA3算法需要设置的ACTIVATION CODE.*/
+typedef struct hiUNF_ADVCA_IRDETO_ACTIVATION_CODE_ATTR_S
+{
+    HI_U8 au8CSA3ActCode[16];   /**<128bit tweak CSA3 Activation Code*/
+}HI_UNF_ADVCA_IRDETO_ACTIVATION_CODE_ATTR_S;
+
+/**Defines the attribute of the high level code CBC-MAC authentication.*/
+/**CNcomment: 定义上层应用CBC-MAC校验属性结构体.*/
+typedef struct hiUNF_ADVCA_IRDETO_CBCMAC_ATTR_S
+{
+    HI_U8 *pu8InputData;
+    HI_U32 u32InputDataLen;
+    HI_U8 au8OutputCBCMAC[16];
+    HI_U8 au8RefCBCMAC[16];  /**<Reference CBC-MAC*/
+    HI_U32 u32AppLen; /**<High level code length*/
+}HI_UNF_ADVCA_IRDETO_CBCMAC_ATTR_S;
+
+typedef struct hiUNF_ADVCA_VMX_GetRNG_S
+{
+    HI_U32 u32RNG;
+}HI_UNF_ADVCA_VMX_GetRNG_S;
+
+/**Defines the attribute of the CA vendor private function.*/
+/**CNcomment: 定义CA厂家私有功能属性结构体.*/
+typedef struct hiADVCA_CA_VENDOR_OPT_S
+{
+    HI_UNF_ADVCA_CA_VENDOR_OPT_E enCaVendorOpt;
+    union
+    {
+        HI_UNF_ADVCA_IRDETO_CHIP_CONF_CMAC_ATTR_S     stIrdetoChipConfCmac;
+        HI_UNF_ADVCA_IRDETO_ACTIVATION_CODE_ATTR_S    stIrdetoCsa3ActCode;
+        HI_UNF_ADVCA_IRDETO_CBCMAC_ATTR_S             stIrdetoCbcMac;
+        HI_UNF_ADVCA_VMX_GetRNG_S                     stVMXRng;
+    }unCaVendorOpt;
+}HI_UNF_ADVCA_CA_VENDOR_OPT_S;
+
+/************************************************/
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      ADVCA */
+/** @{ */  /** <!-- [ADVCA] */
+
+/**
+\brief Initializes the advanced CA module CNcomment:初始化advance CA模块 CNend
+\attention \n
+Call this application programming interface (API) before using the advanced CA module.
+The code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:在进行advance CA相关操作前应该首先调用本接口\n
+重复调用本接口，会返回成功 CNend
+\param N/A CNcomment:无 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_OPEN_ERR The CA device fails to start CNcomment:HI_ERR_CA_OPEN_ERR 打开CA设备失败 CNend
+\see \n
+::HI_UNF_ADVCA_DeInit
+*/
+HI_S32 HI_UNF_ADVCA_Init(HI_VOID);
+
+/**
+\brief Deinitializes the advanced CA module CNcomment:去初始化advance CA模块 CNend
+\attention \n
+None CNcomment:无 CNend
+\param N/A CNcomment:无 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_DeInit(HI_VOID);
+
+/**
+\brief Set the ChipId CNcomment:设置ChipId  CNend
+\attention \n
+This application programming interface (API) is allowed to invoked only once.
+It's not allowed to call this API repeatedly.
+CHIP_ID should have been setting before chipset is delivered to STB Manufacture.
+Please contact Hisilicon before Customer try to use this interface.
+CNcomment:\n  CNend
+CNcomment:该接口只允许调用一次，不能重复调用，请谨慎使用\n
+CHIP_ID可能已按照CA公司要求设置，该接口如果客户需要使用该接口需要先通知海思\n  CNend
+\param[in] Id chip id CNcomment:Id chip id\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\see \n
+::HI_UNF_ADVCA_SetChipId
+*/
+HI_S32 HI_UNF_ADVCA_SetChipId(HI_U32 Id);
+
+/**
+\brief Obtains the chip ID CNcomment:获取芯片ID  CNend
+\attention \n
+The chip ID is read-only.
+CNcomment:芯片ID只能读不能写 CNend
+\param[out] pu32ChipId Chip ID CNcomment:pu32ChipId   芯片ID  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetChipId(HI_U32 *pu32ChipId);
+
+
+/**
+\brief Obtains the market ID CNcomment:获取Market ID  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pu8MarketId market ID CNcomment:pu8MarketId   针对市场的标识序号 CNend
+\param[in] u32MarketIdLen market ID length, must be equal to 4 CNcomment:u32MarketIdLen   针对市场的标识序号长度，必须等于4 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_SetMarketId
+*/
+HI_S32 HI_UNF_ADVCA_GetMarketId(HI_U8 *pu8MarketId, HI_U32 u32MarketIdLen);
+
+/**
+\brief Sets the Market ID CNcomment:设置Market ID  CNend
+\attention \n
+The market ID of the set-top box (STB) is set before delivery. The market ID can be set once only and takes effects after the STB restarts.
+CNcomment:在机顶盒出厂时设置，仅支持设置一次 设置后重启生效 CNend
+\param[in] pu8MarketId market ID CNcomment:pu8MarketId   针对市场的标识序号 CNend
+\param[in] u32MarketIdLen market ID length, must be equal to 4 CNcomment:u32MarketIdLen   针对市场的标识序号长度，必须等于4 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN  重复设置 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetMarketId(HI_U8 *pu8MarketId, HI_U32 u32MarketIdLen);
+
+/**
+\brief Obtains the serial number of the STB CNcomment:获取机顶盒序列号 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pu8StbSn Serial number of the STB CNcomment:pu8StbSn   机顶盒序列号 CNend
+\param[in] u32StbSnLen Serial number length, must be equal to 4 CNcomment:u32StbSnLen   机顶盒序列号，必须等于4 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_SetStbSn
+*/
+HI_S32 HI_UNF_ADVCA_GetStbSn(HI_U8 *pu8StbSn, HI_U32 u32StbSnLen);
+
+/**
+\brief Sets the serial number of the STB CNcomment:设置机顶盒序列号 CNend
+\attention \n
+The serial number of the STB is set before delivery. The market ID can be set once only and takes effects after the STB restarts.
+CNcomment:在机顶盒出厂时设置，仅支持设置一次 设置后重启生效 CNend
+\param[in] pu8StbSn serial number of the STB CNcomment:pu8StbSn   机顶盒序列号 CNend
+\param[in] u32StbSnLen Serial number length, must be equal to 4 CNcomment:u32StbSnLen   机顶盒序列号，必须等于4 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN  重复设置 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetStbSn(HI_U8 *pu8StbSn, HI_U32 u32StbSnLen);
+
+/**
+\brief Set the R2R RootKey and lock it. CNcomment:设置R2R RootKey并且锁住。  CNend
+\attention \n
+This application programming interface (API) is allowed to invoked only once.
+It's not allowed to call this API repeatedly.
+R2R RootKey should have been setting before chipset is delivered to STB Manufacture.
+Please contact Hisilicon before Customer try to use this interface.
+CNcomment:该接口只允许调用一次，不能重复调用,请谨慎使用该接口\n
+R2RRootKey可能已按照CA公司要求设置，该接口如果客户需要使用该接口需要先通知海思\n  CNend
+\param[in] pkey R2R Root Key CNcomment:pkey  R2R根密钥\n  CNend
+\param[in] u32KeyLen R2R Root key length, must be equal to 16. CNcomment:u32KeyLen R2R根密钥长度，必须为16 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+*/
+HI_S32 HI_UNF_ADVCA_SetR2RRootKey(HI_U8* pkey, HI_U32 u32KeyLen);
+
+/**
+\brief Obtains the security startup enable status CNcomment:获取安全启动使能状态 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pbEnable: Security startup enable. CNcomment:pbEnable   安全启动是否使能， CNend
+HI_TRUE enabled CNcomment:HI_TRUE 使能，  CNend
+HI_FALSE disabled CNcomment:HI_FALSE 不使能 CNend
+\param[out] penFlashType the startup flash type, only valid when SCS is enable
+CNcomment:penFlashType 仅在安全启动使能时有效，表示安全启动的Flash类型 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetSecBootStat(HI_BOOL *pbEnable,HI_UNF_ADVCA_FLASH_TYPE_E *penFlashType);
+
+/**
+\brief Obtains the mode of the JTAG interface CNcomment:获取JTAG调试口模式 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] penJtagMode Mode of the JTAG interface CNcomment:penJtagMode   JTAG调试口模式 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetJtagMode(HI_UNF_ADVCA_JTAG_MODE_E *penJtagMode);
+
+/**
+\brief Sets the mode of the JTAG interface CNcomment:设置JTAG调试口模式   CNend
+\attention \n
+If the mode of the JTAG interface is set to closed or password-protected, it cannot be opened.
+If the JTAG interface is open, it can be closed or password-protected.
+If the JATG interface is password-protected, it can be closed.
+After being closed, the JATG interface cannot be set to open or password-protected mode.
+CNcomment:不支持设置为打开状态。\n
+打开的时候可以关闭或设置为密钥保护状态。\n
+处于密钥保护状态时可以关闭。\n
+关闭之后不能打开和设置为密钥保护状态 CNend
+\param[in] enJtagMode Mode of the JTAG interface CNcomment:enJtagMode   JTAG调试口模式 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN 重复设置 CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetJtagMode(HI_UNF_ADVCA_JTAG_MODE_E enJtagMode);
+
+
+/**
+\brief Obtains the R2R key ladder stage CNcomment:获取R2R key ladder级数 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] penStage Key ladder stage CNcomment:penStage   key ladder级数 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_GetR2RKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E *penStage);
+
+/**
+\brief Sets the R2R key ladder stage CNcomment:设置R2R key ladder的级数    CNend
+\attention \n
+The key ladder stage can be set only once before delivery and cannot be changed. Please use default value.
+CNcomment:机顶盒出厂时设置 仅能设置一次 不可更改,不建议使用该接口改变stage  CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3
+CNcomment:enStage   key ladder级数\n 取值只能为HI_UNF_ADVCA_KEYLADDER_LEV2 或者 HI_UNF_ADVCA_KEYLADDER_LEV3  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetR2RKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage);
+
+/**
+\brief Obtains the digital video broadcasting (DVB) key ladder stage CNcomment:获取DVB key ladder的级数 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] penStage Key ladder stage CNcomment:penStage   key ladder级数 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_GetDVBKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E *penStage);
+
+/**
+\brief Sets the DVB key ladder stage CNcomment:设置DVB key ladder的级数    CNend
+\attention \n
+The key ladder stage can be set only once before delivery and cannot be changed. Please use default value.
+CNcomment:机顶盒出厂时设置 仅能设置一次 不可更改,不建议使用该接口改变stage  CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage  key ladder级数\n 取值只能为HI_UNF_ADVCA_KEYLADDER_lev2 或者 HI_UNF_ADVCA_KEYLADDER_lev3  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetDVBKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage);
+
+/**
+\brief Obtains the CSA3 key ladder stage CNcomment:获取CSA3 key ladder的级数 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] penStage Key ladder stage CNcomment:penStage   key ladder级数 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_GetCSA3KeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E *penStage);
+
+/**
+\brief Sets the CSA3 key ladder stage CNcomment:设置CSA3 key ladder的级数    CNend
+\attention \n
+The key ladder stage can be set only once before delivery and cannot be changed. Please use default value.
+CNcomment:机顶盒出厂时设置 仅能设置一次 不可更改,不建议使用该接口改变stage  CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage  key ladder级数\n 取值只能为HI_UNF_ADVCA_KEYLADDER_lev2 或者 HI_UNF_ADVCA_KEYLADDER_lev3  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetCSA3KeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage);
+
+/**
+\brief Sets session keys for an R2R key ladder CNcomment:为R2R key ladder配置会话密钥    CNend
+\attention \n
+
+The stage of the session key cannot be greater than the configured stage of the key ladder. The last stage of the session key is configured by calling the API of the CIPHER module rather than this API.
+That is, only session key 1 and session key 2 need to be configured for a 3-stage key ladder.
+Only session key 1 needs to be configured for a 2-stage key ladder.
+You need to set the key ladder stage by calling HI_UNF_ADVCA_SetR2RKeyLadderStage first.
+Session keys can be set during initialization or changed at any time.
+CNcomment:注意配置的级数不能超过设置的级数值，最后一级由CIPHER模块内部配置，不用通过此接口配置。\n
+也就是说，对于3级key ladder，只用配置会话密钥1和会话密钥2。\n
+对于2级的key ladder，只用配置会话密钥1。\n
+请先调用HI_UNF_ADVCA_SetR2RKeyLadderStage设置key ladder级数。\n
+会话密钥可以初始时设置一次，也可以随时修改。 CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage    密钥级数，[HI_UNF_ADVCA_KEYLADDER_LEV1 ~ HI_UNF_ADVCA_KEYLADDER_LEV2]  CNend
+\param[in] pu8Key Protection key pointer, 128 bits (16 bytes) in total CNcomment:pu8Key     保护密钥指针，共128bit(16byte)  CNend
+\param[in] u32KeyLen Protection key length, must be equal to 16. CNcomment:u32KeyLen 保护密钥长度，必须为16 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT CA等待加解密超时 CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The R2R decryption fails CNcomment:HI_ERR_CA_R2R_DECRYPT  R2R解密失败 CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetR2RSessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage, HI_U8* pu8Key, HI_U32 u32KeyLen);
+
+/**
+\brief Sets session keys for a DVB key ladder CNcomment:为DVB key ladder配置会话密钥    CNend
+\attention \n
+The stage of the session key cannot be greater than the configured stage of the key ladder. The last stage of the session key is configured by calling the API of the CIPHER module rather than this API.
+That is, only session key 1 and session key 2 need to be configured for a 3-stage key ladder.
+Only session key 1 needs to be configured for a 2-stage key ladder.
+You need to set the key ladder stage by calling HI_UNF_ADVCA_SetDVBKeyLadderStage first.
+ Session keys can be set during initialization or changed at any time.
+CNcomment:注意配置的级数不能超过设置的级数值，最后一级由Descrambler模块内部配置，不用通过此接口配置。\n
+也就是说，对于3级key ladder，只用配置会话密钥1和会话密钥2。\n
+对于2级的key ladder，只用配置会话密钥1。\n
+请先调用HI_UNF_ADVCA_SetDVBKeyLadderStage设置key ladder级数。\n
+会话密钥可以初始时设置一次，也可以随时修改。 CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage    密钥级数，[HI_UNF_ADVCA_KEYLADDER_LEV1 ~ HI_UNF_ADVCA_KEYLADDER_LEV2]  CNend
+\param[in] pu8Key Protection key pointer, 128 bits (16 bytes) in total CNcomment:pu8Key     保护密钥指针，共128bit(16byte)  CNend
+\param[in] u32KeyLen Protection key length, must be equal to 16. CNcomment:u32KeyLen 保护密钥长度，必须为16 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT CA等待加解密超时 CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The CW decryption fails CNcomment:HI_ERR_CA_CW_DECRYPT   CW解密失败 CNend
+
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetDVBSessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage, HI_U8 *pu8Key, HI_U32 u32KeyLen);
+
+/**
+\brief Sets session keys for a CSA3 key ladder CNcomment:为CSA3 key ladder配置会话密钥    CNend
+\attention \n
+The stage of the session key cannot be greater than the configured stage of the key ladder. The last stage of the session key is configured by calling the API of the CIPHER module rather than this API.
+That is, only session key 1 and session key 2 need to be configured for a 3-stage key ladder.
+Only session key 1 needs to be configured for a 2-stage key ladder.
+You need to set the key ladder stage by calling HI_UNF_ADVCA_SetDVBKeyLadderStage first.
+ Session keys can be set during initialization or changed at any time.
+CNcomment:注意配置的级数不能超过设置的级数值，最后一级由Descrambler模块内部配置，不用通过此接口配置。\n
+也就是说，对于3级key ladder，只用配置会话密钥1和会话密钥2。\n
+对于2级的key ladder，只用配置会话密钥1。\n
+请先调用HI_UNF_ADVCA_SetDVBKeyLadderStage设置key ladder级数。\n
+会话密钥可以初始时设置一次，也可以随时修改。 CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage    密钥级数，[HI_UNF_ADVCA_KEYLADDER_LEV1 ~ HI_UNF_ADVCA_KEYLADDER_LEV2]  CNend
+\param[in] pu8Key Protection key pointer, 128 bits (16 bytes) in total CNcomment:pu8Key     保护密钥指针，共128bit(16byte)  CNend
+\param[in] u32KeyLen Protection key length, must be equal to 16. CNcomment:u32KeyLen 保护密钥长度，必须为16 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT CA等待加解密超时 CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The CW decryption fails CNcomment:HI_ERR_CA_CW_DECRYPT   CW解密失败 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetCSA3SessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage, HI_U8 *pu8Key, HI_U32 u32KeyLen);
+
+/**
+\brief Set widevine keyladder session key CNcomment:设置widevine keyladder的各级输入密钥 CNend
+\param[in]  enLevel keyladder level for input CNcomment:enLevel 输入密钥的级数 CNend
+\param[in]  hCipherHandle cipher handle input when level 3 CNcomment:hCipherHandle 当输入第三级数据时，需要传入预先创建好的Cipher的句柄 CNend
+\param[in]  pu8Input input data for keyladder CNcomment:pu8Input  keyladder的输入数据 CNend
+\param[in]  u32InputLen input data length CNcomment:u32InputLen 数据的长度 CNend
+\param[out] pu32GdrmFlag the flag value when level 3 CNcomment:pu32GdrmFlag  当输入第三级别密钥时，输出的GDRM标志  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS               成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT       CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   输入参数非法 CNend
+\retval ::HI_ERR_CA_NOT_SUPPORT The function is not supported CNcomment:HI_ERR_CA_NOT_SUPPORT    功能不支持 CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT   CA等待加解密超时 CNend
+\return ::HI_ERR_CA_SWPK_ENCRYPT SWPK encryption fails CNcomment:HI_ERR_CA_SWPK_ENCRYPT   SWPK加密失败 CNend
+\see
+\li ::
+*/
+HI_S32 HI_UNF_ADVCA_SetGDRMSessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enLevel,
+                                    HI_HANDLE hCipherHandle,
+                                    HI_U8 *pu8Input,
+                                    HI_U32 u32InputLen,
+                                    HI_U32 *pu32GdrmFlag);
+
+
+/**
+\brief Encrypts software protect keys (SWPKs) CNcomment:加密软件保护密钥 CNend
+\attention
+Before the delivery of the STB, you need to read the SWPKs in plain text format from the flash memory, encrypt SWPKs by calling this API, and store the encrypted SWPKs in the flash memory for security startup.
+CNcomment:机顶盒出厂时 从Flash上读取明文的SWPK(Software Protect Key),调用该接口加密,将加密的SWPK存储在Flash中，用于安全启动 CNend
+The fist 8 bytes of the SWPK can't be equal to the last 8 bytes.
+CNcomment:SWPK的前8个字节与后8个字节不能相等 CNend
+This API is only for special CA, please contact Hislicon before usage.
+CNcomment:注意:此接口为特定CA专用，如需使用，请联系海思 CNend
+\param[in]  pPlainSwpk SWPKs in plain text format CNcomment:pPlainSwpk    明文SWPK  CNend
+\param[in] u32PlainSwpkLen SWPK length, must be equal to 16. CNcomment:u32PlainSwpkLen 明文SWPK长度，必须为16 CNend
+\param[out] pEncryptedSwpk Encrypted SWPKs CNcomment:pEncryptedSwpk  加密后的SWPK  CNend
+\param[in] u32PlainSwpkLen Encrypted SWPK length, must be equal to 16. CNcomment:u32PlainSwpkLen 加密的SWPK长度，必须为16 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS               成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT       CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA   输入参数非法 CNend
+\retval ::HI_ERR_CA_NOT_SUPPORT The function is not supported CNcomment:HI_ERR_CA_NOT_SUPPORT    功能不支持 CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT   CA等待加解密超时 CNend
+\return ::HI_ERR_CA_SWPK_ENCRYPT SWPK encryption fails CNcomment:HI_ERR_CA_SWPK_ENCRYPT   SWPK加密失败 CNend
+
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_EncryptSWPK(HI_U8 *pPlainSwpk, HI_U32 u32PlainSwpkLen, HI_U8 *pEncryptedSwpk, HI_U32 u32EncryptedSwpkLen);
+
+/**
+\brief Sets the algorithm of the DVB key ladder CNcomment:设置DVB key ladder的算法    CNend
+\attention \n
+You must set an algorithm before using a key ladder in a session. The default algorithm is TDES.
+It is recommended that you retain the algorithm in a session.
+CNcomment:每次会话过程中使用key ladder之前，须设置具体算法, 系统初始默认值 HI_UNF_ADVCA_ALG_TYPE_TDES；\n
+本次会话过程中，建议保持算法的稳定不变。 CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder算法\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetDVBAlg(HI_UNF_ADVCA_ALG_TYPE_E enType);
+
+/**
+\brief Sets the algorithm of the CSA2 key ladder CNcomment:设置CSA3 key ladder的算法    CNend
+\attention \n
+You must set an algorithm before using a key ladder in a session. The default algorithm is TDES.
+It is recommended that you retain the algorithm in a session.
+CNcomment:每次会话过程中使用key ladder之前，须设置具体算法, 系统初始默认值 HI_UNF_ADVCA_ALG_TYPE_TDES；\n
+本次会话过程中，建议保持算法的稳定不变。 CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder算法\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetCSA3Alg(HI_UNF_ADVCA_ALG_TYPE_E enType);
+
+/**
+\brief Sets the algorithm of the R2R key ladder CNcomment:设置R2R key ladder的算法    CNend
+\attention \n
+You must set an algorithm before using a key ladder in a session. The default algorithm is TDES.
+It is recommended that you retain the algorithm in a session.
+CNcomment:每次会话过程中使用key ladder之前，须设置具体算法, 系统初始默认值 HI_UNF_ADVCA_ALG_TYPE_TDES；\n
+本次会话过程中，建议保持算法的稳定不变。 CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder算法\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetR2RAlg(HI_UNF_ADVCA_ALG_TYPE_E enType);
+
+/**
+\brief Obtains the algorithm of the DVB key ladder CNcomment: 获取 DVB key ladder的算法    CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] pEnType Key ladder algorithm CNcomment:pEnType  key ladder算法\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetDVBAlg(HI_UNF_ADVCA_ALG_TYPE_E *pEnType);
+
+/**
+\brief Obtains the algorithm of the R2R key ladder CNcomment:获取 R2R key ladder的算法    CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder算法\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetR2RAlg(HI_UNF_ADVCA_ALG_TYPE_E *pEnType);
+
+/**
+  \brief set RSA key CNcomment:设置签名校验的RSA公钥 CNeng
+  \attention \n
+  If the mass-produced chipset have been set RSA Key by CA, there's no need to use this API to set RSA Key again.
+  This API can been called only once, please be careful, after setting RSA key, you should lock it by call API
+  HI_UNF_ADVCA_ConfigLockFlag.The length of RSA key must be 512 Bytes.
+  CNcomment:如果量产芯片已经按照CA公司设置RSAKey,则无需再次使用该接口设置RSAKey\n
+     该接口只允许调用一次，不能重复调用,请谨慎使用该接口,并且设置后RSAKey后需要使用接口\n
+     HI_UNF_ADVCA_ConfigLockFlag进行锁定。 RSA key的长度必须为512 Bytes  CNend
+  \param[in] pkey RSA key CNcomment:pkey  RSA公钥\n  CNend
+  \param[in] u32KeyLen RSA key length, must be equal to 512. CNcomment:u32KeyLen RSA密钥长度，必须为512 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+  \see  \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetRSAKey(HI_U8 *pkey, HI_U32 u32KeyLen);
+
+/**
+  \brief set RSA key CNcomment:获取签名校验的RSA公钥 CNend
+  \attention \n
+     RSA key can be read out when only the RSAKey is not locked,The length of RSA key is 512 Bytes.
+     RSA key should have been setting and lock before chipset is delivered to STB Manufacture.
+     Please contact Hisilicon before Customer try to use this interface.
+  CNcomment:该接口仅在RSAkey没有被锁定的情况下，读取出来, RSA key的长度为512 Bytes\n
+     RSA key可能已按照CA公司要求设置并锁定，该接口如果客户需要使用该接口需要先通知海思\n  CNend
+  \param[out] pkey RSA key CNcomment:pkey  RSA密公钥\n  CNend
+  \param[in] u32KeyLen RSA key length, must be equal to 512. CNcomment:u32KeyLen RSA密钥长度，必须为512 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetRSAKey(HI_U8 *pkey, HI_U32 u32KeyLen);
+
+/**
+  \brief set RSA key CNcomment:获取签名校验的RSA密码 CNend
+  \attention \n
+    This API is used to lock RSA KEY/Trustzone OTP\misc keyladder etc.Please contact Hisilicon before Customer try to use this interface.
+  CNcomment:该接口用于锁定RSAkey\Trustzone OTP\misc keyladder等，该接口如果客户需要使用该接口需要先通知海思\n  CNend
+  \param[enType] enType the type you want to lock.  CNcomment:enType  需要锁定的类型\n  CNend
+  \param[pu8ParamIn] pu8ParamIn reserved, default is null. CNcomment:pu8ParamIn  预留，默认为null\n  CNend
+  \param[u32ParamLen] u32ParamLen reserved, default is 0. CNcomment:u32ParamLen  预留，默认为0\n  CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_ConfigLockFlag(HI_UNF_ADVCA_LOCK_TYPE_E enType, HI_U8 *pu8ParamIn, HI_U32 u32ParamLen);
+
+
+/**
+  \brief This function is used to check if the MarketID is already set
+  \attention \n
+  None
+  \param[in] pbIsMarketIdSet: the pointer point to the buffer to store the return value
+  \param[out] pbIsMarketIdSet: save the return value
+  \retval ::HI_SUCCESS Success
+  \retval ::HI_FAILURE This API fails to be called
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_IsMarketIdSet(HI_BOOL *pbIsMarketIdSet);
+
+/**
+  \brief This function is used to get the vendor type of the chipset
+  \attention \n
+  None
+  \param[out] pu32VendorID: The number indicates the vendor id
+  \retval ::HI_SUCCESS Success
+  \retval ::HI_FAILURE This API fails to be called
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetVendorID(HI_U32 *pu32VendorID);
+
+/**
+\brief Enables the security startup function and sets the type of flash memory for security startup
+CNcomment:设置安全启动使能,同时指定安全启动的Flash类型 CNend
+\attention \n
+This function can be enabled only and cannot be disabled after being enabled.
+CNcomment:只能使能，使能之后不可修改。 CNend
+\param[in]  enFlashType Type of the flash memory for security startup CNcomment:enFlashType  启动的Flash类型 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN  重复设置 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_EnableSecBoot(HI_UNF_ADVCA_FLASH_TYPE_E enFlashType);
+
+/**
+\brief Enables the security startup function. This API should be used with the API HI_UNF_ADVCA_SetFlashTypeEx.
+CNcomment:设置安全启动使能，该接口必须和HI_UNF_ADVCA_SetFlashTypeEx配套使用。 CNend
+\attention \n
+\param[in]  None
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN  重复设置 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_EnableSecBootEx(HI_VOID);
+
+/**
+\brief Sets the type of flash memory for security startup and disable the self boot, which mean that you cannot use the serial port to update the boot. This API should be used with the API HI_UNF_ADVCA_EnableSecBootEx
+CNcomment:指定安全启动的Flash类型，同时关闭自举功能，即不能通过串口升级fastboot。该接口跟HI_UNF_ADVCA_EnableSecBootEx配套使用 CNend
+\attention \n
+The setting is performed before delivery and can be performed once only.
+CNcomment:在机顶盒出厂时选择是否设置，仅支持设置一次 CNend
+\param[in]  enFlashType Type of the flash memory for security startup CNcomment:enFlashType  启动的Flash类型 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN  重复设置 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetFlashTypeEx(HI_UNF_ADVCA_FLASH_TYPE_E enFlashType);
+
+/**
+\brief  Sets whether to use hardware CWs only CNcomment:设置固定使用硬件CW字 CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+By default, the CW type (hardware CWs or software CWs) depends on the configuration of the DEMUX.
+CNcomment:在机顶盒出厂时选择是否设置，仅支持设置一次
+默认根据Demux的配置选择使用硬件CW字还是软件CW字 CNend
+\param  none
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                  成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA未初始化 CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN    重复设置参数 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_LockHardCwSel(HI_VOID);
+
+/**
+\brief Disables the self-boot function CNcomment:关闭SelfBoot功能,也就是boot下不能使用串口/网口升级 CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+The self-boot function is enabled by default.
+CNcomment:在机顶盒出厂时选择是否设置，仅支持设置一次
+默认使能SelfBoot功能 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                  成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized.  CNcomment:HI_ERR_CA_NOT_INIT          CA未初始化 CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN    重复设置参数 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_DisableSelfBoot(HI_VOID);
+
+/**
+\brief Obtains the self-boot status CNcomment:获取SelfBoot状态 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pbDisable: self-boot status. CNcomment:pbEnable   SelfBoot是否禁用 CNend
+HI_TRUE enabled CNcomment:HI_TRUE 禁用，  CNend
+HI_FALSE disabled CNcomment:HI_FALSE 未禁用 CNend
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetSelfBootStat(HI_BOOL *pbDisable);
+
+/**
+\brief  Get whether to use hardware CWs only CNcomment:获取固定使用硬件CW字标志 CNend
+\attention
+None CNcomment:无 CNend
+\param[out] pbLock indicates the state of hardware CWs  CNcomment:pbLock 硬件CW字的标志位 CNend
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                  成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetHardCwSelStat(HI_BOOL *pbLock);
+
+/**
+\brief  Open the SWPK key ladder CNcomment:打开boot key ladder  CNend
+\attention
+\param  none
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                  成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA未初始化 CNend
+
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SWPKKeyLadderOpen(HI_VOID);
+
+/**
+\brief  Close the SWPK key ladder CNcomment:关闭boot key ladder  CNend
+\attention
+\param  none
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                  成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA未初始化 CNend
+
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SWPKKeyLadderClose(HI_VOID);
+
+/**
+\brief Obtains the Version ID CNcomment:获取Version ID  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pu8VersionId Version ID CNcomment:pu8VersionId   版本号标志 CNend
+\param[in] u32VersionIdLen Version ID length, must be equal to 4 CNcomment:u32VersionIdLen   版本号标志，必须等于4 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_SetVersionId
+*/
+HI_S32 HI_UNF_ADVCA_GetVersionId(HI_U8 *pu8VersionId, HI_U32 u32VersionIdLen);
+
+/**
+\brief Sets the Version ID CNcomment:设置Version ID  CNend
+\attention \n
+The version ID of the set-top box (STB) is set before delivery. The version ID can be set once only and takes effects after the STB restarts.
+CNcomment:在机顶盒出厂时设置，仅支持设置一次 设置后重启生效 CNend
+\param[in] pu8VersionId version ID CNcomment:pu8VersionId   版本号标志 CNend
+\param[in] u32VersionIdLen Version ID length, must be equal to 4 CNcomment:u32VersionIdLen   版本号标志，必须等于4 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN  重复设置 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetVersionId(HI_U8 *pu8VersionId, HI_U32 u32VersionIdLen);
+
+/**
+\brief  Sets whether to check the boot version CNcomment:设置是否检查Version  CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+By default, the version check function is disabled
+CNcomment:在机顶盒出厂时选择是否设置，仅支持设置一次
+默认不使能version check  CNend
+\param  none
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                  成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA未初始化 CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN    重复设置参数 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_EnableVersionCheck(HI_VOID);
+
+/**
+\brief  Get the boot version check flag CNcomment:获取是否检查version的标志位 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pu32Stat boot version check flag CNcomment:pu32Stat    version检查的标志位 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetVersionCheckStat(HI_U32 *pu32Stat);
+
+/**
+\brief  Sets whether to check the MSID in boot area CNcomment:设置是否检查boot area的MSID  CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+By default, the boot MSID check function is disabled
+CNcomment:在机顶盒出厂时选择是否设置，仅支持设置一次
+默认不使能boot MSID check  CNend
+\param none
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                  成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA未初始化 CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN    重复设置参数 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_EnableBootMSIDCheck(HI_VOID);
+
+/**
+\brief  Get the boot MSID check flag CNcomment:获取是否检查MSID的标志位 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pu32Stat boot MSID check flag CNcomment:pu32Stat    MSID检查的标志位 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetBootMSIDCheckStat(HI_U32 *pu32Stat);
+
+/**
+\brief  Get the software revision
+CNcomment:获取软件的revision版本号 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] revision string of Revision CNcomment:revision    Revision版本号 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetRevision(HI_U8 revision[25]);
+
+/**
+\brief  Set the DDR Scramble flag. Normally, this flag has been set as required by CA vendor
+CNcomment:设置DDR加扰标志位，一般高安芯片出厂时已按照CA公司要求设置 CNend
+\attention \n
+None CNcomment:无 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetDDRScramble(HI_VOID);
+
+/**
+\brief  Get the DDR Scramble flag
+CNcomment:获取DDR加扰标志位 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pu32Stat DDR Scramble flag CNcomment:pu32Stat    DDR加扰标志 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetDDRScrambleStat(HI_U32 *pu32Stat);
+
+/**
+\brief Sets whether to decrypt the BootLoader CNcomment:设置必须对BootLoader进行解密 CNend
+\attention
+The setting is performed before delivery and can be performed once only.
+CNcomment:在机顶盒出厂时选择是否设置，仅支持设置一次
+默认根据Flash中的数据标识，决定BootLoader是否需要解密 CNend
+
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS                  成功 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT          CA未初始化 CNend
+\return ::HI_ERR_CA_SETPARAM_AGAIN The parameter has been set CNcomment:HI_ERR_CA_SETPARAM_AGAIN    重复设置参数 CNend
+
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_LockBootDecEn(HI_VOID);
+
+/**
+\brief Get the BootLoader Decryption flag CNcomment:获取BootLoader解密的标志位 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pu32Stat BootLoader Decryption flag CNcomment:pu32Stat    Bootloader解密标志位 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetBootDecEnStat(HI_U32 *pu32Stat);
+
+
+
+/**
+\brief  Calculte the AES_CMAC value of data
+CNcomment: 计算数据的AES_CMAC 值 CNend
+\attention \n
+None CNcomment:无 CNend
+
+\param[in]  buffer  pointer of data buffer .        CNcomment:数据buffer 指针 CNend
+\param[in]  Length  The length  of data .   CNcomment:数据长度 CNend
+\param[in]  pKey   The key used in Calculte the AES_CMAC of data           CNcomment:pKey AES_CMAC 计算中使用的key  CNend
+\param[in] u32KeyLen pKey length, must be equal to 16. CNcomment:u32KeyLen 密钥长度，必须为16 CNend
+\param[out]  pCMAC   The AES_CMAC value          CNcomment:pCMAC AES_CMAC 值 CNend
+\param[in] u32CMACLen AES_CMAC length, must be equal to 16. CNcomment:u32CMACLen AES_CMAC长度，必须为16 CNend
+\retval ::HI_SUCCESS  Success                 CNcomment:成功 CNend
+\retval ::HI_FAILURE    Failure                     CNcomment:失败 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_CalculteAES_CMAC(HI_U8 *buffer, HI_U32 Length, HI_U8 *pKey, HI_U32 u32KeyLen, HI_U8 *pCMAC, HI_U32 u32CMACLen);
+
+/**
+\brief Sets the algorithm of the SP key ladder CNcomment:设置SP key ladder的算法    CNend
+\attention \n
+You must set an algorithm before using a key ladder in a session. The default algorithm is TDES.
+It is recommended that you retain the algorithm in a session.
+CNcomment:每次会话过程中使用key ladder之前，须设置具体算法, 系统初始默认值 HI_UNF_ADVCA_ALG_TYPE_TDES；\n
+本次会话过程中，建议保持算法的稳定不变。 CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder算法\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetSPAlg(HI_UNF_ADVCA_ALG_TYPE_E enType);
+
+/**
+\brief Obtains the algorithm of the SP key ladder CNcomment: 获取 SP key ladder的算法    CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] pEnType Key ladder algorithm CNcomment:pEnType  key ladder算法\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetSPAlg(HI_UNF_ADVCA_ALG_TYPE_E *pEnType);
+
+/**
+\brief Sets the SP key ladder stage CNcomment:设置SP key ladder的级数    CNend
+\attention \n
+The key ladder stage can be set only once before delivery and cannot be changed. Please use default value.
+CNcomment:机顶盒出厂时设置 仅能设置一次 不可更改,不建议使用该接口改变stage  CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage  key ladder级数\n 取值只能为HI_UNF_ADVCA_KEYLADDER_lev2 或者 HI_UNF_ADVCA_KEYLADDER_lev3  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_SetSPKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage);
+
+/**
+\brief Obtains the SP key ladder stage CNcomment:获取SP key ladder的级数 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] penStage Key ladder stage CNcomment:penStage   key ladder级数 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_KEYLADDER_LEV_E
+*/
+HI_S32 HI_UNF_ADVCA_GetSPKeyLadderStage(HI_UNF_ADVCA_KEYLADDER_LEV_E *penStage);
+
+
+/**
+\brief Sets session keys for a SP key ladder CNcomment:为SP key ladder配置会话密钥    CNend
+\attention \n
+The stage of the session key cannot be greater than the configured stage of the key ladder. The last stage of the session key is configured by calling the API of the CIPHER module rather than this API.
+That is, only session key 1 and session key 2 need to be configured for a 3-stage key ladder.
+Only session key 1 needs to be configured for a 2-stage key ladder.
+You need to set the key ladder stage by calling HI_UNF_ADVCA_SetSPKeyLadderStage first.
+ Session keys can be set during initialization or changed at any time.
+CNcomment:注意配置的级数不能超过设置的级数值，最后一级由Descrambler模块内部配置，不用通过此接口配置。\n
+也就是说，对于3级key ladder，只用配置会话密钥1和会话密钥2。\n
+对于2级的key ladder，只用配置会话密钥1。\n
+请先调用HI_UNF_ADVCA_SetSPKeyLadderStage设置key ladder级数。\n
+会话密钥可以初始时设置一次，也可以随时修改。 CNend
+\param[in] enStage Key ladder stage Its value is HI_UNF_ADVCA_KEYLADDER_LEV2 or HI_UNF_ADVCA_KEYLADDER_LEV3.
+CNcomment:enStage    密钥级数，[HI_UNF_ADVCA_KEYLADDER_LEV1 ~ HI_UNF_ADVCA_KEYLADDER_LEV2]  CNend
+\param[in] pu8Key Protection key pointer, 128 bits (16 bytes) in total CNcomment:pu8Key     保护密钥指针，共128bit(16byte)  CNend
+\param[in] u32KeyLen Protection key length, must be equal to 16. CNcomment:u32KeyLen 保护密钥长度，必须为16 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\retval ::HI_ERR_CA_WAIT_TIMEOUT Timeout occurs when the CA module waits for encryption or decryption
+CNcomment:HI_ERR_CA_WAIT_TIMEOUT CA等待加解密超时 CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The CW decryption fails CNcomment:HI_ERR_CA_CW_DECRYPT   CW解密失败 CNend
+
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetSPSessionKey(HI_UNF_ADVCA_KEYLADDER_LEV_E enStage, HI_U8 *pu8Key, HI_U32 u32KeyLen);
+
+/**
+\brief Sets the descramble mode of the SP key ladder CNcomment:设置SP key ladder的解扰算法    CNend
+\attention \n
+You must set a descramble mode before using a key ladder in a session. The default algorithm is HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC_CI.
+It is recommended that you retain the descramble mode in a session.
+CNcomment:每次会话过程中使用key ladder之前，须设置具体算法, 系统初始默认值 HI_UNF_ADVCA_SP_DSC_MODE_PAYLOAD_AES_CBC_CI；\n
+本次会话过程中，建议保持算法的稳定不变。 CNend
+\param[in] enType Key ladder algorithm CNcomment:enType  key ladder算法\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_SetSPDscMode(HI_UNF_ADVCA_SP_DSC_MODE_E enType);
+
+/**
+\brief Obtains the descramble mode of the SP key ladder CNcomment: 获取 SP key ladder的算法    CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] pEnType Key ladder algorithm CNcomment:pEnType  key ladder算法\n  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_ALG_TYPE_E
+*/
+HI_S32 HI_UNF_ADVCA_GetSPDscMode(HI_UNF_ADVCA_SP_DSC_MODE_E *pEnType);
+
+/**
+  \brief this function is used by the Novel CA for the encryption and decryption setting
+   CNcomment:Novel内存加解密算法和key配置 CNend
+  \attention \n
+  This function is used for the Novel encryption and decrption
+  CNcomment:  本函数是提供给 Novel 内存加解密方案使用，用作配置加解密过程keyladder算法和key CNend
+  \retval ::HI_SUCCESS Success  CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called  CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \see  \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_NovelCryptologyConfig(HI_VOID);
+
+/**
+  \brief Used for Novel CA to encrypt the data  CNcomment:Novel内存数据加密 CNend
+  \attention \n
+  None  CNcomment: 无 CNend
+  \param[in]  pPlainText: the buffer to store the data to be encrypted CNcomment:pPlainText 待加密数据指针 CNend
+  \param[in]  TextLen: the length of the data to be encrypted CNcomment:TextLen    待加密数据长度 CNend
+  \param[in]  pCipherText: the buffer to store the encrypted data CNcomment:pCipherText 加密后数据指针 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_NovelDataEncrypt(HI_U8 *pPlainText, HI_U32 TextLen, HI_U8 *pCipherText);
+
+/**
+  \brief This function is used for Novel to decrypt the data CNcomment:TextNovel内存数据解密 CNend
+  \attention \n
+  None  CNcomment:无 CNend
+  \param[in]  pPlainText: point to the data to be decrypted CNcomment:pPlainText 待解密密数据指针 CNend
+  \param[in]  TextLen: the length of the data to be decrypted CNcomment:TextLen    待解密数据长度 CNend
+  \param[in]  pCipherText: the buffer store the decrypted data CNcomment:pCipherText 解密后数据指针 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \see  \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_NovelDataDecrypt(HI_U8 *pCipherText, HI_U32 TextLen, HI_U8 *pPlainText);
+
+/**
+\brief Sets oem root key， it's mainly used for widevine keyladder CNcomment:OEM_root_key 主要用于Widevine keyladder    CNend
+\attention \n
+This root key could only be written only once be careful, thanks    CNcomment: 这个密钥只允许写一次,请谨慎操作 CNend
+\param[in] pu8OEMRootKey buffer of the input key    CNcomment:pu8OEMRootKey    输入密钥的buffer  CNend
+\param[in] u32KeyLen key length of the input CNcomment:u32KeyLen     输入密钥的长度，限定为16字节  CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+\retval ::HI_ERR_CA_R2R_DECRYPT The CW decryption fails CNcomment:HI_ERR_CA_CW_DECRYPT   CW解密失败 CNend
+
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetOEMRootKey(HI_U8 *pu8OEMRootKey, HI_U32 u32KeyLen);
+
+/**
+  \brief This function is used to open the DCAS CNcomment:用于打开DCAS CNend
+  \attention \n
+  None  CNcomment:无 CNend
+  \param[in]  enAlg: DCAS keyladder algorithm CNcomment:enAlg DCAS keyladder算法 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \see  \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_DCASOpen(HI_UNF_CIPHER_ALG_E enAlg);
+
+/**
+  \brief This function is used to get the DCAS CHIPID CNcomment:用于获取DCAS CHIPID
+  \attention \n
+  None  CNcomment:无 CNend
+  \param[out]  pu32MSBID: First 4 bytes of DCAS CHIPID CNcomment:DCAS CHIPID前4个字节 CNend
+  \param[out]  pu32LSBID: last 4 bytes of DCAS CHIPID CNcomment:DCAS CHIPID后4个字节 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \see  \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetDCASChipId(HI_U32 *pu32MSBID, HI_U32 *pu32LSBID);
+
+/**
+  \brief This function is used to set the session key CNcomment:用于设置DCAS session密钥 CNend
+  \attention \n
+  None  CNcomment:无 CNend
+  \param[in]  enDCASLevel: the DCAS keyladder level CNcomment:enAlg DCAS keyladder级数 CNend
+  \param[in]  pu8Key: the DCAS keyladder session key CNcomment:enAlg DCAS keyladder密钥 CNend
+  \param[in] u32KeyLen DCAS keyladder session key length, must be equal to 16. CNcomment:u32KeyLen DCAS keyladder密钥长度，必须为16 CNend
+  \param[out]  pu8Output: the output of the DCAS keyladder CNcomment:pu8Output DCAS keyladder输出 CNend
+  \param[in] u32OutputLen Output length, must be equal to 16. CNcomment:u32OutputLen DCAS keyladder输出长度，必须为16 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetDCASSessionKey(HI_UNF_ADVCA_DCAS_KEYLADDER_LEV_E enDCASLevel,
+                            HI_U8 *pu8Key , HI_U32 u32KeyLen, HI_U8 *pu8Output,  HI_U32 u32OutputLen);
+
+/**
+  \brief This function is used to close the DCAS keyladder CNcomment:用于关闭DCAS CNend
+  \attention \n
+  None  CNcomment:无 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \see  \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_DCASClose(HI_VOID);
+
+/**
+  \brief This function is used to set the OTP fuse. CNcomment:用于设置OTP位 CNend
+  \attention \n
+  None  CNcomment:无 CNend
+  \param[in]  enOtpFuse: the OTP fuse ID CNcomment:enOtpFuse 待设置的OTP位ID CNend
+  \param[in]  pstOtpFuseAttr: the OTP fuse attribute CNcomment:pstOtpFuseAttr 待设置的OTP位属性 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetOtpFuse(HI_UNF_ADVCA_OTP_FUSE_E enOtpFuse, HI_UNF_ADVCA_OTP_ATTR_S *pstOtpFuseAttr);
+
+/**
+  \brief This function is used to get the OTP fuse. CNcomment:用于获取OTP位 CNend
+  \attention \n
+  None  CNcomment:无 CNend
+  \param[in]  enOtpFuse: the OTP fuse ID CNcomment:enOtpFuse 待获取的OTP位ID CNend
+  \param[in]  pstOtpFuseAttr: the OTP fuse attribute CNcomment:pstOtpFuseAttr 获取的OTP位属性 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_GetOtpFuse(HI_UNF_ADVCA_OTP_FUSE_E enOtpFuse, HI_UNF_ADVCA_OTP_ATTR_S *pstOtpFuseAttr);
+
+/**
+  \brief This function is used to set the keyladder attribute. CNcomment:用于设置keyladder属性 CNend
+  \attention \n
+  None  CNcomment:无 CNend
+  \param[in]  enKeyLadderType: The keyladder type ID CNcomment:enKeyLadderType Keyladder类型ID CNend
+  \param[in]  pstKeyladderAttr: The keyladder attribute CNcomment:pstKeyladderAttr 待设置的keyladder属性CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetKeyLadderAttr(HI_UNF_ADVCA_KEYLADDER_TYPE_E enKeyLadderType, HI_UNF_ADVCA_KEYLADDER_ATTR_S *pstKeyladderAttr);
+
+/**
+  \brief This function is used to achieve the CA vendor privated function. CNcomment:用于完成CA厂家特有的操作 CNend
+  \attention \n
+  None  CNcomment:无 CNend
+  \param[in]  enCaVendor: The CA vendor type ID CNcomment:enCaVendor CA vendor类型ID CNend
+  \param[in]  pstCavendorOpt: The parameter to achieve the CA vendor private function CNcomment:pstCavendorOpt 完成CA厂家特有功能需要的参数CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS  成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized. CNcomment:HI_ERR_CA_NOT_INIT CA未初始化 CNend
+  \retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA 输入参数非法 CNend
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_CaVendorOperation(HI_UNF_ADVCA_VENDORID_E enCaVendor, HI_UNF_ADVCA_CA_VENDOR_OPT_S *pstCaVendorOpt);
+
+/**
+  \brief This function is used to set the session key CNcomment:用于设置LP session密钥 CNend
+  \attention \n
+  None  CNcomment:无 CNend
+  \param[in]  pu8Key: the LP keyladder session key CNcomment:enAlg LP keyladder密钥 CNend
+  \param[in] u32KeyLen Protection key length, must be equal to 16. CNcomment:u32KeyLen 保护密钥长度，必须为16 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_SetLPSessionKey(HI_U8 *pu8Key, HI_U32 u32KeyLen);
+
+/**
+  \brief This function is used to generate the clear key CNcomment:用于生成LP 明文密钥 CNend
+  \attention \n
+  None  CNcomment:无 CNend
+  \param[in]  pEncryptedKey: the LP keyladder encrypted key CNcomment:配置密文key CNend
+  \param[in] u32EncryptedSwpkLen SWPK length, must be equal to 16. CNcomment:u32EncryptedSwpkLen  加密的SWPK长度，必须为16 CNend
+  \param[out]  pPlainKey: the LP keyladder clear key CNcomment:生成的明文key CNend
+  \param[in] u32PlainSwpkLen SWPK length, must be equal to 16. CNcomment:u32PlainSwpkLen 明文SWPK长度，必须为16 CNend
+  \retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+  \retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+  \see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_ADVCA_DecryptLPKey(HI_U8 *pEncryptedSwpk, HI_U32 u32EncryptedSwpkLen, HI_U8 *pPlainSwpk, HI_U32 u32PlainSwpkLen);
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_ADVCA_H__ */
+
+
diff -uNr a/include/hi_unf_aenc.h b/include/hi_unf_aenc.h
--- a/include/hi_unf_aenc.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_aenc.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,271 @@
+/******************************************************************************
+  Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+  File Name     : hi_unf_aenc.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       :
+  Last Modified :
+  Description   : header file for audio and video output control
+  Function List :
+  History       :
+  1.Date        :
+  Author        :
+  Modification  : Created file
+******************************************************************************/
+
+/**
+ * \file
+ * \brief describle the information about AENC. CNcomment:提供AENC的相关信息 CNend
+ */
+
+#ifndef  __HI_UNF_AENC_H__
+#define  __HI_UNF_AENC_H__
+
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#define HI_UNF_AENC_MAX_TYPE 1
+
+/* AENC Capability Description */
+/**CNcomment: 编码能力描述*/
+typedef struct
+{
+    HA_CODEC_ID_E  enCodecType; /* support aenc type */
+} HI_UNF_AENC_CAP_INFO_S;
+
+typedef struct
+{
+    HI_U32 u32SupportTypeNum;                               /* support aenc type num */
+    HI_U32 u32MaxAencInstance;                              /* maximum running aenc encoder */
+    HI_UNF_AENC_CAP_INFO_S stCapInfo[HI_UNF_AENC_MAX_TYPE]; /* capability information for each aenc type */
+} HI_UNF_AENC_CAP_S;
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      AENC */
+/** @{ */  /** <!-- [AENC] */
+
+/**
+\brief Initializes audio encoder. CNcomment:初始化音频编码器 CNend
+\attention \n
+Call the interface before calling HI_UNF_AENC_Open. CNcomment:HI_UNF_AENC_Open接口前调用 CNend
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE Failure CNcomment:失败 CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_AENC_Init(HI_VOID);
+
+/**
+\brief Deinitializes audio encoder. CNcomment:去初始化音频编码器 CNend
+\attention \n
+N/A
+\param N/A
+\retval ::HI_ERR_AENC_CH_NOT_SUPPORT  Invalid operation CNcomment:HI_ERR_AENC_CH_NOT_SUPPORT 无效的操作 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_AENC_DeInit(HI_VOID);
+
+/**
+\brief Create audio encoder. CNcomment:创建音频编码器 CNend
+\attention \n
+Before calling the interface, you must configure the encoder. Now AENC only supports 16-bit and 2 channels, and support 16K, 22K, 24K, 32K, 44K, or 48Ksample rate.
+CNcomment:调用该接口前，必须配置编码器，目前AENC只支持16位2声道，且采样率为：16K 22K 24K 32K 44K和48K CNend
+\param[in] pstAencAttr               Attribute structure of the audio encoder. CNcomment:音频编码器属性结构 CNend
+\param[out] phAenc                   Obtain the handle of the audio encoder. CNcomment:得到音频编码器句柄 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE Failure CNcomment:失败 CNend
+\retval ::HI_ERR_AENC_NULL_PTR        The pointer is null. CNcomment:指针为空 CNend
+\retval ::HI_ERR_AENC_CREATECH_FAIL   The encoder fails to be created. CNcomment:创建编码器失败 CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_AENC_Create(const HI_UNF_AENC_ATTR_S* pstAencAttr, HI_HANDLE* phAenc);
+
+/**
+\brief Destroy the audio encoder. CNcomment:销毁音频编码器 CNend
+\attention \n
+\param[in] phAenc the handle of the audio encoder CNcomment:音频编码器句柄 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AENC_CH_NOT_SUPPORT  The operation is invalid. CNcomment:无效的操作 CNend
+\retval ::HI_ERR_AENC_INVALID_PARA    The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AENC_CH_NOT_OPEN     The audio encoder is not opened. CNcomment:音频编码器没有打开 CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_AENC_Destroy(HI_HANDLE hAenc);
+
+/**
+\brief Copy data to the encoder for encoding. CNcomment:向编码器拷贝数据以供编码 CNend
+\attention \n
+\param[in] phAenc     The audio encoder handle CNcomment:音频编码器句柄 CNend
+\param[in] pstAOFrame Send a frame of data to the encoder. CNcomment:向音频编码器送一帧数据 CNend
+\retval ::HI_SUCCESS  Success CNcomment:成功 CNend
+\retval ::HI_ERR_AENC_IN_BUF_FULL      The input buffer of the encoder is full. CNcomment:编码器输入缓冲满 CNend
+\retval ::HI_ERR_AENC_INVALID_PARA     The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AENC_CH_NOT_SUPPORT   The operation is invalid. CNcomment:无效的操作 CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_AENC_SendFrame(HI_HANDLE hAenc, const HI_UNF_AO_FRAMEINFO_S* pstAOFrame);
+
+/**
+\brief Obtain data from a output buffer of the encoder and write the data into the file. CNcomment:从编码器的一个输出缓冲中取出数据以供写入文件 CNend
+\attention \n
+\param[in] phAenc     The audio encoder handle CNcomment:音频编码器句柄 CNend
+\param[in] pstStream  The data in a output buffer of the audio encoder CNcomment:音频编码器一个输出缓冲中的数据 CNend
+\retval ::HI_SUCCESS  Success CNcomment:成功 CNend
+\retval ::HI_ERR_AENC_INVALID_PARA    The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AENC_OUT_BUF_EMPTY   The output buffer of the encoder is empty. CNcomment:编码器输出缓冲为空 CNend
+\retval ::HI_ERR_AENC_CH_NOT_SUPPORT  The operation is invalid. CNcomment:无效的操作 CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_AENC_AcquireStream(HI_HANDLE hAenc, HI_UNF_ES_BUF_S* pstStream, HI_U32 u32TimeoutMs);
+
+/**
+\brief Destroy the data in a output buffer of the encoder. CNcomment:销毁编码器一个输出缓冲中的数据 CNend
+\attention \n
+Call the interface after calling HI_UNF_AENC_ReceiveStream. CNcomment:在HI_UNF_AENC_ReceiveStream之后调用 CNend
+\param[in] phAenc     The handle of audio encoder CNcomment:音频编码器句柄 CNend
+\param[in] u32TimeoutMs   allowable timeout  CNcomment:获取编码数据允许的超时 CNend
+\param[out] pstStream  The data in a output buffer of the audio encoder CNcomment:音频编码器一个输出缓冲中的数据 CNend
+\retval ::HI_SUCCESS  Success CNcomment:成功 CNend
+\retval ::HI_ERR_AENC_INVALID_PARA   The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AENC_OUT_BUF_BAD    The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AENC_IN_BUF_UNEMPTY The input buffer is empty. CNcomment:输入缓冲非空 CNend
+\retval ::HI_ERR_AENC_CH_NOT_SUPPORT The operation is invalid. CNcomment:无效的操作 CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_AENC_ReleaseStream(HI_HANDLE hAenc, const HI_UNF_ES_BUF_S* pstStream);
+
+/**
+\brief Register dynamic audio encoding libraries. CNcomment:注册音频动态编码库 CNend
+\attention \n
+\param[in] pEncoderDllName The file name of audio encoding  libraries CNcomment:pEncoderDllName 音频编码库文件名 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE Failure CNcomment:失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AENC_RegisterEncoder(const HI_CHAR* pEncoderDllName);
+
+/**
+\brief Attach audio encoder with audio track. CNcomment:绑定音频编码器和音频Track 通路 CNend
+\attention \n
+Before obtaining the streams and encoding, you must call the interface. CNcomment:开始编码和获取码流之前需要首先调用该接口 CNend
+\param[in] hSrc   The handle of audio track CNcomment:资源句柄 CNend
+\param[in] hAenc     The handle of audio encoder CNcomment:音频编码器句柄 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AENC_INVALID_PARA	        The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AENC_CH_NOT_SUPPORT        The operation is invalid. CNcomment:无效的操作 CNend
+\retval ::HI_ERR_AENC_NULL_PTR	            The pointer is null. CNcomment:指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT	        The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AENC_AttachInput(HI_HANDLE hAenc, HI_HANDLE hSrc);
+
+/**
+\brief Detach audio encoder with audio track. CNcomment:解除音频编码器和音频Track 通路的绑定 CNend
+\attention \n
+Before calling the interface, stop the encoding. CNcomment:调用该接口需要首先停止编码 CNend
+\param[in] hAenc     The handle of audio encoder CNcomment:音频编码器句柄 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AENC_INVALID_PARA	        The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AENC_CH_NOT_SUPPORT        The operation is invalid. CNcomment:无效的操作 CNend
+\retval ::HI_ERR_AENC_NULL_PTR	            The pointer is null. CNcomment:指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT	        The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AENC_DetachInput(HI_HANDLE hAenc);
+
+/**
+\brief Start to encode. CNcomment:开始编码 CNend
+\attention \n
+Before calling the interface, you need to initialize the encoder, create an encoding channel and attach the player.
+CNcomment:调用该接口需要首先初始化编码器，创建编码通道，绑定播放器 CNend
+\param[in] hAenc The handle of audio encoder CNcomment:音频编码器句柄 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AENC_INVALID_PARA	        The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AENC_NULL_PTR	            The pointer is null. CNcomment:指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT	        The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AENC_Start(HI_HANDLE hAenc);
+
+/**
+\brief Stop to encode. CNcomment:停止编码 CNend
+\attention \n
+Before calling the interface, you need to initialize the encoder, create an encoding channel, attach the player, and start the encoding.
+CNcomment:调用该接口需要首先初始化编码器，创建编码通道，绑定播放器，已经开始编码 CNend
+\param[in] hAenc   The handle of audio encoder CNcomment:音频编码器句柄 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AENC_INVALID_PARA	        The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AENC_NULL_PTR	            The pointer is null. CNcomment:指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT	        The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AENC_Stop(HI_HANDLE hAenc);
+
+/**
+\brief Set the attribution of encode. CNcomment:设置编码属性 CNend
+\attention \n
+Before calling the interface, you need to stop the encoder.
+CNcomment:调用该接口需要首先停止编码CNend
+\param[in] hAenc   The handle of audio encoder CNcomment:音频编码器句柄 CNend
+\param[in] pstAencAttr   The attribution of audio encoder CNcomment:音频编码属性 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AENC_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AENC_NULL_PTR            The pointer is null. CNcomment:指针为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AENC_SetAttr(HI_HANDLE hAenc, const HI_UNF_AENC_ATTR_S* pstAencAttr);
+
+/**
+\brief Set the attribution of encode. CNcomment:获取编码属性 CNend
+\attention \n
+\param[in] hAenc   The handle of audio encoder CNcomment:音频编码器句柄 CNend
+\param[out] pstAencAttr   The attribution of audio encoder CNcomment:音频编码属性 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AENC_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AENC_NULL_PTR            The pointer is null. CNcomment:指针为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AENC_GetAttr(HI_HANDLE hAenc, HI_UNF_AENC_ATTR_S* pstAencAttr);
+
+/**
+\brief get AENC capability. CNcomment:获取编码能力集 CNend
+\attention \n
+\param[in] pstCapability The returned capability of AENC CNcomment:pstCapability 编码能力集描述结构体 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE Failure CNcomment:失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AENC_GetCapability(HI_UNF_AENC_CAP_S* pstCapability);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif  /*__HI_UNF_AENC_H__*/
+
diff -uNr a/include/hi_unf_ai.h b/include/hi_unf_ai.h
--- a/include/hi_unf_ai.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_ai.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,340 @@
+/******************************************************************************
+  Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+  File Name     : hi_unf_ai.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2013/4/22
+  Last Modified :
+  Description   : header file for audio and video output control
+  Function List :
+  History       :
+  1.Date        :
+  Author        : zgjie
+  Modification  : Created file
+******************************************************************************/
+/**
+ * \file
+ * \brief Describes the information about the audio input (AI) module. CNcomment:提供AI的相关信息 CNend
+ */
+
+#ifndef  __HI_UNF_AI_H__
+#define  __HI_UNF_AI_H__
+
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+/********************************Macro Definition********************************/
+/** \addtogroup      AI */
+/** @{ */  /** <!-- AI */
+
+
+/** @} */  /** <!-- ==== Macro Definition end ==== */
+
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      AI */
+/** @{ */  /** <!--  【AI】 */
+
+
+
+
+/**Audio inputport defination */
+/**CNcomment:音频输入端口定义*/
+typedef enum hiUNF_AI_E
+{
+    HI_UNF_AI_I2S0 = 0,
+
+    HI_UNF_AI_I2S1,
+
+    HI_UNF_AI_ADC0 = 0x10,
+
+    HI_UNF_AI_ADC1,
+
+    HI_UNF_AI_ADC2,
+
+    HI_UNF_AI_ADC3,
+
+    HI_UNF_AI_ADC4,
+
+    HI_UNF_AI_SIF0 = 0x20,
+
+    HI_UNF_AI_HDMI0 = 0x30,
+
+    HI_UNF_AI_HDMI1,
+
+    HI_UNF_AI_HDMI2,
+
+    HI_UNF_AI_HDMI3,
+
+    HI_UNF_AI_BUTT = 0xff,
+} HI_UNF_AI_E;
+
+/**Defines internal Audio ADC inputport attribute */
+/**CNcomment:定义内置音频ADC输入端口属性*/
+typedef struct hiUNF_AI_ADC_ATTR_S
+{
+    HI_BOOL   bByPass;
+} HI_UNF_AI_ADC_ATTR_S;
+
+
+/**Defines  Audio I2S inputport attribute */
+/**CNcomment:定义音频I2S输入端口属性*/
+typedef struct hiUNF_AI_I2S_ATTR_S
+{
+    HI_UNF_I2S_ATTR_S  stAttr;  /**<I2S Attribute*/ /**<CNcomment:I2S属性*/
+}  HI_UNF_AI_I2S_ATTR_S;
+
+/**Defines the HDMI RX Audio data format .*/
+typedef enum hiHI_UNF_AI_HDMI_FORMAT_E
+{
+    HI_UNF_AI_HDMI_FORMAT_LPCM = 0,          /* LPCM 2/8 channels,  Audio Sample Packet layout0 or layout1 */ 
+    HI_UNF_AI_HDMI_FORMAT_LBR = 1,           /* IEC-61937 DD/DDP/DTS, Audio Sample Packet layout0 */ 
+    HI_UNF_AI_HDMI_FORMAT_HBR = 8,           /* IEC-61937 DTSHD/TrueHD, High-Bitrate (HBR) Audio Stream Packet*/ 
+    HI_UNF_AI_HDMI_FORMAT_BUTT
+} HI_UNF_AI_HDMI_FORMAT_E;
+
+
+/**Defines  HDMI Audio inputport attribute */
+/**CNcomment:定义HDMI音频输入端口属性*/
+typedef struct hiUNF_AI_HDMI_ATTR_S
+{
+    HI_UNF_I2S_CHNUM_E    enChannel;    /**<Channel number*/ /**<CNcomment:通道数*/
+    HI_UNF_I2S_BITDEPTH_E enBitDepth;   /**<Bit Depth*/ /**<CNcomment:位宽*/
+    HI_UNF_SAMPLE_RATE_E  enSampleRate; /**<Sample Rate*/ /**<CNcomment:采样率*/
+    HI_UNF_AI_HDMI_FORMAT_E enHdmiAudioDataFormat;  /**<HDMI audio data format*/ /**<CNcomment:HDMI音频数据格式*/
+} HI_UNF_AI_HDMI_ATTR_S;
+
+/**Defines internal SIF(Audio Demodulator) inputport attribute */
+/**CNcomment:定义SIF输入端口属性*/
+typedef struct hiUNF_AI_SIF_ATTR_S
+{
+    HI_VOID* pPara;
+} HI_UNF_AI_SIF_ATTR_S;
+
+/**Defines  Audio inputport attribute */
+/**CNcomment:定义音频输入端口属性*/
+typedef struct hiHI_UNF_AI_ATTR_S
+{
+    HI_UNF_SAMPLE_RATE_E    enSampleRate;          /**<samplerate, default 48000Hz*/ /**<CNcomment:设备采样频率，默认 48000Hz*/
+    HI_U32                  u32PcmFrameMaxNum;     /**<Max frame of the PCM data at cast buffer, default 16*/ /**<CNcomment: 最大可缓存帧数，默认 16*/
+    HI_U32                  u32PcmSamplesPerFrame; /**<Number of sample of the PCM data, default 960*/ /**<CNcomment: PCM数据采样点数量，默认 960*/
+    union
+    {
+        HI_UNF_AI_ADC_ATTR_S  stAdcAttr;    /**<ADC Attribute*/ /**<CNcomment:ADC属性*/
+        HI_UNF_AI_I2S_ATTR_S  stI2sAttr;    /**<I2S Attribute*/ /**<CNcomment:I2S属性*/
+        HI_UNF_AI_HDMI_ATTR_S stHDMIAttr;   /**<HDMI Attribute*/ /**<CNcomment:HDMI属性*/
+    } unAttr;
+} HI_UNF_AI_ATTR_S;
+
+/**Defines AI Delay attribute */
+/**CNcomment:定义AI延迟属性*/
+typedef struct hiHI_UNF_AI_DELAY_S
+{
+    HI_U32                  u32DelayMs;    /**<buffer delay compensation(ms), Min Value is 20, Max Value depends on u32PcmFrameMaxNum, u32PcmSamplesPerFrame and enSampleRate in HI_UNF_AI_ATTR_S.
+                                                    MaxValue = u32PcmSamplesPerFrame * u32PcmFrameMaxNum * 1000 / enSampleRate. 
+                                                    MaxValue is equal to 320ms according to default HI_UNF_AI_ATTR_S*/ 
+                                                   /**<CNcomment:缓存中数据量延迟补偿控制(ms), 最小值为20ms，最大值依赖HI_UNF_AI_ATTR_S中的u32PcmFrameMaxNum，u32PcmSamplesPerFrame以及enSampleRate
+                                                    计算公式:MaxValue = u32PcmSamplesPerFrame * u32PcmFrameMaxNum * 1000 / enSampleRate，
+                                                    若根据默认HI_UNF_AI_ATTR_S，则最大值为320ms */
+    HI_BOOL                 bDelayMsAutoHold;  /**<if hold buffer delay compensation time automatically*/ /**<CNcomment:是否由AI_AO通路自动保持缓存数据量稳定在u32CompensationMs*/
+} HI_UNF_AI_DELAY_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+
+/******************************* API declaration *****************************/
+/** \addtogroup      AI */
+/** @{ */  /** <!--  【AI】 */
+
+/**
+\brief Initializes an AI device. CNcomment:初始化音频输入设备 CNend
+\attention \n
+Before calling the AI module, you must call this application programming interface (API). CNcomment:调用AI模块要求首先调用该接口 CNend
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AI_Init(HI_VOID);
+
+/**
+\brief Deinitializes an AI device. CNcomment:去初始化音频输入设备 CNend
+\attention \n
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment:成功  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AI_DeInit(HI_VOID);
+
+/**
+ \brief Obtains the default attributes of a AI port. CNcomment: 获取AI端口默认属性 CNend
+ \attention \n
+ \param[in] pstAttr Pointer to AI attributes CNcomment: AI属性指针 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \retval ::HI_ERR_AI_NULL_PTR   The pointer is null. CNcomment: 空指针 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_AI_GetDefaultAttr(HI_UNF_AI_E enAiPort, HI_UNF_AI_ATTR_S *pstAttr);
+
+/**
+ \brief Enables a AI port to create a AI handle. CNcomment: 打开AI Port，创建AI句柄 CNend
+ \attention \n
+Before calling the AI, you must call this API.\n
+CNcomment: 调用AI 模块需要首先调用该接口 CNend
+ \param[in] pstAttr CNcomment: Pointer to AI attributes AI属性指针 CNend
+ \param[in] phandle CNcomment: hAi Pointer to the AI handle AI句柄指针 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \retval ::HI_ERR_AI_NULL_PTR   The pointer is null. CNcomment: 空指针 CNend
+ \retval ::HI_ERR_AI_INVALID_PARA   The attribute parameters are incorrect. CNcomment: 属性参数错误 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_AI_Create(HI_UNF_AI_E enAiPort, HI_UNF_AI_ATTR_S *pstAttr, HI_HANDLE *phAI);
+
+/**
+ \brief Disable a AI port to destroy the handle. CNcomment: 关闭AI Port，销毁句柄 CNend
+ \attention \n
+ \param[in] hAi AI handle CNcomment: AI句柄 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \retval ::HI_ERR_AI_INVALID_PARA  The handle is incorrect. CNcomment: 句柄错误 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_AI_Destroy(HI_HANDLE hAI);
+
+/**
+ \brief Set the attributes of a AI port. CNcomment: 设置AI Port属性 CNend
+ \attention \n
+ \param[in] hAi AI handle CNcomment: AI句柄 CNend
+ \param[in] pstAttr  Pointer to AI attributes CNcomment: AI属性指针 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \retval ::HI_ERR_AI_NULL_PTR   The pointer is null. CNcomment: 空指针 CNend
+ \retval ::HI_ERR_AI_INVALID_ID   The handle is invalid. CNcomment: 非法句柄 CNend
+ \retval ::HI_ERR_AI_INVALID_PARA   The attribute parameters are incorrect. CNcomment: 属性参数错误 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+ HI_S32 HI_UNF_AI_SetAttr(HI_HANDLE hAI, HI_UNF_AI_ATTR_S *pstAttr);
+
+
+/**
+ \brief Obtains the attributes of a AI port. CNcomment: 获取AI Port属性 CNend
+ \attention \n
+ \param[in] hAi AI handle CNcomment: AI句柄 CNend
+ \param[out] pstAttr Pointer to AI attributes CNcomment: AI属性指针 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \retval ::HI_ERR_AI_NULL_PTR   The pointer is null. CNcomment: 空指针 CNend
+ \retval ::HI_ERR_AI_INVALID_ID   The handle is invalid. CNcomment: 非法句柄 CNend
+ \retval ::HI_ERR_AI_INVALID_PARA   The handle is incorrect. CNcomment: 句柄错误 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_AI_GetAttr(HI_HANDLE hAI, HI_UNF_AI_ATTR_S *pstAttr);
+
+
+/**
+\brief enable AI port. CNcomment: 使能AI通道 CNend
+\attention \n
+\param[in] AI handle CNcomment: AI句柄 CNend
+\param[in] bEnable      enable  .CNcomment:使能控制 CNend
+\retval ::HI_SUCCESS CNcomment: success.成功 CNend
+\retval ::HI_ERR_AI_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AI_INVALID_ID     The handle is invalid. CNcomment: 非法句柄 CNend
+\retval ::HI_ERR_AI_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_AI_SetEnable(HI_HANDLE hAI, HI_BOOL bEnable);
+
+/**
+\brief Obtains enable/disable status of AI port. CNcomment: 获取AI通道时能状态 CNend
+\attention \n
+\param[in] AI handle CNcomment: AI句柄 CNend
+\param[out] pbEnable enable/disable status AI port. CNcomment:AI通道时能状态 CNend
+\retval ::HI_SUCCESS CNcomment: success.成功 CNend
+\retval ::HI_ERR_AI_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AI_INVALID_ID     The handle is invalid. CNcomment: 非法句柄 CNend
+\retval ::HI_ERR_AI_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_AI_GetEnable(HI_HANDLE hAI, HI_BOOL *pbEnable);
+
+/**
+\brief set AI delay compensation. CNcomment: 设置AI缓存延迟补偿 CNend
+\attention \n
+\param[in] AI handle CNcomment: AI句柄 CNend
+\param[in] pstDelay  delay compensation .CNcomment:延迟补偿参数 CNend
+\retval ::HI_SUCCESS CNcomment: success.成功 CNend
+\retval ::HI_ERR_AI_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AI_INVALID_ID     The handle is invalid. CNcomment: 非法句柄 CNend
+\retval ::HI_ERR_AI_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_AI_SetDelay(HI_HANDLE hAI, const HI_UNF_AI_DELAY_S *pstDelay);
+
+/**
+\brief Obtains AI delay compensation. CNcomment: 获取AI缓存延迟补偿 CNend
+\attention \n
+\param[in] AI handle CNcomment: AI句柄 CNend
+\param[out] pstDelay delay compensation. CNcomment:延迟补偿参数 CNend
+\retval ::HI_SUCCESS CNcomment: success.成功 CNend
+\retval ::HI_ERR_AI_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AI_INVALID_ID     The handle is invalid. CNcomment: 非法句柄 CNend
+\retval ::HI_ERR_AI_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_AI_GetDelay(HI_HANDLE hAI, HI_UNF_AI_DELAY_S *pstDelay);
+
+/**
+\brief get frame buffer from AI. CNcomment: 获取声音帧存 CNend
+\attention \n
+Cast pcm data format  s32BitPerSample(16), u32Channels(2),bInterleaved(HI_TRUE), u32SampleRate(same as AI).
+\param[in] AI handle CNcomment: AI句柄 CNend
+\param[in] u32TimeoutMs     acquire timeout.CNcomment:获取超时 CNend
+\param[out] pstFrame        frame info.CNcomment:帧信息 CNend
+\retval ::HI_SUCCESS CNcomment: success.成功 CNend
+\retval ::HI_ERR_AI_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AI_INVALID_ID     The handle is invalid. CNcomment: 非法句柄 CNend
+\retval ::HI_ERR_AI_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_AI_AcquireFrame(HI_HANDLE hAI, HI_UNF_AO_FRAMEINFO_S *pstFrame, HI_U32 u32TimeoutMs);
+
+/**
+\brief Releases the frame buffer for AI . CNcomment: 释放声音帧存 CNend
+\attention \n
+\param[in] AI handle CNcomment: AI句柄 CNend
+\param[in] u32TimeoutMs     acquire timeout.CNcomment:释放超时 CNend
+\param[out] pstFrame        frame info.CNcomment:帧信息 CNend
+\retval ::HI_SUCCESS CNcomment: success.成功 CNend
+\retval ::HI_ERR_AI_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AI_INVALID_ID     The handle is invalid. CNcomment: 非法句柄 CNend
+\retval ::HI_ERR_AI_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_AI_ReleaseFrame(HI_HANDLE hAI, HI_UNF_AO_FRAMEINFO_S *pstFrame);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif  /*__HI_UNF_AI_H__*/
+
diff -uNr a/include/hi_unf_audio.h b/include/hi_unf_audio.h
--- a/include/hi_unf_audio.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_audio.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,238 @@
+/******************************************************************************
+
+  Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_audio.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/17
+  Description   :
+  History       :
+  1.Date        : 2009/12/17
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+
+#ifndef __HI_UNF_AUDIO_H__
+#define __HI_UNF_AUDIO_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#include "hi_common.h"
+#include "hi_audio_codec.h"
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      Audio_Common */
+/** @{ */  /** <!-- [Audio_Common] */
+
+/**CNcomment: 定义音频采样率枚举*/
+typedef enum hiUNF_SAMPLE_RATE_E
+{
+    HI_UNF_SAMPLE_RATE_UNKNOWN=0,       /**<Unknown*/ /**<CNcomment: 未知采样频率 */
+    HI_UNF_SAMPLE_RATE_8K    = 8000,    /**<8 kHz sampling rate*/ /**<CNcomment: 8K采样频率 */
+    HI_UNF_SAMPLE_RATE_11K   = 11025,   /**<11.025 kHz sampling rate*/ /**<CNcomment: 11.025K采样频率 */
+    HI_UNF_SAMPLE_RATE_12K   = 12000,   /**<12 kHz sampling rate*/ /**<CNcomment: 12K采样频率 */
+    HI_UNF_SAMPLE_RATE_16K   = 16000,   /**<16 kHz sampling rate*/ /**<CNcomment: 16K采样频率 */
+    HI_UNF_SAMPLE_RATE_22K   = 22050,   /**<22.050 kHz sampling rate*/ /**<CNcomment: 22.050K采样频率 */
+    HI_UNF_SAMPLE_RATE_24K   = 24000,   /**<24 kHz sampling rate*/ /**<CNcomment: 24K采样频率 */
+    HI_UNF_SAMPLE_RATE_32K   = 32000,   /**<32 kHz sampling rate*/ /**<CNcomment: 32K采样频率 */
+    HI_UNF_SAMPLE_RATE_44K   = 44100,   /**<44.1 kHz sampling rate*/ /**<CNcomment: 44.1K采样频率 */
+    HI_UNF_SAMPLE_RATE_48K   = 48000,   /**<48 kHz sampling rate*/ /**<CNcomment: 48K采样频率 */
+    HI_UNF_SAMPLE_RATE_88K   = 88200,   /**<88.2 kHz sampling rate*/ /**<CNcomment: 88.2K采样频率 */
+    HI_UNF_SAMPLE_RATE_96K   = 96000,   /**<96 kHz sampling rate*/ /**<CNcomment: 96K采样频率 */
+    HI_UNF_SAMPLE_RATE_176K  = 176400,  /**<176 kHz sampling rate*/ /**<CNcomment: 176K采样频率 */
+    HI_UNF_SAMPLE_RATE_192K  = 192000,  /**<192 kHz sampling rate*/ /**<CNcomment: 192K采样频率 */
+
+    HI_UNF_SAMPLE_RATE_BUTT
+} HI_UNF_SAMPLE_RATE_E;
+
+/**Defines the bit depth during audio sampling.*/
+/**CNcomment: 定义音频采样位宽枚举*/
+typedef enum hiUNF_BIT_DEPTH_E
+{
+    HI_UNF_BIT_DEPTH_UNKNOWN =0,/**<Unknown*/ /**<CNcomment: 未知采样位宽  */
+    HI_UNF_BIT_DEPTH_8  = 8,    /**< 8-bit depth*/ /**<CNcomment: 8位采样位宽  */
+    HI_UNF_BIT_DEPTH_16 = 16,   /**<16-bit depth*/ /**<CNcomment: 16位采样位宽 */
+    HI_UNF_BIT_DEPTH_18 = 18,   /**<18-bit depth*/ /**<CNcomment: 18位采样位宽 */
+    HI_UNF_BIT_DEPTH_20 = 20,   /**<20-bit depth*/ /**<CNcomment: 20位采样位宽 */
+    HI_UNF_BIT_DEPTH_24 = 24,   /**<24-bit depth*/ /**<CNcomment: 24位采样位宽 */
+    HI_UNF_BIT_DEPTH_32 = 32,   /**<32-bit depth*/ /**<CNcomment: 32位采样位宽 */
+
+    HI_UNF_BIT_DEPTH_BUTT
+} HI_UNF_BIT_DEPTH_E;
+
+/**Defines the mode of audio channels.*/
+/**CNcomment: 定义音频声道模式枚举*/
+typedef enum hiUNF_TRACK_MODE_E
+{
+    HI_UNF_TRACK_MODE_STEREO = 0,          /**<Stereo*/ /**<CNcomment: 立体声*/
+    HI_UNF_TRACK_MODE_DOUBLE_MONO,         /**<Data is output after being mixed in the audio-left channel and audio-right channel.*/ /**<CNcomment: 左右声道混合后输出*/
+    HI_UNF_TRACK_MODE_DOUBLE_LEFT,         /**<The audio-left channel and audio-right channel output the data of the audio-left channel.*/ /**<CNcomment: 左右声道输出左声道数据*/
+    HI_UNF_TRACK_MODE_DOUBLE_RIGHT,        /**<The audio-left channel and audio-right channel output the data of the audio-right channel.*/ /**<CNcomment: 左右声道输出右声道数据*/
+    HI_UNF_TRACK_MODE_EXCHANGE,            /**<Data is output after being exchanged in the audio-left channel and audio-right channel.*/ /**<CNcomment: 左右声道数据交换输出 */
+    HI_UNF_TRACK_MODE_ONLY_RIGHT,          /**<Only the data in the audio-right channel is output.*/ /**<CNcomment: 只输出右声道数据*/
+    HI_UNF_TRACK_MODE_ONLY_LEFT,           /**<Only the data in the audio-left channel is output.*/ /**<CNcomment: 只输出左声道数据*/
+    HI_UNF_TRACK_MODE_MUTED,               /**<Mute*/ /**<CNcomment: 静音*/
+
+    HI_UNF_TRACK_MODE_BUTT
+} HI_UNF_TRACK_MODE_E;
+
+/**Defines the attributes of the audio decoder.*/
+/**CNcomment: 定义音频解码器属性结构*/
+typedef struct hiUNF_ACODEC_ATTR_S
+{
+    HA_CODEC_ID_E        enType;                    /**<Audio decoder type*/ /**<CNcomment: 音频解码类型*/
+    HI_HADECODE_OPENPARAM_S stDecodeParam;   /**<Audio decoder parameter*/ /**<CNcomment: 音频解码参数*/
+} HI_UNF_ACODEC_ATTR_S;
+
+/**Defines the attributes of audio encoder.*/
+/**CNcomment: 定义音频编码器属性结构*/
+typedef struct hiUNF_AENC_ATTR_S
+{
+    HI_U32         enAencType;              /**<Audio encoder type*/ /**<CNcomment: 音频编码类型*/
+    HI_HAENCODE_OPENPARAM_S   sOpenParam;   /**<Audio encoder parameter*/ /**<CNcomment: 音频编码参数*/
+} HI_UNF_AENC_ATTR_S;
+
+/**Defines the information about audio streams.*/
+/**CNcomment: 定义音频码流信息结构*/
+typedef struct hiUNF_ACODEC_STREAMINFO_S
+{
+    HI_U32               enACodecType;     /**<Audio Codec type*/ /**<CNcomment: 音频Codec类型 HA_CODEC_ID_E*/
+    HI_U32               enSampleRate;     /**<Audio sampling rate*/ /**<CNcomment: 音频采样率*/
+    HI_UNF_BIT_DEPTH_E   enBitDepth;       /**<Bit depth during audio sampling*/ /**<CNcomment: 音频采样位宽*/
+    HI_U32               u32Channel;       /**<Audio output channel*//**<CNcomment: 音频输出声道数*/
+    HI_U32               u32BitRate;       /**<Audio bitrate*/ /**<CNcomment: 音频比特率*/
+    HA_FORMAT_E          enAudioFormat;    /**<Audio stream format*/ /**<CNcomment: 音频码流格式*/
+    HA_AUDIO_CHANNELMODE_E enChannelMode;  /**<Audio channel mode*/ /**<CNcomment: 音频声道模式*/
+    HI_BOOL              bLfePresent;      /**<Lfe present flag*/ /**<CNcomment: 是否存在重低音*/
+    HI_BOOL              bAtmos;           /**<Atmos stream flag*/ /**<CNcomment: 音频码流是否是Atmos*/
+} HI_UNF_ACODEC_STREAMINFO_S;
+
+/**Defines the I2S(Inter-IC Sound) mode.*/
+/**CNcomment: 定义音频I2S接口模式枚举*/
+typedef enum hiHI_UNF_I2S_MODE_E
+{
+    HI_UNF_I2S_STD_MODE = 0,     /**<I2S standard mode*/ /**<CNcomment: I2S标准模式*/
+    HI_UNF_I2S_PCM_MODE,         /**<pcm mode*/ /**<CNcomment: PCM模式*/
+    HI_UNF_I2S_TDM_MODE,         /**<TDM mode*/ /**<CNcomment: TDM模式*/
+
+    HI_UNF_I2S_MODE_BUTT
+} HI_UNF_I2S_MODE_E;
+
+/**Defines the I2S(Inter-IC Sound) master clock.*/
+/**CNcomment: 定义音频I2S接口工作时钟枚举*/
+typedef enum hiHI_UNF_I2S_MCLK_SEL_E
+{
+    HI_UNF_I2S_MCLK_128_FS = 0,      /* mclk 128*fs  */
+    HI_UNF_I2S_MCLK_256_FS,          /* mclk 256*fs */
+    HI_UNF_I2S_MCLK_384_FS,          /* mclk 384*fs */
+    HI_UNF_I2S_MCLK_512_FS,          /* mclk 512*fs */
+    HI_UNF_I2S_MCLK_768_FS,          /* mclk 768*fs */
+    HI_UNF_I2S_MCLK_1024_FS,         /* mclk 1024*fs */
+    HI_UNF_I2S_MCLK_BUTT
+} HI_UNF_I2S_MCLK_SEL_E;
+
+/**Defines the I2S(Inter-IC Sound) bclk clock.*/
+typedef enum hiHI_UNF_I2S_BCLK_SEL_E
+{
+     HI_UNF_I2S_BCLK_1_DIV = 1,           /* bclk=mclk/1  */
+     HI_UNF_I2S_BCLK_2_DIV = 2,           /* bclk=mclk/2  */
+     HI_UNF_I2S_BCLK_3_DIV = 3,           /* bclk=mclk/3  */
+     HI_UNF_I2S_BCLK_4_DIV = 4,           /* bclk=mclk/4  */
+     HI_UNF_I2S_BCLK_6_DIV = 6,           /* bclk=mclk/6  */
+     HI_UNF_I2S_BCLK_8_DIV = 8 ,          /* bclk=mclk/8  */
+     HI_UNF_I2S_BCLK_12_DIV= 12,          /* bclk=mclk/12 */
+     HI_UNF_I2S_BCLK_24_DIV= 24,          /* bclk=mclk/24 */
+     HI_UNF_I2S_BCLK_32_DIV= 32,          /* bclk=mclk/32 */
+     HI_UNF_I2S_BCLK_48_DIV= 48,          /* bclk=mclk/48 */
+     HI_UNF_I2S_BCLK_64_DIV= 64,          /* bclk=mclk/64 */
+     HI_UNF_I2S_BCLK_BUTT
+} HI_UNF_I2S_BCLK_SEL_E;
+
+/**Defines the I2S(Inter-IC Sound) channels.*/
+/**CNcomment: 定义音频I2S接口音频通道枚举*/
+typedef enum hiHI_UNF_I2S_CHNUM_E
+{
+    HI_UNF_I2S_CHNUM_1  = 1,
+    HI_UNF_I2S_CHNUM_2  = 2,              /* only work for I2S mode */
+    HI_UNF_I2S_CHNUM_8  = 8,              /* only work for I2S mode */
+    HI_UNF_I2S_CHNUM_16 = 16,             /* only work for TDM mode */
+
+    HI_UNF_I2S_BUTT,
+} HI_UNF_I2S_CHNUM_E;
+
+/**Defines the I2S(Inter-IC Sound) bit depth.*/
+typedef enum hiHI_UNF_I2S_BITDEPTH_E
+{
+    HI_UNF_I2S_BIT_DEPTH_16 = 16,
+    HI_UNF_I2S_BIT_DEPTH_24 = 24,         /* only work for I2S mode */
+} HI_UNF_I2S_BITDEPTH_E;
+
+/**Defines the I2S(Inter-IC Sound) data valid after frame sync clock at PCM mode .*/
+/**CNcomment: 定义音频I2S接口，数据有效延迟周期，仅PCM模式有效*/
+typedef enum hiHI_UNF_I2S_PCMDELAY_E
+{
+    HI_UNF_I2S_PCM_0_DELAY = 0,           /* 0  bclk cycles delay*/
+    HI_UNF_I2S_PCM_1_DELAY = 1,           /* 1  bclk cycles delay*/
+    HI_UNF_I2S_PCM_8_DELAY = 8,           /* 8  bclk cycles delay*/
+    HI_UNF_I2S_PCM_16_DELAY = 16,         /* 16 bclk cycles delay*/
+    HI_UNF_I2S_PCM_17_DELAY = 17,         /* 17 bclk cycles delay*/
+    HI_UNF_I2S_PCM_24_DELAY = 24,         /* 24 bclk cycles delay*/
+    HI_UNF_I2S_PCM_32_DELAY = 32,         /* 32 bclk cycles delay*/
+    HI_UNF_I2S_PCM_DELAY_BUTT
+} HI_UNF_I2S_PCMDELAY_E;
+
+/**Defines the I2S(Inter-IC Sound) attribute .*/
+/**CNcomment: 定义音频I2S接口配置属性*/
+typedef struct hiHI_UNF_I2S_ATTR_S
+{
+    HI_BOOL               bMaster;           /* HI_TRUE:master, HI_FALSE: slave */
+    HI_UNF_I2S_MODE_E     enI2sMode;
+    HI_UNF_I2S_MCLK_SEL_E enMclkSel;
+    HI_UNF_I2S_BCLK_SEL_E enBclkSel;
+    HI_UNF_I2S_CHNUM_E    enChannel;
+    HI_UNF_I2S_BITDEPTH_E enBitDepth;
+    HI_BOOL               bPcmSampleRiseEdge; /* only work for PCM mode. HI_TRUE:sample data at positive edge of bclk, HI_FALSE: sample data at  negative edge of bclk */
+    HI_UNF_I2S_PCMDELAY_E enPcmDelayCycle;    /* only work for PCM mode.  */
+} HI_UNF_I2S_ATTR_S;
+
+/**Defines the information about audio frames.*/
+/**CNcomment: 定义音频帧信息结构*/
+typedef struct hiUNF_AO_FRAMEINFO_S
+{
+    /** s32BitPerSample: (PCM) Data depth, and format of storing the output data
+          If the data depth is 16 bits, 16-bit word memory is used.
+          If the data depth is greater than 16 bits, 32-bit word memory is used, and data is stored as left-aligned data. That is, the valid data is at upper bits.
+     */
+    /**CNcomment: s32BitPerSample: (PCM) 数据位宽设置. 输出存放格式
+          等于16bit:   占用16bit word内存
+          大于16bit:   占用32bit word内存, 数据左对齐方式存放(有效数据在高位)
+     */
+    HI_S32  s32BitPerSample;       /**<Data depth*/ /**<CNcomment: 数据位宽*/
+    HI_BOOL bInterleaved;          /**<Whether the data is interleaved*/ /**<CNcomment: 数据是否交织*/
+    HI_U32  u32SampleRate;         /**<Sampling rate*/ /**<CNcomment: 采样率*/
+    HI_U32  u32Channels;           /**<Number of channels*/ /**<CNcomment: 通道数量*/
+    HI_U32  u32PtsMs;              /**<Presentation time stamp (PTS)*/ /**<CNcomment: 时间戳*/
+    HI_S32 *ps32PcmBuffer;         /**<Pointer to the buffer for storing the pulse code modulation (PCM) data*/ /**<CNcomment: PCM数据缓冲指针*/
+    HI_S32 *ps32BitsBuffer;        /**<Pointer to the buffer for storing the stream data*/ /**<CNcomment: 码流数据缓冲指针*/
+    HI_U32  u32PcmSamplesPerFrame; /**<Number of sampling points of the PCM data*/ /**<CNcomment: PCM数据采样点数量*/
+    HI_U32  u32BitsBytesPerFrame;  /**<IEC61937 data size*/ /**<CNcomment: IEC61937数据长度*/
+    HI_U32  u32FrameIndex;         /**<Frame ID*/ /**<CNcomment: 帧序号 */
+    HI_U32  u32IEC61937DataType;   /**<IEC61937 Data Type*/ /**<CNcomment: IEC61937数据类型标识，低8bit为IEC数据类型 */
+} HI_UNF_AO_FRAMEINFO_S;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_AUDIO_ H*/
diff -uNr a/include/hi_unf_avplay.h b/include/hi_unf_avplay.h
--- a/include/hi_unf_avplay.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_avplay.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,1639 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_avplay.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/21
+  Description   :
+  History       :
+  1.Date        : 2009/12/21
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+/**
+ * \file
+ * \brief Describes the information about the audio/video player (AVPLAY) module.
+          CNcomment:提供AVPLAY的相关信息 CNend
+ */
+#ifndef __HI_UNF_AVPLAY_H__
+#define __HI_UNF_AVPLAY_H__
+
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif
+
+/*********************************error  macro******************************************/
+/*************************** Structure Definition ****************************/
+/** \addtogroup      AVPLAY */
+/** @{ */  /** <!-- [AVPLAY] */
+
+/**Highest priority of the video decoder*/
+/**CNcomment:视频解码器的最大优先级 */
+#define HI_UNF_VCODEC_MAX_PRIORITY  16
+
+
+/**Defines the buffer ID required in an AVPLAY.*/
+/**CNcomment:定义AV播放器中需要的BufferID枚举类型 */
+typedef enum hiUNF_AVPLAY_BUFID_E
+{
+    HI_UNF_AVPLAY_BUF_ID_ES_VID  = 0,       /**<ID of the buffer for storing the video elementary streams (ESs) played by an AVPLAY*//**<CNcomment: AV播放器ES视频Buffer ID. */
+    HI_UNF_AVPLAY_BUF_ID_ES_AUD,            /**<ID of the buffer for storing the audio ESs played by an AVPLAY*//**<CNcommentAV播放器ES音频Buffer ID.*/
+    HI_UNF_AVPLAY_BUF_ID_ES_AUD_AD,         /**<ID of the buffer for storing the AD audio ESs played by an AVPLAY*//**<CNcommentAV播放器AD ES音频Buffer ID.*/
+    HI_UNF_AVPLAY_BUF_ID_ES_VID_HDR_BL,     /**<ID of the buffer for storing the HDR BL video elementary streams (ESs) played by an AVPLAY*//**<CNcomment: AV播放器HDR BL帧Buffer ID. */
+    HI_UNF_AVPLAY_BUF_ID_ES_VID_HDR_EL,     /**<ID of the buffer for storing the HDR EL video elementary streams (ESs) played by an AVPLAY*//**<CNcomment: AV播放器HDR EL帧Buffer ID. */
+    HI_UNF_AVPLAY_BUF_ID_ES_VID_HDR_DL,     /**<ID of the buffer for storing the HDR BL+EL video elementary streams (ESs) played by an AVPLAY*//**<CNcomment: AV播放器HDR BL+EL帧Buffer ID. */
+    HI_UNF_AVPLAY_BUF_ID_BUTT
+} HI_UNF_AVPLAY_BUFID_E;
+
+/**Defines the type of a media channel.*/
+/**CNcomment:定义媒体通道类型. */
+typedef enum hiUNF_AVPLAY_MEDIA_CHAN
+{
+    HI_UNF_AVPLAY_MEDIA_CHAN_AUD  = 0x01,  /**<Audio channel*//**<CNcomment: 音频通道 */
+    HI_UNF_AVPLAY_MEDIA_CHAN_VID  = 0x02,  /**<Video channel*//**<CNcomment: 视频通道 */
+
+    HI_UNF_AVPLAY_MEDIA_CHAN_BUTT = 0x8
+} HI_UNF_AVPLAY_MEDIA_CHAN_E;
+
+/**Defines the type of an input stream interface.*/
+/**CNcomment:定义数据输入流接口类型 */
+typedef enum hiUNF_AVPLAY_STREAM_TYPE_E
+{
+    HI_UNF_AVPLAY_STREAM_TYPE_TS = 0,   /**<Transport stream (TS)*//**<CNcomment:TS码流 */
+    HI_UNF_AVPLAY_STREAM_TYPE_ES,       /**<ES stream*//**<CNcomment:ES码流 */
+
+    HI_UNF_AVPLAY_STREAM_TYPE_BUTT
+} HI_UNF_AVPLAY_STREAM_TYPE_E;
+
+/**Defines the stream attributes.*/
+/**CNcomment:定义码流属性的结构体 */
+typedef struct hiUNF_AVPLAY_STREAM_ATTR_S
+{
+    HI_UNF_AVPLAY_STREAM_TYPE_E enStreamType;   /**<Stream type*//**<CNcomment:码流类型 */
+
+    HI_U32                      u32VidBufSize;  /**<Video buffer size*//**<CNcomment: 视频缓冲大小 */
+    HI_U32                      u32AudBufSize;  /**<Audio buffer size*//**<CNcomment: 音频缓冲大小 */
+
+} HI_UNF_AVPLAY_STREAM_ATTR_S;
+
+/**Supported synchronization control mode*/
+/**CNcomment:支持的同步控制模式 */
+typedef enum hiUNF_SYNC_REF_E
+{
+    HI_UNF_SYNC_REF_NONE = 0, /**<Free playing without synchronization*//**<CNcomment: 自由播放 */
+    HI_UNF_SYNC_REF_AUDIO,    /**<Audio-based synchronization*//**<CNcomment: 以音频为准 */
+    HI_UNF_SYNC_REF_VIDEO,    /**<Video-based synchronization*//**<CNcomment: 以视频为准 */
+    HI_UNF_SYNC_REF_PCR,      /**<Program Clock Reference (PCR)-based synchronization*//**<CNcomment: 以PCR（Program Clock Reference）为准 */
+    HI_UNF_SYNC_REF_SCR,      /**<System Clock Reference (SCR)-based synchronization*//**<CNcomment: 以SCR (System Clock Reference) 为准 */
+
+    HI_UNF_AVPLAY_SYNC_REF_BUTT
+} HI_UNF_SYNC_REF_E;
+
+/**Defines the status of a buffer.*/
+/**CNcomment:定义使用的缓冲区状态枚举类型 */
+typedef enum hiUNF_AVPLAY_BUF_STATE_E
+{
+    HI_UNF_AVPLAY_BUF_STATE_EMPTY = 0,   /**<The buffer is idle.*//**<CNcomment: 缓冲区空闲 */
+    HI_UNF_AVPLAY_BUF_STATE_LOW,         /**<The buffer usage is too low.*//**<CNcomment: 缓冲区占用率过低 */
+    HI_UNF_AVPLAY_BUF_STATE_NORMAL,      /**<The buffer works normally.*//**<CNcomment: 缓冲区使用正常 */
+    HI_UNF_AVPLAY_BUF_STATE_HIGH,        /**<The buffer usage is too high.*//**<CNcomment: 缓冲区占用率过高 */
+    HI_UNF_AVPLAY_BUF_STATE_FULL,        /**<The buffer is full.*//**<CNcomment: 缓冲区已满 */
+
+    HI_UNF_AVPLAY_BUF_STATE_BUTT
+}HI_UNF_AVPLAY_BUF_STATE_E;
+
+/**Defines the type of pts channel.*/
+/** CNcomment:定义PTS通道类型 */
+typedef enum hiUNF_SYNC_PTS_CHAN_E
+{
+    HI_UNF_SYNC_PTS_CHAN_VID,   /**<Video pts channel.*//**<CNcomment:视频PTS通道 */
+    HI_UNF_SYNC_PTS_CHAN_AUD,   /**<Audio pts channel.*//**<CNcomment:音频PTS通道 */
+    HI_UNF_SYNC_PTS_CHAN_PCR,   /**<Pcr channel.*//**<CNcomment:PCR通道 */
+
+    HI_UNF_SYNC_PTS_CHAN_BUTT
+}HI_UNF_SYNC_PTS_CHAN_E;
+
+/**Defines the parameters of pts jump.*/
+/** CNcomment:定义PTS跳变参数的结构体 */
+typedef struct hiUNF_SYNC_PTSJUMP_PARAM_S
+{
+    HI_UNF_SYNC_PTS_CHAN_E  enPtsChan;  /**<Pts channel.*//**<CNcomment:PTS通道 */
+    HI_BOOL                 bLoopback;  /**<Loopback or not.*//**<CNcomment:是否环回 */
+    HI_U32                  u32FirstPts;/**<The first pts.*//**<CNcomment:第一个PTS */
+    HI_U32                  u32FirstValidPts;/**<The first valid pts.*//**<CNcomment:第一个有效PTS */
+    HI_U32                  u32CurSrcPts;   /**<The current src pts.*//**<CNcomment:当前原始PTS */
+    HI_U32                  u32CurPts;      /**<The current pts.*//**<CNcomment:当前PTS */
+    HI_U32                  u32LastSrcPts;  /**<The last src pts.*//**<CNcomment:上一个原始PTS */
+    HI_U32                  u32LastPts;     /**<The last pts.*//**<CNcomment:上一个PTS */
+}HI_UNF_SYNC_PTSJUMP_PARAM_S;
+
+typedef enum hiUNF_SYNC_PROC_E
+{
+    HI_UNF_SYNC_PROC_DISCARD,       /**<*Discard*//**<CNcomment:丢帧*/
+    HI_UNF_SYNC_PROC_REPEAT,        /**<*Repeat*//**<CNcomment:重复帧*/
+    HI_UNF_SYNC_PROC_PLAY,          /**<*Play*//**<CNcomment:播放*/
+    HI_UNF_SYNC_PROC_QUICKOUTPUT,   /**<*Quickoutput*//**<CNcomment:快输出*/
+    HI_UNF_SYNC_PROC_TPLAY,         /**<*Tplay*//**<CNcomment:特技播放*/
+    HI_UNF_SYNC_PROC_CONTINUE,      /**<*Continue*//**<CNcomment:继续*/
+    HI_UNF_SYNC_PROC_BLOCK,         /**<*Block*//**<CNcomment:阻塞*/
+
+    HI_UNF_SYNC_PROC_BUTT
+}HI_UNF_SYNC_PROC_E;
+
+typedef struct hiUNF_SYNC_VID_TPLAYTIME_S
+{
+    HI_U32              u32PrivDispTime;    /**<This displaytime is for pvr smooth tplay*//**<CNcomment:此显示时间适用于pvr流畅播放*/
+    HI_U32              u32Pts;             /**<The fram info PTS*//**<CNcomment:帧信息PTS*/
+    HI_UNF_SYNC_PROC_E  enSyncProc;         /**<*Sync results*//**<CNcomment:帧同步结果*/
+}HI_UNF_SYNC_VID_TPLAYTIME_S;
+
+/**Defines the parameters of synchronization status change*/
+/** CNcomment:定义同步状态变更参数的结构体 */
+typedef struct hiUNF_SYNC_STAT_PARAM_S
+{
+     HI_S32          s32VidAudDiff;     /**<The diffrence between video and audio frames*//**<CNcomment: 音视频差值 */
+     HI_S32          s32VidPcrDiff;     /**<The diffrence between video frame and pcr*//**<CNcomment: 视频PCR差值 */
+     HI_S32          s32AudPcrDiff;     /**<The diffrence between audio frame and pcr*//**<CNcomment: 音频PCR差值 */
+     HI_U32          u32VidLocalTime;   /**<Local video synchronization reference time*//**<CNcomment: 视频本地时间 */
+     HI_U32          u32AudLocalTime;   /**<Local audio synchronization reference time*//**<CNcomment: 音频本地时间 */
+     HI_U32          u32PcrLocalTime;   /**<Local pcr synchronization reference time*//**<CNcomment: PCR本地时间 */
+}HI_UNF_SYNC_STAT_PARAM_S;
+
+/**Defines the parameters of pcr and stc info*/
+/** CNcomment:定义PCR 和STC信息的结构体 */
+typedef struct hiUNF_SYNC_PCR_STC_INFO_S
+{
+     HI_U64          u64PcrValue;     /**<the value of PCR*//**<CNcomment:PCR值 */
+     HI_U64          u64StcValue;     /**<The value of STC*//**<CNcomment:STC值 */
+}HI_UNF_SYNC_PCR_STC_INFO_S;
+
+/*Type of the event callback function*/
+/**CNcomment: 事件回调函数类型 */
+typedef enum hiUNF_AVPLAY_EVENT_E
+{
+    HI_UNF_AVPLAY_EVENT_EOS,                   /**<The end of stream (EOS) operation is performed, NULL*//**<CNcomment: EOS执行结束, NULL.*/
+    HI_UNF_AVPLAY_EVENT_STOP,                  /**<The stop operation is performed, NULL*//**<CNcomment: STOP执行结束, NULL.*/
+    HI_UNF_AVPLAY_EVENT_RNG_BUF_STATE,         /**<Status change of the media buffer queue, HI_UNF_AVPLAY_BUF_STATE_E*//**<CNcomment: 媒体缓存队列状态变化, HI_UNF_AVPLAY_BUF_STATE_E.*/
+    HI_UNF_AVPLAY_EVENT_NORM_SWITCH,           /**<Standard switch, HI_UNF_NORMCHANGE_PARAM_S*//**<CNcomment: 制式切换, HI_UNF_NORMCHANGE_PARAM_S .*/
+    HI_UNF_AVPLAY_EVENT_FRAMEPACKING_CHANGE,   /**<3D Frame packing change, HI_UNF_VIDEO_FRAME_PACKING_TYPE_E*//**<CNcomment: 3D帧类型变化, HI_UNF_VIDEO_FRAME_PACKING_TYPE_E .*/
+    HI_UNF_AVPLAY_EVENT_NEW_VID_FRAME,         /**<New video frame will be rendered, indicates the new video frame that can be sent to display, HI_UNF_VIDEO_FRAME_INFO_S*//**<CNcomment: 新送显视频帧, HI_UNF_VIDEO_FRAME_INFO_S .*/
+    HI_UNF_AVPLAY_EVENT_NEW_AUD_FRAME,         /**<New audio frame, HI_UNF_AO_FRAMEINFO_S*//**<CNcomment: 新音频帧, HI_UNF_AO_FRAMEINFO_S .*/
+    HI_UNF_AVPLAY_EVENT_NEW_USER_DATA,         /**<New video user data, HI_UNF_VIDEO_USERDATA_S*//**<CNcomment: 新视频用户数据, HI_UNF_VIDEO_USERDATA_S .*/
+    HI_UNF_AVPLAY_EVENT_GET_AUD_ES,            /**<New audio ES data, HI_UNF_ES_BUF_S*//**<CNcomment: 新音频ES数据, HI_UNF_ES_BUF_S .*/
+    HI_UNF_AVPLAY_EVENT_IFRAME_ERR,            /**<I frame decode error*//**<CNcomment: 解码I帧错误 .*/
+    HI_UNF_AVPLAY_EVENT_SYNC_PTS_JUMP,         /**<Pts Jump, HI_UNF_SYNC_PTSJUMP_PARAM_S * *//**<CNcomment: PTS跳变, HI_UNF_SYNC_PTSJUMP_PARAM_S * .*/
+    HI_UNF_AVPLAY_EVENT_SYNC_STAT_CHANGE,      /**<Synchronization status change, HI_UNF_SYNC_STAT_PARAM_S * *//**<CNcomment: 同步状态变更, HI_UNF_SYNC_STAT_PARAM_S * .*/
+    HI_UNF_AVPLAY_EVENT_VID_BUF_STATE,         /**<Status change of the media buffer queue, HI_UNF_AVPLAY_EVENT_VID_BUF_STATE*//**<CNcomment: 视频缓存队列状态变化, HI_UNF_AVPLAY_EVENT_VID_BUF_STATE */
+    HI_UNF_AVPLAY_EVENT_AUD_BUF_STATE,         /**<Status change of the media buffer queue, HI_UNF_AVPLAY_EVENT_AUD_BUF_STATE*//**<CNcomment: 音频缓存队列状态变化, HI_UNF_AVPLAY_EVENT_AUD_BUF_STATE */
+    HI_UNF_AVPLAY_EVENT_VID_UNSUPPORT,         /**<The video stream is unsupport*//**<CNcomment: 视频码流不支持*/
+    HI_UNF_AVPLAY_EVENT_VID_ERR_RATIO,         /**<frame error ratio *//**<CNcomment: 图像帧出错比例*/
+    HI_UNF_AVPLAY_EVENT_AUD_INFO_CHANGE,       /**<audio info change, HI_UNF_ACODEC_STREAMINFO_S *//**<CNcomment: 音频信息变化，HI_UNF_ACODEC_STREAMINFO_S*/
+    HI_UNF_AVPLAY_EVENT_AUD_UNSUPPORT,         /**<unsupported audio *//**<CNcomment: 不支持的音频*/
+    HI_UNF_AVPLAY_EVENT_AUD_FRAME_ERR,         /**<audio frame error *//**<CNcomment: 音频帧出错*/
+    HI_UNF_AVPLAY_EVENT_VID_ERR_TYPE,          /**<the setting vid codec type is error, HI_UNF_VCODEC_TYPE_E*//**<CNcomment: 设置的视频协议类型错误, HI_UNF_VCODEC_TYPE_E*/
+    HI_UNF_AVPLAY_EVENT_FIRST_FRAME_DISPLAYED, /**<the first deocded frame have been displayed out by the tv.*//**<CNcomment: 第一帧已被显示*/
+    HI_UNF_AVPLAY_EVENT_VID_ERR_FRAME,         /**<vid frame decode error.*/ /**<CNcomment: 解码视频帧错误*/
+    HI_UNF_AVPLAY_EVENT_STATUS_REPORT,         /**<avplay status info, HI_UNF_AVPLAY_STATUS_INFO_S*/ /**<CNcomment: 播放器状态信息*/
+    HI_UNF_AVPLAY_EVENT_VID_FRAME_INFO,        /**<Video frame status info, HI_UNF_VIDEO_FRM_STATUS_INFO_S*/ /**<CNcomment: 视频帧状态信息*/
+    HI_UNF_AVPLAY_EVENT_VID_START_POS,         /**<the peek frame first pts, HI_U32*/ /**<CNcomment: peek帧pts, HI_U32*/
+    HI_UNF_AVPLAY_EVENT_FRAME_DISPLAY_TIME,    /**<Estimated time of display, HI_UNF_VIDEO_FRM_DISPLAY_TIME_S*/ /**<CNcomment: 视频帧预显示时间, HI_UNF_VIDEO_FRM_DISPLAY_TIME_S*/
+    HI_UNF_AVPLAY_EVENT_HDCPSTRATEGY_CHANGE,   /**<HDCP strategy change, HI_UNF_AVPLAY_HDCPSTRATEGY_PARAM_S*//**<CNcomment:HDCP 保护策略改变, HI_UNF_AVPLAY_HDCPSTRATEGY_PARAM_S .*/
+    HI_UNF_AVPLAY_EVENT_GET_PCR_STC_VALUE,     /**<Pcr and Stc info,HI_UNF_SYNC_PCR_STC_INFO_S*//**<CNcomment:Pcr和Stc值,HI_UNF_SYNC_PCR_STC_INFO_S.*/
+    HI_UNF_AVPLAY_EVENT_VID_LASTFRMFLAG,       /**<Report vid last frame flag*//**<CNcomment: 上报vdec最后一帧标志*/
+    HI_UNF_AVPLAY_EVENT_VID_TPLAYTIME_SYNC,    /**<Trick play is to adjust the video frame,HI_UNF_SYNC_VID_TPLAYTIME_S*//**<CNcomment: 特技播放时对视频帧进行调整,HI_UNF_SYNC_VID_TPLAYTIME_S*/
+    HI_UNF_AVPLAY_EVENT_NEW_PICTURE_DECODED, /**<New video frame is decoded, indicates that the video decoder present a new video frame，HI_UNF_VIDEO_FRAME_INFO_S*//**<CNcomment: 新解码视频帧, HI_UNF_VIDEO_FRAME_INFO_S .*/
+    HI_UNF_AVPLAY_EVENT_BUTT
+} HI_UNF_AVPLAY_EVENT_E;
+
+/**Mode of processing the buffer overflow*/
+/**CNcomment: 缓冲溢出处理类型  */
+typedef enum hiUNF_AVPLAY_OVERFLOW_E
+{
+    HI_UNF_AVPLAY_OVERFLOW_RESET,              /**<Reset during overflow*//**<CNcomment: 溢出时进行复位  */
+    HI_UNF_AVPLAY_OVERFLOW_DISCARD,            /**<Discard during overflow*//**<CNcomment: 溢出时进行丢弃  */
+    HI_UNF_AVPLAY_OVERFLOW_BUTT
+} HI_UNF_AVPLAY_OVERFLOW_E;
+
+/**Defines the parameters of HDCP output control */
+/**CNcomment: 定义HDCP输出控制相关参数*/
+typedef struct hiUNF_AVPLAY_HDCPSTRATEGY_PARAM_S
+{
+    HI_U32 u32ImageWidth;                     /**<Width of image allowed by HDCP strategy*/ /**<CNcomment: 当前码流 HDCP 策略允许输出的图像分辨率宽度(仅在tvp模式下有效)*/
+    HI_U32 u32ImageHeight;                    /**<Height of image allowed by HDCP strategy*/ /**<CNcomment: 当前码流 HDCP 策略允许输出的图像分辨率高度(仅在tvp模式下有效)*/
+}HI_UNF_AVPLAY_HDCPSTRATEGY_PARAM_S;
+
+/**Defines the type of the event callback function.*/
+/**CNcomment: 定义事件回调函数枚举类型 */
+typedef HI_S32 (*HI_UNF_AVPLAY_EVENT_CB_FN)(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_U32 u32Para);
+
+/**Defines the type of the event callback function.*/
+/**CNcomment: 定义事件回调函数枚举类型 */
+typedef HI_S32 (*HI_UNF_AVPLAY_EVENT_CB_FN64)(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_VOID *pPara);
+
+/**Defines the attribute of audio security.*/
+/**CNcomment: 定义音频安全属性结构体*/
+typedef struct hiUNF_AVPLAY_AUD_SECURITY_ATTR_S
+{
+    HI_BOOL    bEnable; /**<Audio dmx channel is security mode or not*//**<CNcomment: 音频DMX通道是否为安全模式*/
+}HI_UNF_AVPLAY_AUD_SECURITY_ATTR_S;
+
+/**Defines the attribute ID of an AVPLAY.*/
+/**CNcomment: 定义AV播放器属性ID枚举类型 */
+typedef enum hiUNF_AVPLAY_ATTR_ID_E
+{
+    HI_UNF_AVPLAY_ATTR_ID_STREAM_MODE = 0,  /**<Playing mode, HI_UNF_AVPLAY_ATTR_S*//**<CNcomment: 播放模式, HI_UNF_AVPLAY_ATTR_S.*/
+
+    HI_UNF_AVPLAY_ATTR_ID_ADEC,             /**<Audio attribute, HI_UNF_ACODEC_ATTR_S*//**<CNcomment: 音频属性, HI_UNF_ACODEC_ATTR_S.*/
+    HI_UNF_AVPLAY_ATTR_ID_VDEC,             /**<Video attribute, HI_UNF_VCODEC_ATTR_S*//**<CNcomment: 视频属性, HI_UNF_VCODEC_ATTR_S.*/
+
+    HI_UNF_AVPLAY_ATTR_ID_AUD_PID,          /**<Audio packet identifier (PID), HI_U32*//**<CNcomment: 音频PID, HI_U32.*/
+    HI_UNF_AVPLAY_ATTR_ID_VID_PID,          /**<Video PID, HI_U32*//**<CNcomment: 视频PID, HI_U32.*/
+    HI_UNF_AVPLAY_ATTR_ID_PCR_PID,          /**<PCR PID, HI_U32*//**<CNcomment: PCR PID, HI_U32.*/
+
+    HI_UNF_AVPLAY_ATTR_ID_SYNC,             /**<Synchronization attribute, HI_UNF_SYNC_ATTR_S*//**<CNcomment: 同步属性, HI_UNF_SYNC_ATTR_S.*/
+    HI_UNF_AVPLAY_ATTR_ID_AFD,              /**<Whether to enable the active format descriptor (AFD), HI_BOOL* *//**<CNcomment: AFD 是否开启， HI_BOOL * .*/
+    HI_UNF_AVPLAY_ATTR_ID_OVERFLOW,         /**<Overflow processing type, HI_UNF_AVPLAY_OVERFLOW_E* *//**<CNcomment: 溢出处理类型 , HI_UNF_AVPLAY_OVERFLOW_E * .*/
+
+    HI_UNF_AVPLAY_ATTR_ID_MULTIAUD,         /**<Multiple audio attribute,  HI_UNF_AVPLAY_MULTIAUD_ATTR_S **//**<CNcomment: 多音轨属性, HI_UNF_AVPLAY_MULTIAUD_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_FRMRATE_PARAM,    /**<Frame Rate Parameter, HI_UNF_AVPLAY_FRMRATE_PARAM_S * *//**<CNcomment:帧率参数,HI_UNF_AVPLAY_FRMRATE_PARAM_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_FRMPACK_TYPE,     /**<3D Frame Packing Type, HI_UNF_VIDEO_FRAME_PACKING_TYPE_E * *//**<CNcomment:3D帧的打包类型,HI_UNF_VIDEO_FRAME_PACKING_TYPE_E * .*/
+    HI_UNF_AVPLAY_ATTR_ID_LOW_DELAY,        /**<Low Delay Attr, HI_UNF_AVPLAY_LOW_DELAY_ATTR_S * *//**<CNcomment: 低延时属性 , HI_UNF_AVPLAY_LOW_DELAY_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_TVP,              /**<Trusted Video Path Attr, HI_UNF_AVPLAY_TVP_ATTR_S * *//**<CNcomment: 安全视频通路属性 , HI_UNF_AVPLAY_TVP_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_AD,               /**<MS12 Attr, HI_UNF_AVPLAY_AD_ATTR_S * *//**<CNcomment: MS12通路属性 , HI_UNF_AVPLAY_AD_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_HDR,              /**<HDR Attr, HI_UNF_AVPLAY_HDR_ATTR_S * *//**<CNcomment: HDR通路属性 , HI_UNF_AVPLAY_HDR_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_AUD_SECURITY,     /**<Dmx audio channel security mode, HI_UNF_AVPLAY_AUD_SECURITY_ATTR_S * *//**<CNcomment: 音频安全属性 , HI_UNF_AVPLAY_AUD_SECURITY_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_AD_PID,           /**<AD program id*/ /**<CNcomment: AD流PID,HI_S32*/
+    HI_UNF_AVPLAY_ATTR_ID_START_POSITION,   /**< Set video start play position, HI_UNF_AVPLAY_START_POSITION_ATTR_S * *//**<CNcomment: 设置视频起播点， HI_UNF_AVPLAY_START_POSITION_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_EXTERNAL_AUDIO,   /**< Set external audio codec attr, HI_UNF_ACODEC_ATTR_S * *//**<CNcomment: 设置外部音频属性， HI_UNF_ACODEC_ATTR_S * .*/
+    HI_UNF_AVPLAY_ATTR_ID_BUTT
+} HI_UNF_AVPLAY_ATTR_ID_E;
+
+/**Defines the stream type of HDR.*/
+/**CNcomment: 定义DOLBY HDR码流类型 */
+typedef enum hiUNF_AVPLAY_HDR_STREAM_TYPE_E
+{
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_DL_SINGLE_VES = 0,    /**<Dolby Vision Dual layer Single VES Format*/ /**<CNcomment: 单流双层格式.*/
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_DL_DUAL_VES,          /**<Dolby Vision Dual Layer Dual VES Format*/ /**<CNcomment: 双流双层格式.*/
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_SL_VES,               /**<Dolby Vision Single Layer VES Format*/ /**<CNcomment: 单流单层格式.*/
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_BUTT
+} HI_UNF_AVPLAY_HDR_STREAM_TYPE_E;
+
+/**Defines the low delay mode.*/
+/**CNcomment: 定义低延时模式 */
+typedef enum
+{
+    HI_UNF_AVPLAY_LOW_DELAY_FIRST = 0,      /**<Low delay first*/ /**<CNcomment: 低延时优先.*/
+    HI_UNF_AVPLAY_LOW_DELAY_SMOOTH_LEVEL1, /**<Smooth first ,the delaytime is longer than LOW_DELAY_FIRST mode*/ /**<CNcomment: 流畅性优先.会牺牲延时，相比FIRST延时更大*/
+    HI_UNF_AVPLAY_LOW_DELAY_SMOOTH_LEVEL2, /**<Smooth than level 1, the delaytime is longer than LOW_DELAY_FIRST mode*/ /**<CNcomment: 流畅性优于level1.会牺牲延时，相比FIRST延时更大*/
+    HI_UNF_AVPLAY_LOW_DELAY_MODE_BUTT
+} HI_UNF_AVPLAY_LOW_DELAY_MODE_E;
+
+/**Defines the attribute of low delay.*/
+/**CNcomment: 定义低延时属性结构体*/
+typedef struct hiUNF_AVPLAY_LOW_DELAY_ATTR_S
+{
+    HI_BOOL               bEnable;          /**<Is low delay enable or not*//**<CNcomment: 低延时是否使能*/
+    HI_UNF_AVPLAY_LOW_DELAY_MODE_E enMode;  /**<Low delay mode*//**<CNcomment: 低延时模式*/
+}HI_UNF_AVPLAY_LOW_DELAY_ATTR_S;
+
+/**Defines the attribute of trust video path.*/
+/**CNcomment: 定义安全视频通路属性结构体*/
+typedef struct hiUNF_AVPLAY_TVP_ATTR_S
+{
+    HI_BOOL               bEnable;  /**<Is trusted video path enable or not*//**<CNcomment: 安全视频通路是否使能*/
+}HI_UNF_AVPLAY_TVP_ATTR_S;
+
+/**Defines the audio/video synchronization .*/
+/**CNcomment: 定义音视频同步调整区间 */
+typedef struct hiUNF_SYNC_REGION_S
+{
+    HI_S32                s32VidPlusTime;        /**<Plus time range during video synchronization*//**<CNcomment: 视频同步超前的时间范围 */
+    HI_S32                s32VidNegativeTime;    /**<Negative time range during video synchronization*//**<CNcomment: 视频同步落后的时间范围 */
+    HI_BOOL               bSmoothPlay;           /**<Slow playing enable*//**<CNcomment: 慢放使能 */
+} HI_UNF_SYNC_REGION_S;
+
+/**Defines the audio/video synchronization attributes.*/
+/**CNcomment: 定义音视频同步属性 */
+typedef struct hiUNF_SYNC_ATTR_S
+{
+    HI_UNF_SYNC_REF_E     enSyncRef;             /**<Audio-based synchronization, PCR-based synchronization, and free playing without synchronization*//**<CNcomment: 音频为准，PCR为准，自由播放等 */
+    HI_UNF_SYNC_REGION_S  stSyncStartRegion;     /**<Synchronization start region*//**<CNcomment: 同步起调区间 */
+    HI_UNF_SYNC_REGION_S  stSyncNovelRegion;     /**<Synchronization exception region*//**<CNcomment: 同步异常区间 */
+    HI_S32                s32VidPtsAdjust;       /**<Video presentation time stamp (PTS) adjustment*//**<CNcomment: 视频PTS调整 */
+    HI_S32                s32AudPtsAdjust;       /**<Audio PTS adjustment*//**<CNcomment: 音频PTS调整 */
+
+    HI_U32                u32PreSyncTimeoutMs;   /**<Pre-synchronization timeout, in ms*//**<CNcomment: 预同步的超时时间，单位为毫秒 */
+    HI_BOOL               bQuickOutput;          /**<Fast output enable*//**<CNcomment: 快速输出使能 */
+} HI_UNF_SYNC_ATTR_S;
+
+/**Defines the playing attributes of an AVPLAY.*/
+/**CNcomment: 定义AV播放属性 */
+typedef struct hiUNF_AVPLAY_ATTR_S
+{
+    HI_U32                       u32DemuxId;   /**<ID of the DEMUX used by an AVPLAY*//**<CNcomment: AVPLAY所使用的DEMUX ID 仅当码流类型为TS时有效 */
+    HI_UNF_AVPLAY_STREAM_ATTR_S  stStreamAttr; /**<Stream attributes*//**<CNcomment: 码流属性 */
+} HI_UNF_AVPLAY_ATTR_S;
+
+/**Defines the synchronization status when an AVPLAY is running.*/
+/**CNcomment: 定义播放器运行状态信息中同步状态信息类型 */
+typedef struct hiUNF_SYNC_STATUS_S
+{
+    HI_U32 u32FirstAudPts;    /**<PTS of the first audio frame*//**<CNcomment: 第一个音频帧 PTS .*/
+    HI_U32 u32FirstVidPts;    /**<PTS of the first video frame*//**<CNcomment: 第一个视频帧 PTS .*/
+    HI_U32 u32LastAudPts;     /**<PTS of the last audio frame*//**<CNcomment: 最近播放的一个音频帧 PTS .*/
+    HI_U32 u32LastVidPts;     /**<PTS of the last video frame*//**<CNcomment: 最近播放的一个视频帧 PTS .*/
+    HI_S32 s32DiffAvPlayTime; /**<Playing time difference between audio and video frames*//**<CNcomment: 音视频 播放时差 .*/
+    HI_U32 u32PlayTime;       /**<Playing time*//**<CNcomment: 当前已播放时间 .*/
+    HI_U32 u32LocalTime;      /**<Local synchronization reference time*//**<CNcomment: 本地同步参考时间 .*/
+} HI_UNF_SYNC_STATUS_S;
+
+/**Defines the status of a media buffer.*/
+/**CNcomment:定义媒体缓冲区的状态信息 */
+typedef struct hiUNF_AVPLAY_BUF_STATUS_S
+{
+    HI_U32 u32BufId;                /**<Media buffer ID*//**<CNcomment: 媒体缓冲 标识 */
+    HI_U32 u32BufSize;              /**<Media buffer size*//**<CNcomment: 媒体缓冲大小 */
+    HI_U32 u32BufRptr;              /*Read pointer of the media buffer. This pointer is valid when TSs are being played.*//**<CNcomment: 媒体缓冲读指针,Ts播放时有效 */
+    HI_U32 u32BufWptr;              /*Write pointer of the media buffer. This pointer is valid when TSs are being played.*//**<CNcomment: 媒体缓冲写指针,Ts播放时有效 */
+    HI_U32 u32UsedSize;             /**<Used size of the media buffer*//**<CNcomment: 媒体缓冲已使用大小 */
+    HI_U32 u32CurrentAvailableSize; /**<Current available size of the media buffer for HI_UNF_AVPLAY_GetBuf()*//**<CNcomment: 媒体缓冲可使用大小 */
+    HI_U32 u32FrameBufTime;         /**<Frame buffer time*//**<CNcomment: 帧缓冲时间 */
+    HI_U32 u32FrameBufNum;          /**<The number of frames in frame buffer*//**<CNcomment: 帧缓冲数目 仅VIDEO有效 */
+    HI_BOOL bEndOfStream;           /**<Flag to indicate end of stream*//**<CNcomment: 缓冲中码流解码完毕标识 仅VIDEO有效 */
+} HI_UNF_AVPLAY_BUF_STATUS_S;
+
+/**Defines the playing status of an AVPLAY.*/
+/**CNcomment:定义AV的播放状态 */
+typedef enum hiUNF_AVPLAY_STATUS_E
+{
+    HI_UNF_AVPLAY_STATUS_STOP = 0,  /**<Stop*/      /**<CNcomment: 停止 */
+    HI_UNF_AVPLAY_STATUS_PREPLAY,   /**<Buffer*/    /**<CNcomment: 缓冲 */
+    HI_UNF_AVPLAY_STATUS_PLAY,      /**<Play*/      /**<CNcomment: 播放 */
+    HI_UNF_AVPLAY_STATUS_TPLAY,     /**<Trick play, such as fast forward and rewind*/   /**<CNcomment: TPlay, 快进快退 */
+    HI_UNF_AVPLAY_STATUS_PAUSE,     /**<Pause*/     /**<CNcomment: 暂停 */
+    HI_UNF_AVPLAY_STATUS_EOS,       /**<EOS*/       /**<CNcomment: 码流播放结束 */
+    HI_UNF_AVPLAY_STATUS_SEEK ,     /**<Seek play*/ /**<CNcomment: 定位播放 */
+
+    HI_UNF_AVPLAY_STATUS_BUTT
+} HI_UNF_AVPLAY_STATUS_E;
+
+/**Defines the output value after the playing status of an AVPLAY is queried.*/
+/**CNcomment:定义AV播放状态查询输出值类型 */
+typedef struct hiUNF_AVPLAY_STATUS_INFO_S
+{
+    HI_UNF_SYNC_STATUS_S       stSyncStatus;      /**<Synchronization status*//**<CNcomment: 同步状态 */
+    HI_UNF_AVPLAY_STATUS_E     enRunStatus;       /**<Running status*//**< CNcomment:运行状态 */
+    HI_U32                     u32VidFrameCount;  /**<Count of played video frames*//**<CNcomment: 视频已播放帧数 */
+    HI_U32                     u32AuddFrameCount; /**<Count of played audio frames*//**<CNcomment: 音频已播放帧数 */
+    HI_UNF_AVPLAY_BUF_STATUS_S stBufStatus[HI_UNF_AVPLAY_BUF_ID_BUTT]; /**<Status of the media buffer*//**<CNcomment:媒体缓冲状态 */
+    HI_U32                     u32VidErrorFrameCount; /**<Number of error frames during video decoding*/ /**<CNcomment: 视频解码错误帧数 */
+    HI_U32                     u32AudErrorFrameCount; /**<Number of error frames during audio decoding*//**<CNcomment: 音频解码错误帧数 */
+    HI_U32                     u32VidFrameDropCount; /**<Number of dropped video frame*/ /**<CNcomment: 视频播放期间丢帧个数*/
+    HI_U32                     u32AudFrameDropCount; /**<Number of dropped audio frame*/ /**<CNcomment: 音频播放期间丢帧个数*/
+} HI_UNF_AVPLAY_STATUS_INFO_S;
+
+/**Defines the information about the playing program streams to be queried.*/
+/**CNcomment: 定义播放节目流查询信息类型 */
+typedef struct hiUNF_AVPLAY_STREAM_INFO_S
+{
+    HI_UNF_VCODEC_STREAMINFO_S stVidStreamInfo; /**<Video stream information*//**<CNcomment:视频流信息 */
+    HI_UNF_ACODEC_STREAMINFO_S stAudStreamInfo; /**<Audio stream information*//**<CNcomment:音频流信息 */
+} HI_UNF_AVPLAY_STREAM_INFO_S;
+
+/**Defines the information about an I frame.*//**CNcomment:定义I帧数据信息类型 */
+typedef struct hiUNF_AVPLAY_I_FRAME_S
+{
+    HI_U8  *pu8Addr;    /**<User-state virtual address of a frame*//**<CNcomment:帧数据用户态虚拟地址 */
+    HI_U32 u32BufSize; /**<Frame size, in byte*//**<CNcomment:帧数据大小，单位字节 */
+    HI_UNF_VCODEC_TYPE_E enType;     /*Protocol type of a data segment*//**<CNcomment:该片数据的协议类型 */
+    HI_UNF_VCODEC_EXTATTR_U unExtAttr; /**<Extra attribute for video format vc1 and vp6*//**<CNcomment:为视频格式vc1和vp6添加的额外属性信息*/
+} HI_UNF_AVPLAY_I_FRAME_S;
+
+/**Defines the decoder type. The occupied memory varies according to decoders.*/
+/**CNcomment:定义解码器类型 不同类型的解码器占用内存不同 */
+typedef enum hiHI_UNF_VCODEC_DEC_TYPE_E
+{
+    HI_UNF_VCODEC_DEC_TYPE_NORMAL,            /**<Normal type.*//**<CNcomment:普通类型 */
+
+    /**<I frame decoding type. If an AVPLAY is used to decode I frames only (HI_UNF_AVPLAY_DecodeIFrame), you can select this type to reduce the memory usage.*/
+    /**<CNcomment:I帧解码类型 如果avplay仅用于I帧解码(HI_UNF_AVPLAY_DecodeIFrame) 设置为此类型可以节省内存 */
+    HI_UNF_VCODEC_DEC_TYPE_ISINGLE,
+
+    HI_UNF_VCODEC_DEC_TYPE_BUTT
+}HI_UNF_VCODEC_DEC_TYPE_E;
+
+/**Defines the level of the protocol supported by the decoder. This value affects the number of frame buffers allocated by the normal decoder.
+The greater the value, the more the required frame buffers.*/
+/**CNcomment:定义解码器支持的协议级别 影响NORMAL类型解码器分配的帧存个数 值越大需要的帧存数目越多 */
+typedef enum hiHI_UNF_VCODEC_PRTCL_LEVEL_E
+{
+    HI_UNF_VCODEC_PRTCL_LEVEL_MPEG = 0,     /**<All protocols except MVC *//**<CNcomment:除MVC外的所有协议 */
+    HI_UNF_VCODEC_PRTCL_LEVEL_H264 = 1,     /**<Same as HI_UNF_VCODEC_PRTCL_LEVEL_MPEG now *//**<CNcomment:和HI_UNF_VCODEC_PRTCL_LEVEL_MPEG相同*/
+    HI_UNF_VCODEC_PRTCL_LEVEL_MVC,
+    HI_UNF_VCODEC_PRTCL_LEVEL_BUTT
+}HI_UNF_VCODEC_PRTCL_LEVEL_E;
+
+/**Defines the attributes when an AVPLAY enables the video decoder. The settings affect the memory occupied by the video decoder and decoding performance.*/
+/**CNcomment:定义AV播放器打开视频解码器时属性设置结构体 影响视频解码器占用内存大小及解码能力 */
+typedef struct hiHI_UNF_AVPLAY_OPEN_OPT_S
+{
+    HI_UNF_VCODEC_DEC_TYPE_E    enDecType;       /**<Decoder type.*//**<CNcomment:解码器类型*/
+    HI_UNF_VCODEC_CAP_LEVEL_E   enCapLevel;      /**<Maximum resolution supported by the decoder. This value affects the size of each frame buffer.*//**<CNcomment:解码器支持的最大分辨率 影响每个帧存的大小 */
+    HI_UNF_VCODEC_PRTCL_LEVEL_E enProtocolLevel; /**<Supported protocol level. This value affects the number of frame buffers.*//**<CNcomment:支持的协议级别 影响帧存数目 */
+}HI_UNF_AVPLAY_OPEN_OPT_S;
+
+/**Defines the attribute of MS12.*/
+/**CNcomment: 定义音频MS12属性结构体*/
+typedef struct hiUNF_AVPLAY_AD_ATTR_S
+{
+    HI_BOOL             bAdEnble;       /**<whether enable ad service (on/off)*/ /**<CNcomment: 是否使能AD.*/
+    HI_BOOL             bAdToSomePort;  /**<whether enable ad only to some port,such as speaker/headphone etc*/ /**<CNcomment: 是否使能所有输出都混音，默认为false.*/
+    HI_U32              u32AdPid;       /**<AD program id*/ /**<CNcomment: AD流PID.*/
+    HI_S16              s16AdBalance;   /**<AD Balance 0~-100 AD Volume attenuation percentage. 0~100 master Volume attenuation percentage*/ /**<CNcomment: 0~-100 辅音音量衰减百分比, 0~100 主音量衰减百分比*/
+} HI_UNF_AVPLAY_AD_ATTR_S;
+
+/**Defines the attribute of HDR.*/
+/**CNcomment: 定义HDR属性结构体*/
+typedef struct hiUNF_AVPLAY_HDR_ATTR_S
+{
+    HI_BOOL                           bEnable;          /**<Is Dolby HDR enable or not*/ /**<CNcomment: Dolby HDR是否使能.*/
+    HI_UNF_AVPLAY_HDR_STREAM_TYPE_E   enHDRStreamType;  /**<Dolby Vision VES Format*/ /**<CNcomment: Dolby HDR流类型.*/
+    HI_UNF_VCODEC_TYPE_E              enElType;         /**<Video encoding type*/ /**<CNcomment: EL视频编码类型*/
+    HI_UNF_AVPLAY_OPEN_OPT_S          stElCodecOpt;     /**<Video decoding option*/ /**<CNcomment: 视频解码能力级设置*/
+    HI_BOOL                           bCompatible;      /**<Dolby frame is compatible or not.*/ /**<CNcomment: Dolby帧是否兼容.*/
+} HI_UNF_AVPLAY_HDR_ATTR_S;
+
+/**Defines the video display mode after an AVPLAY is stopped.*/
+/**CNcomment:定义AV播放器停止时视频显示模式 */
+typedef enum hiUNF_AVPLAY_STOP_MODE_E
+{
+    HI_UNF_AVPLAY_STOP_MODE_STILL = 0,  /**<The last frame is still after an AVPLAY is stopped.*//**<CNcomment:stop后保留最后一帧 */
+    HI_UNF_AVPLAY_STOP_MODE_BLACK = 1,  /**<The blank screen is displayed after an AVPLAY is stopped.*//**<CNcomment:stop后黑屏 */
+    HI_UNF_AVPLAY_STOP_MODE_BUTT
+} HI_UNF_AVPLAY_STOP_MODE_E;
+
+
+/**Defines the attributes when an AVPLAY is prestarted.*/
+/**CNcomment:定义AV播放器预启动时属性设置结构体 */
+typedef struct hiAVPLAY_PRESTART_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_PRESTART_OPT_S;
+
+/**Defines the attributes when an AVPLAY is started.*/
+/**CNcomment:定义AV播放器启动时属性设置结构体 */
+typedef struct hiAVPLAY_START_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_START_OPT_S;
+
+/**Defines the attributes when an AVPLAY is prestoped.*/
+/**CNcomment:定义AV播放器预停止时属性设置结构体 */
+typedef struct hiAVPLAY_PRESTOP_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_PRESTOP_OPT_S;
+
+
+/**Defines the attributes when an AVPLAY is stopped.*/
+/**CNcomment:定义AV播放器停止时属性设置结构体 */
+typedef struct hiAVPLAY_STOP_OPT_S
+{
+    /*
+         s32Timeout: end of stream timeout
+         s32Timeout = 0   Wait until streams are played in non-block mode, that is, the interface is returned immediately. CNcomment:非阻塞等待码流播放结束，立即返回 CNend
+         s32Timeout > 0   Block timeout, in ms, CNcomment:阻塞超时时间，单位为毫秒 CNend
+         s32Timeout = -1  Infinite wait,CNcomment:无限等待 CNend
+     */
+    HI_U32                    u32TimeoutMs;    /**<Timeout*//**<CNcomment:超时值 */
+    HI_UNF_AVPLAY_STOP_MODE_E enMode;          /**<Video display mode*//**<CNcomment:视频显示模式 */
+} HI_UNF_AVPLAY_STOP_OPT_S;
+
+/*Defines the attributes when an AVPLAY is paused.*/
+/**CNcomment:定义AV播放器暂停时属性设置结构体 */
+typedef struct hiAVPLAY_PAUSE_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_PAUSE_OPT_S;
+
+/**Defines the direction of tplay*/
+/**CNcomment:定义AV播放器TPLAY的方向 */
+typedef enum hiUNF_AVPLAY_TPLAY_DIRECT_E
+{
+    HI_UNF_AVPLAY_TPLAY_DIRECT_FORWARD,     /**<Tplay forward*//**<CNcomment: 向前TPLAY. */
+    HI_UNF_AVPLAY_TPLAY_DIRECT_BACKWARD,    /**<Tplay backward*//**<CNcomment: 向后TPLAY. */
+    HI_UNF_AVPLAY_TPLAY_DIRECT_BUTT
+
+} HI_UNF_AVPLAY_TPLAY_DIRECT_E;
+
+/**Defines the attributes when the playing mode of an AVPLAY is tplay.*/
+/**CNcomment:定义AV播放器TPALY时属性设置结构体 */
+typedef struct hiAVPLAY_TPLAY_OPT_S
+{
+    HI_UNF_AVPLAY_TPLAY_DIRECT_E    enTplayDirect;      /**<Tplay direction*//**<CNcomment: TPLAY方向 */
+    HI_U32                          u32SpeedInteger;    /**<Integral part of tplay speed*//**<CNcomment: TPLAY倍数的整数部分 */
+    HI_U32                          u32SpeedDecimal;    /**<Fractional part (calculated to three decimal places) of tplay speed*//**<CNcomment: TPLAY倍数的小数部分，保留3位小数 */
+} HI_UNF_AVPLAY_TPLAY_OPT_S;
+
+/**Defines the attributes when an AVPLAY is resumed.*/
+/**CNcomment:定义AV播放器恢复时属性设置结构体 */
+typedef struct hiAVPLAY_RESUME_OPT_S
+{
+    HI_U32       u32Reserved;
+} HI_UNF_AVPLAY_RESUME_OPT_S;
+
+/**Defines the attributes when an AVPLAY is reset.*/
+/**CNcomment:定义AV播放器复位时属性设置结构体 */
+typedef struct hiAVPLAY_RESET_OPT_S
+{
+    HI_U32        u32SeekPtsMs;   /**<clear these datas which pts is smaller than u32SeekPtsMs in buffer *//**<CNcomment:清空buffer内u32SeekPtsMs之前的数据 */
+} HI_UNF_AVPLAY_RESET_OPT_S;
+
+/**Defines the attributes when an AVPLAY is step.*/
+/**CNcomment:定义AV播放器步进时属性设置结构体 */
+typedef struct hiUNF_AVPLAY_STEP_OPT_S
+{
+    HI_U32       u32Reserved;
+}HI_UNF_AVPLAY_STEP_OPT_S;
+
+/**Defines the attributes when an AVPLAY is in Flushing Stream Status.*/
+/**CNcomment:定义AV播放器Flush Stream时属性设置结构体 */
+typedef struct hiUNF_AVPLAY_FLUSH_STREAM_OPT_S
+{
+    HI_U32          u32Reserved;
+}HI_UNF_AVPLAY_FLUSH_STREAM_OPT_S;
+
+/**Defines the attributes of multiple audio.*/
+/**CNcomment:定义多音轨属性结构体 */
+typedef struct hiUNF_AVPLAY_MULTIAUD_ATTR_S
+{
+    HI_U32                  u32PidNum;      /**<the number of Audio PID *//**< CNcomment:音频PID个数 */
+    HI_U32                  *pu32AudPid;    /**<Pointer to the array of audio PID*//**< CNcomment:指向PID数组的指针 */
+    HI_UNF_ACODEC_ATTR_S    *pstAcodecAttr; /**<Pointer to the array of audio attribute*//**< CNcomment:指向音频属性数组的指针 */
+}HI_UNF_AVPLAY_MULTIAUD_ATTR_S;
+
+/**Defines the source of frame rate.*/
+/**CNcomment: 定义帧率来源类型的枚举 */
+typedef enum hiUNF_AVPLAY_FRMRATE_TYPE_E
+{
+    HI_UNF_AVPLAY_FRMRATE_TYPE_PTS,         /**<Use the frame rate calculates from PTS*//**<CNcomment: 采用PTS计算帧率 */
+    HI_UNF_AVPLAY_FRMRATE_TYPE_STREAM,      /**<Use the frame rate comes from stream*//**<CNcomment: 采用码流信息中的帧率 */
+    HI_UNF_AVPLAY_FRMRATE_TYPE_USER,        /**<Use the frame rate set by user*//**<CNcomment: 采用用户设置的帧率 */
+    HI_UNF_AVPLAY_FRMRATE_TYPE_USER_PTS,    /**<Use the frame rate set by user until the 2nd I frame comes, then use the frame rate calculates from PTS*//**<CNcomment: 第二个I帧来之前采用用户设置的帧率，之后根据PTS计算帧率 */
+    HI_UNF_AVPLAY_FRMRATE_TYPE_BUTT
+}HI_UNF_AVPLAY_FRMRATE_TYPE_E;
+
+/**Defines the parameter of frame rate.*/
+/**CNcomment: 定义帧率属性参数的结构体 */
+typedef struct hiUNF_AVPLAY_FRMRATE_PARAM_S
+{
+    HI_UNF_AVPLAY_FRMRATE_TYPE_E    enFrmRateType;  /**<The source of frame rate*//**<CNcomment: 帧率来源类型 */
+    HI_UNF_VCODEC_FRMRATE_S         stSetFrmRate;   /**<Setting frame rate*//**<CNcomment: 设置的帧率 */
+}HI_UNF_AVPLAY_FRMRATE_PARAM_S;
+
+/**Defines commond to get vdec information, the parameter is HI_UNF_AVPLAY_VDEC_INFO_S.*/
+/**CNcomment: 获取解码器信息命令，参数对应类型为HI_UNF_AVPLAY_VDEC_INFO_S */
+#define HI_UNF_AVPLAY_GET_VDEC_INFO_CMD         0x20
+/**Defines commond to set TPLAY parameter, the parameter is HI_UNF_AVPLAY_TPLAY_OPT_S.*/
+/**CNcomment: 设置TPLAY参数命令，参数对应类型为HI_UNF_AVPLAY_TPLAY_OPT_S*/
+#define HI_UNF_AVPLAY_SET_TPLAY_PARA_CMD        0x21
+/**Defines commond to set special control information of stream, the parameter is HI_UNF_AVPLAY_CONTROL_INFO_S*/
+/**CNcomment: 用来设置一些码流的特殊控制信息，参数对应类型为HI_UNF_AVPLAY_CONTROL_INFO_S*/
+#define HI_UNF_AVPLAY_SET_CTRL_INFO_CMD         0x22
+
+/**Defines commond to set video sample type, HI_BOOL *, HI_TRUE: force Progressive, HI_FALSE: auto recognise Progressive or Interlance */
+/**CNcomment: 设置视频逐行信息, HI_TRUE: 强制逐行, HI_FALSE: 自动识别逐隔行*/
+#define HI_UNF_AVPLAY_SET_PROGRESSIVE_CMD       0x23
+
+/**Defines commond to set video color space, the parameter is HI_UNF_COLOR_SPACE_E*/
+/**CNcomment: 设置视频色彩空间, 参数对应类型为HI_UNF_COLOR_SPACE_E*/
+#define HI_UNF_AVPLAY_SET_COLORSPACE_CMD        0x24
+
+/**Defines commond to set dpb full control, HI_BOOL* ,HI_TRUE:force delete min poc frame when dpb is full,HI_FALSE:return error when dpb is full*/
+/**CNcomment:设置dpb满的时候的处理策略, 参数对应类型为HI_BOOL*/
+#define HI_UNF_AVPLAY_SET_DPBFULL_CTRL_CMD      0x25
+
+/***fix  videophone scene by AVPLAY ,  format MJPEG**/
+#define HI_UNF_AVPLAY_SET_SCENE_MODE_CMD        0x26
+
+/**Defines commond to keep SPS/PPS(VDEC) info in vfmw,set it before avplay reset. HI_BOOL* ,HI_TRUE:keep SPS/PPS,HI_FALSE:not keep*/
+/**CNcomment:保留SPS/PPS信息到VFMW, AVPLAY reset前调用。参数对应类型为HI_BOOL*/
+#define HI_UNF_AVPLAY_KEEP_SPS_PPS_INFO_CMD     0x27
+
+/***Defines commond to get vdec handle, the parameter is HI_U32**/
+#define HI_UNF_AVPLAY_GET_VDEC_HANDLE_CMD       0x28
+
+/**Defines commond to set video last frame, the parameter is HI_BOOL*/
+/**CNcomment: 设置VDEC最后一帧标志, 参数对应类型为HI_BOOL*/
+#define HI_UNF_AVPLAY_SET_VDEC_LSTFRAME_CMD     0x29
+
+/**Defines commond to set video last frame, the parameter is HI_U32,range is 0-0xffffffff*/
+/**CNcomment: 设置VDEC POC阈值, 参数对应类型为HI_U32 范围是0-0xffffffff*/
+#define HI_UNF_AVPLAY_SET_VDEC_POC_THRESHOLD_CMD 0x2c
+
+/**Defines the mode of videophone.*/
+/**CNcomment: 定义Videophone 场景类型的枚举 */
+typedef enum hiUNF_AVPLAY_SCENE_MODE_E
+{
+   HI_UNF_AVPLAY_SCENE_MODE_NORMAL,     /**<Normal scene of non-voip*//**<CNcomment: 非可视电视场景 */
+   HI_UNF_AVPLAY_SCENE_MODE_VIDEOPHONE_PREVIEW,   /**<Voip scene of the local end*//**<CNcomment: 可视电话近端场景 */
+   HI_UNF_AVPLAY_SCENE_MODE_VIDEOPHONE_REMOTE,   /**<Voip scene of the remote end*//**<CNcomment: 可视电话远端场景 */
+   HI_UNF_AVPLAY_SCENE_MODE_VIRTUAL_REAL,     /**<Virtual reality *//**<CNcomment: VR场景 */
+   HI_UNF_AVPLAY_SCENE_MODE_BUTT,
+} HI_UNF_AVPLAY_SCENE_MODE_E;
+
+
+/**Defines the type of AVPLAY invoke.*/
+/**CNcomment: 定义AVPLAY Invoke调用类型的枚举 */
+typedef enum hiUNF_AVPLAY_INVOKE_E
+{
+    HI_UNF_AVPLAY_INVOKE_ACODEC  = 0,   /**<Invoke commond to control audio codec*//**<CNcomment: 控制音频解码器的Invoke调用 */
+    HI_UNF_AVPLAY_INVOKE_VCODEC,        /**<Invoke commond to control video codec, HI_CODEC_VIDEO_CMD_S*//**<CNcomment: 控制视频解码器的Invoke调用 */
+    HI_UNF_AVPLAY_INVOKE_GET_PRIV_PLAYINFO, /**<Invoke commond to get private play infomation,the parameter is HI_UNF_AVPLAY_PRIVATE_STATUS_INFO_S*//**<CNcomment: 获取私有播放信息的Invoke调用， 参数为HI_UNF_AVPLAY_PRIVATE_STATUS_INFO_S * */
+    HI_UNF_AVPLAY_INVOKE_SET_DISP_OPTIMIZE_FLAG, /**Defines commond to set Display Optimize Flag, The Parameter is HI_U32, 1: Enable, 0: Disable */
+    HI_UNF_AVPLAY_INVOKE_GET_GLOBAL_PLAYINFO,   /**<Get global play information of avplay*//**<CNcomment: 获取AVPLAY全局播放信息 */
+    HI_UNF_AVPLAY_INVOKE_SET_SYNC_MODE,  /**<Invoke commond to set sync mode, HI_U32, 0 normal sync, 1 use sync replace frc*//**<CNcomment: 设置同步模式，HI_U32，0: 正常模式, 1: 使用同步替代帧率转换*/
+    HI_UNF_AVPLAY_INVOKE_SET_TPLAY_AUDIO_ENABLE, /**<Invoke commond to enable audio tplay(support 0.25/0.5/0.9/0.95/1.05/1.1/1.25/1.5/2), HI_U32, 1: enable audio tplay, 0: disable audio tplay*//**<CNcomment: 使能音频倍速播放(支持 0.25/0.5/0.9/0.95/1.05/1.1/1.25/1.5/2)，HI_U32，1: 使能音频倍速, 0: 去使能音频倍速*/
+    HI_UNF_AVPLAY_INVOKE_SET_TPLAY_RESET_ENABLE,  /**<Invoke commond to set tplay mode, HI_U32, 0 do not reset avplay, 1 reset avplay*//**<CNcomment:设置tplay 模式，HI_U32,  0: 不reset avplay, 1: reset avplay*/
+    HI_UNF_AVPLAY_INVOKE_BUTT
+} HI_UNF_AVPLAY_INVOKE_E;
+
+/**Defines the decoding information of video codec.*/
+/**CNcomment: 定义VDEC解码信息的结构体 */
+typedef struct hiUNF_AVPLAY_VDEC_INFO_S
+{
+    HI_U32                  u32DispFrmBufNum;   /**<the number of display frame*//**<CNcomment: 显示帧存个数 */
+    HI_U32                  u32FieldFlag;       /**<The encoding mode of image, 0 frame mode, 1 filed mode*//**<CNcomment: 图像编码方式, 0 帧模式，1 场模式 */
+    HI_UNF_VCODEC_FRMRATE_S stDecFrmRate;      /**<decoding frame rate*//**<CNcomment: 解码帧率 */
+    HI_U32                  u32UndecFrmNum;     /**<the number of undecoded frame*//**<CNcomment: 未解码帧个数 */
+}HI_UNF_AVPLAY_VDEC_INFO_S;
+
+/**Defines the private status information.*/
+/**CNcomment: 定义AVPLAY私有状态信息 */
+typedef struct hiUNF_AVPLAY_PRIVATE_STATUS_INFO_S
+{
+    HI_U32 u32LastPts;   /**<PTS of the last audio or video frame*/ /**<CNcomment: 最近播放的一个音频帧 PTS或视频PTS*/
+    HI_U32 u32LastPlayTime; /**< PlayTime of the last audio or video frame */ /**<CNcomment: 最近播放的一个音频帧 PlayTime或视PlayTime  */
+    HI_U32 u32DispOptimizeFlag; /**<Display Optimize Flag,1: Enable, 0: Disable*//**<CNcomment: 显示优化标志*/
+} HI_UNF_AVPLAY_PRIVATE_STATUS_INFO_S;
+
+/**Defines the special control information of stream.*/
+/**CNcomment: 定义特殊控制信息 */
+typedef struct hiUNF_AVPLAY_CONTROL_INFO_S
+{
+    HI_U32 u32IDRFlag;               /**<IDR frame Flag, 1 means IDR(instantaneous decoding refresh) frame.*/ /**<CNcomment: 是否是IDR(此帧前后无参考关系)帧，1表示是*/
+    HI_U32 u32BFrmRefFlag;           /**<Whether B frame is refer frame, 1 means B frame is refer frame.*/ /**<CNcomment: B帧是否是参考帧，1表示是*/
+    HI_U32 u32ContinuousFlag;        /**<Whether send frame is continusous. 1 means continusous*/ /**<CNcomment: 帧是否连续，1表示连续*/
+    HI_U32 u32BackwardOptimizeFlag;  /**<The Backward Optimize Flag*//**<CNcomment: 快退优化使能标志.*/
+    HI_U32 u32DispOptimizeFlag;      /**<Display Optimize Flag,1: Enable, 0: Disable*//**<CNcomment: 显示优化标志*/
+}HI_UNF_AVPLAY_CONTROL_INFO_S;
+
+/**Defines the parameter when the stream is send by HI_UNF_AVPLAY_PutBufEx.*/
+/**CNcomment: 定义按PutBufEx模式送码流的参数结构体 */
+typedef struct hiUNF_AVPLAY_PUTBUFEX_OPT_S
+{
+    HI_BOOL bEndOfFrm;      /**<whether this package of stream is the end of one frame*//**<CNcomment: 该包码流是否为一帧的最后一包 */
+    HI_BOOL bContinue;      /**<whether this package of stream is contnued with the last package*//**<CNcomment: 该包码流是否与之前连续 */
+}HI_UNF_AVPLAY_PUTBUFEX_OPT_S;
+
+typedef struct hiUNF_AVPLAY_GLOBAL_PLAY_INFO_S
+{
+    HI_U32 u32ContentCount;
+} HI_UNF_AVPLAY_GLOBAL_PLAY_INFO_S;
+
+typedef struct hiUNF_AVPLAY_VIDEO_FRAME_INFO_S
+{
+    HI_U32                              u32Width;           /**<Width of the source picture*/ /**<CNcomment: 原始图像宽*/
+    HI_U32                              u32Height;          /**<Height of the source picture*/ /**<CNcomment: 原始图像高*/
+    HI_U32                              u32AspectWidth;     /**<aspect ratio: width*/ /**<CNcomment:宽高比之宽值 */
+    HI_U32                              u32AspectHeight;    /**<aspect ratio: height*/ /**<CNcomment:宽高比之高值 */
+    HI_U32                              u32fpsInteger;     /**<Integral part of the frame rate (in frame/s)*/ /**<CNcomment: 码流的帧率的整数部分, fps */
+    HI_U32                              u32fpsDecimal;     /**<Fractional part (calculated to three decimal places) of the frame rate (in frame/s)*/
+    HI_BOOL                             bProgressive;       /**<Sampling type (progressive or interlaced)*/ /**<CNcomment: 采样方式(逐行/隔行) */
+    HI_UNF_VIDEO_FRAME_PACKING_TYPE_E   enFramePackingType; /**<3D frame packing type*/
+} HI_UNF_AVPLAY_VIDEO_FRAME_INFO_S;
+
+/**Defines the avplay video start position .*/
+/**CNcomment: 视频起播点属性 */
+typedef struct hiUNF_AVPLAY_START_POSITION_ATTR_S
+{
+    HI_U32                              u32StartPosPts;     /**<Start play Pts*/ /**<CNcomment: 起播Pts*/
+    HI_U32                              u32IdrPts;          /**<Instantaneous Decoding Refresh Pts */ /**<CNcomment: I帧Pts*/
+}HI_UNF_AVPLAY_START_POSITION_ATTR_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      AVPLAY */
+/** @{ */  /** <!-- [AVPLAY] */
+
+/**
+\brief Initializes the AVPLAY module.CNcomment:初始化AVPLAY模块 CNend
+\attention \n
+Before calling ::HI_UNF_AVPLAY_Create to create an AVPLAY, you must call this application programming interface (API).
+CNcomment 在调用AVPLAY模块其他接口前，要求首先调用本接口 CNend
+\param  N/A
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NOT_EXIST There is no AVPLAY. CNcomment:AVPLAY设备不存在 CNend
+\retval ::HI_ERR_AVPLAY_NOT_DEV_FILE  The file is not an AVPLAY file. CNcomment:AVPLAY非设备 CNend
+\retval ::HI_ERR_AVPLAY_DEV_OPEN_ERR  An AVPLAY fails to be started. CNcomment:AVPLAY打开失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Init(HI_VOID);
+
+/**
+\brief Deinitializes the AVPLAY module. CNcomment:去初始化AVPLAY模块 CNend
+\attention \n
+Please call this API function, before call anyother API of AVPLAY module.
+CNcomment: 在调用::HI_UNF_AVPLAY_Destroy接口销毁所有的播放器后，调用本接口 CNend
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT  The operation is invalid.  CNcomment:操作非法 CNend
+\retval ::HI_ERR_AVPLAY_DEV_CLOSE_ERR  An AVPLAY fails to be stopped. CNcomment:AVPLAY关闭失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_DeInit(HI_VOID);
+
+/**
+\brief Get video frame info. CNcomment:获取视频帧信息 CNend
+\attention \n
+\param[out] pstVideoFrameInfo  Pointer to video frame info. For details, see the description of ::HI_UNF_AVPLAY_VIDEO_FRAME_INFO_S. CNcomment:指针类型，视频帧信息，请参见::HI_UNF_AVPLAY_VIDEO_FRAME_INFO_S. CNend
+\param[in] hAvplay    AVPLAY handle . CNcomment:AVPLAY句柄 . CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR  The pointer is null.  CNcomment:指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_FAILURE  Failure. CNcomment:失败. CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetVideoFrameInfo(HI_HANDLE hAvplay, HI_UNF_AVPLAY_VIDEO_FRAME_INFO_S *pstVideoFrameInfo);
+
+/**
+\brief Obtains the default configuration of an AVPLAY. CNcomment:获取缺省的AV播放配置 CNend
+\attention \n
+When calling this API to set the enCfg parameter, you must enter correct mode of the player to be created.\n
+It is recommended that you call this API to obtain the default AVPLAY attributes before creating an AVPLAY. This avoids creation failures due to incomplete or incorrect parameters.
+CNcomment:调用本接口输入enCfg参数时，请正确输入想要创建播放器模式\n
+创建AV播放器前建议调用本接口，获取到AV播放器默认属性，避免创建AV播放器时由于参数不全或参数错误导致播放器创建不成功现象 CNend
+\param[out] pstAvAttr  Pointer to AVPLAY attributes. For details, see the description of ::HI_UNF_AVPLAY_ATTR_S. CNcomment: 指针类型，AV播放属性，请参见::HI_UNF_AVPLAY_ATTR_S. CNend
+\param[in] enCfg       AVPLAY type. For details, see the description of ::HI_UNF_AVPLAY_STREAM_TYPE_E. CNcomment: AV播放的类型，请参见::HI_UNF_AVPLAY_STREAM_TYPE_E. CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetDefaultConfig(HI_UNF_AVPLAY_ATTR_S *pstAvAttr, HI_UNF_AVPLAY_STREAM_TYPE_E enCfg);
+
+/**
+\brief Registers a dynamic audio decoding library. CNcomment:注册音频动态解码库 CNend
+\attention \n
+\param[in] pFileName Name of the file in the audio decoding library CNcomment:音频解码库文件名 CNend
+\retval ::HI_SUCCESS  Success CNcomment:成功 CNend
+\retval ::HI_FAILURE Failure CNcomment:失败 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR  The input pointer is null. CNcomment:输入指针为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RegisterAcodecLib(const HI_CHAR *pFileName);
+
+/**
+\brief Registers a dynamic video decoding library. CNcomment:注册视频动态解码库 CNend
+\attention \n
+\param[in] pFileName Name of the file in the video decoding library CNcomment:视频解码库文件名 CNend
+\retval ::HI_SUCCESS  Success CNcomment:成功 CNend
+\retval ::HI_FAILURE Failure CNcomment:失败 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR  The input pointer is null. CNcomment:输入指针为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RegisterVcodecLib(const HI_CHAR *pFileName);
+
+/**
+\brief Searches for registered dynamic audio decoding libraries based on the audio format.
+CNcomment:根据音频格式, 查找注册音频动态解码库 CNend
+\attention \n
+\param[in] enFormat Audio format CNcomment:音频格式 CNend
+\param[out] penDstCodecID If an audio decoding library is found, its codec ID is returned.
+CNcomment:成功则返回音频解码库CodecID CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE Failure CNcomment:失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_FoundSupportDeoder(const HA_FORMAT_E enFormat,HI_U32 * penDstCodecID);
+
+
+/**
+\brief Sets private commands for a dynamic audio decoding library. These commands are used to call ha_codec.
+CNcomment:设置私有命令给音频动态解码库, 调用ha_codec 方法  CNend
+HI_HA_ERRORTYPE_E (*DecSetConfig)(HI_VOID * hDecoder, HI_VOID * pstConfigStructure);
+\attention \n
+\param[in] enDstCodecID  The audio Codec ID  CNcomment:音频解码库ID CNend
+\param[in] pPara  Attribute structure CNcomment:属性结构 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE Failure CNcomment:失败 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR  The input pointer is null. CNcomment:输入指针为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_ConfigAcodec(const HI_U32 enDstCodecID, HI_VOID *pPara);
+
+/**
+\brief Creates an AVPLAY. CNcomment:创建AV播放器 CNend
+\attention \n
+Note the following point when setting the input parameter pstAttr: The stream source can be HI_UNF_AVPLAY_STREAM_TYPE_ES (ESs input from the memory) or HI_UNF_AVPLAY_STREAM_TYPE_TS (ESs input from the memory and TSs input from the Tuner).
+CNcomment:输入属性参数pstAttr中有几点需要注意：码流源支持HI_UNF_AVPLAY_STREAM_TYPE_ES（内存输入ES流）、HI_UNF_AVPLAY_STREAM_TYPE_TS（内存输入TS流或TUNER输入TS 流）CNend
+\param[in]  pstAvAttr   Pointer to AVPLAY attributes. For details, see the description of ::HI_UNF_AVPLAY_ATTR_S. CNcomment:指针类型，AV播放属性，请参见::HI_UNF_AVPLAY_ATTR_S. CNend
+\param[out] phAvplay    Pointer to the handle of a created AVPLAY.CNcomment:指针类型，创建的AV播放句柄 CNend
+\retval ::HI_SUCCESS  Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_CREATE_ERR       The AVPLAY fails to be created. CNcomment:AVPLAY创建失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Create(const HI_UNF_AVPLAY_ATTR_S *pstAvAttr, HI_HANDLE *phAvplay);
+
+/**
+\brief Destroys an AVPLAY. CNcomment:销毁AV播放器 CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Destroy(HI_HANDLE hAvplay);
+
+/**
+\brief Sets the attributes of an AVPLAY. CNcomment:设置AV播放属性 CNend
+\attention \n
+You can set the audio/video PID, audio/video decoding type, and synchronization mode by calling this API.\n
+Different attribute IDs correspond to different data types. For details, see the Note part of HI_UNF_AVPLAY_ATTR_ID_E. The attribute types of the pPara and enAttrID parameters must be the same.\n
+Before setting HI_UNF_AVPLAY_ATTR_ID_ADEC (audio decoding attribute) and HI_UNF_AVPLAY_ATTR_ID_VDEC (video decoding attribute),\n
+you must disable the audio channel or video channel. The new attributes take effect when you enable the audio channel or video channel again.
+CNcomment:调用本接口可实现设置音视频PID、设置音视频解码类型、设置同步方式等功能\n
+不同的属性ID对应的结构体请参见结构体HI_UNF_AVPLAY_ATTR_ID_E的[注意], pPara参数要与enAttrID对应的属性结构体类型保持一致\n
+当需要设置HI_UNF_AVPLAY_ATTR_ID_ADEC(音频解码属性),HI_UNF_AVPLAY_ATTR_ID_VDEC(视频解码属性)时\n
+需要先关闭音频或视频通道，再设置新属性，然后再重新打开音频或视频通道新属性才可以生效。 CNend
+\param[in] hAvplay         AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enAttrID        Attribute ID CNcomment:属性ID CNend
+\param[in] pPara  Data type corresponding to an attribute ID CNcomment:属性ID对应结构 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_SetAttr(HI_HANDLE hAvplay, HI_UNF_AVPLAY_ATTR_ID_E enAttrID, const HI_VOID *pPara);
+
+/**
+\brief Obtains the attributes of an AVPLAY. CNcomment:获取AV播放属性 CNend
+\attention \n
+N/A
+\param[in] hAvplay          AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enAttrID         Attribute ID CNcomment:属性ID CNend
+\param[in] pPara   Data type corresponding to an attribute ID, CNcomment:属性ID对应结构 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetAttr(HI_HANDLE hAvplay, HI_UNF_AVPLAY_ATTR_ID_E enAttrID, HI_VOID *pPara);
+
+/**
+\brief Decodes I frames. CNcomment:解码I帧码流 CNend
+\attention \n
+If pstCapPicture is null, the decoded I frames are displayed in the window,and do not need release memory; \n
+if pstCapPicture is not null, the information about I frames is reported, and need invoke ::HI_UNF_AVPLAY_ReleaseIFrame to release memory.
+You must stop the video decoder before calling this API. If I frames are being processed, do not enable the video decoder.
+CNcomment:当pstCapPicture为空指针时，解完的I帧将在window上显示，不需释放内存，如果非空，则不会显示而是将I帧信息上报,同时I帧处理完毕后，需要调用HI_UNF_AVPLAY_ReleaseIFrame来释放I帧
+调用该接口前，需停止视频解码器；I帧处理没有完成时，也不能启动视频解码器 CNend
+\param[in] hAvplay         AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] pstFrame        Pointer to frame attributes CNcomment:指针类型，帧数据属性 CNend
+\param[in] pstCapPicture   Pointer to the frame information CNcomment:指针类型，帧信息 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_DecodeIFrame(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_I_FRAME_S *pstFrame, HI_UNF_VIDEO_FRAME_INFO_S *pstCapPicture);
+
+
+/**
+\brief Release memory of I frame. CNcomment:释放I帧帧存 CNend
+\attention \n
+If you call HI_UNF_AVPLAY_DecodeIFrame with non-null pstCapPicture, you need call this API to release the memory.
+CNcomment:如果调用HI_UNF_AVPLAY_DecodeIFrame时pstCapPicture不为空，需要调用此接口来释放内存 CNend
+\param[in] hAvplay         AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] pstCapPicture   Pointer to the frame information CNcomment:指针类型，释放的帧信息 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_ReleaseIFrame(HI_HANDLE hAvplay, HI_UNF_VIDEO_FRAME_INFO_S *pstCapPicture);
+
+
+/**
+\brief Sets the mode of a video decoder. CNcomment:设置视频解码器的模式 CNend
+\attention \n
+This API is used in trick play mode. Before switching the mode to the trick play mode, you must enable a decoder to decode only I frames by calling this API.\n
+Before switching the mode to the normal mode, you also need to set the mode of a decoder to normal by calling this API.
+CNcomment:本接口主要应用在快进播放的场景，当切换到快进播放前，可以先调用本接口将解码器设置为只解I帧，\n
+当切换回正常播放前，先调用本接口将解码器设置为NORMAL。 CNend
+\param[in] hAvplay            AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enDecodeMode       Decoding mode CNcomment:解码模式 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_SetDecodeMode(HI_HANDLE hAvplay, HI_UNF_VCODEC_MODE_E enDecodeMode);
+
+/**
+\brief Registers an event on 32bit system. CNcomment:注册事件 CNend
+\attention \n
+N/A
+\param[in] hAvplay     AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enEvent     Event type enumeration CNcomment:枚举类型，表示事件类型 CNend
+\param[in] pfnEventCB  Pointer to the callback function corresponding to the registered event. CNcomment:回调函数指针，指向与注册事件对应的回调函数 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT     The AVPLAY is not initialized.  CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RegisterEvent(HI_HANDLE      hAvplay,
+                                   HI_UNF_AVPLAY_EVENT_E     enEvent,
+                                   HI_UNF_AVPLAY_EVENT_CB_FN pfnEventCB);
+/**
+\brief Registers an event on 64bit system. CNcomment:64位系统注册事件 CNend
+\attention \n
+N/A
+\param[in] hAvplay     AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enEvent     Event type enumeration CNcomment:枚举类型，表示事件类型 CNend
+\param[in] pfnEventCB  Pointer to the callback function corresponding to the registered event. CNcomment:回调函数指针，指向与注册事件对应的回调函数 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT     The AVPLAY is not initialized.  CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RegisterEvent64(HI_HANDLE      hAvplay,
+                                   HI_UNF_AVPLAY_EVENT_E     enEvent,
+                                   HI_UNF_AVPLAY_EVENT_CB_FN64 pfnEventCB);
+
+/**
+\brief Deregisters an event. CNcomment:取消注册事件 CNend
+\attention \n
+N/A
+\param[in] hAvplay   AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enEvent   Event type enumeration CNcomment:枚举类型，表示事件类型 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_UnRegisterEvent(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent);
+
+/**
+\brief Enables an AVPLAY channel. CNcomment:打开AV播放器通道 CNend
+\attention \n
+You can enable an audio channel and a video channel for each AVPLAY. If you only need to play videos or audios, you can enable the corresponding channel to save resources.
+CNcomment:每个AV播放器仅支持打开音视频通道各1个。如果只播放音频或视频，只需要打开相应通道，以节省资源。 CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enChn    Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:单独的音视频通道，请参见::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pPara    Pointer type. For details, see the description of ::HI_UNF_AVPLAY_OPEN_OPT_S. CNcomment:指针类型，请参见::HI_UNF_AVPLAY_OPEN_OPT_S. CNend
+    If enChn is set to HI_UNF_AVPLAY_MEDIA_CHAN_VID, this API is used to specify the maximum decoding performance of the video decoder.
+    If enChn is set to NULL, the maximum performance H264+HI_UNF_VCODEC_CAP_LEVEL_FULLHD is used by default.
+    The higher the configured decoding performance, the larger the required MMZ. It is recommended that you configure the performance as required.
+    CNcomment:enChn为HI_UNF_AVPLAY_MEDIA_CHAN_VID时用来指定视频解码器的最大解码能力。
+    如果设为NULL，将默认为最大能力: H264+HI_UNF_VCODEC_CAP_LEVEL_FULLHD。
+    配置支持的能力越大，需要的MMZ物理内存也就越大，建议按需配置即可。 CNend
+\retval ::HI_SUCCESS Success             CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_ChnOpen(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_VOID *pPara);
+
+/**
+\brief Disables an AVPLAY channel. CNcomment:关闭AV播放器通道 CNend
+\attention \n
+N/A
+\param[in] hAvplay   AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enChn     Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:单独的音视频通道，请参见::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_ChnClose(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn);
+
+/**
+\brief Start an AVPLAY to prepare play mode, which just demux ts stream. CNcomment:启动播放器进入仅仅做解复用TS的PREPLAY状态 CNend
+\attention \n
+After enabling channels and setting their attributes, you can call this API to start an AVPLAY to enable it to work in prepare play mode. The audios and videos can be prepared play separately or simultaneously.
+CNcomment:当完成通道打开和属性设置后，调用本接口启动预播放，进入PREPLAY状态。支持分别和同时启动音视频预播放。 CNend
+\param[in] hAvplay         AVPLAY handle  CNcomment:AV播放句柄 CNend
+\param[in] enChn           Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:单独的音视频通道，请参见::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pstPreStartOpt     Pointer used for expansion. You can set it to NULL. CNcomment:指针类型，待扩展使用，设为NULL即可. CNend
+\retval ::HI_SUCCESS  Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_PreStart(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_PRESTART_OPT_S *pstPreStartOpt);
+
+/**
+\brief Starts an AVPLAY. The AVPLAY is in play mode. CNcomment:启动播放器，进入PLAY状态 CNend
+\attention \n
+After enabling channels and setting their attributes, you can call this API to start an AVPLAY to enable it to work in play mode. The audios and videos can be played separately or simultaneously.
+CNcomment:当完成通道打开和属性设置后，调用本接口启动播放，进入PLAY状态。支持分别和同时启动音视频播放。 CNend
+\param[in] hAvplay         AVPLAY handle  CNcomment:AV播放句柄 CNend
+\param[in] enChn           Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:单独的音视频通道，请参见::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pstStartOpt     Pointer used for expansion. You can set it to NULL. CNcomment:指针类型，待扩展使用，设为NULL即可. CNend
+\retval ::HI_SUCCESS  Success CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Start(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_START_OPT_S *pstStartOpt);
+
+/**
+\brief Stop an AVPLAY to prepare stop mode,the interface is reserved for future use. CNcomment:停止AV播放使其进入PRESTOP状态,该接口保留备用 CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enChn    Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:单独的音视频通道，请参见::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pstPreStopOpt   Pointer to stop mode. For details, see the description of ::HI_UNF_AVPLAY_PRESTOP_OPT_S. CNcomment:指针类型，清屏模式，请参见::HI_UNF_AVPLAY_STOP_OPT_S. CNend
+\retval ::HI_ERR_AVPLAY_NOT_SUPPORT not support for the moment  CNcomment:暂不支持 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_PreStop(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_PRESTOP_OPT_S *pstPreStopOpt);
+
+/**
+\brief Stops an AVPLAY. Then the AVPLAY is in stop mode. CNcomment:停止AV播放，进入STOP状态 CNend
+\attention \n
+If you call this API, all selected channels stop playing. The playing audios and videos can be stopped separately or simultaneously.\n
+The parameter pstStopOpt->enMode takes effect only when a video channel is selected.\n
+If pstStopOpt->enMode is set to NULL or HI_UNF_AVPLAY_STOP_MODE_STILL, the last frame is kept still.\n
+If pstStopOpt->enMode is set to HI_UNF_AVPLAY_STOP_MODE_BLACK, the last frame is cleared, and the blank screen appears.\n
+When pstStopOpt->u32TimeoutMs is 0, the AVPLAY stops and this API is returned.\n
+When pstStopOpt->u32TimeoutMs is greater than 0, this API is blocked until the data in the buffer is used up.\n
+When pstStopOpt->u32TimeoutMs is greater than -1, this API is blocked until the data in the buffer is used up.\n
+To stop the audio or video separately when both the audio and video are enabled, you must set pstStopOpt->u32TimeoutMs to 0.
+CNcomment:调用本接口将停止所选通道的播放，支持分别和同时停止音视频播放。\n
+当所选通道中包含视频通道时，参数pstStopOpt->enMode才有意义。\n
+当pstStopOpt->enMode为空或者为HI_UNF_AVPLAY_STOP_MODE_STILL时，保留最后一帧视频图像。\n
+当pstStopOpt->enMode为HI_UNF_AVPLAY_STOP_MODE_BLACK时，清除视频最后一帧，视频输出为黑屏。\n
+当pstStopOpt->u32TimeoutMs为0时将离开停止播放并返回。\n
+当pstStopOpt->u32TimeoutMs>0时将阻塞相应时间，直到缓冲中的数据播完。\n
+当pstStopOpt->u32TimeoutMs=-1时将一直阻塞到缓冲中的数据播完。\n
+当音视频都处于开启状态时,要单独停止音频和视频，必须设置pstStopOpt->u32TimeoutMs为0. CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enChn    Separate audio channel or video channel. For details, see the description of ::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNcomment:单独的音视频通道，请参见::HI_UNF_AVPLAY_MEDIA_CHAN_E. CNend
+\param[in] pstStopOpt   Pointer to the clear screen mode. For details, see the description of ::HI_UNF_AVPLAY_STOP_OPT_S. CNcomment:指针类型，清屏模式，请参见::HI_UNF_AVPLAY_STOP_OPT_S. CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Stop(HI_HANDLE hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_E enChn, const HI_UNF_AVPLAY_STOP_OPT_S *pstStopOpt);
+
+/**
+\brief Pauses an AVPLAY. Then the AVPLAY is in pause mode. CNcomment:暂停AV播放，进入PAUSE状态 CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] pstPauseOpt  Pointer used for expansion. You can set it to NULL. CNcomment:指针类型，待扩展使用，设为为NULL即可 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Pause(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_PAUSE_OPT_S *pstPauseOpt);
+
+/**
+\brief Plays videos or audios in trick play mode. Then the AVPLAY is in TPLAY mode. CNcomment:倍速播放，进入TPLAY状态 CNend
+\attention \n
+pstTplayOpt->u32SpeedInteger is the integer part of speed, the range is 0-64.
+pstTplayOpt->u32SpeedDecimal is the decimal part of speed, the range is 0-999.
+CNcomment: pstTplayOpt->u32SpeedInteger为速度的整数部分，取值范围为0-64. CNend
+CNcomment: pstTplayOpt->u32SpeedDecimal为速度的小数部分，保留3位小数，取值范围为0-999. CNend
+\param[in] hAvplay  AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] pstTplayOpt   The pointer of Tplay parameter,For details, see the description of ::HI_UNF_AVPLAY_TPLAY_OPT_S . CNcomment:指针类型，TPLAY参数指针,请参见HI_UNF_AVPLAY_TPLAY_OPT_S结构体定义 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Tplay(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_TPLAY_OPT_S *pstTplayOpt);
+
+/**
+\brief Resumes an AVPLAY. Then the AVPLAY is in play mode. CNcomment:恢复AV播放，进入PLAY状态 CNend
+\attention \n
+By calling this API, you can resume an AVPLAY from the trick play mode or pause mode rather than the stop mode.
+CNcomment:本接口用来将倍速或暂停状态恢复为播放状态，但无法将停止状态恢复为播放状态。 CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] pstResumeOpt  Pointer used for expansion. You can set it to NULL. CNcomment:指针类型，待扩展使用，暂置为空即可 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Resume(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_RESUME_OPT_S *pstResumeOpt);
+
+/**
+\brief Resets an AVPLAY. In this case, the play mode is not changed. CNcomment:复位AV播放，不改变状态 CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] pstResetOpt   Pointer used for expansion. You can set it to NULL. CNcomment:指针类型，待扩展使用，设为为NULL即可 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Reset(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_RESET_OPT_S *pstResetOpt);
+
+/**
+\brief Step play. CNcomment:步进播放 CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] pstStepOpt   Pointer used for expansion. You can set it to NULL. CNcomment:指针类型，待扩展使用，设为为NULL即可 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Step(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_STEP_OPT_S *pstStepOpt);
+
+/**
+\brief Applies for a buffer for storing the streams played by an AVPLAY. CNcomment:申请AV播放的码流缓冲 CNend
+\attention \n
+This API is used only when you want to play the ESs obtained from Internet or local ESs.\n
+The pstData parameter is used to return the start address and size of the buffer applied for.\n
+If u32TimeOutMs is set to 0, it indicates that the waiting time is 0; if u32TimeOutMs is set to 0XFFFFFFFF, it indicates that the API waits for an infinite time; if u32TimeOutMs is set to other values, it indicates that the waiting time is u32TimeOutMs ms.\n
+If no buffer can be applied for during the block period, an error code indicating full buffer is returned.\n
+If u32TimeOutMs is set to 0, and no buffer can be applied for, it indicates that the audio and video buffers are full. In this case, you need to call the usleep(N*1000) function to release the CPU.
+Therefore, other threads can be scheduled.
+CNcomment:当播放网络或本地ES流时才需要使用本接口。\n
+参数pstData用来返回成功申请到的Buffer的首地址以及大小。\n
+u32TimeOutMs设置为0表示不等待，设置为0xffffffff表示一直等待，设置为其他值表示等待u32TimeOutMs毫秒。\n
+若超过阻塞时间，还无法申请到Buffer，则返回buffer满错误码\n
+u32TimeOutMs配置为0时，如果申请不到Buffer，说明此时音视频的Buffer已满，需要通过usleep(N*1000)释放cpu
+以使其它线程能够得到调度。 CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enBufId     Buffer queue ID CNcomment:缓冲队列ID CNend
+\param[in] u32ReqLen   Size of the buffer applied for CNcomment:申请缓存的大小 CNend
+\param[out] pstData    Pointer to the returned buffer CNcomment:返回缓存指针 CNend
+\param[in] u32TimeOutMs      Wait timeout, in ms CNcomment:等待超时时间，单位ms. CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetBuf(HI_HANDLE  hAvplay,
+                            HI_UNF_AVPLAY_BUFID_E enBufId,
+                            HI_U32                u32ReqLen,
+                            HI_UNF_STREAM_BUF_S  *pstData,
+                            HI_U32                u32TimeOutMs);
+
+/**
+\brief Updates the write pointer after data is successfully copied. CNcomment:拷贝数据成功后，更新写指针 CNend
+\attention \n
+After transmitting streams to the buffer applied for, you can call this API to update the write pointer of the audio and video buffers.\n
+If the transmitted streams do not contain PTS, u32ptsMs must be set to -1.
+CNcomment:在向申请到的缓冲区内送码流完毕后，调用本接口更新音视频缓冲区的写指针。\n
+如果本次送入的码流没有对应的PTS，u32ptsMs必须为-1。 CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enBufId     Buffer queue ID CNcomment:缓冲队列ID. CNend
+\param[in] u32ValidDataLen     Number of bytes that are written to the buffer CNcomment:实际写入缓冲区的字节数 CNend
+\param[in] u32PtsMs            PTS, in ms  CNcomment:时间戳,以毫秒为单位 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_PutBuf(HI_HANDLE hAvplay, HI_UNF_AVPLAY_BUFID_E enBufId,
+                         HI_U32 u32ValidDataLen, HI_U32 u32PtsMs);
+
+
+/**
+\brief Updates the write pointer after data is successfully copied. CNcomment:拷贝数据成功后，更新写指针 CNend
+\attention \n
+After transmitting streams to the buffer applied for, you can call this API to update the write pointer of the audio and video buffers.\n
+If the transmitted streams do not contain PTS, u32ptsMs must be set to -1.
+CNcomment:在向申请到的缓冲区内送码流完毕后，调用本接口更新音视频缓冲区的写指针, 本接口可由于一帧码流分多包送入。\n
+如果本次送入的码流没有对应的PTS，u32ptsMs必须为-1。 CNend
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] enBufId     Buffer queue ID CNcomment:缓冲队列ID CNend
+\param[in] u32ValidDataLen     Number of bytes that are written to the buffer CNcomment:实际写入缓冲区的字节数 CNend
+\param[in] u32PtsMs            PTS, in ms  CNcomment:时间戳,以毫秒为单位 CNend
+\param[in] pPutOpt   the extern parameter of PutBufEx, see the description of ::HI_UNF_AVPLAY_PUTBUFEX_OPT_S.CNcomment:PutBufEx的额外参数，请参见::HI_UNF_AVPLAY_PUTBUFEX_OPT_S. CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT      The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_PutBufEx(HI_HANDLE hAvplay, HI_UNF_AVPLAY_BUFID_E enBufId,
+                                       HI_U32 u32ValidDataLen, HI_U32 u32Pts, HI_UNF_AVPLAY_PUTBUFEX_OPT_S *pPutOpt);
+
+/**
+\brief Obtains the handle of the DMX audio channel used by an AVPLAY in TS mode. CNcomment:TS模式时获取AV播放器使用的DMX音频通道的Handle CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] phDmxAudChn    Pointer to the handle of a DMX audio channel CNcomment:DMX音频通道Handle指针 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetDmxAudChnHandle(HI_HANDLE hAvplay, HI_HANDLE *phDmxAudChn);
+
+/**
+\brief Obtains the handle of the DMX audio channel used by an AVPLAY in TS mode. CNcomment:TS模式时获取AV播放器使用的DMX辅音音频通道的Handle CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] phDmxAudChn    Pointer to the handle of a DMX audio channel CNcomment:DMX辅音音频通道Handle指针 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetDmxAdAudChnHandle(HI_HANDLE hAvplay, HI_HANDLE *phDmxAdAudChn);
+
+/**
+\brief Obtains the handle of the DMX video channel used by an AVPLAY in TS mode. CNcomment:TS模式时获取AV播放器使用的DMX视频通道的Handle. CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[in] phDmxVidChn    Pointer to the handle of a DMX video channel CNcomment:DMX视频通道Handle指针 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetDmxVidChnHandle(HI_HANDLE hAvplay, HI_HANDLE *phDmxVidChn);
+
+
+/**
+\brief Obtains the status information about an AVPLAY. CNcomment:获取AV播放状态信息 CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle  CNcomment:AV播放句柄 CNend
+\param[out] pstStatusInfo  Pointer to the status of an AVPLAY. For details, see the description of HI_UNF_AVPLAY_STATUS_INFO_S. CNcomment:指针类型，AV播放状态信息，请参见HI_UNF_AVPLAY_STATUS_INFO_S. CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetStatusInfo(HI_HANDLE          hAvplay,
+                                 HI_UNF_AVPLAY_STATUS_INFO_S *pstStatusInfo);
+
+
+/**
+\brief Obtains the information about audio and video streams. CNcomment:获取音视频码流信息 CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle  CNcomment:AV播放句柄 CNend
+\param[in] pstStreamInfo     Pointer to the information about audio and video streams. For details, see the description of HI_UNF_AVPLAY_STREAM_INFO_S. CNcomment:指针类型，音视频码流信息，请参见HI_UNF_AVPLAY_STREAM_INFO_S CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetStreamInfo(HI_HANDLE          hAvplay,
+                                   HI_UNF_AVPLAY_STREAM_INFO_S *pstStreamInfo);
+
+/**
+\brief Obtains the information audio spectrums. CNcomment:获取音频能量信息 CNend
+\attention \n
+N/A
+\param[in] hAvplay  AVPLAY handle  CNcomment:AV播放句柄 CNend
+\param[in] pSpectrum      Pointer to the array of audio spectrums. CNcomment:指针类型，音频能量信息数组指针 CNend
+\param[in] u32BandNum     Length of an audio spectrum array CNcomment:音频能量信息数组长度 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_OPT    The operation is invalid. CNcomment:操作非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetAudioSpectrum(HI_HANDLE hAvplay, HI_U16 *pSpectrum, HI_U32 u32BandNum);
+
+/**
+\brief Queries whether the AVPLAY buffer is empty. CNcomment:查询AVPLAY buffer是否已经为空 CNend
+\attention \n
+N/A
+\param[in] hAvplay        AVPLAY handle CNcomment:AV播放句柄 CNend
+\param[out] pbIsEmpty      Pointer type. This pointer indicates whether the AVPLAY buffer is empty (the playing ends). CNcomment:指针类型，指示buffer是否已经为空(播放完成) CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_IsBuffEmpty(HI_HANDLE hAvplay, HI_BOOL * pbIsEmpty);
+
+/**
+\brief Switch the demux audio channel CNcomment:切换音频DEMUX句柄 CNend
+\attention \n
+N/A
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] hNewDmxAud     New demux audio handle CNcomment:新DMX句柄 CNend
+\param[out] phOldDmxAud     Old  demux audio handle CNcomment:旧DMX句柄指针 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_SwitchDmxAudChn(HI_HANDLE hAvplay, HI_HANDLE hNewDmxAud, HI_HANDLE *phOldDmxAud);
+
+/**
+\brief Notify an AVPLAY the stream is end CNcomment:通知AVPLAY码流已经送完 CNend
+\attention \n
+Call this interface to notice AVPLAY when the last package of stream has been sent,
+then check whether the last frame has been output by eos event or by invoking ::HI_UNF_AVPLAY_IsBuffEmpty,
+this interface is only apply to ES mode.
+CNcomment: 当用户送完最后一包码流时，调用该接口通知AVPLAY，之后可以通过检测EOS事件或者调用::HI_UNF_AVPLAY_IsBuffEmpty判断最后一帧是否输出
+目前该接口仅适用于ES模式 CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] pstFlushOpt   Pointer used for expansion. You can set it to NULL.CNcomment:指针类型，待扩展使用，设为为NULL即可 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_FlushStream(HI_HANDLE hAvplay, const HI_UNF_AVPLAY_FLUSH_STREAM_OPT_S *pstFlushOpt);
+
+/**
+\brief AVPLAY private command invoking. CNcomment: AVPLAY私有命令调用 CNend
+\attention \n
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] enInvokeType  Type of private command invoking.CNcomment:私有命令调用类型 CNend
+\param[in] pPara         Pointer to the parameter of invoking. CNcomment:指针类型，指向Invoke调用的参数 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_Invoke(HI_HANDLE hAvplay, HI_UNF_AVPLAY_INVOKE_E enInvokeType, HI_VOID *pPara);
+
+/**
+\brief Accquire user dada. CNcomment: 获取用户数据 CNend
+\attention \n
+Only support Closed Caption Data.
+CNcomment: 仅支持CC数据 CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[out] pstUserData  user data.CNcomment:用户数据 CNend
+\param[out] penType      user data type. CNcomment:用户数据类型 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_AcqUserData(HI_HANDLE hAvplay, HI_UNF_VIDEO_USERDATA_S *pstUserData, HI_UNF_VIDEO_USERDATA_TYPE_E *penType);
+
+/**
+\brief Accquire user dada. CNcomment: 释放用户数据 CNend
+\attention \n
+Only support Closed Caption Data.
+CNcomment: 仅支持CC数据 CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] pstUserData  user data.CNcomment:用户数据 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RlsUserData(HI_HANDLE hAvplay, HI_UNF_VIDEO_USERDATA_S* pstUserData);
+
+/**
+\brief Extended interface for Accquire user data. CNcomment: 获取用户数据的扩展接口 CNend
+\attention \n
+support Closed Caption Data,Active Format Description.
+CNcomment: 支持CC、AFD数据 CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] enType      user data type. CNcomment:用户数据类型 CNend
+\param[out] pstUserData  user data.CNcomment:用户数据 CNend
+
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_AcqUserDataEx(HI_HANDLE hAvplay, HI_UNF_VIDEO_USERDATA_TYPE_E enType, HI_UNF_VIDEO_USERDATA_S *pstUserData);
+
+/**
+\brief Extended interface for Release user dada. CNcomment: 释放用户数据的扩展接口 CNend
+\attention \n
+Only support Closed Caption Data,Active Format Description..
+CNcomment: 仅支持CC、AFD数据 CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] enType      user data type. CNcomment:用户数据类型 CNend
+\param[in] pstUserData  user data.CNcomment:用户数据 CNend
+
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_RlsUserDataEx(HI_HANDLE hAvplay, HI_UNF_VIDEO_USERDATA_TYPE_E enType, HI_UNF_VIDEO_USERDATA_S *pstUserData);
+
+/**
+\brief set stream HDR information. CNcomment: 设置HDR信息接口 CNend
+\attention \n
+Only support VP9 HDR.
+CNcomment: 仅支持VP9 HDR 信息 CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] pstHdrInfo    HDR information. CNcomment:HDR信息 CNend
+\param[in] bPaddingHdrInfo    if need padding HDR information to frame information. CNcomment:是否需要填充HDR信息到帧信息中 CNend
+\param[in] u32PtsMs  current pts of HDR information.it must be set invaild(-1),when that can not available.CNcomment:当前HDR信息对应的pts CNend
+
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_SetHDRInfo(HI_HANDLE hAvplay, const HI_UNF_VIDEO_HDR_INFO_S* pstHdrInfo, HI_BOOL bPaddingHdrInfo, HI_U32 u32PtsMs);
+
+/**
+\brief Queries whether the AudioCodec is supported. CNcomment:查询 AudioCodec 是否支持 CNend
+\attention \n
+N/A
+\param[in] enCodecID        AudioCodec CNcomment:音频编解码器类型 CNend
+\param[out] pbSupport      Pointer support. This pointer indicates whether the AudioCodec is supported. CNcomment:指针类型，指示AudioCodec是否支持 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_IsAudioCodecSupport(const HA_CODEC_ID_E enCodecID, HI_BOOL* pbSupport);
+
+/**
+\brief Switch to external audio.  CNcomment:切换外部音频 CNend
+\attention \n
+N/A
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] bSwitchExternalAudio     whether switch to exteral audio:是否切换到外部音频 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_FAILUER     Call the function failed!. CNcomment:执行失败CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_SwitchToExternalAudio(HI_HANDLE hAvplay,HI_BOOL bSwitchExternalAudio);
+
+/**
+\brief Stc calibration by user.  CNcomment:STC 校正 CNend
+\attention \n
+N/A
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] StcPPM      stc ppm:STC校正PPM CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_FAILUER     Call the function failed!. CNcomment:执行失败CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_STCCalibration(HI_HANDLE hAvplay,HI_S32 StcPPM);
+
+/**
+\brief get stream HDR information. CNcomment: 获取HDR信息接口 CNend
+\attention \n
+Support getting HDR info.
+CNcomment: 支持获取 HDR 信息 CNend
+\param[in] hAvplay       AVPLAY handle CNcomment: AV播放句柄 CNend
+\param[in] pstHdrInfo    HDR information. CNcomment:HDR信息 CNend
+
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_AVPLAY_DEV_NO_INIT      The AVPLAY is not initialized. CNcomment:AVPLAY未初始化 CNend
+\retval ::HI_ERR_AVPLAY_NULL_PTR         The input pointer is null. CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AVPLAY_INVALID_PARA     The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_AVPLAY_GetHDRInfo(HI_HANDLE hAvplay, HI_UNF_VIDEO_HDR_INFO_S* pstHdrInfo);
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif
+
+#endif
diff -uNr a/include/hi_unf_cc.h b/include/hi_unf_cc.h
--- a/include/hi_unf_cc.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_cc.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,739 @@
+/******************************************************************************
+
+Copyright (C), 2012-2019, HiSilicon Technologies Co., Ltd.
+******************************************************************************
+File Name       : hi_unf_cc.h
+Version         : Initial draft
+Author          :
+Created Date    :
+Last Modified by:
+Description     :
+Function List   :
+Change History  :
+******************************************************************************/
+
+/**
+ * \file
+ * \brief Describes the information about CC module (CC).
+*/
+
+#ifndef _HI_UNF_CC_H_
+#define _HI_UNF_CC_H_
+
+#include "hi_type.h"
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/*****************************************************************************
+*                    Macro Definitions
+*****************************************************************************/
+#define ARIBCC_MAX_LANGUAGE 2
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      CC */
+/** @{*/  /** <!-- [CC]*/
+
+/**CC data type*//** CNcomment:CC数据类型分类 */
+typedef enum hiUNF_CC_DATA_TYPE_E
+{
+    HI_UNF_CC_DATA_TYPE_608,  /**<CC608*//**<CNcomment:CC608数据 */
+    HI_UNF_CC_DATA_TYPE_708,        /**<CC708*//**<CNcomment:CC708数据 */
+    HI_UNF_CC_DATA_TYPE_ARIB,       /**<ARIB CC*//**<CNcomment:ARIB CC数据 */
+    HI_UNF_CC_DATA_TYPE_BUTT
+}HI_UNF_CC_DATA_TYPE_E;
+
+/**708CC service channel*//** CNcomment:708CC的服务通道号*/
+typedef enum hiUNF_CC_708_SERVICE_NUM_E
+{
+    HI_UNF_CC_708_SERVICE1 = 0x1, /**<708CC service 1*//**<CNcomment:708CC服务1 */
+    HI_UNF_CC_708_SERVICE2,       /**<708CC service 2*//**<CNcomment:708CC服务2 */
+    HI_UNF_CC_708_SERVICE3,       /**<708CC service 3*//**<CNcomment:708CC服务3 */
+    HI_UNF_CC_708_SERVICE4,       /**<708CC service 4*//**<CNcomment:708CC服务4 */
+    HI_UNF_CC_708_SERVICE5,       /**<708CC service 5*//**<CNcomment:708CC服务5 */
+    HI_UNF_CC_708_SERVICE6,       /**<708CC service 6*//**<CNcomment:708CC服务6 */
+    HI_UNF_CC_708_SERVICE_BUTT
+}HI_UNF_CC_708_SERVICE_NUM_E;
+
+/**CC608 data type*//** CNcomment:CC608在line 21的数据类型分类 */
+typedef enum hiUNF_CC_608_DATATYPE_E
+{
+    HI_UNF_CC_608_DATATYPE_CC1,       /**<CC1*//**<CNcomment:CC1 */
+    HI_UNF_CC_608_DATATYPE_CC2,       /**<CC2*//**<CNcomment:CC2 */
+    HI_UNF_CC_608_DATATYPE_CC3,       /**<CC3*//**<CNcomment:CC3 */
+    HI_UNF_CC_608_DATATYPE_CC4,       /**<CC4*//**<CNcomment:CC4 */
+    HI_UNF_CC_608_DATATYPE_TEXT1,     /**<TEXT1*//**<CNcomment:TEXT1 */
+    HI_UNF_CC_608_DATATYPE_TEXT2,     /**<TEXT2*//**<CNcomment:TEXT2 */
+    HI_UNF_CC_608_DATATYPE_TEXT3,     /**<TEXT3*//**<CNcomment:TEXT3 */
+    HI_UNF_CC_608_DATATYPE_TEXT4,     /**<TEXT4*//**<CNcomment:TEXT4 */
+    HI_UNF_CC_608_DATATYPE_BUTT
+}HI_UNF_CC_608_DATATYPE_E;
+
+/**standard color*//** CNcomment:标准颜色 */
+typedef enum hiUNF_CC_COLOR_E
+{
+    HI_UNF_CC_COLOR_DEFAULT=0x00000000,       /**<default color*//**<CNcomment:默认颜色 */
+    HI_UNF_CC_COLOR_BLACK=0xff000000,         /**<black*//**<CNcomment:黑色 */
+    HI_UNF_CC_COLOR_WHITE=0xffffffff,         /**<white*//**<CNcomment:白色 */
+    HI_UNF_CC_COLOR_RED=0xffff0000,           /**<red*//**<CNcomment:红色 */
+    HI_UNF_CC_COLOR_GREEN=0xff00ff00,         /**<green*//**<CNcomment:绿色 */
+    HI_UNF_CC_COLOR_BLUE=0xff0000ff,          /**<blue*//**<CNcomment:蓝色 */
+    HI_UNF_CC_COLOR_YELLOW=0xffffff00,        /**<yellow*//**<CNcomment:黄色 */
+    HI_UNF_CC_COLOR_MAGENTA=0xffff00ff,       /**<magenta*//**<CNcomment:品红 */
+    HI_UNF_CC_COLOR_CYAN=0xff00ffff,          /**<cyan*//**<CNcomment:青色 */
+}HI_UNF_CC_COLOR_E;
+
+/**opacity*//** CNcomment:透明度 */
+typedef enum hiUNF_CC_OPACITY_E
+{
+    HI_UNF_CC_OPACITY_DEFAULT,         /**<default*//**<CNcomment:默认透明度 */
+    HI_UNF_CC_OPACITY_SOLID,           /**<opaque*//**<CNcomment:不透明 */
+    HI_UNF_CC_OPACITY_FLASH,           /**<flash*//**<CNcomment:闪烁 */
+    HI_UNF_CC_OPACITY_TRANSLUCENT,     /**<translucent*//**<CNcomment:半透明 */
+    HI_UNF_CC_OPACITY_TRANSPARENT,     /**<transparent*//**<CNcomment:透明 */
+    HI_UNF_CC_OPACITY_BUTT
+}HI_UNF_CC_OPACITY_E;
+
+/**justify*//** CNcomment:排版*/
+typedef enum hiUNF_CC_JUSTIFY_E
+{
+    HI_UNF_CC_JUSTIFY_LEFT,        /**<left*//**<CNcomment:居左 */
+    HI_UNF_CC_JUSTIFY_RIGHT,       /**<rigth*//**<CNcomment:居右 */
+    HI_UNF_CC_JUSTIFY_CENTER,      /**<center*//**<CNcomment:居中 */
+    HI_UNF_CC_JUSTIFY_FULL,        /**<full*//**<CNcomment:两端对齐 */
+    HI_UNF_CC_JUSTIFY_BUTT
+}HI_UNF_CC_JUSTIFY_E;
+
+/**word wrap*//** CNcomment:自动换行*/
+typedef enum hiUNF_CC_WORDWRAP_E
+{
+    HI_UNF_CC_WW_DISABLE,         /**<disable*//**<CNcomment:不自动换行 */
+    HI_UNF_CC_WW_ENABLE,          /**<enable*//**<CNcomment:自动换行 */
+    HI_UNF_CC_WW_BUTT
+}HI_UNF_CC_WORDWRAP_E;
+
+/**font style*//** CNcomment:字体风格 */
+typedef enum hiUNF_CC_FONTSTYLE_E
+{
+    HI_UNF_CC_FONTSTYLE_DEFAULT,         /**<default*//**<CNcomment:默认字体风格 */
+    HI_UNF_CC_FONTSTYLE_NORMAL,          /**<normal*//**<CNcomment:正常 */
+    HI_UNF_CC_FONTSTYLE_ITALIC,          /**<italic*//**<CNcomment:斜体 */
+    HI_UNF_CC_FONTSTYLE_UNDERLINE,       /**<underline*//**<CNcomment:下划线 */
+    HI_UNF_CC_FONTSTYLE_ITALIC_UNDERLINE,/**<italic&underline*//**<CNcomment:斜体并且带下滑线 */
+    HI_UNF_CC_FONTSTYLE_BUTT
+}HI_UNF_CC_FONTSTYLE_E;
+
+/**font size*//** CNcomment:字体大小 */
+typedef enum hiUNF_CC_FONTSIZE_E
+{
+    HI_UNF_CC_FONTSIZE_DEFAULT,       /**<default font size *//**<CNcomment:默认字体大小 */
+    HI_UNF_CC_FONTSIZE_SMALL,         /**<small*//**<CNcomment:小 */
+    HI_UNF_CC_FONTSIZE_STANDARD,      /**<standard*//**<CNcomment:标准 */
+    HI_UNF_CC_FONTSIZE_LARGE,         /**<large*//**<CNcomment:大 */
+    HI_UNF_CC_FONTSIZE_BUTT
+} HI_UNF_CC_FONTSIZE_E;
+
+typedef enum hiUNF_CC_ARIB_SCALE_E
+{
+    HI_UNF_CC_ARIB_SCALE_NORMAL,
+    HI_UNF_CC_ARIB_SCALE_HALF_ALL,
+    HI_UNF_CC_ARIB_SCALE_HALF_WIDTH,
+    HI_UNF_CC_ARIB_SCALE_DOUBLE_HEIGHT,
+    HI_UNF_CC_ARIB_SCALE_DOUBLE_WIDTH,
+    HI_UNF_CC_ARIB_SCALE_DOUBLE_ALL,
+    HI_UNF_CC_ARIB_SCALE_TINY,
+    HI_UNF_CC_ARIB_SCALE_BUTT
+}HI_UNF_CC_ARIB_SCALE_E;
+
+typedef enum tagUNF_CC_ARIB_PRTDIRECT_E
+{
+    HI_UNF_CC_ARIB_PRINT_HORIZONTAL,
+    HI_UNF_CC_ARIB_PRINT_VERTICAL,
+} HI_UNF_CC_ARIB_PRTDIRECT_E;
+
+/**font name*//** CNcomment:字体样式 */
+typedef enum  hiUNF_CC_FONTNAME_E
+{
+    HI_UNF_CC_FN_DEFAULT,                  /**<default *//**<CNcomment:默认字体样式 */
+    HI_UNF_CC_FN_MONOSPACED,               /**<monospaced*//**<CNcomment:monospaced字体 */
+    HI_UNF_CC_FN_PROPORT,                  /**<proport*//**<CNcomment:proport字体 */
+    HI_UNF_CC_FN_MONOSPACED_NO_SERIAFS,    /**<monospaced with no seriafs*//**<CNcomment:monospaced字体(无衬线) */
+    HI_UNF_CC_FN_PROPORT_NO_SERIAFS,       /**<proport with no seriafs*//**<CNcomment:proport字体(无衬线) */
+    HI_UNF_CC_FN_CASUAL,                   /**<casual*//**<CNcomment:casual字体 */
+    HI_UNF_CC_FN_CURSIVE,                  /**<cursive*//**<CNcomment:cursive字体 */
+    HI_UNF_CC_FN_SMALL_CAPITALS,           /**<small capitals*//**<CNcomment:小写字体 */
+    HI_UNF_CC_FN_BUTT
+}HI_UNF_CC_FONTNAME_E;
+
+/**font edge type*//** CNcomment:字体边缘类型 */
+typedef enum hiUNF_CC_EdgeType_E
+{
+    HI_UNF_CC_EDGETYPE_DEFAULT,            /**<default *//**<CNcomment:默认字体边缘类型 */
+    HI_UNF_CC_EDGETYPE_NONE,               /**<none edge type *//**<CNcomment:没有边缘 */
+    HI_UNF_CC_EDGETYPE_RAISED,             /**<raised *//**<CNcomment:边缘突起 */
+    HI_UNF_CC_EDGETYPE_DEPRESSED,          /**<depressed *//**<CNcomment:边缘凹下 */
+    HI_UNF_CC_EDGETYPE_UNIFORM,            /**<uniform *//**<CNcomment:边缘统一 */
+    HI_UNF_CC_EDGETYPE_LEFT_DROP_SHADOW,   /**<left drop shadow *//**<CNcomment:左下阴影 */
+    HI_UNF_CC_EDGETYPE_RIGHT_DROP_SHADOW,  /**<right drop shadow *//**<CNcomment:右下阴影 */
+    HI_UNF_CC_EDGETYPE_BUTT
+}HI_UNF_CC_EdgeType_E;
+
+/**display format of caption display screen*//** CNcomment:显示窗口的显示模式 */
+typedef enum hiUNF_CC_DF_E
+{
+    HI_UNF_CC_DF_720X480,       /**<caption display screen is 720*480*//**<CNcomment:显示窗口的宽高是720*480 */
+    HI_UNF_CC_DF_720X576,       /**<caption display screen is 720*576*//**<CNcomment:显示窗口的宽高是720*576 */
+    HI_UNF_CC_DF_960X540,       /**<caption display screen is 960*540*//**<CNcomment:显示窗口的宽高是960*540 */
+    HI_UNF_CC_DF_1280X720,      /**<caption display screen is 1280*720*//**<CNcomment:显示窗口的宽高是1280*720 */
+    HI_UNF_CC_DF_1920X1080,     /**<caption display screen is 1920*1080*//**<CNcomment:显示窗口的宽高是1920*1080 */
+    HI_UNF_CC_DF_BUTT
+} HI_UNF_CC_DF_E;
+
+/**CC display operation*//** CNcomment:CC显示操作 */
+typedef enum hiUNF_CC_OPT_E
+{
+     HI_UNF_CC_OPT_DRAWTEXT = 0x1, /**<draw text *//**<CNcomment:绘制文本 */
+     HI_UNF_CC_OPT_DRAWBITMAP,     /**<draw bitmap *//**<CNcomment:绘制位图 */
+     HI_UNF_CC_OPT_FILLRECT,       /**<fill rect *//**<CNcomment:填充矩形区域 */
+     HI_UNF_CC_OPT_UPDATE,        /**<Display buffer on the screen. *//**<CNcomment:将缓存数据立即绘制到屏幕上 */
+     HI_UNF_CC_OPT_DRAWLINE,        /**<draw line. *//**<CNcomment:画线*/
+     HI_UNF_CC_OPT_BUTT
+} HI_UNF_CC_OPT_E;
+
+/**Arib CC rollup mode*//** CNcomment:arib CC rollup模式*/
+typedef enum hiUNF_CC_ARIB_ROLLUP_E
+{
+    HI_UNF_CC_ARIB_NON_ROLLUP,        /**<Non roll-up *//**<CNcomment:非rollup模式*/
+    HI_UNF_CC_ARIB_ROLLUP,      /**<roll-up*//**<CNcomment:rollup模式*/
+    HI_UNF_CC_ARIB_ROLLUP_BUTT
+}HI_UNF_CC_ARIB_ROLLUP_E;
+
+
+/**Arib CC character coding*//** CNcomment:arib CC 字符编码方式*/
+typedef enum hiUNF_CC_ARIB_TCS_E
+{
+    HI_UNF_CC_ARIB_TCS_8BIT,         /**<the type of character codig is 8bit-code*//**<CNcomment:字符编码方式(8位)*/
+    HI_UNF_CC_ARIB_TCS_BUTT
+}HI_UNF_CC_ARIB_TCS_E;
+
+/**Arib CC display format*//** CNcomment:arib CC显示方式*/
+typedef enum hiUNF_CC_ARIB_DF_E
+{
+    HI_UNF_CC_ARIB_DF_HORIZONTAL_SD,                /**<horizontal writing in stardard density*/    /**<CNcomment:水平显示，标清*/
+    HI_UNF_CC_ARIB_DF_VERTICAL_SD,                  /**<vertical writing in standard density*/      /**<CNcomment:垂直显示，标清*/
+    HI_UNF_CC_ARIB_DF_HORIZONTAL_HD,                /**<horizontal writing in high density*/        /**<CNcomment:水平显示，高清*/
+    HI_UNF_CC_ARIB_DF_VERTICAL_HD,                  /**<vertical writing in high density*/          /**<CNcomment:垂直显示，高清*/
+    HI_UNF_CC_ARIB_DF_HORIZONTAL_WESTERN,           /**<horizontal writing of western language*/    /**<CNcomment:水平显示，西文*/
+    HI_UNF_CC_ARIB_DF_HORIZONTAL_1920X1080,         /**<horizontal writing in 1920X1080*/           /**<CNcomment:水平显示，屏幕1920X1080*/
+    HI_UNF_CC_ARIB_DF_VERTICAL_1920X1080,           /**<vertical writing in 1920X1080*/             /**<CNcomment:垂直显示，屏幕1920X1080*/
+    HI_UNF_CC_ARIB_DF_HORIZONTAL_960X540,           /**<horizontal writing in 960X540*/             /**<CNcomment:水平显示，屏幕960X540*/
+    HI_UNF_CC_ARIB_DF_VERTICAL_960X540,             /**<vertical writing in 960X540*/               /**<CNcomment:垂直显示，屏幕960X540*/
+    HI_UNF_CC_ARIB_DF_HORIZONTAL_1280X720,          /**<horizontal writing in 1280X720*/            /**<CNcomment:水平显示，屏幕1280X720*/
+    HI_UNF_CC_ARIB_DF_VERTICAL_1280X720,            /**<vertical writing in 1280X720*/              /**<CNcomment:垂直显示，屏幕1280X720*/
+    HI_UNF_CC_ARIB_DF_HORIZONTAL_720X480,           /**<horizontal writing in 720X480*/             /**<CNcomment:水平显示，屏幕720X480*/
+    HI_UNF_CC_ARIB_DF_VERTICAL_720X480,             /**<vertical writing in 720X480*/               /**<CNcomment:垂直显示，屏幕720X480*/
+    HI_UNF_CC_ARIB_DF_BUTT
+}HI_UNF_CC_ARIB_DF_E;
+
+/**Arib CC display mode*//** CNcomment:arib CC显示模式*/
+typedef enum hiUNF_CC_ARIB_DMF_E
+{
+    HI_UNF_CC_ARIB_DMF_AUTO_AND_AUTO=0x0,           /**<atomatic display when received ,automatic display when recording and playback */                    /**<CNcomment:接收后自动播放，录制和回放时自动播放*/
+    HI_UNF_CC_ARIB_DMF_AUTO_AND_NOT,                /**<atomatic display when received ,Non-displayed automatically when recording and playback*/           /**<CNcomment:接收后自动播放，录制和回放时不自动播放*/
+    HI_UNF_CC_ARIB_DMF_AUTO_AND_SELECT,             /**<atomatic display when received ,Selectable display when recording and playback*/                    /**<CNcomment:接收后自动播放，录制和回放时可选择播放*/
+    HI_UNF_CC_ARIB_DMF_NON_AND_AUTO=0x4,            /**<non-displayed automatically when received, automatic display when recording and playback */         /**<CNcomment:接收时不自动播放，录制和回放时自动播放*/
+    HI_UNF_CC_ARIB_DMF_NON_AND_NON,                 /**<non-displayed automatically when received,Non-displayed automatically when recording and playback*/ /**<CNcomment:接收时不自动播放，录制和回放时不自动播放*/
+    HI_UNF_CC_ARIB_DMF_NON_AND_SELECT,              /**<non-displayed automatically when received,Selectable display when recording and playback*/          /**<CNcomment:接收时不自动播放，录制和回放时可选择播放*/
+    HI_UNF_CC_ARIB_DMF_SELECT_AND_AUTO=0x8,         /**<selectable display when received, automatic display when recording and playback */                  /**<CNcomment:接收时可选择播放，录制和回放时可自动播放*/
+    HI_UNF_CC_ARIB_DMF_SELECT_AND_NON,              /**<selectable display when received,Non- displayed automatically when recording and playback*/         /**<CNcomment:接收时可选择播放，录制和回放时不自动播放*/
+    HI_UNF_CC_ARIB_DMF_SELECT_AND_SELECT,           /**<selectable display when received,Selectable display when recording and playback*/                   /**<CNcomment:接收时可选择播放，录制和回放时可选择播放*/
+    HI_UNF_CC_ARIB_DMF_SPECIAL_AND_AUTO=0xc,        /**<automatic display/non-display under specific condition when received,automatic display when recording and playback */           /**<CNcomment:接收时特定情况下自动/非自动播放，录制和回放时自动播放*/
+    HI_UNF_CC_ARIB_DMF_SPECIAL_AND_NON,             /**<automatic display/non-display under specific condition when received,Non-displayed automatically when recording and playback*/  /**<CNcomment:接收时特定情况下自动/非自动播放，录制和回放时不自动播放*/
+    HI_UNF_CC_ARIB_DMF_SPECIAL_AND_SELECT,          /**<automatic display/non-display under specific condition when received,Selectable display when recording and playback*/           /**<CNcomment:接收时特定情况下自动/非自动播放，录制和回放时可选择播放*/
+    HI_UNF_CC_ARIB_DMF_BUTT
+}HI_UNF_CC_ARIB_DMF_E;
+
+/**Arib CC time control mode*//** CNcomment:arib CC时间控制模式*/
+typedef enum hiUNF_CC_ARIB_TMD_E
+{
+    HI_UNF_CC_ARIB_TMD_FREE,            /**<playback time is not restricted to synchronize to the clock*//**<CNcomment:重放时间和时钟无关*/
+    HI_UNF_CC_ARIB_TMD_REAL_TIME,       /**<playback time is given by PTS*//**<CNcomment:重放时间由PTS给出*/
+    HI_UNF_CC_ARIB_TMD_OFFSET_TIME,     /**<playback time added with offset time should be the new playback time*//**<CNcomment:重放时间加上偏移时间将是新的重放时间*/
+    HI_UNF_CC_ARIB_TMD_BUTT
+}HI_UNF_CC_ARIB_TMD_E;
+
+/**CC608 VBI data*//** CNcomment:CC608 VBI数据 */
+typedef struct hiUNF_CC_VBI_DADA_S
+{
+    HI_U8 u8FieldParity; /**<parity field *//**<CNcomment:奇偶场 */
+    HI_U8 u8Data1;       /**<first byte *//**<CNcomment:第一个字节 */
+    HI_U8 u8Data2;       /**<second byte *//**<CNcomment:第二个字节 */
+}HI_UNF_CC_VBI_DADA_S;
+
+/**CC rect*//** CNcomment:定义CC矩形区域*/
+typedef struct hiUNF_CC_RECT_S
+{
+    HI_U16 x;           /**<x cordinate *//**<CNcomment:矩形左上角的x坐标 */
+    HI_U16 y;           /**<y cordinate *//**<CNcomment:矩形左上角的y坐标 */
+    HI_U16 width;       /**<rect width *//**<CNcomment:矩形的宽度 */
+    HI_U16 height;      /**<rect heigth *//**<CNcomment:矩形的高度 */
+}HI_UNF_CC_RECT_S;
+
+/**CC color components*//** CNcomment:CC像素颜色结构 */
+typedef struct hiUNF_CC_COLOR_S
+{
+    HI_U8 u8Blue;       /**<blue component *//**<CNcomment:B分量颜色值 */
+    HI_U8 u8Green;      /**<green component *//**<CNcomment:G分量颜色值 */
+    HI_U8 u8Red;        /**<red component *//**<CNcomment:R分量颜色值 */
+    HI_U8 u8Alpha;      /**<alpha component *//**<CNcomment:透明度，值为0为透明，0xFF为不透明 */
+} HI_UNF_CC_COLOR_S;
+
+/**CC data with text format*//** CNcomment:文本格式的CC数据 */
+typedef struct hiUNF_CC_TEXT_S
+{
+    HI_U16                 *pu16Text;    /**<cc data,2 bytes,unicode *//**<CNcomment:cc数据，unicode编码，2个字节 */
+    HI_U8                  u8TextLen;    /**<cc data length *//**<CNcomment:要显示的cc数据长度 */
+
+    HI_UNF_CC_COLOR_S      stFgColor;    /**<cc foregroud color*//**<CNcomment:要显示的cc数据前景色 */
+    HI_UNF_CC_COLOR_S      stBgColor;    /**<cc backgroud color*//**<CNcomment:要显示的cc数据字体背景色 */
+    HI_UNF_CC_COLOR_S      stEdgeColor;   /**<cc edge color*//**<CNcomment:要显示的cc数据字体边缘颜色*/
+
+    HI_U8                  u8Justify;    /*see HI_UNF_CC_JUSTIFY_E,used when decode cc708*//**<CNcomment:cc数据显示时的排版方式 */
+    HI_U8                  u8WordWrap;   /*see HI_UNF_CC_WORDWRAP_E,used when decode cc708*//**<CNcomment:自动换行 */
+    HI_UNF_CC_FONTSTYLE_E  enFontStyle;  /*font style ,see HI_UNF_CC_FONTSTYLE_E*//**<CNcomment:要显示的cc数据的字体风格 */
+    HI_UNF_CC_FONTSIZE_E   enFontSize;   /*font size ,see HI_UNF_CC_FONTSIZE_E*//**<CNcomment:要显示的cc数据的字体大小 */
+    HI_UNF_CC_EdgeType_E   enEdgetype;  /**<cc edge type*//**<CNcomment:要显示的cc数据字体边缘类型*/
+    HI_U8                  u8AribFontSize;   /*font size *//**<CNcomment:要显示的cc数据的字体大小 */
+    HI_UNF_CC_ARIB_SCALE_E enScaleType;
+    HI_U8                  u8CharInterval;
+    HI_U8                  u8LineInterval;
+    HI_UNF_CC_ARIB_PRTDIRECT_E enPrtDirect;
+} HI_UNF_CC_TEXT_S;
+
+/**CC data with bitmap format*//** CNcomment:位图格式的CC数据 */
+typedef struct hiUNF_CC_BITMAP_S
+{
+    HI_S32                 s32BitWidth;         /**<bit width, is 2/4/8/16/24/32 *//**<CNcomment:位宽,值是2/4/8/16/24/32 */
+    HI_U8                  *pu8BitmapData;      /**<pixel data *//**<CNcomment:图像数据 */
+    HI_U32                 u32BitmapDataLen;    /**<length of pixel data *//**<CNcomment:图像数据长度 */
+    HI_UNF_CC_COLOR_S      astPalette[256];     /**<palette data *//**<CNcomment:调色板数据 */
+    HI_U32                 u32PaletteLen;       /**<length of palette data *//**<CNcomment:调色板数据长度 */
+} HI_UNF_CC_BITMAP_S;
+
+/**parameter of fill rect*//** CNcomment:填充矩形区域的参数 */
+typedef struct hiUNF_CC_FILLRECT_S
+{
+    HI_UNF_CC_COLOR_S      stColor;      /**<color *//**<CNcomment:颜色值 */
+} HI_UNF_CC_FILLRECT_S;
+
+typedef struct hiUNF_CC_LINE_S
+{
+    HI_U32 u32X1;      /*画线起点坐标X1*/
+    HI_U32 u32Y1;      /*画线起点坐标Y1*/
+    HI_U32 u32X2;      /*画线终点坐标X2*/
+    HI_U32 u32Y2;      /*画线终点坐标Y2*/
+    HI_UNF_CC_COLOR_S      stColor;      /*线的颜色值*/
+} HI_UNF_CC_LINE_S;
+
+/**CC display param*//** CNcomment:定义CC数据显示时的参数 */
+typedef struct hiUNF_CC_DISPLAY_PARAM_S
+{
+    HI_UNF_CC_OPT_E        enOpt;
+    HI_U32                 u32DisplayWidth; /**<display screen width*//**<CNcomment:画布宽度 */
+    HI_U32                 u32DisplayHeight;/**<display screen height*//**<CNcomment:画布高度 */
+    HI_UNF_CC_RECT_S       stRect;          /**<cc display location*//**<CNcomment:要显示的cc数据的位置信息 */
+    union
+    {
+        HI_UNF_CC_TEXT_S   stText;          /**<CC data with text format*//**<CNcomment:文本格式的CC数据 */
+        HI_UNF_CC_BITMAP_S stBitmap;        /**<CC data with bitmap format*//**<CNcomment:位图格式的CC数据 */
+        HI_UNF_CC_FILLRECT_S stFillRect;    /**<parameter of fill rect*//**<CNcomment:填充矩形区域的参数 */
+        HI_UNF_CC_LINE_S   stLine;          /**<CC data with line format*//**<CNcomment:直线格式的CC数据 */
+    } unDispParam;
+
+    HI_BOOL bBlit;                          /**<Whether display on screen. HI_TRUE for display immediately and HI_FALSE for save in buffer. */
+                                            /**<CNcomment:是否立即绘制到屏幕上，HI_TRUE表示立即绘制，HI_FALSE表示先缓存到buffer上，暂不绘制到屏幕上 */
+} HI_UNF_CC_DISPLAY_PARAM_S;
+
+/**
+\brief cc get text size callback function. CNcomment: cc用于获得字体大小(宽高)的回调函数。CNend
+\attention \n
+none. CNcomment: 无。CNend
+\param[in] pUserData user data. CNcomment: HI_UNF_CC_Create传入的用户私有数据。CNend
+\param[in] u16Str  string. CNcomment: 数据地址。CNend
+\param[in] s32StrNum  number of character. CNcomment: 数据长度。CNend
+\param[out] ps32Width  total width of character. CNcomment: 得到的字体宽。CNend
+\param[out] ps32Heigth heigth of character. CNcomment: 得到的字体高。CNend
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\see \n
+none. CNcomment: 无。CNend
+*/
+typedef HI_S32 (*HI_UNF_CC_GETTEXTSIZE_CB_FN)(HI_VOID* pUserData, HI_U16 *u16Str,HI_S32 s32StrNum, HI_S32 *ps32Width, HI_S32 *ps32Heigth);
+
+/**
+\brief cc get text size callback function(EX). CNcomment: cc用于获得字体大小(宽高)的回调函数(扩展入参)。CNend
+\attention \n
+none. CNcomment: 无。CNend
+\param[in] pUserData user data. CNcomment: HI_UNF_CC_Create传入的用户私有数据。CNend
+\param[in] pstText  text data. CNcomment: 文本信息。CNend
+\param[out] ps32Width  total width of character. CNcomment: 得到的字体宽。CNend
+\param[out] ps32Heigth heigth of character. CNcomment: 得到的字体高。CNend
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\see \n
+none. CNcomment: 无。CNend
+*/
+typedef HI_S32 (*HI_UNF_CC_GETTEXTSIZE_EX_CB_FN)(HI_VOID* pUserData, HI_UNF_CC_TEXT_S *pstText, HI_S32 *ps32Width, HI_S32 *ps32Heigth);
+
+
+/**
+\brief cc display callback function. CNcomment: cc显示数据回调。CNend
+\attention \n
+none. CNcomment: 无。CNend
+\param[in] u32UserData user data. CNcomment: HI_UNF_CC_Create传入的用户私有数据。CNend
+\param[in] pstCCdisplayParam parameter of display. CNcomment: cc显示数据结构。CNend
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\see \n
+none. CNcomment: 无。CNend
+*/
+typedef HI_S32 (*HI_UNF_CC_DISPLAY_CB_FN)(HI_VOID* pUserData, HI_UNF_CC_DISPLAY_PARAM_S *pstCCdisplayParam);
+
+
+/**
+\brief cc get avplay pts callback function. CNcomment: cc获取当前节目的PTS值的回调。CNend
+\attention \n
+none. CNcomment: 无。CNend
+\param[in] pUserData user data. CNcomment: HI_UNF_CC_Create传入的用户私有数据。CNend
+\param[out] ps64CurrentPts current pts. CNcomment: 存储当前PTS值的变量指针。CNend
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\see \n
+none. CNcomment: 无。CNend
+*/
+typedef HI_S32 (*HI_UNF_CC_GETPTS_CB_FN)(HI_VOID* pUserData, HI_S64 *ps64CurrentPts);
+
+/**
+\brief cc data blit callback function. CNcomment: cc数据搬移回调。CNend
+\attention \n
+none. CNcomment: 无。CNend
+\param[in] pUserData user data. CNcomment: HI_UNF_CC_Create传入的用户私有数据。CNend
+\param[in] SrcRect source rect. CNcomment: 需要搬移的原区域。CNend
+\param[in] DstRect destination rect. CNcomment: 需要搬移的目标区域。CNend
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\see \n
+none. CNcomment: 无。CNend
+*/
+typedef HI_S32 (*HI_UNF_CC_BLIT_CB_FN)(HI_VOID* pUserData, HI_UNF_CC_RECT_S *pstSrcRect, HI_UNF_CC_RECT_S *pstDstRect);
+
+/**
+\brief cc data blit callback function. CNcomment: cc vbi 数据输出回调。CNend
+\attention \n
+none. CNcomment: 无。CNend
+\param[in] pUserData user data. CNcomment: HI_UNF_CC_Create传入的用户私有数据。CNend
+\param[out] pstVBIOddDataField1 VBI data,odd field data. CNcomment: VBI数据结构,奇场数据。CNend
+\param[out] pstVBIEvenDataField2 VBI data,even field data. CNcomment: VBI数据结构,偶场数据。CNend
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\see \n
+none. CNcomment: 无。CNend
+*/
+typedef HI_S32 (*HI_UNF_CC_VBI_CB_FN)(HI_VOID* pUserData, HI_UNF_CC_VBI_DADA_S *pstVBIOddDataField1,HI_UNF_CC_VBI_DADA_S *pstVBIEvenDataField2);
+
+/**
+\brief output XDS packets in CC608. CNcomment: 输出CC608中的XDS包数据。CNend
+\attention \n
+XDS packet is a third data service intended to supply program related and other information.
+CNcomment: XDS包是第三方数据服务，用来提供节目或者其他相关信息。CNend
+\param[in] u8XDSClass XDS class. CNcomment: XDS的分类。CNend
+\param[in] u8XDSPacketType  XDS packet type. CNcomment: XDS数据包的类型。CNend
+\param[in] pu8Data  XDS data. CNcomment: XDS数据。CNend
+\param[in] u8DataLen  XDS data length. CNcomment: XDS数据长度。CNend
+\retval ::HI_SUCCESS
+\retval ::HI_FAILURE
+\see \n
+Decoding of XDS packet data, see sample/cc/sample_cc_xds.c.
+CNcomment: XDS数据包的解析，请参看sdk包sample/cc/sample_cc_xds.c。CNend
+*/
+typedef HI_S32 (*HI_UNF_CC_XDS_CB_FN)(HI_U8 u8XDSClass, HI_U8 u8XDSPacketType, HI_U8 *pu8Data, HI_U8 u8DataLen);
+
+
+/**user data in MPEG*//** CNcomment:MPEG中的USERDATA数据 */
+typedef struct hiUNF_CC_USERDATA_S
+{
+    HI_U8       *pu8userdata;  /**<cc user data in mpeg *//**<CNcomment:mpeg视频帧中的cc用户数据 */
+    HI_U32      u32dataLen;    /**<cc user data length *//**<CNcomment:cc数据长度 */
+    HI_BOOL     bTopFieldFirst;/**<cc top field first flag *//**<CNcomment:cc顶场优先标记 */
+} HI_UNF_CC_USERDATA_S;
+
+/**CC608 config param *//** CNcomment:CC608 配置信息参数 */
+/**CC608 just support 8 stardard colors*//**CNcomment:CC608只支持8种标准颜色*/
+typedef struct hiUNF_CC_608_CONFIGPARAM_S
+{
+    HI_UNF_CC_608_DATATYPE_E    enCC608DataType;        /**<CC608 data type *//**<CNcomment:配置cc608数据类型 */
+    HI_U32                      u32CC608TextColor;      /**<CC608 text color *//**<CNcomment:配置cc608字体颜色 */
+    HI_UNF_CC_OPACITY_E         enCC608TextOpac;        /**<CC608 text opacity *//**<CNcomment:配置cc608字体透明度 */
+    HI_U32                      u32CC608BgColor;        /**<CC608 background color *//**<CNcomment:配置cc608背景色 */
+    HI_UNF_CC_OPACITY_E         enCC608BgOpac;          /**<CC608 background opacity *//**<CNcomment:配置cc608背景透明度 */
+    HI_UNF_CC_FONTSTYLE_E       enCC608FontStyle;       /**<CC608 font style *//**<CNcomment:配置cc608字体风格 */
+    HI_UNF_CC_DF_E              enCC608DispFormat;      /**<CC608 display format of caption display screen *//**<CNcomment:配置cc608显示模式 */
+    HI_BOOL                     bLeadingTailingSpace;   /**<CC608 leading/tailing space flag*//**<CNcomment: 是否显示leading/tailing space*/
+} HI_UNF_CC_608_CONFIGPARAM_S;
+
+/**CC708 config param *//** CNcomment:CC708 配置信息参数 */
+/**CC708 color specification CEA-708-B-1999.pdf section 9.20 Color Representation*//**CNcomment:CC708颜色说明请参考协议CEA-708-B-1999.pdf 9.20 颜色呈现 章节*/
+/**The specification does not define the specific color component, using the following component values in our version*/
+/**协议中没有定义具体的颜色分量，在我们版本中采用如下分量值*/
+/**CC708 support 64 colors.one of RGB color components can be 0x00,0x5f,0xaf,0xff*//**CNcomment:CC708支持64种颜色,一个RGB分量能取的值有0x00,0x5f,0xaf,0xff共4种*/
+/** 0x    FF          FF          FF          FF*/       /**CNcomment: 0x FF     FF         FF          FF*/
+/**    reserve    red value   green value  blue value*/  /**              保留   红色分量   绿色分量    蓝色分量*/
+typedef struct hiUNF_CC_708_CONFIGPARAM_S
+{
+    HI_UNF_CC_708_SERVICE_NUM_E enCC708ServiceNum;      /**<CC708 service number *//**<CNcomment:配置cc708服务通道号 */
+    HI_UNF_CC_FONTNAME_E        enCC708FontName;        /**<CC708 font name *//**<CNcomment:配置cc708字体 */
+    HI_UNF_CC_FONTSTYLE_E       enCC708FontStyle;       /**<CC708 font style *//**<CNcomment:配置cc708字体风格 */
+    HI_UNF_CC_FONTSIZE_E        enCC708FontSize;        /**<CC708 font size *//**<CNcomment:配置cc708字体大小 */
+    HI_U32                      u32CC708TextColor;      /**<CC708 text color *//**<CNcomment:配置cc708字体颜色 */
+    HI_UNF_CC_OPACITY_E         enCC708TextOpac;        /**<CC708 text opacity *//**<CNcomment:配置cc708字体透明度 */
+    HI_U32                      u32CC708BgColor;        /**<CC708 background color *//**<CNcomment:配置cc708背景颜色 */
+    HI_UNF_CC_OPACITY_E         enCC708BgOpac;          /**<CC708 background opacity *//**<CNcomment:配置cc708背景透明度 */
+    HI_U32                      u32CC708WinColor;       /**<CC708 window color *//**<CNcomment:配置cc708窗口颜色 */
+    HI_UNF_CC_OPACITY_E         enCC708WinOpac;         /**<CC708 window opacity *//**<CNcomment:配置cc708窗口透明度 */
+    HI_UNF_CC_EdgeType_E        enCC708TextEdgeType;    /**<CC708 text egde type *//**<CNcomment:配置cc708字体边缘类型 */
+    HI_U32                      u32CC708TextEdgeColor;  /**<CC708 text edge color *//**<CNcomment:配置cc708字体边缘颜色 */
+    HI_UNF_CC_DF_E              enCC708DispFormat;      /**<CC708 display format of caption display screen *//**<CNcomment:配置cc708显示模式 */
+} HI_UNF_CC_708_CONFIGPARAM_S;
+
+/**ARIB CC config param *//** CNcomment:ARIB CC 配置信息参数 */
+typedef struct hiUNF_CC_ARIB_CONFIGPARAM_S
+{
+    HI_U32      u32BufferSize;   /**<size of buffer which used to cache pes data,Recommends its value is 64K ~ 512K.note:This value can only be set when created,does not support dynamic setting*/
+                                 /**<CNcomment:缓存PES数据的缓冲区大小，取值为64k~512K。注意:这个值只能在创建时设置，不支持动态设置*/
+} HI_UNF_CC_ARIB_CONFIGPARAM_S;
+
+/**CC data attribution *//** CNcomment:CC属性信息 */
+typedef struct hiUNF_CC_ATTR_S
+{
+    HI_UNF_CC_DATA_TYPE_E enCCDataType;   /**<cc data type *//**<CNcomment:cc数据类型 */
+    union
+    {
+        HI_UNF_CC_608_CONFIGPARAM_S  stCC608ConfigParam;   /**<CC608 config param *//**<CNcomment:CC608 配置信息参数 */
+        HI_UNF_CC_708_CONFIGPARAM_S  stCC708ConfigParam;   /**<CC708 config param *//**<CNcomment:CC708 配置信息参数 */
+        HI_UNF_CC_ARIB_CONFIGPARAM_S stCCARIBConfigParam;  /**<ARIB CC config param *//**<CNcomment:ARIB CC 配置信息参数 */
+    } unCCConfig;
+} HI_UNF_CC_ATTR_S;
+
+/**CC instance param *//** CNcomment:创建实例时需要的参数信息 */
+typedef struct hiUNF_CC_PARAM_S
+{
+    HI_UNF_CC_ATTR_S             stCCAttr;           /**<cc attribution *//**<CNcomment:cc属性信息 */
+
+    HI_UNF_CC_GETPTS_CB_FN       pfnCCGetPts;        /**<get current pts callback function *//**<CNcomment:获取当前pts的回调函数 */
+    HI_UNF_CC_DISPLAY_CB_FN      pfnCCDisplay;       /**<cc display callback function *//**<CNcomment:cc显示的回调函数 */
+    HI_UNF_CC_GETTEXTSIZE_CB_FN  pfnCCGetTextSize;   /**<cc get text size callback function *//**<CNcomment:cc用于获得字体大小(宽高)的回调函数  */
+    HI_UNF_CC_GETTEXTSIZE_EX_CB_FN pfnCCGetTextSizeEx;
+    HI_UNF_CC_BLIT_CB_FN         pfnBlit;            /**<cc data blit callback function *//**<CNcomment:用于cc数据在屏幕上搬移的回调函数 */
+    HI_UNF_CC_VBI_CB_FN          pfnVBIOutput;       /**<output VBI data callback function *//**<CNcomment:输出VBI数据回调函数 */
+    HI_UNF_CC_XDS_CB_FN          pfnXDSOutput;       /**<output XDS packets function *//**<CNcomment:输出CC608中的XDS包数据 */
+    HI_VOID*                     pUserData;        /**<user data,used in callback function *//**<CNcomment:用户私有数据，用于回调函数 */
+} HI_UNF_CC_PARAM_S;
+
+/*ARIB CC info node*//** CNcomment:arib cc字幕信息节点 */
+typedef struct hiUNF_CC_ARIB_INFONODE_S
+{
+    HI_U8 u8LanguageTag;                   /**<identification of language*//**<CNcomment:字幕语言标记 */
+    HI_UNF_CC_ARIB_DMF_E    enCCAribDMF;   /**<display mode *//**<CNcomment:显示模式 */
+    HI_CHAR    acISO639LanguageCode[4];    /**<language code *//**<CNcomment:字幕语言代码 */
+    HI_UNF_CC_ARIB_DF_E enCCAribDF;        /**<display format *//**<CNcomment:显示方式 */
+    HI_UNF_CC_ARIB_TCS_E enCCAribTCS;         /**<character coding *//**<CNcomment:字符编码 */
+    HI_UNF_CC_ARIB_ROLLUP_E enCCAribRollup;    /**<roll-up mode *//**<CNcomment:roll-up模式 */
+}HI_UNF_CC_ARIB_INFONODE_S;
+
+/*ARIB CC info struct*//** CNcomment:arib cc字幕信息结构体 */
+typedef struct hiUNF_CC_ARIB_INFO_S
+{
+    HI_UNF_CC_ARIB_TMD_E enCCAribTMD;   /**<time control mode*//**<CNcomment:时间控制模式 */
+    HI_U32 u32NumLanguage;       /**<number of languages *//**<CNcomment:字幕语言个数 */
+    HI_UNF_CC_ARIB_INFONODE_S stCCAribInfonode[ARIBCC_MAX_LANGUAGE];     /**<array of arib cc info *//**<CNcomment:arib cc字幕信息数组 */
+}HI_UNF_CC_ARIB_INFO_S;
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+
+/******************************* API Declaration *****************************/
+/**
+\brief Initialize cc module. CNcomment: 初始化CC模块。CNend
+\attention \n
+none. CNcomment: 无。CNend
+\retval ::HI_SUCCESS initialize success. CNcomment: 初始化成功。CNend
+\retval ::HI_FAILURE initialize failure. CNcomment: 初始化失败。CNend
+\see \n
+none. CNcomment: 无。CNend
+*/
+HI_S32 HI_UNF_CC_Init(HI_VOID);
+
+/**
+\brief DeInitialize cc module. CNcomment: 去初始化CC模块。CNend
+\attention \n
+none. CNcomment: 无。CNend
+\retval ::HI_SUCCESS deinitialize success. CNcomment: 去初始化成功。CNend
+\retval ::HI_FAILURE deinitialize failure. CNcomment: 去初始化失败。CNend
+\see \n
+none. CNcomment: 无。CNend
+*/
+HI_S32 HI_UNF_CC_DeInit(HI_VOID);
+
+/**
+\brief Get default attribution in cc module. CNcomment: 获取CC模块的默认属性值。CNend
+\attention \n
+none. CNcomment: 无。CNend
+\retval ::HI_SUCCESS success. CNcomment: 成功。CNend
+\retval ::HI_FAILURE failure. CNcomment: 失败。CNend
+\see \n
+none. CNcomment: 无。CNend
+*/
+HI_S32 HI_UNF_CC_GetDefaultAttr(HI_UNF_CC_ATTR_S *pstDefaultAttr);
+
+/**
+\brief open cc module. CNcomment: 创建cc实例。CNend
+\attention \n
+none. CNcomment: 无。CNend
+\param[in]  pstAttr  cc attribution. CNcomment: 创建时传入的解码器属性。CNend
+\param[out]  phCC  cc handle. CNcomment: cc模块句柄。CNend
+\retval ::HI_SUCCESS success. CNcomment: 创建成功。CNend
+\retval ::HI_FAILURE failure. CNcomment: 创建失败。CNend
+\see \n
+none. CNcomment: 无。CNend
+*/
+HI_S32 HI_UNF_CC_Create(HI_UNF_CC_PARAM_S *pstCCParam, HI_HANDLE *phCC);
+
+/**
+\brief close cc module. CNcomment: 销毁cc实例。CNend
+\attention \n
+none. CNcomment: 无。CNend
+\param[in]  hCC  cc handle. CNcomment: 模块句柄。CNend
+\retval ::HI_SUCCESS success. CNcomment: 销毁成功。CNend
+\retval ::HI_FAILURE failure. CNcomment: 销毁失败。CNend
+\see \n
+none. CNcomment: 无。CNend
+*/
+HI_S32 HI_UNF_CC_Destroy(HI_HANDLE hCC);
+
+/**
+\brief start cc module. CNcomment: 开始cc模块。CNend
+\attention \n
+none. CNcomment: 无。CNend
+\param[in]  hCC  cc handle. CNcomment: 模块句柄。CNend
+\retval ::HI_SUCCESS success. CNcomment: 成功。CNend
+\retval ::HI_FAILURE failure. CNcomment: 失败。CNend
+\see \n
+none. CNcomment: 无。CNend
+*/
+HI_S32 HI_UNF_CC_Start(HI_HANDLE hCC);
+
+/**
+\brief stop cc module. CNcomment: 结束cc模块。CNend
+\attention \n
+none. CNcomment: 无。CNend
+\param[in]  hCC  cc handle. CNcomment: 模块句柄。CNend
+\retval ::HI_SUCCESS success. CNcomment: 成功。CNend
+\retval ::HI_FAILURE failure. CNcomment: 失败。CNend
+\see \n
+none. CNcomment: 无。CNend
+*/
+HI_S32 HI_UNF_CC_Stop(HI_HANDLE hCC);
+
+/**
+\brief reset cc module. CNcomment: 复位cc模块。CNend
+\attention \n
+none. CNcomment: 无。CNend
+\param[in]  hCC  cc handle. CNcomment: 模块句柄。CNend
+\retval ::HI_SUCCESS success. CNcomment: 成功。CNend
+\retval ::HI_FAILURE failure. CNcomment: 失败。CNend
+\see \n
+none. CNcomment: 无。CNend
+*/
+HI_S32 HI_UNF_CC_Reset(HI_HANDLE hCC);
+
+/**
+\brief inject mpeg userdata to  cc module. CNcomment: 注入mpeg用户数据到cc模块。CNend
+\attention \n
+none. CNcomment: 无。CNend
+\param[in]  hCC  cc handle. CNcomment: 模块句柄。CNend
+\param[in]  pstUserData  cc userdata structure used in inject cc data. CNcomment: 用户数据结构体。CNend
+\retval ::HI_SUCCESS success. CNcomment: 成功。CNend
+\retval ::HI_FAILURE failure. CNcomment: 失败。CNend
+\see \n
+none. CNcomment: 无。CNend
+*/
+HI_S32 HI_UNF_CC_InjectUserData(HI_HANDLE hCC, HI_UNF_CC_USERDATA_S *pstUserData);
+
+/**
+\brief inject cc pes data to cc module. CNcomment: 注入pes数据到cc模块(暂不支持)。CNend
+\attention \n
+none. CNcomment: 无。CNend
+\param[in]  hCC  cc handle. CNcomment:模块句柄。CNend
+\param[in]  pu8PesData  pes data address. CNcomment: pes数据首地址。CNend
+\param[in]  u32DataLen  pes data length. CNcomment: pes数据长度。CNend
+\retval ::HI_SUCCESS success. CNcomment: 成功。CNend
+\retval ::HI_FAILURE failure. CNcomment: 失败。CNend
+\see \n
+none. CNcomment: 无。CNend
+*/
+HI_S32 HI_UNF_CC_InjectPESData(HI_HANDLE hCC, HI_U8 *pu8PesData, HI_U32 u32DataLen);
+
+/**
+\brief get cc attribution. CNcomment: 获取cc属性信息。CNend
+\attention \n
+none. CNcomment: 无。CNend
+\param[in]  hCC  cc handle. CNcomment: 模块句柄。CNend
+\param[out]  pstCCAttr  cc attribution structure. CNcomment: 属性信息结构体。CNend
+\retval ::HI_SUCCESS success. CNcomment: 成功。CNend
+\retval ::HI_FAILURE failure. CNcomment: 失败。CNend
+\see \n
+none. CNcomment: 无。CNend
+*/
+HI_S32 HI_UNF_CC_GetAttr(HI_HANDLE hCC, HI_UNF_CC_ATTR_S *pstCCAttr);
+
+/**
+\brief set cc attribution. CNcomment:设置cc属性信息。CNend
+\attention \n
+none. CNcomment: 无。CNend
+\param[in]  hCC  cc handle. CNcomment. CNcomment: 模块句柄。CNend
+\param[in]  pstCCAttr  cc attribution structure. CNcomment:属性信息结构体。CNend
+\retval ::HI_SUCCESS success. CNcomment: 成功。CNend
+\retval ::HI_FAILURE failure. CNcomment: 失败。CNend
+\see \n
+none. CNcomment: 无。CNend
+*/
+HI_S32 HI_UNF_CC_SetAttr(HI_HANDLE hCC, HI_UNF_CC_ATTR_S *pstCCAttr);
+
+
+/**
+\brief get cc arib info. CNcomment: 获取arib cc字幕信息。CNend
+\attention \n
+none. CNcomment: 无。CNend
+\param[in]  hCC  arib cc handle. CNcomment: 模块句柄。CNend
+\param[out]  pstCCAttr  arib cc info structure. CNcomment:arib cc字幕信息结构体。CNend
+\retval ::HI_SUCCESS success. CNcomment: 成功。CNend
+\retval ::HI_FAILURE failure. CNcomment: 失败。CNend
+\see \n
+none. CNcomment: 无。CNend
+*/
+HI_S32 HI_UNF_CC_GetARIBCCInfo(HI_HANDLE hCC,HI_UNF_CC_ARIB_INFO_S *pstCCAribInfo);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif
diff -uNr a/include/hi_unf_ci.h b/include/hi_unf_ci.h
--- a/include/hi_unf_ci.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_ci.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,691 @@
+#ifndef __HI_UNF_CI_TYPE_H__
+#define __HI_UNF_CI_TYPE_H__
+
+#include "hi_error_mpi.h"
+#include "hi_common.h"
+#include <linux/string.h>
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      CI*/
+/** @{ */  /** <!-- [CI] */
+
+/** support CI Port*/
+/** CNcomment:支持的CI Port */
+typedef enum hiUNF_CI_PORT_E
+{
+    HI_UNF_CI_PORT_0,
+    HI_UNF_CI_PORT_1,
+    HI_UNF_CI_PORT_BUTT
+} HI_UNF_CI_PORT_E;
+
+/** support CI PCMCIA Cards(Module) */
+/** CNcomment:支持的CI PCMCIA Cards(Module) */
+typedef enum hiUNF_CI_PCCD_E
+{
+    HI_UNF_CI_PCCD_A,
+    HI_UNF_CI_PCCD_B,
+    HI_UNF_CI_PCCD_BUTT
+} HI_UNF_CI_PCCD_E;
+
+/** Module on-off power control */
+/** CNcomment:Module开关电源控制 */
+typedef enum hiUNF_CI_PCCD_CTRLPOWER_E
+{
+    HI_UNF_CI_PCCD_CTRLPOWER_ON,
+    HI_UNF_CI_PCCD_CTRLPOWER_OFF,
+    HI_UNF_CI_PCCD_CTRLPOWER_BUFF
+} HI_UNF_CI_PCCD_CTRLPOWER_E;
+
+/** Module ready state:ready/busy */
+/** CNcomment:Module就绪状态:ready/busy */
+typedef enum hiUNF_CI_PCCD_READY_E
+{
+    HI_UNF_CI_PCCD_BUSY,
+    HI_UNF_CI_PCCD_READY
+} HI_UNF_CI_PCCD_READY_E, *HI_UNF_CI_PCCD_READY_E_PTR;
+
+/** Module online state:present/absent */
+/** CNcomment:Module在线状态:present/absent */
+typedef enum hiUNF_CI_PCCD_STATUS_E
+{
+    HI_UNF_CI_PCCD_STATUS_ABSENT,
+    HI_UNF_CI_PCCD_STATUS_PRESENT,
+    HI_UNF_CI_PCCD_STATUS_BUTT
+} HI_UNF_CI_PCCD_STATUS_E, *HI_UNF_CI_PCCD_STATUS_E_PTR;
+
+/** card call mode */
+/** CNcomment:卡访问模式 */
+typedef enum hiUNF_CI_PCCD_ACCESSMODE_E
+{
+    HI_UNF_CI_PCCD_ACCESS_ATTR,
+    HI_UNF_CI_PCCD_ACCESS_IO,
+    HI_UNF_CI_PCCD_ACCESS_COMMON,
+    HI_UNF_CI_PCCD_ACCESS_BUTT
+} HI_UNF_CI_PCCD_ACCESSMODE_E;
+
+/** get state register mask code */
+/** CNcomment:获取状态寄存器掩码 */
+typedef enum hiUNF_CI_PCCD_STATUS_BIT_E
+{
+    HI_UNF_CI_PCCD_STATUS_BIT_ALL,  /**< get all bits */               /**< CNcomment:获取所有位 */
+    HI_UNF_CI_PCCD_STATUS_BIT_DA,   /**< get Data Available bit */     /**< CNcomment:获取Data Available位 */
+    HI_UNF_CI_PCCD_STATUS_BIT_FR,   /**< get Free bit */               /**< CNcomment:获取Free位 */
+    HI_UNF_CI_PCCD_STATUS_BIT_RE,   /**< get Read Error bit */         /**< CNcomment:获取Read Error位 */
+    HI_UNF_CI_PCCD_STATUS_BIT_WE,   /**< get Write Error bit */        /**< CNcomment:获取Write Error位 */
+    HI_UNF_CI_PCCD_STATUS_BIT_BUTT
+} HI_UNF_CI_PCCD_STATUS_BIT_E;
+
+/** The mode of CI Transport Stream Interface connection */
+/** CNcomment:CI TSI连接方式 */
+typedef enum hiUNF_CI_TSI_MODE_E
+{
+    HI_UNF_CI_TSI_DAISY_CHAINED,      /**< Daisy-chained */
+    HI_UNF_CI_TSI_INDEPENDENT,        /**< Independent, non-daisy-chained */
+    HI_UNF_CI_TSI_BUTT
+}HI_UNF_CI_TSI_MODE_E;
+
+/** The mode of TS pass to the CI device*/
+/** CNcomment:过CI设备的TS流模式 */
+typedef enum hiUNF_CI_TS_MODE_E
+{
+    HI_UNF_CI_TS_SERIAL,         /**< serial 1*/
+    HI_UNF_CI_TS_PARALLEL,       /**< Parallel TS, default */
+    HI_UNF_CI_TS_USB2SERIAL,     /**< USB input, serial output */
+    HI_UNF_CI_TS_USB2PARALLEL,   /**< USB input, parallel output */
+    HI_UNF_CI_TS_BUTT
+}HI_UNF_CI_TS_MODE_E;
+
+/** The TSI serial number of the CI device*/
+/** CNcomment:CI设备的串行TS输入端口 */
+typedef enum hiUNF_CI_TSI_SERIAL_PORT_E
+{
+    HI_UNF_CI_TSI_SERIAL1 = 0x04,  /**< TSI serial 1*/
+    HI_UNF_CI_TSI_SERIAL2,         /**< TSI serial 2*/
+    HI_UNF_CI_TSI_SERIAL3,         /**< TSI serial 3*/
+    HI_UNF_CI_TSI_SERIAL4,         /**< TSI serial 4*/
+    HI_UNF_CI_TSI_SERIAL_BUTT
+}HI_UNF_CI_TSI_SERIAL_PORT_E;
+
+/** The command exchange channel between the host and device*/
+/** CNcomment:CI设备*/
+typedef enum hiUNF_CI_CMD_EXCHANGE_CHAN_E
+{
+    HI_UNF_CI_CMD_EXCHANGE_CHAN_USB,
+    HI_UNF_CI_CMD_EXCHANGE_CHAN_SPI,
+    HI_UNF_CI_EXCHANGE_CHAN_BUTT,
+}HI_UNF_CI_CMD_EXCHANGE_CHAN_E;
+
+/** CI device*/
+/** CNcomment:支持的CI设备 */
+typedef enum hiUNF_CI_DEV_E
+{
+    HI_UNF_CI_DEV_CIMAX,        /**< CIMaX, default */
+    HI_UNF_CI_DEV_CIMAXPLUS,    /**< CIMaX+ */
+    HI_UNF_CI_DEV_HICI,         /**< HICI */
+    HI_UNF_CI_DEV_STARCI2WIN,   /**< StarCI2Win */
+    HI_UNF_CI_DEV_BUTT
+}HI_UNF_CI_DEV_E;
+
+/** CIMaX device configuration */
+/** CNcomment:CIMaX设备配置 */
+typedef struct hiUNF_CI_CIMAX_ATTR_S
+{
+    HI_U32  u32SMIBitWidth;         /**< SMI Bit Width */
+    HI_U32  u32SMIBaseAddr;         /**< SMI Base Address */
+    HI_U32  u32I2cNum;              /**< I2C Group */
+    HI_U8   u8DevAddress;           /**< I2C device address */
+}HI_UNF_CI_CIMAX_ATTR_S, *HI_UNF_CI_CIMAX_ATTR_S_PTR;
+
+/** CIMaX+ device configuration */
+/** CNcomment:CIMaX+设备配置 */
+typedef struct hiUNF_CI_CIMAXPLUS_ATTR_S
+{
+    HI_U32  u32ResetGpioNo; /**< The GPIO to reset the device */
+    HI_U32  u32IntGpioNo;   /**< The GPIO to receive the device's Interrupt signal */
+    HI_UNF_CI_TSI_SERIAL_PORT_E enTsiSerialPort[HI_UNF_CI_PCCD_BUTT]; /**< The TSI serial port of device*/
+    HI_UNF_CI_CMD_EXCHANGE_CHAN_E  enCmdExchangeChan;     /**< The command exchange channel between the host and device*/
+    HI_U32  u32SPIDevNo;           /**< The SPI device number*/
+}HI_UNF_CI_CIMAXPLUS_ATTR_S, *HI_UNF_CI_CIMAXPLUS_ATTR_S_PTR;
+
+/** HICI device configuration */
+/** CNcomment:HICI设备配置 */
+typedef struct hiUNF_CI_HICI_ATTR_S
+{
+    HI_BOOL bIsPowerCtrlGpioUsed;
+    HI_U32 u32PowerCtrlGpioNo[HI_UNF_CI_PCCD_BUTT];/**< The GPIO to power on/off the device */
+}HI_UNF_CI_HICI_ATTR_S, *HI_UNF_CI_HICI_ATTR_S_PTR;
+
+/** CI device configuration */
+/** CNcomment:CI设备配置 */
+typedef struct hiUNF_CI_ATTR_S
+{
+    HI_UNF_CI_DEV_E enDevType;                          /**< CI device type */
+    HI_UNF_CI_TSI_MODE_E enTSIMode;                     /**< The mode of CI Transport Stream Interface connection */
+    HI_UNF_CI_TS_MODE_E enTSMode[HI_UNF_CI_PCCD_BUTT];     /**< The mode of TS pass to the CI device */
+    union
+    {
+        HI_UNF_CI_CIMAX_ATTR_S stCIMaX;
+        HI_UNF_CI_CIMAXPLUS_ATTR_S stCIMaXPlus;
+        HI_UNF_CI_HICI_ATTR_S stCIHICI;
+    }unDevAttr;
+}HI_UNF_CI_ATTR_S, *HI_UNF_CI_ATTR_S_PTR;
+
+/** TS control command */
+/** CNcomment:TS控制命令 */
+typedef enum hiUNF_CI_PCCD_TSCTRL_E
+{
+    HI_UNF_CI_PCCD_TSCTRL_BYPASS,
+    HI_UNF_CI_PCCD_TSCTRL_SETMODE,
+    HI_UNF_CI_PCCD_TSCTRL_WRITETS,
+    HI_UNF_CI_PCCD_TSCTRL_BUTT
+}HI_UNF_CI_PCCD_TSCTRL_E;
+/** USB TS Write parameter */
+/** CNcomment:USB送流参数 */
+typedef struct hiUNF_CI_PCCD_TSWRITE_S
+{
+    HI_U8* pu8Data;     /**< Write data [in]*/
+    HI_U32 u32Size;     /**< Write data size [in]*/
+}HI_UNF_CI_PCCD_TSWRITE_S;
+
+/** TS control parameter */
+/** CNcomment:TS控制参数 */
+typedef union
+{
+    struct
+    {
+        HI_BOOL bByPass;    /**< TURE means bypass, FALSE means pass-through */  /**< CNcomment:TRUE表示bypass, FALSE表示pass-through */
+    }stByPass;
+
+    struct
+    {
+        HI_UNF_CI_TS_MODE_E enTSMode;        /**< TS mode: parallel/serial/USB */
+    }stMode;
+
+    HI_UNF_CI_PCCD_TSWRITE_S stWrite;
+
+    /* For extend */
+}HI_UNF_CI_PCCD_TSCTRL_PARAM_U;
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      CI */
+/** @{ */  /** <!-- [CI]*/
+
+/**
+\brief CI init
+\brief CNcomment:CI初始化  CNend
+\attention \n
+N/A
+\param    N/A                                         CNcomment:无 CNend
+\retval ::HI_SUCCESS              success             CNcomment: 成功 CNend
+\retval ::HI_FAILURE              fail                CNcomment:失败 CNend
+\retval ::HI_ERR_CI_OPEN_ERR      opening file fail   CNcomment:打开文件失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_Init(HI_VOID);
+
+/**
+\brief CI deinit
+\brief CNcomment:CI去初始化  CNend
+\attention \n
+N/A
+\param  N/A                                              CNcomment:无 CNend
+\retval ::HI_SUCCESS             success                 CNcomment:成功 CNend
+\retval ::HI_FAILURE             fail                    CNcomment:失败 CNend
+\retval ::HI_ERR_CI_CLOSE_ERR    closing file fail       CNcomment:关闭文件失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_DeInit(HI_VOID);
+
+/**
+\brief Sets CI device configration.
+\brief CNcomment:CI设备属性设置  CNend
+\attention \n
+N/A
+\param[in] enCIPort  CI Port number.                     CNcomment:操作的CI port CNend
+\param[in] pstCIAttr The pointer to a structure of CI device.
+                                                         CNcomment:指向CI设备属性的指针。 CNend
+\retval ::HI_SUCCESS            success                  CNcomment:成功 CNend
+\retval ::HI_FAILURE            fail                     CNcomment:失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_SetAttr(HI_UNF_CI_PORT_E enCIPort, const HI_UNF_CI_ATTR_S *pstCIAttr);
+
+/**
+\brief Gets CI device configration.
+\brief CNcomment:CI设备属性获取  CNend
+\attention \n
+N/A
+\param[in] enCIPort  CI Port number.                     CNcomment:操作的CI port CNend
+\param[in] pstCIAttr The pointer to a structure of CI device.
+                                                         CNcomment:指向CI设备属性的指针。 CNend
+\retval ::HI_SUCCESS            success                  CNcomment:成功 CNend
+\retval ::HI_FAILURE            fail                     CNcomment:失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_GetAttr(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_ATTR_S *pstCIAttr);
+
+/**
+\brief open CI Port
+\brief CNcomment:打开CI Port CNend
+\attention \n
+N/A
+\param[in] enCIPort     CI Port number                    CNcomment:操作的CI port CNend
+\retval ::HI_SUCCESS    success                           CNcomment:成功 CNend
+\retval ::HI_FAILURE     fail                             CNcomment:失败 CNend
+\retval ::HI_ERR_CI_INVALID_PARA    invalid parameter     CNcomment:无效参数 CNend
+\retval ::HI_ERR_CI_UNSUPPORT       unsupported CI Port   CNcomment:不支持的CI Port CNend
+\retval ::HI_ERR_CI_REG_READ_ERR    read register error   CNcomment:读寄存器错误 CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR   write register error  CNcomment:写寄存器错误 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_Open(HI_UNF_CI_PORT_E enCIPort);
+
+/**
+\brief close CI Port
+\brief CNcomment:关闭CI Port CNend
+\attention \n
+N/A
+\param[in] enCIPort    CI Port number   CNcomment:操作的CI port CNend
+\retval ::HI_SUCCESS       success      CNcomment:成功 CNend
+\retval ::HI_FAILURE       fail         CNcomment:失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_Close(HI_UNF_CI_PORT_E enCIPort);
+
+/**
+\brief open CAM
+\brief CNcomment:打开CAM卡 CNend
+\attention \n
+N/A
+\param[in] enCIPort    CI Port number                                       CNcomment:操作的CI port CNend
+\param[in] enCardId     Card ID                                             CNcomment:操作卡 CNend
+\retval ::HI_SUCCESS    success                                             CNcomment:成功 CNend
+\retval ::HI_FAILURE     fail                                               CNcomment:失败 CNend
+\retval ::HI_ERR_CI_INVALID_PARA   invalid parameter                        CNcomment: 无效参数 CNend
+\retval ::HI_ERR_CI_NOT_INIT        have not been initialized or not open   CNcomment:未初始化或未打开 CNend
+\retval ::HI_ERR_CI_UNSUPPORT       unsupported CI Port                     CNcomment:不支持的CI Port CNend
+\retval ::HI_ERR_CI_REG_READ_ERR    read register error                     CNcomment:读寄存器错误 CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR   write register error                    CNcomment:写寄存器错误 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_Open(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId);
+
+/**
+ \brief close CAM
+ \brief CNcomment:关闭CAM卡 CNend
+
+ \attention \n
+N/A
+ \param[in] enCIPort   CI Port number   CNcomment:操作的CI port CNend
+ \param[in] enCardId   Card Id          CNcomment:操作卡 CNend
+ \retval ::HI_SUCCESS   success         CNcomment:成功 CNend
+ \retval ::HI_FAILURE    fail           CNcomment:失败 CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_CI_PCCD_Close(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId);
+
+/**
+ \brief CAM power switch
+ \brief CNcomment:CAM卡电源开关 CNend
+ \attention \n
+    Some solutions don't support power down for a single card, the calling of this interface
+    automatically detects a power outage card plug, if it is on ,it will keep power on
+    CNcomment:有的方案不支持针对单卡断电，调用本接口断电时会自动检测是否有卡插上，如果有，将不会断电 CNend
+ \param[in] enCIPort    CI Port number                                       CNcomment:操作的CI port CNend
+ \param[in] enCardId    Card Id                                              CNcomment:操作卡 CNend
+ \param[in] enCtrlPower power on\power off                                   CNcomment:开电、关电 CNend
+ \retval ::HI_SUCCESS      success                                           CNcomment:成功 CNend
+ \retval ::HI_FAILURE      fail                                              CNcomment:失败 CNend
+ \retval ::HI_ERR_CI_INVALID_PARA     invalid parameter                      CNcomment:无效参数 CNend
+ \retval ::HI_ERR_CI_NOT_INIT         have not been initialized or not open  CNcomment:未初始化或未打开 CNend
+ \retval ::HI_ERR_CI_UNSUPPORT        unsupported CI Port                    CNcomment:不支持的CI Port CNend
+ \retval ::HI_ERR_CI_REG_READ_ERR     read register error                    CNcomment:读寄存器错误 CNend
+ \retval ::HI_ERR_CI_REG_WRITE_ERR    write register error                   CNcomment:写寄存器错误 CNend
+ \retval ::HI_ERR_CI_CANNOT_POWEROFF  can not power off                      CNcomment:不能断电 CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_CI_PCCD_CtrlPower(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                            HI_UNF_CI_PCCD_CTRLPOWER_E enCtrlPower);
+
+/**
+\brief CI reset
+\brief CNcomment:CAM卡复位 CNend
+\attention \n
+N/A
+\param[in] enCIPort    CI Port number                                         CNcomment:操作的CI port CNend
+\param[in] enCardId    Card Id                                                CNcomment:操作卡 CNend
+\retval ::HI_SUCCESS   success                                                CNcomment:成功 CNend
+\retval ::HI_FAILURE   fail                                                   CNcomment:失败 CNend
+\retval ::HI_ERR_CI_INVALID_PARA       invalid parameter                      CNcomment:无效参数 CNend
+\retval ::HI_ERR_CI_NOT_INIT           have not been initialized or not open  CNcomment:未初始化或未打开 CNend
+\retval ::HI_ERR_CI_UNSUPPORT          unsupported CI Port                    CNcomment:不支持的CI Port CNend
+\retval ::HI_ERR_CI_REG_READ_ERR       read register error                    CNcomment:读寄存器错误 CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR      write register error                   CNcomment:写寄存器错误 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_Reset(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId);
+
+/**
+\brief CAM ready state checking
+\brief CNcomment:CAM卡就绪状态检测 CNend
+\attention \n
+N/A
+\param[in] enCIPort       CI Port number                                     CNcomment:操作的CI port CNend
+\param[in] enCardId       Card Id                                            CNcomment:操作卡 CNend
+\param[out] penCardReady  state value                                        CNcomment:状态值 CNend
+\retval ::HI_SUCCESS      success                                            CNcomment:成功 CNend
+\retval ::HI_FAILURE      fail                                               CNcomment:失败 CNend
+\retval ::HI_ERR_CI_INVALID_PARA   invalid parameter                         CNcomment:无效参数 CNend
+\retval ::HI_ERR_CI_NOT_INIT       have not been initialized or not open     CNcomment:未初始化或未打开 CNend
+\retval ::HI_ERR_CI_UNSUPPORT      unsupported CI Port                       CNcomment:不支持的CI Port CNend
+\retval ::HI_ERR_CI_REG_READ_ERR   read register error                       CNcomment:读寄存器错误 CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR  write register error                      CNcomment:写寄存器错误 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_IsReady(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                            HI_UNF_CI_PCCD_READY_E_PTR penCardReady);
+
+/**
+\brief check CAM if it is on
+\brief CNcomment:CAM卡是否插上检测 CNend
+\attention \n
+N/A
+\param[in] enCIPort    CI Port number                                         CNcomment:操作的CI port CNend
+\param[in] enCardId    Card Id                                                CNcomment:操作卡 CNend
+\param[out] penCardStatus  card up or card down                               CNcomment:卡插上或未插状态 CNend
+\retval ::HI_SUCCESS        success                                           CNcomment:成功 CNend
+\retval ::HI_FAILURE        fail                                              CNcomment:失败 CNend
+\retval ::HI_ERR_CI_INVALID_PARA    invalid parameter                         CNcomment:无效参数 CNend
+\retval ::HI_ERR_CI_NOT_INIT        have not been initialized or not open     CNcomment:未初始化或未打开 CNend
+\retval ::HI_ERR_CI_UNSUPPORT       unsupported CI Port                       CNcomment:不支持的CI Port CNend
+\retval ::HI_ERR_CI_REG_READ_ERR    read register error                       CNcomment:读寄存器错误 CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR   write register error                      CNcomment:写寄存器错误 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_Detect(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                            HI_UNF_CI_PCCD_STATUS_E_PTR penCardStatus);
+
+/**
+\brief CAM set access module
+\brief CNcomment:CAM卡设置访问模块 CNend
+\attention \n
+N/A
+\param[in] enCIPort    CI Port number                                         CNcomment:操作的CI port CNend
+\param[in] enCardId    Card Id                                                CNcomment:操作卡 CNend
+\param[in] enAccessMode mode you want to set                                  CNcomment:要设置的模式 CNend
+\retval ::HI_SUCCESS        success                                           CNcomment:成功 CNend
+\retval ::HI_FAILURE        fail                                              CNcomment:失败 CNend
+\retval ::HI_ERR_CI_INVALID_PARA    invalid parameter                         CNcomment:无效参数 CNend
+\retval ::HI_ERR_CI_NOT_INIT        have not been initialized or not open     CNcomment:未初始化或未打开 CNend
+\retval ::HI_ERR_CI_UNSUPPORT       unsupported CI Port                       CNcomment:不支持的CI Port CNend
+\retval ::HI_ERR_CI_REG_READ_ERR    read register error                       CNcomment:读寄存器错误 CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR   write register error                      CNcomment:写寄存器错误 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_SetAccessMode(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                                    HI_UNF_CI_PCCD_ACCESSMODE_E enAccessMode);
+
+/**
+\brief CAM write or read state checking
+\brief CNcomment:CAM卡读写状态检测 CNend
+\attention \n
+N/A
+\param[in] enCIPort    CI Port number                                         CNcomment:操作的CI port CNend
+\param[in] enCardId    Card Id                                                CNcomment:操作卡 CNend
+\param[in] enStatus    status of the bit will check                           CNcomment:要检测的状态位 CNend
+\param[out] pu8Value   status code returned                                   CNcomment:返回的状态码 CNend
+\retval ::HI_SUCCESS        success                                           CNcomment:成功 CNend
+\retval ::HI_FAILURE        fail                                              CNcomment:失败 CNend
+\retval ::HI_ERR_CI_INVALID_PARA    invalid parameter                         CNcomment:无效参数 CNend
+\retval ::HI_ERR_CI_NOT_INIT        have not been initialized or not open     CNcomment:未初始化或未打开 CNend
+\retval ::HI_ERR_CI_UNSUPPORT       unsupported CI Port                       CNcomment:不支持的CI Port CNend
+\retval ::HI_ERR_CI_IO_READ_ERR       read IO error                           CNcomment:IO读错误 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_GetStatus (HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                                HI_UNF_CI_PCCD_STATUS_BIT_E enStatus, HI_U8 *pu8Value);
+
+/**
+\brief CAM IO read data
+\brief CNcomment:CAM卡IO读数据 CNend
+\attention \n
+N/A
+\param[in] enCIPort       CI Port number                                      CNcomment:操作的CI port CNend
+\param[in] enCardId       Card Id                                             CNcomment:操作卡 CNend
+\param[out] pu8Buffer     data buffer                                         CNcomment: 数据缓冲区 CNend
+\param[in]  u32BufferLen  data buffer length                                  CNcomment: 数据缓冲区Buffer长度 CNend
+\param[out] pu32ReadLen   data length that read successful                    CNcomment:成功读取的长度 CNend
+\retval ::HI_SUCCESS      success                                             CNcomment:成功 CNend
+\retval ::HI_FAILURE        fail                                              CNcomment:失败 CNend
+\retval ::HI_ERR_CI_INVALID_PARA    invalid parameter                         CNcomment:无效参数 CNend
+\retval ::HI_ERR_CI_NOT_INIT        have not been initialized or not open     CNcomment:未初始化或未打开 CNend
+\retval ::HI_ERR_CI_UNSUPPORT       unsupported CI Port                       CNcomment:不支持的CI Port CNend
+\retval ::HI_ERR_CI_REG_READ_ERR    read register error                       CNcomment:读寄存器错误 CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR   write register error                      CNcomment:写寄存器错误 CNend
+\retval ::HI_ERR_CI_IO_READ_ERR     read IO error                             CNcomment:IO读错误 CNend
+\see \n
+    HI_UNF_CI_PCCD_IOWrite()
+*/
+HI_S32 HI_UNF_CI_PCCD_IORead(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                            HI_U8 *pu8Buffer, HI_U32 u32BufferLen,
+                                            HI_U32 *pu32ReadLen);
+
+/**
+\brief CAM IO write data
+\brief CNcomment:CAM卡IO写数据 CNend
+\attention \n
+N/A
+\param[in] enCIPort       CI Port number                                      CNcomment:操作的CI port CNend
+\param[in] enCardId       Card Id                                             CNcomment:操作卡 CNend
+\param[in] pu8Buffer      data buffer                                         CNcomment:数据缓冲区 CNend
+\param[in] u32WriteLen     byte number that have been  writen                 CNcomment:写入字节数 CNend
+\param[out] pu32WriteOKLen  data length that write successful                 CNcomment:成功写入字节数 CNend
+\param[in] enCIPort       operate CI port                                     CNcomment:操作的CI port CNend
+\param[in] enCardId       Card Id                                             CNcomment:操作卡 CNend
+\param[out] pu8Buffer     data buffer                                         CNcomment: 数据缓冲区 CNend
+\param[out] pu32ReadLen   data length that read successful                    CNcomment:成功读取的长度 CNend
+\retval ::HI_SUCCESS      success                                             CNcomment:成功 CNend
+\retval ::HI_FAILURE        fail                                              CNcomment:失败 CNend
+\retval ::HI_ERR_CI_INVALID_PARA    invalid parameter                         CNcomment:无效参数 CNend
+\retval ::HI_ERR_CI_NOT_INIT        have not been initialized or not open     CNcomment:未初始化或未打开 CNend
+\retval ::HI_ERR_CI_UNSUPPORT       unsupported CI Port                       CNcomment:不支持的CI Port CNend
+\retval ::HI_ERR_CI_REG_READ_ERR    read register error                       CNcomment:读寄存器错误 CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR   write register error                      CNcomment:写寄存器错误 CNend
+\retval ::HI_ERR_CI_IO_WRITE_ERR    write IO error                            CNcomment:IO写错误 CNend
+\see \n
+    HI_UNF_CI_PCCD_IORead()
+*/
+HI_S32 HI_UNF_CI_PCCD_IOWrite(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                            HI_U8 *pu8Buffer, HI_U32 u32WriteLen, HI_U32 *pu32WriteOKLen);
+
+/**
+\brief check CAM CIS information
+\brief CNcomment:检验CAM卡CIS信息 CNend
+\attention \n
+    reference EN50221.
+    CNcomment:请参考规范 EN50221. CNend
+\param[in] enCIPort       CI Port number                                         CNcomment:操作的CI port CNend
+\param[in] enCardId       Card Id                                                CNcomment:操作卡 CNend
+\retval ::HI_SUCCESS      success                                                CNcomment:成功 CNend
+\retval ::HI_FAILURE        fail                                                 CNcomment:失败 CNend
+\retval ::HI_ERR_CI_INVALID_PARA       invalid parameter                         CNcomment:无效参数 CNend
+\retval ::HI_ERR_CI_NOT_INIT           have not been initialized or not open     CNcomment:未初始化或未打开 CNend
+\retval ::HI_ERR_CI_UNSUPPORT          unsupported CI Port                       CNcomment:不支持的CI Port CNend
+\retval ::HI_ERR_CI_PCCD_DEVICE_BUSY   device busy                               CNcomment:设备忙 CNend
+\retval ::HI_ERR_CI_PCCD_CIS_READ      read CIS information fail                 CNcomment:读CIS信息失败 CNend
+\retval ::HI_ERR_CI_REG_READ_ERR    read register error                          CNcomment:读寄存器错误 CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR   write register error                         CNcomment:写寄存器错误 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_CheckCIS(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId);
+
+/**
+\brief config CAM COR information
+\brief CNcomment:配置CAM卡COR信息 CNend
+\attention \n
+    N/A
+\param[in] enCIPort       CI Port number                                         CNcomment:操作的CI port CNend
+\param[in] enCardId       Card Id                                                CNcomment:操作卡 CNend
+\retval ::HI_SUCCESS      success                                                CNcomment:成功 CNend
+\retval ::HI_FAILURE        fail                                                 CNcomment:失败 CNend
+\retval ::HI_ERR_CI_INVALID_PARA       invalid parameter                         CNcomment:无效参数 CNend
+\retval ::HI_ERR_CI_NOT_INIT           have not been initialized or not open     CNcomment:未初始化或未打开 CNend
+\retval ::HI_ERR_CI_UNSUPPORT          unsupported CI Port                       CNcomment:不支持的CI Port CNend
+\retval ::HI_ERR_CI_PCCD_DEVICE_BUSY   device busy                               CNcomment:设备忙 CNend
+\retval ::HI_ERR_CI_ATTR_WRITE_ERR     config COR fail                           CNcomment:配置COR失败 CNend
+\retval ::HI_ERR_CI_REG_READ_ERR       read register error                       CNcomment:读寄存器错误 CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR      write register error                      CNcomment:写寄存器错误 CNend
+\see \n
+    N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_WriteCOR(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId);
+
+/**
+\brief CAM IO reset
+\brief CNcomment:CAM卡IO口复位 CNend
+\attention \n
+    N/A
+\param[in] enCIPort       CI Port number                                         CNcomment:操作的CI port CNend
+\param[in] enCardId       Card Id                                                CNcomment:操作卡 CNend
+\retval ::HI_SUCCESS      success                                                CNcomment:成功 CNend
+\retval ::HI_FAILURE        fail                                                 CNcomment:失败 CNend
+\retval ::HI_ERR_CI_INVALID_PARA       invalid parameter                         CNcomment:无效参数 CNend
+\retval ::HI_ERR_CI_NOT_INIT           have not been initialized or not open     CNcomment:未初始化或未打开 CNend
+\retval ::HI_ERR_CI_UNSUPPORT          not supported CI Port                     CNcomment:不支持的CI Port CNend
+\retval ::HI_ERR_CI_PCCD_TIMEOUT       timeout                                   CNcomment:超时 CNend
+\retval ::HI_ERR_CI_REG_READ_ERR       read register error                       CNcomment:读寄存器错误 CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR      write register error                      CNcomment:写寄存器错误 CNend
+\see \n
+    HI_UNF_CI_PCCD_CheckCIS()
+*/
+HI_S32 HI_UNF_CI_PCCD_IOReset(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId);
+
+/**
+\brief CAM negotiate buffer size
+\brief CNcomment:CAM卡协商buffer size CNend
+\attention \n
+    N/A
+\param[in] enCIPort      CI Port number                                          CNcomment:操作的CI port CNend
+\param[in] enCardId       Card Id                                                CNcomment:操作卡 CNend
+\param[in] pu16BufferSize   input  buffer size that master support               CNcomment:输入主机端支持buffer size CNend
+\param[out] pu16BufferSize  output buffer size after consultation                CNcomment:输出协商后的buffer size CNend
+\retval ::HI_SUCCESS      success                                                CNcomment:成功 CNend
+\retval ::HI_FAILURE        fail                                                 CNcomment:失败 CNend
+\retval ::HI_ERR_CI_INVALID_PARA       invalid parameter                         CNcomment:无效参数 CNend
+\retval ::HI_ERR_CI_NOT_INIT           have not been initialized or not open     CNcomment:未初始化或未打开 CNend
+\retval ::HI_ERR_CI_UNSUPPORT          unsupported CI Port                       CNcomment:不支持的CI Port CNend
+\retval ::HI_ERR_CI_PCCD_TIMEOUT       timeout                                   CNcomment:超时 CNend
+\retval ::HI_ERR_CI_REG_READ_ERR       read register error                       CNcomment:读寄存器错误 CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR      write register error                      CNcomment:写寄存器错误 CNend
+\retval ::HI_ERR_CI_IO_READ_ERR        read IO error                             CNcomment:IO读错误 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_NegBufferSize(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                                    HI_U16 *pu16BufferSize);
+
+/**
+\brief CAM TS control
+CNcomment: \brief CAM卡TS控制 CNend
+\attention \n
+    N/A
+\param[in] enCIPort       CI Port number                                         CNcomment:操作的CI port CNend
+\param[in] enCardId       Card Id                                                CNcomment:操作卡 CNend
+\param[in] enCMD          control command                                        CNcomment:控制命令 CNend
+\param[in] pParam         parameter that matching command                        CNcomment:与命令匹配的参数 CNend
+\retval ::HI_SUCCESS      success                                                CNcomment:成功 CNend
+\retval ::HI_FAILURE        fail                                                 CNcomment:失败 CNend
+\retval ::HI_ERR_CI_INVALID_PARA       invalid parameter                         CNcomment:无效参数 CNend
+\retval ::HI_ERR_CI_NOT_INIT           have not been initialized or not open     CNcomment:未初始化或未打开 CNend
+\retval ::HI_ERR_CI_UNSUPPORT          unsupported CI Port                       CNcomment:不支持的CI Port CNend
+\retval ::HI_ERR_CI_REG_READ_ERR       read register error                       CNcomment:读寄存器错误 CNend
+\retval ::HI_ERR_CI_REG_WRITE_ERR      write register error                      CNcomment:写寄存器错误 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_TSCtrl(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                        HI_UNF_CI_PCCD_TSCTRL_E enCMD, HI_UNF_CI_PCCD_TSCTRL_PARAM_U *pParam);
+
+/**
+\brief Get CAM CIS
+CNcomment:\brief 获取CAM的CIS数据
+\attention \n
+    N/A
+\param[in] enCIPort            CI Port number                                       CNcomment:操作的CI port
+\param[in] enCardId           Card Id                                              CNcomment:操作卡
+\param[out] pu8CisBuffer       output CIS data                                      CNcomment:输出CAM的CIS数据
+\param[in]  u32CisBufferLen the length of output CIS data buffer                 CNcomment:输出CAM的CIS数据Buffer长度
+\param[out] pu32CisLen      output CIS data length                                CNcomment:输出CAM的CIS数据长度
+\retval ::HI_SUCCESS      success                                                CNcomment:成功
+\retval ::HI_FAILURE        fail                                                 CNcomment:失败
+\retval ::HI_ERR_CI_INVALID_PARA       invalid parameter                         CNcomment:无效参数
+\retval ::HI_ERR_CI_NOT_INIT           have not been initialized or not open     CNcomment:未初始化或未打开
+\retval ::HI_ERR_CI_UNSUPPORT          unsupported CI Port                       CNcomment:不支持的CI Port
+\retval ::HI_ERR_CI_PCCD_DEVICE_BUSY   device busy                               CNcomment:设备忙
+\retval ::HI_ERR_CI_PCCD_CIS_READ      read cis error                            CNcomment:读CIS错误
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_GetCIS(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                             HI_U8 *pu8CisBuffer, HI_U32 u32CisBufferLen, HI_U32 *pu32CisLen);
+
+/**
+\brief config CAM COR information
+CNcomment:\brief 配置CAM卡COR信息
+\attention \n
+    N/A
+\param[in] enCIPort       CI Port number                                         CNcomment:操作的CI port
+\param[in] enCardId       Card Id                                                CNcomment:操作卡
+\param[in] u16Addr        COR register address                                   CNcomment:COR寄存器地址
+\param[in] u8Data         COR register data                                      CNcomment:要写入COR寄存器的数据
+\retval ::HI_SUCCESS      success                                                CNcomment:成功
+\retval ::HI_FAILURE        fail                                                 CNcomment:失败
+\retval ::HI_ERR_CI_INVALID_PARA       invalid parameter                         CNcomment:无效参数
+\retval ::HI_ERR_CI_NOT_INIT           have not been initialized or not open     CNcomment:未初始化或未打开
+\retval ::HI_ERR_CI_UNSUPPORT          unsupported CI Port                       CNcomment:不支持的CI Port
+\retval ::HI_ERR_CI_PCCD_DEVICE_BUSY   device busy                               CNcomment:设备忙
+\retval ::HI_ERR_CI_ATTR_WRITE_ERR     config COR fail                           CNcomment:配置COR失败
+\retval ::HI_ERR_CI_REG_READ_ERR       read register error                       CNcomment:读寄存器错误
+\retval ::HI_ERR_CI_REG_WRITE_ERR      write register error                      CNcomment:写寄存器错误
+\see \n
+    N/A
+*/
+HI_S32 HI_UNF_CI_PCCD_WriteCOREx(HI_UNF_CI_PORT_E enCIPort, HI_UNF_CI_PCCD_E enCardId,
+                                  HI_U16 u16Addr, HI_U8 u8Data);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_ECS_TYPE_H__ */
\ No newline at end of file
diff -uNr a/include/hi_unf_cipher.h b/include/hi_unf_cipher.h
--- a/include/hi_unf_cipher.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_cipher.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,1319 @@
+#ifndef __HI_UNF_CIPHER_H__
+#define __HI_UNF_CIPHER_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+/*************************** Structure Definition ****************************/
+/** \addtogroup      CIPHER */
+/** @{ */  /** <!-- [CIPHER] */
+
+/** max length of SM2, unit: word */
+/** CNcomment: SM2数据长度，单位word */
+#define SM2_LEN_IN_WROD                   (8)
+
+/** max length of SM2, unit: byte */
+/** CNcomment: SM2数据长度，单位byte */
+#define SM2_LEN_IN_BYTE                   (SM2_LEN_IN_WROD * 4)
+
+/** CIPHER only update key, don't set the IV */
+/** CNcomment: CIPHER 仅更新密钥，不更数据包的IV */
+#define CIPHER_IV_CHANGE_KEY_ONLY         (0)
+
+/** CIPHER set key and IV for first package */
+/** CNcomment: CIPHER 更新第一个数据包的IV和密钥*/
+#define CIPHER_IV_CHANGE_ONE_PKG          (1)
+
+/** CIPHER set key and IV for all package */
+/** CNcomment: CIPHER 更新所有数据包的IV和密钥*/
+#define CIPHER_IV_CHANGE_ALL_PKG          (2)
+
+/** CIPHER only update IV for first package, don't update the key*/
+/** CNcomment: CIPHER 仅更新第一个数据包的IV，不更新密钥 */
+#define CIPHER_IV_CHANGE_ONE_PKG_IV_ONLY  (3)
+
+
+/** Cipher work mode */
+/** CNcomment:CIPHER工作模式 */
+typedef enum hiHI_UNF_CIPHER_WORK_MODE_E
+{
+    HI_UNF_CIPHER_WORK_MODE_ECB,        /**<Electronic codebook (ECB) mode, ECB has been considered insecure and it is recommended not to use it.*/    /**< CNcomment:ECB模式,ECB被认为是不安全算法，建议不要使用它。*/
+    HI_UNF_CIPHER_WORK_MODE_CBC,        /**<Cipher block chaining (CBC) mode*/  /**< CNcomment:CBC模式 */
+    HI_UNF_CIPHER_WORK_MODE_CFB,        /**<Cipher feedback (CFB) mode*/        /**< CNcomment:CFB模式 */
+    HI_UNF_CIPHER_WORK_MODE_OFB,        /**<Output feedback (OFB) mode*/        /**< CNcomment:OFB模式 */
+    HI_UNF_CIPHER_WORK_MODE_CTR,        /**<Counter (CTR) mode*/                /**< CNcomment:CTR模式 */
+    HI_UNF_CIPHER_WORK_MODE_CCM,        /**<Counter (CCM) mode*/                /**< CNcomment:CCM模式 */
+    HI_UNF_CIPHER_WORK_MODE_GCM,        /**<Counter (GCM) mode*/                /**< CNcomment:GCM模式 */
+    HI_UNF_CIPHER_WORK_MODE_BUTT
+}HI_UNF_CIPHER_WORK_MODE_E;
+
+/** Cipher algorithm */
+/** CNcomment:CIPHER加密算法 */
+typedef enum hiHI_UNF_CIPHER_ALG_E
+{
+    HI_UNF_CIPHER_ALG_DES           = 0x0,  /**< Data encryption standard (DES) algorithm,DES has been considered insecure and it is recommended not to use it. */     /**< CNcomment: DES算法，被认为是不安全算法，建议不要使用它。*/
+    HI_UNF_CIPHER_ALG_3DES          = 0x1,  /**< 3DES algorithm */                               /**< CNcomment: 3DES算法 */
+    HI_UNF_CIPHER_ALG_AES           = 0x2,  /**< Advanced encryption standard (AES) algorithm */ /**< CNcomment: AES算法 */
+    HI_UNF_CIPHER_ALG_SM1           = 0x3,  /**<SM1 algorithm*/  /**< CNcomment: SM1算法 */
+    HI_UNF_CIPHER_ALG_SM4           = 0x4,  /**<SM4 algorithm*/  /**< CNcomment: SM4算法 */
+    HI_UNF_CIPHER_ALG_DMA           = 0x5,  /**<DMA copy*/  /**< CNcomment: DMA拷贝 */
+    HI_UNF_CIPHER_ALG_BUTT          = 0x6
+}HI_UNF_CIPHER_ALG_E;
+
+/** Key length */
+/** CNcomment: 密钥长度 */
+typedef enum hiHI_UNF_CIPHER_KEY_LENGTH_E
+{
+    HI_UNF_CIPHER_KEY_AES_128BIT    = 0x0,  /**< 128-bit key for the AES algorithm */ /**< CNcomment:AES运算方式下采用128bit密钥长度 */
+    HI_UNF_CIPHER_KEY_AES_192BIT    = 0x1,  /**< 192-bit key for the AES algorithm */ /**< CNcomment:AES运算方式下采用192bit密钥长度 */
+    HI_UNF_CIPHER_KEY_AES_256BIT    = 0x2,  /**< 256-bit key for the AES algorithm */ /**< CNcomment:AES运算方式下采用256bit密钥长度 */
+    HI_UNF_CIPHER_KEY_DES_3KEY      = 0x2,  /**< Three keys for the DES algorithm */  /**< CNcomment:DES运算方式下采用3个key */
+    HI_UNF_CIPHER_KEY_DES_2KEY      = 0x3,  /**< Two keys for the DES algorithm */    /**< CNcomment: DES运算方式下采用2个key  */
+    HI_UNF_CIPHER_KEY_DEFAULT       = 0x0,  /**< default key length, DES-8, SM1-48, SM4-16 */    /**< CNcomment: 默认Key长度，DES-8, SM1-48, SM4-16*/
+}HI_UNF_CIPHER_KEY_LENGTH_E;
+
+/** Cipher bit width */
+/** CNcomment: 加密位宽 */
+typedef enum hiHI_UNF_CIPHER_BIT_WIDTH_E
+{
+    HI_UNF_CIPHER_BIT_WIDTH_64BIT   = 0x0,  /**< 64-bit width */   /**< CNcomment:64bit位宽 */
+    HI_UNF_CIPHER_BIT_WIDTH_8BIT    = 0x1,  /**< 8-bit width */    /**< CNcomment:8bit位宽 */
+    HI_UNF_CIPHER_BIT_WIDTH_1BIT    = 0x2,  /**< 1-bit width */    /**< CNcomment:1bit位宽 */
+    HI_UNF_CIPHER_BIT_WIDTH_128BIT  = 0x3,  /**< 128-bit width */  /**< CNcomment:128bit位宽 */
+}HI_UNF_CIPHER_BIT_WIDTH_E;
+
+/** Cipher control parameters */
+/** CNcomment:加密控制参数变更标志 */
+typedef struct hiUNF_CIPHER_CTRL_CHANGE_FLAG_S
+{
+    HI_U32   bit1IV:4;              /**< Initial Vector change flag, 0-don't set, 1-set IV for first package, 2-set IV for each package  */ /**< CNcomment:向量变更, 0-不设置，1-只设置第一个包，2-每个包都设置 */
+    HI_U32   bitsResv:28;           /**< Reserved */                     /**< CNcomment:保留 */
+}HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S;
+
+/** Key ladder selecting parameters */
+/** CNcomment:使用哪个key ladder标志 */
+typedef enum hiUNF_CIPHER_CA_TYPE_E
+{
+    HI_UNF_CIPHER_CA_TYPE_R2R   = 0x0,      /**< Using R2R key ladder */                                                 /**< CNcomment:使用R2R key ladder */
+    HI_UNF_CIPHER_CA_TYPE_SP,               /**< Using SP key ladder */                                                  /**< CNcomment:使用SP key ladder */
+    HI_UNF_CIPHER_CA_TYPE_CSA2,             /**< Using CSA2 key ladder */                                                /**< CNcomment:使用CSA2 key ladder */
+    HI_UNF_CIPHER_CA_TYPE_CSA3,             /**< Using CSA3 key ladder */                                                /**< CNcomment:使用CSA3 key ladder */
+    HI_UNF_CIPHER_CA_TYPE_MISC,             /**< Using MISC ladder */                                                    /**< CNcomment:使用SP key ladder */
+    HI_UNF_CIPHER_CA_TYPE_GDRM,             /**< Using GDRM ladder */                                                    /**< CNcomment:使用GDRM key ladder */
+    HI_UNF_CIPHER_CA_TYPE_BLPK,             /**< Using BLPK ladder */                                                    /**< CNcomment:使用BLPK key ladder */
+    HI_UNF_CIPHER_CA_TYPE_LPK,              /**< Using LPK ladder */                                                     /**< CNcomment:使用LPK key ladder */
+    HI_UNF_CIPHER_CA_TYPE_IRDETO_HCA,       /**< Using high level code authentication key ladder*/                       /**< CNcomment:上层应用校验keyladder*/
+    HI_UNF_CIPHER_CA_TYPE_STBROOTKEY,       /**< Using for AntiCopy With STB_Root_Key  */                                /**< CNcomment:使用STB_Root_Key加解密,用于防拷贝 */
+    HI_UNF_CIPHER_CA_TYPE_SECSTORE,         /**< Using SECSTORE keyladder */                                             /**< CNcomment:使用SecStore key ladder */
+    HI_UNF_CIPHER_CA_TYPE_CLEARCW,          /**< Using Clear keyladder */                                                /**< CNcomment:使用透明 key ladder */
+    HI_UNF_CIPHER_CA_TYPE_OTHER,            /**< Using Other keyladder */                                                /**< CNcomment:使用其它 key ladder */
+    HI_UNF_CIPHER_CA_TYPE_BUTT
+}HI_UNF_CIPHER_CA_TYPE_E;
+
+/** Encryption/Decryption type selecting */
+/** CNcomment:CIPHER加解密类型选择 */
+typedef enum
+{
+    HI_UNF_CIPHER_TYPE_NORMAL       = 0x0,  /**< Create normal channel */                                                /**< CNcomment: 创建普通通道 */
+    HI_UNF_CIPHER_TYPE_COPY_AVOID,          /**< Create special channel for avoid copy */                                /**< CNcomment: 创建防止被拷贝的专用通道 */
+    HI_UNF_CIPHER_TYPE_NONSEC,              /**< Create unsecured channel, for internal use only */                      /**< CNcomment: 创建保留的非安全通道，仅限内部使用 */
+    HI_UNF_CIPHER_TYPE_BUTT,
+}HI_UNF_CIPHER_TYPE_E;
+
+/** Structure of the cipher type */
+/** CNcomment:加密类型结构 */
+typedef struct
+{
+    HI_UNF_CIPHER_TYPE_E enCipherType;
+}HI_UNF_CIPHER_ATTS_S;
+
+/** sm1 round config */
+/** CNcomment: sm1计算的轮数 */
+typedef enum hiHI_UNF_CIPHER_SM1_ROUND_E
+{
+    HI_UNF_CIPHER_SM1_ROUND_08 = 0x00,          /**< sm1 round 08 */ /**< CNcomment:SM1计算的轮数为08 */
+    HI_UNF_CIPHER_SM1_ROUND_10 = 0x01,          /**< sm1 round 10 */ /**< CNcomment:SM1计算的轮数为10 */
+    HI_UNF_CIPHER_SM1_ROUND_12 = 0x02,          /**< sm1 round 12 */ /**< CNcomment:SM1计算的轮数为12 */
+    HI_UNF_CIPHER_SM1_ROUND_14 = 0x03,          /**< sm1 round 14 */ /**< CNcomment:SM1计算的轮数为14 */
+    HI_UNF_CIPHER_SM1_ROUND_BUTT,
+}HI_UNF_CIPHER_SM1_ROUND_E;
+
+/** Structure of the cipher control information */
+/** CNcomment:加密控制信息结构 */
+typedef struct hiHI_UNF_CIPHER_CTRL_S
+{
+    HI_U32 u32Key[8];                               /**< Key input */                                                                                                     /**< CNcomment:输入密钥 */
+    HI_U32 u32IV[4];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment:初始向量 */
+    HI_BOOL bKeyByCA;                               /**< Encryption using advanced conditional access (CA) or decryption using keys */                                    /**< CNcomment:是否使用高安全CA加密或解密Key */
+    HI_UNF_CIPHER_CA_TYPE_E enCaType;                   /**< Select keyladder type when using advanced CA */                                                                  /**< CNcomment:使用高安全CA时,选择何种类型的keyladder */
+    HI_UNF_CIPHER_ALG_E enAlg;                      /**< Cipher algorithm */                                                                                              /**< CNcomment:加密算法 */
+    HI_UNF_CIPHER_BIT_WIDTH_E enBitWidth;           /**< Bit width for encryption or decryption */                                                                        /**< CNcomment:加密或解密的位宽 */
+    HI_UNF_CIPHER_WORK_MODE_E enWorkMode;           /**< Operating mode */                                                                                                /**< CNcomment:工作模式 */
+    HI_UNF_CIPHER_KEY_LENGTH_E enKeyLen;            /**< Key length */                                                                                                    /**< CNcomment:密钥长度 */
+    HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S stChangeFlags; /**< control information exchange choices, we default all woulde be change except they have been in the choices */    /**< CNcomment:控制信息变更选项，选项中没有标识的项默认全部变更 */
+} HI_UNF_CIPHER_CTRL_S;
+
+/** Structure of the cipher AES control information */
+/** CNcomment:AES加密控制信息结构 */
+typedef struct hiHI_UNF_CIPHER_CTRL_AES_S
+{
+    HI_U32 u32EvenKey[8];                           /**< Key input, default use this key*/                                                                                /**< CNcomment:输入偶密钥, 默认使用偶密钥 */
+    HI_U32 u32OddKey[8];                            /**< Key input, only valid for Multi encrypt/decrypt*/                                                                /**< CNcomment:输入奇密钥, 只对多包加解密有效 */
+    HI_U32 u32IV[4];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment:初始向量 */
+    HI_UNF_CIPHER_BIT_WIDTH_E enBitWidth;           /**< Bit width for encryption or decryption */                                                                        /**< CNcomment:加密或解密的位宽 */
+    HI_UNF_CIPHER_KEY_LENGTH_E enKeyLen;            /**< Key length */                                                                                                    /**< CNcomment:密钥长度 */
+    HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S stChangeFlags; /**< control information exchange choices, we default all woulde be change except they have been in the choices */    /**< CNcomment:控制信息变更选项，选项中没有标识的项默认全部变更 */
+} HI_UNF_CIPHER_CTRL_AES_S;
+
+/** Structure of the cipher AES CCM/GCM control information */
+/** CNcomment:AES CCM/GCM 加密控制信息结构 */
+typedef struct hiHI_UNF_CIPHER_CTRL_AES_CCM_GCM_S
+{
+    HI_U32 u32Key[8];                               /**< Key input */                                                                                                     /**< CNcomment:输入密钥 */
+    HI_U32 u32IV[4];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment:初始向量 */
+    HI_UNF_CIPHER_KEY_LENGTH_E enKeyLen;            /**< Key length */                                                                                                    /**< CNcomment:密钥长度 */
+    HI_U32 u32IVLen;                                /**< IV lenght for CCM/GCM, which is an element of {7, 8, 9, 10, 11, 12, 13} for CCM, and is an element of [1-16] for GCM*/  /**< CNcomment: CCM/GCM的IV长度，CCM的取值范围{7, 8, 9, 10, 11, 12, 13}， GCM的取值范围[1-16]*/
+    HI_U32 u32TagLen;                               /**< Tag lenght for CCM which is an element of {4,6,8,10,12,14,16}*/          /**< CNcomment: CCM的TAG长度，取值范围{4,6,8,10,12,14,16}*/
+    HI_U32 u32ALen;                                 /**< Associated data for CCM and GCM*/                                        /**< CNcomment: CCM/GCM的关联数据长度*/
+    HI_U32 u32APhyAddr;                             /**< Physical address of Associated data for CCM and GCM*/                                        /**< CNcomment: CCM/GCM的关联数据长度*/
+} HI_UNF_CIPHER_CTRL_AES_CCM_GCM_S;
+
+/** Structure of the cipher DES control information */
+/** CNcomment:DES加密控制信息结构 */
+typedef struct hiHI_UNF_CIPHER_CTRL_DES_S
+{
+    HI_U32 u32Key[2];                               /**< Key input */                                                                                                     /**< CNcomment:输入偶密钥 */
+    HI_U32 u32IV[2];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment:初始向量 */
+    HI_UNF_CIPHER_BIT_WIDTH_E enBitWidth;           /**< Bit width for encryption or decryption */                                                                        /**< CNcomment:加密或解密的位宽 */
+    HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S stChangeFlags; /**< control information exchange choices, we default all woulde be change except they have been in the choices */    /**< CNcomment:控制信息变更选项，选项中没有标识的项默认全部变更 */
+} HI_UNF_CIPHER_CTRL_DES_S;
+
+/** Structure of the cipher 3DES control information */
+/** CNcomment:3DES加密控制信息结构 */
+typedef struct hiHI_UNF_CIPHER_CTRL_3DES_S
+{
+    HI_U32 u32Key[6];                               /**< Key input */                                                                                                     /**< CNcomment:输入偶密钥 */
+    HI_U32 u32IV[2];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment:初始向量 */
+    HI_UNF_CIPHER_BIT_WIDTH_E enBitWidth;           /**< Bit width for encryption or decryption */                                                                        /**< CNcomment:加密或解密的位宽 */
+    HI_UNF_CIPHER_KEY_LENGTH_E enKeyLen;            /**< Key length */                                                                                                    /**< CNcomment:密钥长度 */
+    HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S stChangeFlags; /**< control information exchange choices, we default all woulde be change except they have been in the choices */    /**< CNcomment:控制信息变更选项，选项中没有标识的项默认全部变更 */
+} HI_UNF_CIPHER_CTRL_3DES_S;
+
+/** Structure of the cipher SM1 control information */
+/** CNcomment:SM1加密控制信息结构 */
+typedef struct hiHI_UNF_CIPHER_CTRL_SM1_S
+{
+    HI_U32 u32EK[4];                               /**< Key of EK input */                                                                                                /**< CNcomment:输入密钥EK */
+    HI_U32 u32AK[4];                               /**< Key of AK input */                                                                                                /**< CNcomment:输入密钥AK */
+    HI_U32 u32SK[4];                               /**< Key of SK input */                                                                                                /**< CNcomment:输入密钥SK */
+    HI_U32 u32IV[4];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment:初始向量 */
+    HI_UNF_CIPHER_BIT_WIDTH_E enBitWidth;           /**< Bit width for encryption or decryption */                                                                        /**< CNcomment:加密或解密的位宽 */
+    HI_UNF_CIPHER_SM1_ROUND_E enSm1Round;           /**< SM1 round number, should be 8, 10, 12 or 14*/                                                                                                    /**< CNcomment:sm1计算的轮数配置 */
+    HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S stChangeFlags; /**< control information exchange choices, we default all woulde be change except they have been in the choices */    /**< CNcomment:控制信息变更选项，选项中没有标识的项默认全部变更 */
+} HI_UNF_CIPHER_CTRL_SM1_S;
+
+/** Structure of the cipher SM4 control information */
+/** CNcomment:SM4加密控制信息结构 */
+typedef struct hiHI_UNF_CIPHER_CTRL_SM4_S
+{
+    HI_U32 u32Key[4];                               /**< Key  input */                                                                                                    /**< CNcomment:输入密钥 */
+    HI_U32 u32IV[4];                                /**< Initialization vector (IV) */                                                                                    /**< CNcomment:初始向量 */
+    HI_UNF_CIPHER_CTRL_CHANGE_FLAG_S stChangeFlags; /**< control information exchange choices, we default all woulde be change except they have been in the choices */    /**< CNcomment:控制信息变更选项，选项中没有标识的项默认全部变更 */
+} HI_UNF_CIPHER_CTRL_SM4_S;
+
+/** Expand Structure of the cipher control information */
+/** CNcomment:加密控制信息扩展结构 */
+typedef struct hiHI_UNF_CIPHER_CTRL_EX_S
+{
+    HI_UNF_CIPHER_ALG_E enAlg;                      /**< Cipher algorithm */                                                                                              /**< CNcomment:加密算法 */
+    HI_UNF_CIPHER_WORK_MODE_E enWorkMode;           /**< Operating mode */                                                                                                /**< CNcomment:工作模式 */
+    HI_BOOL bKeyByCA;                               /**< Encryption using advanced conditional access (CA) or decryption using keys */                                    /**< CNcomment:是否使用高安全CA加密或解密Key */
+    /**< Parameter for special algorithm
+        for AES, the pointer should point to HI_UNF_CIPHER_CTRL_AES_S;
+        for AES_CCM or AES_GCM, the pointer should point to HI_UNF_CIPHER_CTRL_AES_CCM_GCM_S;
+        for DES, the pointer should point to HI_UNF_CIPHER_CTRL_DES_S;
+        for 3DES, the pointer should point to HI_UNF_CIPHER_CTRL_3DES_S;
+        for SM1, the pointer should point to HI_UNF_CIPHER_CTRL_SM1_S;
+        for SM4, the pointer should point to HI_UNF_CIPHER_CTRL_SM4_S;
+    */
+    /**< CNcomment: 算法的专用参数
+        对于 AES, 指针应指向 HI_UNF_CIPHER_CTRL_AES_S;
+        对于 AES_CCM 或 AES_GCM, 指针应指向 HI_UNF_CIPHER_CTRL_AES_CCM_GCM_S;
+        对于 DES, 指针应指向 HI_UNF_CIPHER_CTRL_DES_S;
+        对于 3DES, 指针应指向 HI_UNF_CIPHER_CTRL_3DES_S;
+        对于 SM1, 指针应指向 HI_UNF_CIPHER_CTRL_SM1_S;
+        对于 SM4, 指针应指向 HI_UNF_CIPHER_CTRL_SM4_S;
+    */
+    HI_VOID *pParam;
+} HI_UNF_CIPHER_CTRL_EX_S;
+
+/** Cipher data */
+/** CNcomment:加解密数据 */
+typedef struct hiHI_UNF_CIPHER_DATA_S
+{
+    HI_U32 u32SrcPhyAddr;     /**< phy address of the original data */   /**< CNcomment:源数据物理地址 */
+    HI_U32 u32DestPhyAddr;    /**< phy address of the purpose data */    /**< CNcomment:目的数据物理地址 */
+    HI_U32 u32ByteLength;     /**< cigher data length*/                 /**< CNcomment:加解密数据长度 */
+    HI_BOOL bOddKey;    /**< Use odd key or even key*/                  /**< CNcomment:是否使用奇密钥 */
+} HI_UNF_CIPHER_DATA_S;
+
+/** Hash algrithm type */
+/** CNcomment:哈希算法类型 */
+typedef enum hiHI_UNF_CIPHER_HASH_TYPE_E
+{
+    HI_UNF_CIPHER_HASH_TYPE_SHA1,
+    HI_UNF_CIPHER_HASH_TYPE_SHA256,
+    HI_UNF_CIPHER_HASH_TYPE_HMAC_SHA1,
+    HI_UNF_CIPHER_HASH_TYPE_HMAC_SHA256,
+    HI_UNF_CIPHER_HASH_TYPE_IRDETO_CBCMAC,
+    HI_UNF_CIPHER_HASH_TYPE_SHA224,
+    HI_UNF_CIPHER_HASH_TYPE_SHA384,
+    HI_UNF_CIPHER_HASH_TYPE_SHA512,
+    HI_UNF_CIPHER_HASH_TYPE_HMAC_SHA224,
+    HI_UNF_CIPHER_HASH_TYPE_HMAC_SHA384,
+    HI_UNF_CIPHER_HASH_TYPE_HMAC_SHA512,
+    HI_UNF_CIPHER_HASH_TYPE_SM3,
+    HI_UNF_CIPHER_HASH_TYPE_BUTT,
+}HI_UNF_CIPHER_HASH_TYPE_E;
+
+/** Hash init struct input */
+/** CNcomment:哈希算法初始化输入结构体 */
+typedef struct
+{
+    HI_U8 *pu8HMACKey;
+    HI_U32 u32HMACKeyLen;
+    HI_UNF_CIPHER_HASH_TYPE_E eShaType;
+}HI_UNF_CIPHER_HASH_ATTS_S;
+
+typedef enum hiHI_UNF_CIPHER_RSA_ENC_SCHEME_E
+{
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_NO_PADDING,            /**< without padding */             /**< CNcomment: 不填充 */
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_BLOCK_TYPE_0,          /**< PKCS#1 block type 0 padding*/  /**< CNcomment: PKCS#1的block type 0填充方式*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_BLOCK_TYPE_1,          /**< PKCS#1 block type 1 padding*/  /**< CNcomment: PKCS#1的block type 1填充方式*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_BLOCK_TYPE_2,          /**< PKCS#1 block type 2 padding*/  /**< CNcomment: PKCS#1的block type 2填充方式*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_RSAES_OAEP_SHA1,       /**< PKCS#1 RSAES-OAEP-SHA1 padding*/    /**< CNcomment: PKCS#1的RSAES-OAEP-SHA1填充方式*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_RSAES_OAEP_SHA224,     /**< PKCS#1 RSAES-OAEP-SHA224 padding*/  /**< CNcomment: PKCS#1的RSAES-OAEP-SHA224填充方式*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_RSAES_OAEP_SHA256,     /**< PKCS#1 RSAES-OAEP-SHA256 padding*/  /**< CNcomment: PKCS#1的RSAES-OAEP-SHA256填充方式*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_RSAES_OAEP_SHA384,     /**< PKCS#1 RSAES-OAEP-SHA384 padding*/    /**< CNcomment: PKCS#1的RSAES-OAEP-SHA384填充方式*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_RSAES_OAEP_SHA512,     /**< PKCS#1 RSAES-OAEP-SHA512 padding*/  /**< CNcomment: PKCS#1的RSAES-OAEP-SHA512填充方式*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_RSAES_PKCS1_V1_5,      /**< PKCS#1 RSAES-PKCS1_V1_5 padding*/   /**< CNcomment: PKCS#1的PKCS1_V1_5填充方式*/
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_BUTT,
+}HI_UNF_CIPHER_RSA_ENC_SCHEME_E;
+
+typedef enum hiHI_UNF_CIPHER_RSA_SIGN_SCHEME_E
+{
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA1 = 0x100, /**< PKCS#1 RSASSA_PKCS1_V15_SHA1 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_V15_SHA1签名算法*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA224,       /**< PKCS#1 RSASSA_PKCS1_V15_SHA224 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_V15_SHA224签名算法*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA256,       /**< PKCS#1 RSASSA_PKCS1_V15_SHA256 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_V15_SHA256签名算法*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA384,       /**< PKCS#1 RSASSA_PKCS1_V15_SHA384 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_V15_SHA384签名算法*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_V15_SHA512,       /**< PKCS#1 RSASSA_PKCS1_V15_SHA512 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_V15_SHA512签名算法*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA1,         /**< PKCS#1 RSASSA_PKCS1_PSS_SHA1 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_PSS_SHA1签名算法*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA224,       /**< PKCS#1 RSASSA_PKCS1_PSS_SHA224 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_PSS_SHA224签名算法*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA256,       /**< PKCS#1 RSASSA_PKCS1_PSS_SHA256 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_PSS_SHA256签名算法*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA384,       /**< PKCS#1 RSASSA_PKCS1_PSS_SHA1 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_PSS_SHA384签名算法*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_RSASSA_PKCS1_PSS_SHA512,       /**< PKCS#1 RSASSA_PKCS1_PSS_SHA256 signature*/   /**< CNcomment: PKCS#1 RSASSA_PKCS1_PSS_SHA512签名算法*/
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_BUTT,
+}HI_UNF_CIPHER_RSA_SIGN_SCHEME_E;
+
+typedef struct
+{
+    HI_U8  *pu8N;              /**< point to public modulus  */   /**< CNcomment: 指向RSA公钥N的指针*/
+    HI_U8  *pu8E;              /**< point to public exponent */   /**< CNcomment: 指向RSA公钥E的指针*/
+    HI_U16 u16NLen;            /**< length of public modulus, max value is 512Byte*/  /**< CNcomment: RSA公钥N的长度, 最大为512Byte*/
+    HI_U16 u16ELen;            /**< length of public exponent, max value is 512Byte*/  /**< CNcomment: RSA公钥E的长度, 最大为512Byte*/
+}HI_UNF_CIPHER_RSA_PUB_KEY_S;
+
+/** RSA private key struct */
+/** CNcomment:RSA私钥结构体 */
+typedef struct
+{
+    HI_U8 *pu8N;                      /*!<  public modulus    */ /**< CNcomment: 指向RSA公钥N的指针*/
+    HI_U8 *pu8E;                      /*!<  public exponent   */ /**< CNcomment: 指向RSA公钥E的指针*/
+    HI_U8 *pu8D;                      /*!<  private exponent  */ /**< CNcomment: 指向RSA私钥D的指针*/
+    HI_U8 *pu8P;                      /*!<  1st prime factor  */ /**< CNcomment: 指向RSA私钥P的指针*/
+    HI_U8 *pu8Q;                      /*!<  2nd prime factor  */ /**< CNcomment: 指向RSA私钥Q的指针*/
+    HI_U8 *pu8DP;                     /*!<  D % (P - 1)       */ /**< CNcomment: 指向RSA私钥DP的指针*/
+    HI_U8 *pu8DQ;                     /*!<  D % (Q - 1)       */ /**< CNcomment: 指向RSA私钥DQ的指针*/
+    HI_U8 *pu8QP;                     /*!<  1 / (Q % P)       */ /**< CNcomment: 指向RSA私钥QP的指针*/
+    HI_U16 u16NLen;                   /**< length of public modulus */   /**< CNcomment: RSA公钥N的长度*/
+    HI_U16 u16ELen;                   /**< length of public exponent */  /**< CNcomment: RSA公钥E的长度*/
+    HI_U16 u16DLen;                   /**< length of private exponent */ /**< CNcomment: RSA私钥D的长度*/
+    HI_U16 u16PLen;                   /**< length of 1st prime factor,should be half of u16NLen */ /**< CNcomment: RSA私钥P的长度，必须为u16NLen长度的1/2*/
+    HI_U16 u16QLen;                   /**< length of 2nd prime factor,should be half of u16NLen */ /**< CNcomment: RSA私钥Q的长度，必须为u16NLen长度的1/2*/
+    HI_U16 u16DPLen;                  /**< length of D % (P - 1),should be half of u16NLen */      /**< CNcomment: RSA私钥DP的长度，必须为u16NLen长度的1/2*/
+    HI_U16 u16DQLen;                  /**< length of D % (Q - 1),should be half of u16NLen */      /**< CNcomment: RSA私钥DQ的长度，必须为u16NLen长度的1/2*/
+    HI_U16 u16QPLen;                  /**< length of 1 / (Q % P),should be half of u16NLen */      /**< CNcomment: RSA私钥QP的长度，必须为u16NLen长度的1/2*/
+}HI_UNF_CIPHER_RSA_PRI_KEY_S;
+
+/** RSA public key encryption struct input */
+/** CNcomment:RSA 公钥加解密算法参数结构体 */
+typedef struct
+{
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_E enScheme;   /** RSA encryption scheme*/ /** CNcomment:RSA数据加解密算法策略*/
+    HI_UNF_CIPHER_RSA_PUB_KEY_S stPubKey;      /** RSA private key struct */ /** CNcomment:RSA私钥结构体 */
+}HI_UNF_CIPHER_RSA_PUB_ENC_S;
+
+/** RSA private key decryption struct input */
+/** CNcomment:RSA 私钥解密算法参数结构体 */
+typedef struct
+{
+    HI_UNF_CIPHER_RSA_ENC_SCHEME_E enScheme; /** RSA encryption scheme */ /** CNcomment:RSA数据加解密算法*/
+    HI_UNF_CIPHER_RSA_PRI_KEY_S stPriKey;    /** RSA private key struct */ /** CNcomment:RSA私钥结构体 */
+}HI_UNF_CIPHER_RSA_PRI_ENC_S;
+
+/** RSA signature struct input */
+/** CNcomment:RSA签名算法参数结构体 */
+typedef struct
+{
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_E enScheme;  /** RSA signature scheme*/ /** CNcomment:RSA数据签名策略*/
+    HI_UNF_CIPHER_RSA_PRI_KEY_S stPriKey;      /** RSA private key struct */ /** CNcomment:RSA私钥结构体 */
+ }HI_UNF_CIPHER_RSA_SIGN_S;
+
+/** RSA signature verify struct input */
+/** CNcomment:RSA签名验证算法参数输入结构体 */
+typedef struct
+{
+    HI_UNF_CIPHER_RSA_SIGN_SCHEME_E enScheme; /** RSA signature scheme*/ /** CNcomment:RSA数据签名策略*/
+    HI_UNF_CIPHER_RSA_PUB_KEY_S stPubKey;     /** RSA public key struct */ /** CNcomment:RSA公钥结构体 */
+ }HI_UNF_CIPHER_RSA_VERIFY_S;
+
+ /** SM2 signature struct input */
+/** CNcomment: SM2签名算法参数结构体 */
+ typedef struct hiHI_UNF_CIPHER_SM2_SIGN_S
+{
+    HI_U32 u32d[SM2_LEN_IN_WROD];
+    HI_U32 u32Px[SM2_LEN_IN_WROD];
+    HI_U32 u32Py[SM2_LEN_IN_WROD];
+    HI_U8 *pu8Id;
+    HI_U16 u16IdLen;
+}HI_UNF_CIPHER_SM2_SIGN_S;
+
+/** SM2 signature verify struct input */
+/** CNcomment: SM2签名验证算法参数输入结构体 */
+typedef struct hiHI_UNF_CIPHER_SM2_VERIFY_S
+{
+    HI_U32 u32Px[SM2_LEN_IN_WROD];
+    HI_U32 u32Py[SM2_LEN_IN_WROD];
+    HI_U8 *pu8Id;
+    HI_U16 u16IdLen;
+}HI_UNF_CIPHER_SM2_VERIFY_S;
+
+/** SM2 publuc key encryption struct input */
+/** CNcomment: SM2公钥加密算法参数结构体 */
+typedef struct hiHI_UNF_CIPHER_SM2_ENC_S
+{
+    HI_U32 u32Px[SM2_LEN_IN_WROD];
+    HI_U32 u32Py[SM2_LEN_IN_WROD];
+}HI_UNF_CIPHER_SM2_ENC_S;
+
+/** SM2 private key decryption struct input */
+/** CNcomment: SM2私钥解密算法参数结构体 */
+typedef struct hiHI_UNF_CIPHER_SM2_DEC_S
+{
+    HI_U32 u32d[SM2_LEN_IN_WROD];
+}HI_UNF_CIPHER_SM2_DEC_S;
+
+/** SM2 key generate struct input */
+/** CNcomment: SM2密钥生成算法参数结构体 */
+typedef struct hiHI_UNF_CIPHER_SM2_KEY_S
+{
+    HI_U32 u32d[SM2_LEN_IN_WROD];
+    HI_U32 u32Px[SM2_LEN_IN_WROD];
+    HI_U32 u32Py[SM2_LEN_IN_WROD];
+}HI_UNF_CIPHER_SM2_KEY_S;
+
+/** Elliptic curve domain parameters. */
+/** CNcomment: ECC椭圆曲线参数 */
+typedef struct
+{
+  HI_U8 *pu8p; /** Finite field: equal to p in case of prime field curves or equal to 2^n in case of binary field curves.*/
+  HI_U8 *pu8a; /** Curve parameter a (q-3 in Suite B).*/
+  HI_U8 *pu8b; /** Curve parameter b*/
+  HI_U8 *pu8GX;/** X coordinates of G which is a base point on the curve.*/
+  HI_U8 *pu8GY;/** Y coordinates of G which is a base point on the curve.*/
+  HI_U8 *pu8n; /** Prime which is the order of G point.*/
+  HI_U32 u32h; /**<  Cofactor, which is the order of the elliptic curve divided by the order of the point G. For the Suite B curves, h = 1.*/
+  HI_U32 u32keySize; /**<  Key size in bytes. It corresponds to the size in bytes of the prime pu8n*/
+} HI_UNF_CIPHER_ECC_PARAM_S;
+
+/** CENC subsample struct input */
+/** CNcomment: CENC subsample 参数结构体 */
+typedef struct hiHI_UNF_CIPHER_SUBSAMPLE_S
+{
+    HI_U32 u32ClearHeaderLen;
+    HI_U32 u32PayLoadLen;
+    HI_U32 u32PayloadPatternEncryptLen;
+    HI_U32 u32PayloadPatternClearLen;
+    HI_U32 u32PayloadPatternOffsetLen;
+}HI_UNF_CIPHER_SUBSAMPLE_S;
+
+typedef struct hiHI_UNF_CIPHER_SUBSAMPLE_EX_S
+{
+    HI_U32 u32ClearHeaderLen;
+    HI_U32 u32PayLoadLen;
+    HI_U32 u32PayloadPatternEncryptLen;
+    HI_U32 u32PayloadPatternClearLen;
+    HI_U32 u32PayloadPatternOffsetLen;
+    HI_U32 u32IvChange;
+    HI_U32 u32IV[4];
+}HI_UNF_CIPHER_SUBSAMPLE_EX_S;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+
+#define HI_UNF_CIPHER_Open(HI_VOID)    HI_UNF_CIPHER_Init(HI_VOID);
+#define HI_UNF_CIPHER_Close(HI_VOID)   HI_UNF_CIPHER_DeInit(HI_VOID);
+#define HI_UNF_CIPHER_HASH_TYPE_CBCMAC HI_UNF_CIPHER_HASH_TYPE_IRDETO_CBCMAC
+#define HI_UNF_CIPHER_CA_TYPE_HCA      HI_UNF_CIPHER_CA_TYPE_IRDETO_HCA
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      CIPHER */
+/** @{ */  /** <!-- [CIPHER] */
+/* ---CIPHER---*/
+/**
+\brief  Init the cipher device.  CNcomment:初始化CIPHER设备。 CNend
+\attention \n
+This API is used to start the cipher device.
+CNcomment:调用此接口初始化CIPHER设备。 CNend
+\param N/A                                                                      CNcomment:无 CNend
+\retval ::HI_SUCCESS  Call this API successful.                                 CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Call this API fails.                                      CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_CIPHER_FAILED_INIT  The cipher device fails to be initialized. CNcomment:CIPHER设备初始化失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Init(HI_VOID);
+
+
+/**
+\brief  Deinit the cipher device.
+CNcomment:\brief  去初始化CIPHER设备。 CNend
+\attention \n
+This API is used to stop the cipher device. If this API is called repeatedly, HI_SUCCESS is returned, but only the first operation takes effect.
+CNcomment:调用此接口关闭CIPHER设备。重复关闭返回成功，第一次起作用。 CNend
+
+\param N/A                                                                      CNcomment:无 CNend
+\retval ::HI_SUCCESS  Call this API successful.                                 CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Call this API fails.                                      CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER设备未初始化 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_DeInit(HI_VOID);
+
+
+/**
+\brief Obtain a cipher handle for encryption and decryption.
+CNcomment：创建一路Cipher句柄。 CNend
+
+\param[in] cipher attributes                                                    CNcomment:cipher 属性。 CNend
+\param[out] phCipher Cipher handle                                              CNcomment:CIPHER句柄。 CNend
+\retval ::HI_SUCCESS Call this API successful.                                  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Call this API fails.                                       CNcomment: API系统调用失败 CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER设备未初始化 CNend
+\retval ::HI_ERR_CIPHER_INVALID_POINT  The pointer is null.                     CNcomment:指针参数为空 CNend
+\retval ::HI_ERR_CIPHER_FAILED_GETHANDLE  The cipher handle fails to be obtained, because there are no available cipher handles. CNcomment: 获取CIPHER句柄失败，没有空闲的CIPHER句柄 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_CreateHandle(HI_HANDLE* phCipher, const HI_UNF_CIPHER_ATTS_S *pstCipherAttr);
+
+
+/**
+\brief Destroy the existing cipher handle. CNcomment:销毁已存在的CIPHER句柄。 CNend
+\attention \n
+This API is used to destroy existing cipher handles.
+CNcomment:调用此接口销毁已经创建的CIPHER句柄。 CNend
+
+\param[in] hCipher Cipher handle                                                CNcomment:CIPHER句柄。 CNend
+\retval ::HI_SUCCESS  Call this API successful.                                 CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Call this API fails.                                      CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER设备未初始化 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_DestroyHandle(HI_HANDLE hCipher);
+
+
+/**
+\brief Configures the cipher control information.
+CNcomment:\brief 配置CIPHER控制信息。 CNend
+\attention \n
+Before encryption or decryption, you must call this API or HI_UNF_CIPHER_ConfigHandleEx to configure the cipher control information.
+The first 64-bit data and the last 64-bit data should not be the same when using TDES algorithm.
+Support AES/DES/3DES/SM4 algorithm, support ECB/CBC/CTR/OFB/CFB mode.
+CNcomment:进行加密解密前必须先使用此接口或HI_UNF_CIPHER_ConfigHandleEx配置CIPHER的控制信息。
+使用TDES算法时，输入密钥的前后64 bit数据不能相同。
+支持 AES/DES/3DES/SM4 算法, ECB/CBC/CTR/OFB/CFB 模式.CNend
+
+\param[in] hCipher Cipher handle.                                               CNcomment:CIPHER句柄 CNend
+\param[in] pstCtrl Cipher control information.                                  CNcomment:CIPHER控制信息 CNend
+\retval ::HI_SUCCESS Call this API successful.                                  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Call this API fails.                                       CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER设备未初始化 CNend
+\retval ::HI_ERR_CIPHER_INVALID_POINT  The pointer is null.                     CNcomment:指针参数为空 CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                 CNcomment:参数错误 CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.                  CNcomment:句柄非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_ConfigHandle(HI_HANDLE hCipher, HI_UNF_CIPHER_CTRL_S* pstCtrl);
+
+
+/**
+\brief Configures the cipher control information.
+CNcomment:\brief 配置CIPHER控制信息。 CNend
+\attention \n
+Before encryption or decryption, you must call this API or HI_UNF_CIPHER_ConfigHandle to configure the cipher control information.
+The first 64-bit data and the last 64-bit data should not be the same when using TDES algorithm.
+Support AES/DES/3DES/SM1/SM4 algorithm, support ECB/CBC/CTR/OFB/CFB/CCM/GCM mode.
+CNcomment:进行加密解密前必须先使用此接口或HI_UNF_CIPHER_ConfigHandle配置CIPHER的控制信息。
+使用TDES算法时，输入密钥的前后64 bit数据不能相同。
+支持 AES/DES/3DES/SM1/SM4 算法, ECB/CBC/CTR/OFB/CFB/CCM/GCM 模式.CNend
+
+\param[in] hCipher Cipher handle.                                               CNcomment:CIPHER句柄 CNend
+\param[in] pstExCtrl Cipher control information.                                CNcomment:CIPHER扩展控制信息 CNend
+\retval ::HI_SUCCESS Call this API succussful.                                  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Call this API fails.                                       CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER设备未初始化 CNend
+\retval ::HI_ERR_CIPHER_INVALID_POINT  The pointer is null.                     CNcomment:指针参数为空 CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                 CNcomment:参数错误 CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.                  CNcomment:句柄非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_ConfigHandleEx(HI_HANDLE hCipher, HI_UNF_CIPHER_CTRL_EX_S* pstExCtrl);
+
+
+/**
+\brief Performs encryption.
+CNcomment:\brief 进行加密。 CNend
+
+\attention \n
+This API is used to perform encryption by using the cipher module.
+The length of the encrypted data should be a multiple of 8 in TDES mode and 16 in AES mode. Besides, the length can not be bigger than 0xFFFFF.After this operation, the result will affect next operation.If you want to remove vector, you need to config IV(config pstCtrl->stChangeFlags.bit1IV with 1) by transfering HI_UNF_CIPHER_ConfigHandle.
+CNcomment:使用CIPHER进行加密操作。TDES模式下加密的数据长度应当是8的倍数，AES下应当是16的倍数。此外，加密数据长度不能长于0xFFFFF。本次操作完成后，此次操作的向量运算结果会作用于下一次操作，如果要清除向量，需要在下次加密操作之前调用HI_UNF_CIPHER_ConfigHandle重新配置IV(需要设置pstCtrl->stChangeFlags.bit1IV为1)。 CNend
+\param[in] hCipher Cipher handle                                                CNcomment:CIPHER句柄 CNend
+\param[in] u32SrcPhyAddr Physical address of the source data                    CNcomment:源数据物理地址 CNend
+\param[in] u32DestPhyAddr Physical address of the target data                   CNcomment:目的数据物理地址 CNend
+\param[in] u32ByteLength   Length of the encrypted data                         CNcomment:加密数据长度 CNend
+\retval ::HI_SUCCESS  Call this API successful.                                 CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Call this API fails.                                      CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER设备未初始化 CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                 CNcomment:参数错误 CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.                  CNcomment:句柄非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Encrypt(HI_HANDLE hCipher, HI_U32 u32SrcPhyAddr, HI_U32 u32DestPhyAddr, HI_U32 u32ByteLength);
+
+
+/**
+\brief Performs decryption.
+CNcomment:\brief 进行解密 CNend
+
+\attention \n
+This API is used to perform decryption by using the cipher module.
+The length of the decrypted data should be a multiple of 8 in TDES mode and 16 in AES mode. Besides, the length can not be bigger than 0xFFFFF.After this operation, the result will affect next operation.If you want to remove vector, you need to config IV(config pstCtrl->stChangeFlags.bit1IV with 1) by transfering HI_UNF_CIPHER_ConfigHandle.
+CNcomment:使用CIPHER进行解密操作。TDES模式下解密的数据长度应当是8的倍数，AES下应当是16的倍数。此外，解密数据长度不能长于0xFFFFF。本次操作完成后，此次操作的向量运算结果会作用于下一次操作，如果要清除向量，需要在下次解密操作之前调用HI_UNF_CIPHER_ConfigHandle重新配置IV(需要设置pstCtrl->stChangeFlags.bit1IV为1)。 CNend
+\param[in] hCipher Cipher handle.                                               CNcomment:CIPHER句柄 CNend
+\param[in] u32SrcPhyAddr Physical address of the source data.                   CNcomment:源数据物理地址 CNend
+\param[in] u32DestPhyAddr Physical address of the target data.                  CNcomment:目的数据物理地址 CNend
+\param[in] u32ByteLength Length of the decrypted data                           CNcomment:解密数据长度 CNend
+\retval ::HI_SUCCESS Call this API successful.                                  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Call this API fails.                                       CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER设备未初始化 CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                 CNcomment:参数错误 CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.                  CNcomment:句柄非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Decrypt(HI_HANDLE hCipher, HI_U32 u32SrcPhyAddr, HI_U32 u32DestPhyAddr, HI_U32 u32ByteLength);
+
+
+/**
+\brief Encrypt multiple packaged data.
+CNcomment:\brief 进行多个包数据的加密。 CNend
+\attention \n
+You can not encrypt more than 128 data package one time. When HI_ERR_CIPHER_BUSY return, the data package you send will not be deal, the custmer should decrease the number of data package or run cipher again.Note:When encrypting more than one packaged data, every one package will be calculated using initial vector configured by HI_UNF_CIPHER_ConfigHandle.Previous result will not affect the later result.
+CNcomment:每次加密的数据包个数最多不能超过128个。返回HI_ERR_CIPHER_BUSY的时候，送入数据包一个也不会被处理，用户需要减少送入的数据包的数量或者再次尝试加密。注意: 对于多个包的操作，每个包都使用HI_UNF_CIPHER_ConfigHandle配置的向量进行运算，前一个包的向量运算结果不会作用于下一个包的运算，每个包都是独立运算的。前一次函数调用的结果也不会影响后一次函数调用的运算结果。 CNend
+\param[in] hCipher cipher handle                                                                  CNcomment:CIPHER句柄。 CNend
+\param[in] pstDataPkg data package ready for cipher                                               CNcomment:待加密的数据包。 CNend
+\param[in] u32DataPkgNum  number of package ready for cipher                                      CNcomment:待加密的数据包个数。 CNend
+\retval ::HI_SUCCESS  Call this API successful.                                                   CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Call this API fails.                                                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  cipher device have not been initialized                         CNcomment:CIPHER设备未初始化 CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  parameter error                                             CNcomment:参数错误 CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  handle invalid                                            CNcomment:句柄非法 CNend
+\retval ::HI_ERR_CIPHER_BUSY  hardware is busy, it can not deal with all data package once time   CNcomment:硬件正忙，无法一次性处理全部的数据包 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_EncryptMulti(HI_HANDLE hCipher, HI_UNF_CIPHER_DATA_S *pstDataPkg, HI_U32 u32DataPkgNum);
+
+
+/**
+\brief Decrypt multiple packaged data.
+CNcomment:\brief 进行多个包数据的解密。 CNend
+\attention \n
+You can not decrypt more than 128 data package one time.When HI_ERR_CIPHER_BUSY return, the data package you send will not be deal, the custmer should decrease the number of data package or run cipher again.Note:When decrypting more than one packaged data, every one package will be calculated using initial vector configured by HI_UNF_CIPHER_ConfigHandle.Previous result will not affect the later result.
+CNcomment:每次解密的数据包个数最多不能超过128个。返回HI_ERR_CIPHER_BUSY的时候，送入数据包一个也不会被处理，用户需要减少送入的数据包的数量或者再次尝试解密。注意: 对于多个包的操作，每个包都使用HI_UNF_CIPHER_ConfigHandle配置的向量进行运算，前一个包的向量运算结果不会作用于下一个包的运算，每个包都是独立运算的，前一次函数调用的结果也不会影响后一次函数调用的运算结果。 CNend
+\param[in] hCipher cipher handle                                                                 CNcomment:CIPHER句柄。 CNend
+\param[in] pstDataPkg data package ready for cipher                                              CNcomment:待解密的数据包。 CNend
+\param[in] u32DataPkgNum  number of package ready for cipher                                     CNcomment:待解密的数据包个数。 CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                                  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Call this API fails.                                                       CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  cipher device have not been initialized                        CNcomment:CIPHER设备未初始化 CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  parameter error                                            CNcomment:参数错误 CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  handle invalid                                           CNcomment:句柄非法 CNend
+\retval ::HI_ERR_CIPHER_BUSY  hardware is busy, it can not deal with all data package once time  CNcomment:硬件正忙，无法一次性处理全部的数据包 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_DecryptMulti(HI_HANDLE hCipher, HI_UNF_CIPHER_DATA_S *pstDataPkg, HI_U32 u32DataPkgNum);
+
+
+/**
+\brief Get the tag data of CCM/GCM.
+CNcomment:\brief 获取CCM/GCM的TAG数据。 CNend
+
+\attention \n
+This API is used to get the tag data of CCM/GCM.
+\param[in] hCipher cipher handle                                                CNcomment:CIPHER句柄。 CNend
+\param[out] pu8Tag tag data of CCM/GCM                                          CNcomment:TAG指针 CNend
+\param[in/out] pu32TagLen tag data length of CCM/GCM, the input should be 16 now. CNcomment:TAG数据长度，输入需设置为16 CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                 CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Call this API fails.                                      CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER设备未初始化 CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                 CNcomment:参数错误 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_GetTag(HI_HANDLE hCipher, HI_U8 *pu8Tag, HI_U32 *pu32TagLen);
+
+
+/**
+\brief Get the random number.
+CNcomment:\brief 获取随机数。 CNend
+
+\attention \n
+This API is used to obtain the random number from the hardware.
+CNcomment:调用此接口用于获取随机数。 CNend
+
+\param[out] pu32RandomNumber Point to the random number.                                        CNcomment:随机数数值。 CNend
+\retval ::HI_SUCCESS  Call this API successful.                                                 CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                                                      CNcomment: API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_GetRandomNumber(HI_U32 *pu32RandomNumber);
+
+/**
+\brief Get the random bytes.
+CNcomment:\brief 获取随机数。 CNend
+
+\attention \n
+This API is used to obtain the random number from the hardware.
+CNcomment:调用此接口用于获取随机数。 CNend
+
+\param[out] pu32RandomNumber Point to the random number.                                        CNcomment:随机数数值。 CNend
+\param[in]  u32Bytes size of the random bytes.                                                  CNcomment:随机数大小。 CNend
+\retval ::HI_SUCCESS  Call this API successful.                                                 CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                                                      CNcomment: API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_GetMultiRandomBytes(HI_U8 *pu8RandomByte, HI_U32 u32Bytes);
+
+/**
+\brief Get the AES CBC-MAC value.
+CNcomment:\brief 获取数据的AES CBC-MAC值。 CNend
+
+\attention \n
+This API is used to obtain the AES CBC-MAC value.
+CNcomment:调用此接口用于获取AES CBC-MAC值。 CNend
+\param[in] hCipherHandle:  The cipher handle.                                                   CNcomment:Cipher句柄。 CNend
+\param[in] pInputData: input data.                                                              CNcomment:输入数据。 CNend
+\param[in] u32InputDataLen: input data length,the length should be multiple of 16 bytes if it is not the last block. CNcomment:输入数据的长度，如果不是最后一个block，则必须为16个byte的倍数。 CNend
+\param[in] bIsLastBlock: Whether this block is last block or not.                               CNcomment:是否最后一个block。 CNend
+\param[out] pOutputMAC: output CBC-MAC value,the length of pOutputMAC should be 16.             CNcomment:输出的CBC-MAC。   输出长度为16。CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                                 CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                                                      CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_CalcMAC(HI_HANDLE hCipherHandle, HI_U8 *pInputData, HI_U32 u32InputDataLen,
+                                        HI_U8 *pOutputMAC, HI_BOOL bIsLastBlock);
+
+
+/**
+\brief Init the hash module, if other program is using the hash module, the API will return failure.
+CNcomment:\brief 初始化HASH模块，如果有其他程序正在使用HASH模块，返回失败状态。 CNend
+
+\attention \n
+N/A
+
+\param[in] pstHashAttr: The hash calculating structure input.                                      CNcomment:用于计算hash的结构体参数 CNend
+\param[out] pHashHandle: The output hash handle.                                                CNcomment:输出的hash句柄 CNend
+\retval ::HI_SUCCESS  Call this API successful.                                                 CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                                                      CNcomment: API系统调用失败 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_HashInit(HI_UNF_CIPHER_HASH_ATTS_S *pstHashAttr, HI_HANDLE *pHashHandle);
+
+
+/**
+\brief Calculate the hash, if the size of the data to be calculated is very big and the DDR ram is not enough, this API can calculate the data one block by one block. Attention: The input block length must be 64bytes alingned except for the last block.
+CNcomment:\brief 计算hash值，如果需要计算的数据量比较大，该接口可以实现一个block一个block的计算，避免数据量比较大的情况下，内存不足的问题。 特别注意，除了最后一个block，前面的每一轮输入的长度都必须是64字节对齐。CNend
+
+\attention \n
+N/A
+
+\param[in] hHashHandl:  Hash handle.                                        CNcomment:Hash句柄。 CNend
+\param[in] pu8InputData:  The input data buffer.                            CNcomment:输入数据缓冲 CNend
+\param[in] u32InputDataLen:  The input data length, attention: the block length input must be 64bytes aligned except the last block!            CNcomment:输入数据的长度。重要： 输入数据块的长度必须是64字节对齐，最后一个block无此限制。 CNend
+\retval ::HI_SUCCESS  Call this API successful.                             CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                                  CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_HashUpdate(HI_HANDLE hHashHandle, HI_U8 *pu8InputData, HI_U32 u32InputDataLen);
+
+
+/**
+\brief Get the final hash value, after calculate all of the data, call this API to get the final hash value and close the handle.If there is some reason need to interupt the calculation, this API should also be call to close the handle.
+CNcomment:获取hash值，在计算完所有的数据后，调用这个接口获取最终的hash值，该接口同时会关闭hash句柄。如果在计算过程中，需要中断计算，也必须调用该接口关闭hash句柄。 CNend
+
+\attention \n
+N/A
+
+\param[in] hHashHandle:  Hash handle.                                       CNcomment:Hash句柄。  CNend
+\param[out] pu8OutputHash:  The final output hash value，and its length depends on hash type, it is 20 for sha1,28 for sha224,32 for sha256 or sm3,48 for sha384,64 for sha512.
+CNcomment:输出的hash值，长度由hash类型决定，sha1时输出长度20，sha224输出长度28，sha256和上sm3输出长度32，sha384输出长度48，sha512输出长度64。 CNend
+
+\retval ::HI_SUCCESS  Call this API successful.                             CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                                  CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_HashFinal(HI_HANDLE hHashHandle, HI_U8 *pu8OutputHash);
+
+
+/**
+\brief RSA encryption a plaintext with a RSA public key.
+CNcomment:使用RSA公钥加密一段明文。 CNend
+
+\attention \n
+N/A
+
+\param[in] pstRsaEnc:   encryption struct.                                   CNcomment:加密属性结构体。 CNend
+\param[in] pu8Input：   input data to be encryption                          CNcomment: 待加密的数据。 CNend
+\param[out] u32InLen:   length of input data to be encryption                CNcomment: 待加密的数据长度。 CNend
+\param[out] pu8Output： output data to be encryption                         CNcomment: 加密结果数据。 CNend
+\param[out] pu32OutLen: length of output data to be encryption               CNcomment: 加密结果的数据长度。 CNend
+
+\retval ::HI_SUCCESS  Call this API successful.                         CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaPublicEncrypt(HI_UNF_CIPHER_RSA_PUB_ENC_S *pstRsaEnc,
+                                  HI_U8 *pu8Input, HI_U32 u32InLen,
+                                  HI_U8 *pu8Output, HI_U32 *pu32OutLen);
+
+
+/**
+\brief RSA decryption a ciphertext with a RSA private key.
+CNcomment:使用RSA私钥解密一段密文。 CNend
+
+\attention \n
+N/A
+
+\param[in] pstRsaDec:   decryption struct.                                   CNcomment: 公钥解密属性结构体。 CNend
+\param[in] pu8Input：   input data to be decryption                          CNcomment: 待解密的数据。 CNend
+\param[out] u32InLen:   length of input data to be decryption                CNcomment: 待解密的数据长度。 CNend
+\param[out] pu8Output： output data to be decryption                         CNcomment: 解密结果数据。 CNend
+\param[out] pu32OutLen: length of output data to be decryption               CNcomment: 解密结果的数据长度。 CNend
+
+\retval ::HI_SUCCESS  Call this API successful.                         CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaPrivateDecrypt(HI_UNF_CIPHER_RSA_PRI_ENC_S *pstRsaDec,
+                                   HI_U8 *pu8Input, HI_U32 u32InLen,
+                                   HI_U8 *pu8Output, HI_U32 *pu32OutLen);
+
+
+/**
+\brief RSA encryption a plaintext with a RSA private key.
+CNcomment:使用RSA私钥加密一段明文。 CNend
+
+\attention \n
+N/A
+
+\param[in] pstRsaSign:   encryption struct.                                  CNcomment:加密属性结构体。 CNend
+\param[in] pu8Input：   input data to be encryption                          CNcomment: 待加密的数据。 CNend
+\param[out] u32InLen:   length of input data to be encryption                CNcomment: 待加密的数据长度。 CNend
+\param[out] pu8Output： output data to be encryption                         CNcomment: 加密结果数据。 CNend
+\param[out] pu32OutLen: length of output data to be encryption               CNcomment: 加密结果的数据长度。 CNend
+
+\retval ::HI_SUCCESS  Call this API successful.                         CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaPrivateEncrypt(HI_UNF_CIPHER_RSA_PRI_ENC_S *pstRsaEnc,
+                                   HI_U8 *pu8Input, HI_U32 u32InLen,
+                                   HI_U8 *pu8Output, HI_U32 *pu32OutLen);
+
+
+/**
+\brief RSA decryption a ciphertext with a RSA public key.
+CNcomment:使用RSA公钥解密一段密文。 CNend
+
+\attention \n
+N/A
+
+\param[in] pstRsaVerify:   decryption struct.                                CNcomment: 解密属性结构体。 CNend
+\param[in] pu8Input：   input data to be decryption                          CNcomment: 待解密的数据。 CNend
+\param[out] u32InLen:   length of input data to be decryption                CNcomment: 待解密的数据长度。 CNend
+\param[out] pu8Output： output data to be decryption                         CNcomment: 解密结果数据。 CNend
+\param[out] pu32OutLen: length of output data to be decryption               CNcomment: 解密结果的数据长度。 CNend
+
+\retval ::HI_SUCCESS  Call this API successful.                         CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaPublicDecrypt(HI_UNF_CIPHER_RSA_PUB_ENC_S *pstRsaDec,
+                               HI_U8 *pu8Input, HI_U32 u32InLen,
+                               HI_U8 *pu8Output, HI_U32 *pu32OutLen);
+
+
+/**
+\brief RSA signature a context with appendix, where a signer’s RSA private key is used.
+CNcomment:使用RSA私钥签名一段文本。 CNend
+
+\attention \n
+N/A
+
+\param[in] pstRsaSign:      signature struct.                                    CNcomment: 签名属性结构体。 CNend
+\param[in] pu8Input：       input context to be signature，maybe null            CNcomment: 待签名的数据, 如果pu8HashData不为空，则该指空可以为空。 CNend
+\param[in] u32InLen:        length of input context to be signature              CNcomment: 待签名的数据长度。 CNend
+\param[in] pu8HashData：    hash value of context,if NULL, let pu8HashData = Hash(context) automatically,its length depends on hash type, it is 20 for sha1,28 for sha224,32 for sha256 or sm3,48 for sha384,64 for sha512.  Ncomment: 待签名文本的HASH摘要，
+CNcomment:输出的hash摘要，长度由hash类型决定，sha1时输出长度20，sha224输出长度28，sha256和上sm3输出长度32，sha384输出长度48，sha512输出长度64。如果为空，则自动计算文本的HASH摘要。 CNend
+\param[out] pu8OutSign：    output message of signature                          CNcomment: 签名信息。 CNend
+\param[out] pu32OutSignLen: length of message of signature                       CNcomment: 签名信息的数据长度。 CNend
+
+\retval ::HI_SUCCESS  Call this API successful.                         CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaSign(HI_UNF_CIPHER_RSA_SIGN_S *pstRsaSign,
+                             HI_U8 *pu8InData, HI_U32 u32InDataLen,
+                             HI_U8 *pu8HashData,
+                             HI_U8 *pu8OutSign, HI_U32 *pu32OutSignLen);
+
+
+/**
+\brief RSA signature verification a context with appendix, where a signer’s RSA public key is used.
+CNcomment:使用RSA公钥签名验证一段文本。 CNend
+
+\attention \n
+N/A
+
+\param[in] pstRsaVerify:    signature verification struct.                         CNcomment: 签名验证属性结构体。 CNend
+\param[in] pu8Input：       input context to be signature verification，maybe null CNcomment: 待签名验证的数据, 如果pu8HashData不为空，则该指空可以为空。 CNend
+\param[in] u32InLen:        length of input context to be signature                CNcomment: 待签名验证的数据长度。 CNend
+\param[in] pu8HashData：    hash value of context,if NULL, let pu8HashData = Hash(context) automatically,its length depends on hash type, it is 20 for sha1,28 for sha224,32 for sha256 or sm3,48 for sha384,64 for sha512.  Ncomment: 待签名文本的HASH摘要，
+CNcomment:输出的hash摘要，长度由hash类型决定，sha1时输出长度20，sha224输出长度28，sha256和上sm3输出长度32，sha384输出长度48，sha512输出长度64。   Ncomment: 待签名文本的HASH摘要，如果为空，则自动计算文本的HASH摘要。 CNend
+\param[in] pu8InSign：      message of signature                                 CNcomment: 签名信息。 CNend
+\param[in] pu32InSignLen:   length of message of signature                       CNcomment: 签名信息的数据长度。 CNend
+
+\retval ::HI_SUCCESS  Call this API successful.                         CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaVerify(HI_UNF_CIPHER_RSA_VERIFY_S *pstRsaVerify,
+                               HI_U8 *pu8InData, HI_U32 u32InDataLen,
+                               HI_U8 *pu8HashData,
+                               HI_U8 *pu8InSign, HI_U32 u32InSignLen);
+
+/**
+\brief Generate a RSA private key.
+CNcomment:生成一个RSA私钥。 CNend
+
+\attention \n
+N/A
+
+\param[in] u32NumBits: bit numbers of the integer public modulus. CNcomment: RSA密钥N的位宽。 CNend
+\param[in] u32Exponent: value of public exponent. CNcomment: RSA密钥E值。 CNend
+\param[out] ptRsaPriKey: private key struct. CNcomment: RSA私钥。 CNend
+
+\retval ::HI_SUCCESS Call this API succussful. CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE Call this API fails. CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaGenKey(HI_U32 u32NumBits, HI_U32 u32Exponent, HI_UNF_CIPHER_RSA_PRI_KEY_S *pstRsaPriKey);
+
+/**
+\brief Computes CRT parameters dP, dQ and qInv from the two primes p and q and the public exponent e.
+CNcomment: 根据p和q参数，计算CRT参数dP, dQ 和 qInv 。 CNend
+
+\attention \n
+N/A
+
+\param[in] u32NumBits:     bit numbers of the integer public modulus.  CNcomment: RSA密钥N的位宽。 CNend
+\param[in] u32Exponent:    value of public exponent.                   CNcomment: RSA密钥E值。 CNend
+\param[in] pu8P Buffer containing the prime number p used as input parameter for the computation of CRT parameters. The buffer is allocated by the caller and is u32NumBits/2 bytes long. CNcomment: CRT的p参数，长度为u32NumBits/2. CNend
+\param[in] pu8Q Buffer containing the prime number q used as input parameter for the computation of CRT parameters. The buffer is allocated by the caller and is u32NumBits/2 bytes long. CNcomment: CRT的q参数，长度为u32NumBits/2. CNend
+\param[out] pu8DP Buffer where to store the CRT exponent dP computed. The buffer is allocated by the caller and is u32NumBits/2 bytes long. CNcomment: CRT的dP参数，长度为u32NumBits/2. CNend
+\param[out] pu8DQ Buffer where to store the CRT exponent dQ computed. The buffer is allocated by the caller and is u32NumBits/2 bytes long. CNcomment: CRT的dQ参数，长度为u32NumBits/2. CNend
+\param[out] pu8QP Buffer where to store the CRT exponent qInv computed. The buffer is allocated by the caller and is u32NumBits/2 bytes long. CNcomment: CRT的qInv参数，长度为u32NumBits/2. CNend
+
+\param[out] ptRsaPriKey:   private key struct.                         CNcomment: RSA私钥。 CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_RsaComputeCrtParams(HI_U32 u32NumBits, HI_U32 u32Exponent, HI_U8 *pu8P,
+                               HI_U8 *pu8Q, HI_U8 *pu8DP, HI_U8 *pu8DQ, HI_U8 *pu8QP);
+
+
+/**
+\brief SM2 signature a context with appendix, where a signer’s SM2 private key is used.
+CNcomment:使用SM2私钥签名一段文本。 CNend
+
+\attention \n
+N/A
+
+\param[in] pstSm2Sign:      signature struct.                                    CNcomment: 签名属性结构体。 CNend
+\param[in] pu8Msg:          input context to be signature，maybe null            CNcomment: 待签名的数据, 如果pu8HashData不为空，则该指空可以为空。 CNend
+\param[in] u32MsgLen:       length of input context to be signature              CNcomment: 待签名的数据长度。 CNend
+\param[out] pu8R：           The R value of the signature result,its length is 32.CNcomment: 签名结果的R值，长度32。 CNend
+\param[out] pu8S:           The S value of the signature result,its length is 32.CNcomment: 签名结果的S值，长度32。 CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Sm2Sign(HI_UNF_CIPHER_SM2_SIGN_S *pstSm2Sign, HI_U8 *pu8Msg, HI_U32 u32MsgLen, HI_U8 *pu8R, HI_U8 *pu8S);
+
+
+/**
+\brief SM2 signature verification a context with appendix, where a signer’s SM2 public key is used.
+CNcomment:使用SM2公钥签名验证一段文本。 CNend
+
+\attention \n
+N/A
+
+\param[in] pstSm2Verify:    signature verification struct.                         CNcomment: 签名验证属性结构体。 CNend
+\param[in] pu8Msg：          input context to be signature verification，maybe null CNcomment: 待签名验证的数据, 如果pu8HashData不为空，则该指空可以为空。 CNend
+\param[in] u32MsgLen:       length of input context to be signature                CNcomment: 待签名验证的数据长度。 CNend
+\param[in] pu8R：            The R value of the signature result,its length is 32.  CNcomment: 签名结果的R值，长度32。 CNend
+\param[in] pu8S:            The S value of the signature result,its length is 32.  CNcomment: 签名结果的S值，长度32。 CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Sm2Verify(HI_UNF_CIPHER_SM2_VERIFY_S *pstSm2Verify, HI_U8 *pu8Msg, HI_U32 u32MsgLen, HI_U8 *pu8R, HI_U8 *pu8S);
+
+
+/**
+\brief SM2 encryption a plaintext with a RSA public key.
+CNcomment:使用SM2公钥加密一段明文。 CNend
+
+\attention \n
+N/A
+
+\param[in] pstSm2Enc:   encryption struct.                                   CNcomment: 加密属性结构体。 CNend
+\param[in] pu8Msg：     input data to be encryption                          CNcomment: 待加密的数据。 CNend
+\param[in] u32MsgLen:   length of input data to be encryption                CNcomment: 待加密的数据长度。 CNend
+\param[out] pu8C：      output data to be encryption                         CNcomment: 加密结果数据。 CNend
+\param[out] pu32Clen:   length of output data to be encryption               CNcomment: 加密结果的数据长度。 CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Sm2Encrypt(HI_UNF_CIPHER_SM2_ENC_S *pstSm2Enc,  HI_U8 *pu8Msg, HI_U32 u32MsgLen, HI_U8 *pu8C, HI_U32 *pu32Clen);
+
+
+/**
+\brief RSA decryption a ciphertext with a SM2 private key.
+CNcomment:使用SM2私钥解密一段密文。 CNend
+
+\attention \n
+N/A
+
+\param[in] pstSm2Dec:   decryption struct.                                   CNcomment: 公钥解密属性结构体。 CNend
+\param[in] pu8C：       input data to be decryption                          CNcomment: 待解密的数据。 CNend
+\param[out] u32Clen:    length of input data to be decryption                CNcomment: 待解密的数据长度。 CNend
+\param[out] pu8Msg：    output data to be decryption                         CNcomment: 解密结果数据。 CNend
+\param[out] pu32MsgLen: length of output data to be decryption               CNcomment: 解密结果的数据长度。 CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Sm2Decrypt(HI_UNF_CIPHER_SM2_DEC_S *pstSm2Dec, HI_U8 *pu8C, HI_U32 u32Clen, HI_U8 *pu8Msg, HI_U32 *pu32MsgLen);
+
+
+/**
+\brief Generate a SM2 key pair.
+CNcomment:生成一个SM2密钥对。 CNend
+
+\attention \n
+N/A
+
+\param[out] pstSm2Key:   key pair struct.                               CNcomment: SM2密钥对。 CNend
+
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_Sm2GenKey(HI_UNF_CIPHER_SM2_KEY_S *pstSm2Key);
+
+/**
+\brief CENC decryption a ciphertext.
+CNcomment: CENC格式解密一段密文。 CNend
+
+\attention \n
+This API is used to perform decryption ciphertext base on CENC format.
+CNcomment:使用CIPHER进行CENC格式解密操作。 CNend
+\param[in] hCipher Cipher handle                                                   CNcomment:CIPHER句柄 CNend
+\param[in] u8Key key for cipher decryption,its length should be 16.                CNcomment:CIPHER 解密密钥,长度为16. CNend
+\param[in] u8IV  iv for cipher decryption,its length should be 16.                 CNcomment:CIPHER 解密IV ,长度为16.CNend
+\param[in] u32NonSecInputPhyAddr non-secure Physical address of the source data    CNcomment:源数据非安全物理地址 CNend
+\param[in] u32SecOutputPhyAddr secure Physical address of the target data          CNcomment:目的数据安全物理地址 CNend
+\param[in] u32ByteLength   Length of the decrypted data                            CNcomment:加密数据长度 CNend
+\param[in] u32FirstEncrypt offset of the first encrypt block data                  CNcomment:第一个加密数据的偏移地址，0~15 CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                    CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Call this API fails.                                         CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.            CNcomment:CIPHER设备未初始化 CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                    CNcomment:参数错误 CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.                     CNcomment:句柄非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_CENCDecrypt(HI_HANDLE hCipher, HI_U8 *pu8Key, HI_U8 *pu8IV,
+                               HI_U32 u32NonSecInPhyAddr, HI_U32 u32SecOutPhyAddr, HI_U32 u32ByteLength,
+                               HI_U32 u32FirstEncryptOffset,
+                               HI_UNF_CIPHER_SUBSAMPLE_S *pstSubSample, HI_U32 u32SubsampleNum);
+
+/**
+\brief CENC decryption a ciphertext.
+CNcomment: CENC格式解密一段密文。 CNend
+
+\attention \n
+This API is used to perform decryption ciphertext base on CENC format.
+CNcomment:使用CIPHER进行CENC格式解密操作。 CNend
+\param[in] hCipher Cipher handle                                                CNcomment:CIPHER句柄 CNend
+\param[in] u8Key key for cipher decryption,its length should be 16.             CNcomment:CIPHER 解密密钥 CNend
+\param[in] bOddKey use odd key or not                                           CNcomment:CIPHER 是否使用odd key CNend
+\param[in] u32NonSecInputPhyAddr non-secure Physical address of the source data    CNcomment:源数据非安全物理地址 CNend
+\param[in] u32SecOutputPhyAddr secure Physical address of the target data          CNcomment:目的数据安全物理地址 CNend
+\param[in] u32ByteLength   Length of the decrypted data                         CNcomment:加密数据长度 CNend
+\param[in] u32FirstEncrypt offset of the first encrypt block data               CNcomment:第一个加密数据的偏移地址，0~15 CNend
+\retval ::HI_SUCCESS  Call this API succussful.                                 CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Call this API fails.                                      CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_CIPHER_NOT_INIT  The cipher device is not initialized.         CNcomment:CIPHER设备未初始化 CNend
+\retval ::HI_ERR_CIPHER_INVALID_PARA  The parameter is invalid.                 CNcomment:参数错误 CNend
+\retval ::HI_ERR_CIPHER_INVALID_HANDLE  The handle is invalid.                  CNcomment:句柄非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_CENCDecryptEx(HI_HANDLE hCipher, HI_U8 *pu8Key, HI_BOOL bOddKey,
+                               HI_U32 u32NonSecInPhyAddr, HI_U32 u32SecOutPhyAddr, HI_U32 u32ByteLength,
+                               HI_U32 u32FirstEncryptOffset,
+                               HI_UNF_CIPHER_SUBSAMPLE_EX_S *pstSubSample, HI_U32 u32SubsampleNum);
+
+/**
+\brief Compute Diffie-Hellman shared secret as otherPubKey^privKey mod p.
+CNcomment: 计算DH共享密钥。 CNend
+
+\attention \n
+N/A
+
+\param[in] pu8P:  Buffer containing the DH prime modulus p used for the operation.  CNcomment: DH参数p. CNend
+\param[in] pu8PrivKey: Buffer containing the DH private key. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.                       CNcomment: DH私钥，长度不足Key的大小，前面补0。 CNend
+\param[in] pu8OtherPubKey: Buffer containing the DH public key of the other peer. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.  CNcomment: 对方的DH公钥，长度不足Key的大小，前面补0。 CNend
+\param[out] pu8SharedSecret:  Buffer where to write the computed shared secret. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.    CNcomment: DH共享密钥，长度不足Key的大小，前面补0。 CNend
+\param[in] u32KeySize: DH key size. CNcomment: DH密钥长度. CNend
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_DhComputeKey(HI_U8 * pu8P, HI_U8 *pu8PrivKey, HI_U8 *pu8OtherPubKey,
+                                  HI_U8 *pu8SharedSecret, HI_U32 u32KeySize);
+
+
+/**
+\brief Generate Diffie-Hellman public/private key pair from g and p parameters. The public key is equal to g^x mod p, where x is random number considered as the private key.
+CNcomment: 生成DH公私密钥对。 CNend
+
+\attention \n
+N/A
+
+\param[in] pu8G: Buffer containing the DH generator g used for the operation. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.  CNcomment: DH的g参数，长度不足Key的大小，前面补0。 CNend
+\param[in] pu8P: Buffer containing the DH generator p used for the operation. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.  CNcomment: DH的p参数，长度不足Key的大小，前面补0。 CNend
+\param[in] pu8InputPrivKey: Buffer containing an optional input private key from which the public has to be generated.  The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.  If no private key is provided as input (\c pu8InputPrivKey=NULL), function generates a random private key and stores it in pu8OutputPrivKey this buffer. CNcomment: DH的私钥，长度不足Key的大小，前面补0, 如果为空指针，该函数将生成一个私钥放到pu8OutputPrivKey中。 CNend
+\param[out] pu8OutputPrivKey: Buffer where to write the generated private key, in case no private key is provided as input (pu8InputPrivKey==NULL). It must be padded with leading zeros if the effective size of the private key is smaller than the buffer size. CNcomment: DH的私钥，长度不足Key的大小，前面补0, 如果pu8InputPrivKey为空指针，该函数将生成一个私钥放到这个buffer中。 CNend
+\param[in] u32KeySize: DH key size.                       CNcomment: DH密钥长度. CNend
+\retval ::HI_SUCCESS  Call this API succussful.           CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_DhGenKey(HI_U8 *pu8G, HI_U8 *pu8P, HI_U8 *pu8InputPrivKey,
+                                   HI_U8 *pu8OutputPrivKey, HI_U8 *pu8PubKey,
+                                   HI_U32 u32KeySize);
+
+
+/**
+\brief Compute ECDH shared secret key. This key corresponds to the X coordinates of the computed P point.
+CNcomment: 计算ECC DH共享密钥。 CNend
+
+\attention \n
+N/A
+
+\param[in] pstParams:  Elliptic curve domain parameters. The caller is in charge padding each buffer with leading zeros if the effective size of the domain parameter conveyed is smaller than pstParams->keySize.  CNcomment: ECC椭圆曲线参数，长度不足Key的大小，前面补0. CNend
+\param[in] pu8PrivKey: Buffer containing the ECDH private key. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.                       CNcomment: ECDH私钥，长度不足Key的大小，前面补0。 CNend
+\param[in] pu8OtherPubKeyX: Buffer containing the X coordinates of other peer's ECDH public key. It is padded by the caller with leading zeros if the effective size of the public key X coordinates is smaller than the buffer size.  CNcomment: 对方的ECDH公钥的X坐标，长度不足Key的大小，前面补0。 CNend
+\param[in] pu8OtherPubKeyY: Buffer containing the Y coordinates of other peer's ECDH public key. It is padded by the caller with leading zeros if the effective size of the public key Y coordinates is smaller than the buffer size.  CNcomment: 对方的ECDH公钥的Y坐标，长度不足Key的大小，前面补0。 CNend
+\param[out] pu8SharedSecret:  Buffer where to write the computed shared secret. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.    CNcomment: ECDH共享密钥，长度不足Key的大小，前面补0。 CNend
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_EcdhComputeKey(HI_UNF_CIPHER_ECC_PARAM_S *pstParams, HI_U8 *pu8PrivKey,
+                                    HI_U8 *pu8OtherPubKeyX, HI_U8 *pu8OtherPubKeyY,
+                                    HI_U8 *pu8SharedSecret);
+
+
+/**
+\brief Generate ECC public/private key pair.
+CNcomment: 生成ECDH公私密钥对。 CNend
+
+\attention \n
+N/A
+
+\param[in] pstParams:  Elliptic curve domain parameters. The caller is in charge padding each buffer with leading zeros if the effective size of the domain parameter conveyed is smaller than pstParams->keySize.  CNcomment: ECC椭圆曲线参数，长度不足Key的大小，前面补0. CNend
+\param[in] pu8InputPrivKey: Buffer containing an optional input private key from which the public has to be generated.  The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.  If no private key is provided as input (\c pu8InputPrivKey=NULL), function generates a random private key and stores it in pu8OutputPrivKey this buffer. CNcomment: ECC的私钥，长度不足Key的大小，前面补0, 如果为空指针，该函数将生成一个私钥放到pu8OutputPrivKey中。 CNend
+\param[out] pu8OutputPrivKey: Buffer where to write the generated private key, in case no private key is provided as input (pu8InputPrivKey==NULL). It must be padded with leading zeros if the effective size of the private key is smaller than the buffer size. CNcomment: ECC的私钥，长度不足Key的大小，前面补0, 如果pu8InputPrivKey为空指针，该函数将生成一个私钥放到这个buffer中。 CNend
+\pu8PubKeyX[out] Buffer where to write the X coordinates of the generated public key. It must be padded with leading zeros if the effective size of the public key X coordinates is smaller than the buffer size. CNcomment: ECC公钥X坐标. CNend
+\pu8PubKeyX[out] Buffer where to write the Y coordinates of the generated public key. It must be padded with leading zeros if the effective size of the public key X coordinates is smaller than the buffer size. CNcomment: ECC公钥Y坐标. CNend
+\retval ::HI_SUCCESS  Call this API succussful.           CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_EccGenKey(HI_UNF_CIPHER_ECC_PARAM_S *pstParams, HI_U8 *pu8InputPrivKey,
+                                    HI_U8 *pu8OutputPrivKey, HI_U8 *pu8PubKeyX, HI_U8 *pu8PubKeyY);
+
+
+/**
+\brief Sign a message with ECDSA algorithm and returns an uncompressed signature made of the pair (r, s).
+CNcomment: ECDSA签名。 CNend
+
+\attention \n
+N/A
+
+\param[in] pstParams:  Elliptic curve domain parameters. The caller is in charge padding each buffer with leading zeros if the effective size of the domain parameter conveyed is smaller than pstParams->keySize.  CNcomment: ECC椭圆曲线参数，长度不足Key的大小，前面补0. CNend
+\param[in] pu8PrivKey: Buffer containing the ECDH private key. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.                       CNcomment: ECDH私钥，长度不足Key的大小，前面补0。 CNend
+\param[in] enShaType: One of the hash algorithm.  						CNcomment: HASH 算法类型。 CNend
+\param[in] pu8Message: Message to be signed.  							CNcomment: 待签名消息。 CNend
+\param[in] Size in bytes of message to be signed.  						CNcomment: 待签名消息的长度。 CNend
+\param[out] pu8SigR:  Buffer where to write the uncompressed r component of the resulting signature. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.    CNcomment: 签名结果的R值。 CNend
+\param[out] pu8SigS:  Buffer where to write the uncompressed s component of the resulting signature. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.    CNcomment: 签名结果的S值。 CNend
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_EcdsaSign(HI_UNF_CIPHER_ECC_PARAM_S *pstParams, HI_U8 *pu8PrivKey,
+                               HI_UNF_CIPHER_HASH_TYPE_E enShaType,
+                               HI_U8 *pu8Message, HI_U32 u32MessageSize,
+                               HI_U8 *pu8SigR, HI_U8 *pu8SigS);
+
+
+/**
+\brief Verify an ECDSA signature made of an uncompressed pair (r, s).
+CNcomment: ECDSA签名验证。 CNend
+
+\attention \n
+N/A
+
+\param[in] pstParams:  Elliptic curve domain parameters. The caller is in charge padding each buffer with leading zeros if the effective size of the domain parameter conveyed is smaller than pstParams->keySize.  CNcomment: ECC椭圆曲线参数，长度不足Key的大小，前面补0. CNend
+\pu8PubKeyX[out] Buffer where to write the X coordinates of the generated public key. It must be padded with leading zeros if the effective size of the public key X coordinates is smaller than the buffer size. CNcomment: ECC公钥X坐标. CNend
+\pu8PubKeyX[out] Buffer where to write the Y coordinates of the generated public key. It must be padded with leading zeros if the effective size of the public key X coordinates is smaller than the buffer size. CNcomment: ECC公钥Y坐标. CNend
+\param[in] enShaType: One of the hash algorithm.  						CNcomment: HASH 算法类型。 CNend
+\param[in] pu8Message: Message to be signed.  							CNcomment: 待签名消息。 CNend
+\param[in] Size in bytes of message to be signed.  						CNcomment: 待签名消息的长度。 CNend
+\param[in] pu8SigR:  Buffer where to write the uncompressed r component of the resulting signature. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.    CNcomment: 签名结果的R值。 CNend
+\param[in] pu8SigS:  Buffer where to write the uncompressed s component of the resulting signature. The caller ensures it is padded with leading zeros if the effective size of this key is smaller than the u32KeySize.    CNcomment: 签名结果的S值。 CNend
+\retval ::HI_SUCCESS  Call this API succussful.                         CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                              CNcomment:API系统调用失败。 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_CIPHER_EcdsaVerify(HI_UNF_CIPHER_ECC_PARAM_S *pstParams,
+                                 HI_U8 *pu8PubKeyX, HI_U8 *pu8PubKeyY,
+                                 HI_UNF_CIPHER_HASH_TYPE_E enShaType,
+                                 HI_U8 *pu8Message, HI_U32 u32MessageSize,
+                                 HI_U8 *pu8SigR, HI_U8 *pu8SigS);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_CIPHER_H__ */
diff -uNr a/include/hi_unf_common.h b/include/hi_unf_common.h
--- a/include/hi_unf_common.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_common.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,90 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_common.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/17
+  Description   :
+  History       :
+  1.Date        : 2009/12/17
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+
+#ifndef __HI_UNF_COMMON_H__
+#define __HI_UNF_COMMON_H__
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#include "hi_common.h"
+#include "hi_unf_audio.h"
+#include "hi_unf_video.h"
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      Media_Common */
+/** @{ */  /** <!-- [Media_Common] */
+
+/**Defines the stream buffer.*/
+/**CNcomment: 定义码流缓冲结构体 */
+typedef struct hiUNF_STREAM_BUF_S
+{
+    HI_U8   *pu8Data;        /**<Data pointer*/ /**<CNcomment: 数据指针 */
+    HI_U32  u32Size;         /**<Data size*/ /**<CNcomment: 数据长度 */
+} HI_UNF_STREAM_BUF_S;
+
+/**Defines the private Es buffer address.*/
+typedef struct hiUNF_BUF_ADDR_S
+{
+        HI_U64 u64BufKerVirAddr;    /**<Es Buffer Kernel Virtual Address*/ /**<CNcomment: Buffer内核态虚拟地址*/
+        HI_U64 u64BufPhyAddr;       /**<Es Buffer Physical Address*/ /**<CNcomment: Buffer物理地址*/
+}HI_UNF_BUF_ADDR_S;
+
+/**Defines the structure of the ES buffer.*/
+/**CNcomment: 定义ES码流缓冲结构体 */
+typedef struct hiUNF_ES_BUF_S
+{
+    HI_U8 * pu8Buf;    /**<User-state virtual address of the buffer*/ /**<CNcomment: buffer的用户态虚地址*/
+    HI_U32 u32BufLen;  /**<Buffer length*/ /**<CNcomment: buffer的长度*/
+    HI_U32 u32PtsMs;   /**<Presentation time stamp (PTS) value corresponding to the start of the stream. The invalid value is 0xFFFFFFFF.*/
+                       /**<CNcomment: 码流开始处对应的PTS值，无效为0xffffffff*/
+    HI_UNF_BUF_ADDR_S   stPriEsBufAddr;  /**<Private Es Buffer Address */ /**<CNcomment: Es buffer私有地址信息 */
+}HI_UNF_ES_BUF_S;
+
+/* Crop parameter */
+typedef struct hiUNF_CROP_RECT_S
+{
+    HI_U32 u32LeftOffset;
+    HI_U32 u32TopOffset;
+    HI_U32 u32RightOffset;
+    HI_U32 u32BottomOffset;
+}HI_UNF_CROP_RECT_S;
+
+/**Defines the signal status of the input source.*/
+/**CNcomment: 定义输入源的信号状态 */
+typedef enum hiUNF_SIG_STATUS_E
+{
+    HI_UNF_SIG_SUPPORT = 0,  /**<Stable signal*/            /**<CNcomment:识别稳定信号 */
+    HI_UNF_SIG_NO_SIGNAL,    /**<No signal*/                /**<CNcomment:无信号 */
+    HI_UNF_SIG_NOT_SUPPORT,  /**<Not support the signal*/   /**<CNcomment:信号不支持 */
+    HI_UNF_SIG_UNSTABLE,     /**<Unstable signal*/          /**<CNcomment:信号不稳定 */
+    HI_UNF_SIG_BUTT          /**<Invalid value*/            /**<CNcomment:非法边界值 */
+} HI_UNF_SIG_STATUS_E;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_COMMON_ H*/
diff -uNr a/include/hi_unf_demux.h b/include/hi_unf_demux.h
--- a/include/hi_unf_demux.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_demux.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,2238 @@
+/******************************************************************************
+
+Copyright (C), 2004-2014, HiSilicon Technologies Co., Ltd.
+******************************************************************************
+File Name     : hi_unf_demux.h
+Version       : Initial
+Author        : HiSilicon multimedia software group
+Created       : 2008-06-10
+Last Modified :
+Description   : HiSilicon DEMUX API declaration
+Function List :
+History       :
+* Version   Date         Author                           Defect No.     Description
+* main\1    2008-06-10   Jiang Lei (employee ID: 40671)     NULL         Created this file.
+* main\2    2010-04-02   Jiang Lei (employee ID: 40671)     NULL         modified for HD series.
+******************************************************************************/
+/**
+ * \file
+ * \brief Describes the information about the DEMUX module.CNcomment:提供DEMUX的相关信息 CNend
+ */
+
+#ifndef __HI_UNF_DEMUX_H__
+#define __HI_UNF_DEMUX_H__
+
+#include "hi_unf_common.h"
+#include "hi_error_mpi.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      DEMUX */
+/** @{ */  /** <!-- [DEMUX] */
+
+/**Maximum depth of a filter. */
+/**CNcomment:filter最大深度*/
+#define DMX_FILTER_MAX_DEPTH            16
+#define DMX_MAX_IDX_ACQUIRED_EACH_TIME  256
+
+/**Defines the capability of the DEMUX module*/
+/**CNcomment:定义DEMUX模块业务功能结构体*/
+typedef struct hiUNF_DMX_CAPABILITY_S
+{
+    HI_U32 u32IFPortNum;        /**<Number of IF ports. */ /**< CNcomment: IF 端口数量  (与TS In 端口都是通过Tuner 连接,但是IF 端口是使用内置 QAM)    */
+    HI_U32 u32TSIPortNum;       /**<Number of TS In ports. */ /**< CNcomment: TS In 端口数量 (与IF端口都是通过Tuner 连接,但是IF 端口是使用内置 QAM)    */
+    HI_U32 u32TSOPortNum;       /**<Number of TS Out ports. */ /**< CNcomment: TS Out  端口数量*/
+    HI_U32 u32RamPortNum;       /**<Number of Ram ports. */ /**< CNcomment: Ram端口数量     */
+    HI_U32 u32DmxNum;           /**<Number of DEMUX devices*/ /**< CNcomment:设备数量     */
+    HI_U32 u32ChannelNum;       /**<Number of channels, containing the audio and video channels */ /**< CNcomment:通道数量，含音视频通道的数量 */
+    HI_U32 u32AVChannelNum;     /**<Number of av channels*/ /**< CNcomment:音视频通道数量 */
+    HI_U32 u32FilterNum;        /**<Number of filters*/ /**< CNcomment:过滤器数量   */
+    HI_U32 u32KeyNum;           /**<Number of keys*/ /**< CNcomment:密钥区数量   */
+    HI_U32 u32RecChnNum;        /**<Number of record channels */ /**< CNcomment:录制通道的数量 */
+    HI_U32 u32TagPortNum;       /**<Number of Tag ports. */ /**< CNcomment: Tag端口数量     */
+    HI_U32 u32TsioPortNum;      /**<Number of Tsio ports. */ /**< CNcomment: Tsio端口数量     */
+} HI_UNF_DMX_CAPABILITY_S;
+
+/**TSO port ID*/
+/**CNcomment:TS输出端口ID */
+typedef enum hiUNF_DMX_TSO_PORT_E
+{
+    HI_UNF_DMX_PORT_TSO_0,      /**<The first TS OUT port . */ /**< CNcomment:TS Out 端口0 */
+    HI_UNF_DMX_PORT_TSO_1,
+    HI_UNF_DMX_PORT_TSO_2,
+    HI_UNF_DMX_PORT_TSO_3
+}HI_UNF_DMX_TSO_PORT_E;
+
+/**TS port ID*/
+/**CNcomment:TS端口ID */
+typedef enum hiUNF_DMX_PORT_E
+{
+    HI_UNF_DMX_PORT_IF_0 = 0x0,  /**<The first IF port (port with  QAM  inside chipset). */ /**< CNcomment: IF 端口0 , (IF 端口是内置QAM端口，通常不多于一个) */
+    HI_UNF_DMX_PORT_IF_1,
+    HI_UNF_DMX_PORT_IF_2,
+    HI_UNF_DMX_PORT_IF_3,
+    HI_UNF_DMX_PORT_IF_4,
+    HI_UNF_DMX_PORT_IF_5,
+    HI_UNF_DMX_PORT_IF_6,
+    HI_UNF_DMX_PORT_IF_7,
+    HI_UNF_DMX_PORT_IF_8,
+    HI_UNF_DMX_PORT_IF_9,
+    HI_UNF_DMX_PORT_IF_10,
+    HI_UNF_DMX_PORT_IF_11,
+    HI_UNF_DMX_PORT_IF_12,
+    HI_UNF_DMX_PORT_IF_13,
+    HI_UNF_DMX_PORT_IF_14,
+    HI_UNF_DMX_PORT_IF_15,
+
+    HI_UNF_DMX_PORT_TSI_0 = 0x20,/**<The first TS IN  port . */ /**< CNcomment:TSIN 端口0 , (TSIN 端口即Tuner 端口) */
+    HI_UNF_DMX_PORT_TSI_1,
+    HI_UNF_DMX_PORT_TSI_2,
+    HI_UNF_DMX_PORT_TSI_3,
+    HI_UNF_DMX_PORT_TSI_4,
+    HI_UNF_DMX_PORT_TSI_5,
+    HI_UNF_DMX_PORT_TSI_6,
+    HI_UNF_DMX_PORT_TSI_7,
+    HI_UNF_DMX_PORT_TSI_8,
+    HI_UNF_DMX_PORT_TSI_9,
+    HI_UNF_DMX_PORT_TSI_10,
+    HI_UNF_DMX_PORT_TSI_11,
+    HI_UNF_DMX_PORT_TSI_12,
+    HI_UNF_DMX_PORT_TSI_13,
+    HI_UNF_DMX_PORT_TSI_14,
+    HI_UNF_DMX_PORT_TSI_15,
+
+    HI_UNF_DMX_PORT_RAM_0 = 0x80,/**<The first RAM port . */ /**< CNcomment:RAM 端口0 */
+    HI_UNF_DMX_PORT_RAM_1,
+    HI_UNF_DMX_PORT_RAM_2,
+    HI_UNF_DMX_PORT_RAM_3,
+    HI_UNF_DMX_PORT_RAM_4,
+    HI_UNF_DMX_PORT_RAM_5,
+    HI_UNF_DMX_PORT_RAM_6,
+    HI_UNF_DMX_PORT_RAM_7,
+    HI_UNF_DMX_PORT_RAM_8,
+    HI_UNF_DMX_PORT_RAM_9,
+    HI_UNF_DMX_PORT_RAM_10,
+    HI_UNF_DMX_PORT_RAM_11,
+    HI_UNF_DMX_PORT_RAM_12,
+    HI_UNF_DMX_PORT_RAM_13,
+    HI_UNF_DMX_PORT_RAM_14,
+    HI_UNF_DMX_PORT_RAM_15,
+
+    HI_UNF_DMX_PORT_TSIO_0 = 0xA0,/**<The first TSIO port . */ /**< CNcomment:TSIO 端口0 */
+    HI_UNF_DMX_PORT_TSIO_1,
+    HI_UNF_DMX_PORT_TSIO_2,
+    HI_UNF_DMX_PORT_TSIO_3,
+    HI_UNF_DMX_PORT_TSIO_4,
+    HI_UNF_DMX_PORT_TSIO_5,
+    HI_UNF_DMX_PORT_TSIO_6,
+    HI_UNF_DMX_PORT_TSIO_7,
+
+    HI_UNF_DMX_PORT_TAG_0 = 0xB0,/**<The first Tag port . */ /**< CNcomment:Tag 端口0 */
+    HI_UNF_DMX_PORT_TAG_1,
+    HI_UNF_DMX_PORT_TAG_2,
+    HI_UNF_DMX_PORT_TAG_3,
+    HI_UNF_DMX_PORT_TAG_4,
+    HI_UNF_DMX_PORT_TAG_5,
+    HI_UNF_DMX_PORT_TAG_6,
+    HI_UNF_DMX_PORT_TAG_7,
+
+    HI_UNF_DMX_PORT_BUTT
+} HI_UNF_DMX_PORT_E;
+
+
+/**TS port mode*/
+/**CNcomment:TS端口模式 */
+typedef enum hiUNF_DMX_PORT_MODE_E
+{
+    HI_UNF_DMX_PORT_MODE_EXTERNAL,   /**<External TS input mode*/ /**< CNcomment:外部TS输入*/
+    HI_UNF_DMX_PORT_MODE_INTERNAL,   /**<Internal TS input mode*/ /**< CNcomment:内部TS输入*/
+    HI_UNF_DMX_PORT_MODE_RAM,        /**<Memory input mode*/ /**< CNcomment:从内存输入*/
+
+    HI_UNF_DMX_PORT_MODE_BUTT
+} HI_UNF_DMX_PORT_MODE_E;
+
+/**TS port type*/
+/**CNcomment:TS端口类型 */
+typedef enum hiUNF_DMX_PORT_TYPE_E
+{
+    HI_UNF_DMX_PORT_TYPE_PARALLEL_BURST,          /**<Parallel burst mode*/ /**< CNcomment:并行BURST模式             */
+    HI_UNF_DMX_PORT_TYPE_PARALLEL_VALID,          /**<Parallel valid mode*/ /**< CNcomment:并行VALID模式             */
+    HI_UNF_DMX_PORT_TYPE_PARALLEL_NOSYNC_188,     /**<Self-sync 188 mode*/ /**< CNcomment:自同步188模式             */
+    HI_UNF_DMX_PORT_TYPE_PARALLEL_NOSYNC_204,     /**<Self-sync 204 mode*/ /**< CNcomment:自同步204模式             */
+    HI_UNF_DMX_PORT_TYPE_PARALLEL_NOSYNC_188_204, /**<self-sync 188/204 auto-identification mode */ /**< CNcomment:自同步188/204自动识别模式 */
+    HI_UNF_DMX_PORT_TYPE_SERIAL,                  /**<Serial sync mode, 1bit*/ /**< CNcomment:串行sync模式, 1bit串行 */
+    HI_UNF_DMX_PORT_TYPE_USER_DEFINED,            /**<User defined mode*//**< CNcomment:用户自定义模式 */
+    HI_UNF_DMX_PORT_TYPE_SERIAL2BIT,              /**<Serial sync mode, 2bit*/ /**< CNcomment:串行sync模式, 2bit串行 */
+    HI_UNF_DMX_PORT_TYPE_SERIAL_NOSYNC,           /**<Serial nosync mode, 1bit */ /**< CNcomment:串行nosync模式, 1bit串行 */
+    HI_UNF_DMX_PORT_TYPE_SERIAL2BIT_NOSYNC,       /**<Serial nosync mode, 2bit */ /**< CNcomment:串行nosync模式, 2bit串行 */
+    HI_UNF_DMX_PORT_TYPE_AUTO,                    /**<Auto mode*/ /**< CNcomment: 自动模式 */
+    HI_UNF_DMX_PORT_TYPE_PARALLEL_VALID_DUMMY_SYNC, /**<Parallel valid dummy sync mode*/ /**< CNcomment:并行VALID DUMMY SYNC模式 用于非TS全码流录制*/
+    HI_UNF_DMX_PORT_TYPE_SERIAL_NOSYNC_NOVALID,     /**<Serial nosync novalid mode, 1bit */ /**< CNcomment:串行nosync novalid模式, 1bit串行 */
+    HI_UNF_DMX_PORT_TYPE_SERIAL2BIT_NOSYNC_NOVALID, /**<Serial nosync novalid mode, 2bit */ /**< CNcomment:串行nosync novalid模式, 2bit串行 */
+
+    HI_UNF_DMX_PORT_TYPE_BUTT
+} HI_UNF_DMX_PORT_TYPE_E;
+
+/**TSO clock mode*/
+/**CNcomment:TS输出端口时钟模式 */
+typedef enum hiUNF_DMX_TSO_CLK_MODE_E
+{
+    HI_UNF_DMX_TSO_CLK_MODE_NORMAL,                  /**<Normal clock: clock always active*/ /**< CNcomment:普通模式的时钟,时钟平率均匀*/
+    HI_UNF_DMX_TSO_CLK_MODE_JITTER ,                  /**<Jittered clock: clock active only when outputing data*/ /**< CNcomment:Jittered 模式时钟,时钟频率不均匀,此时只有在有数据输出时才会出时钟 (valid信号为高的情况下)*/
+    HI_UNF_DMX_TSO_CLK_MODE_BUTT
+}HI_UNF_DMX_TSO_CLK_MODE_E;
+
+/**TSO valid mode*/
+/**CNcomment:TS输出端口valid信号模式 */
+typedef enum hiUNF_DMX_TSO_VALID_MODE_E
+{
+    HI_UNF_DMX_TSO_VALID_ACTIVE_OUTPUT,          /**<Valid signal high when outputing datas*/ /**< CNcomment:valid信号在输出数据时为高*/
+    HI_UNF_DMX_TSO_VALID_ACTIVE_HIGH ,          /**<Valid signal always high*/ /**< CNcomment:valid信号总是为高*/
+    HI_UNF_DMX_TSO_VALID_ACTIVE_BUTT
+}HI_UNF_DMX_TSO_VALID_MODE_E;
+
+/**TSO port signal line selector*/
+/**CNcomment:TS输出端口线序选择 */
+typedef enum hiUNF_DMX_TSO_SERIAL_BIT_E
+{
+    HI_UNF_DMX_TSO_SERIAL_BIT_0 = 0x0,          /**< Serial output data using data[0] as signal line*/ /**< CNcomment:使用data[0]作为串行信号线输出*/
+    HI_UNF_DMX_TSO_SERIAL_BIT_7 = 0x7,          /**< Serial output data using data[7] as signal line*/ /**< CNcomment:使用data[7]作为串行信号线输出*/
+    HI_UNF_DMX_TSO_SERIAL_BIT_BUTT
+}HI_UNF_DMX_TSO_SERIAL_BIT_E;
+
+/**TS out mode clock frequency*/
+/**CNcomment:TS输出模块时钟频率 ,注意,实际的TS out 端口输出频率 = TSO 模块时钟/分频因子*/
+typedef enum hiUNF_DMX_TSO_CLK_E
+{
+    HI_UNF_DMX_TSO_CLK_100M ,           /**< TS out mode clock frequency 100M*/ /**< CNcomment:TS输出模块时钟频率选择为100M*/
+    HI_UNF_DMX_TSO_CLK_150M ,           /**< TS out mode clock frequency 150M*/ /**< CNcomment:TS输出模块时钟频率选择为150M*/
+    HI_UNF_DMX_TSO_CLK_1200M ,          /**< TS out mode clock frequency 1200M*/ /**< CNcomment:TS输出模块时钟频率选择为1200M*/
+    HI_UNF_DMX_TSO_CLK_1500M ,          /**< TS out mode clock frequency 1500M*/ /**< CNcomment:TS输出模块时钟频率选择为1500M*/
+    HI_UNF_DMX_TSO_CLK_BUTT
+}HI_UNF_DMX_TSO_CLK_E;
+
+/** Tag sync mode */
+/** CNcomment: Tag 同步模式*/
+typedef enum hiUNF_DMX_TAG_SYNC_MODE_E
+{
+    HI_UNF_DMX_TAG_HEAD_SYNC = 0x0,          /** < tag sync signal at tag head*/ /**< CNcomment:sync信号在tag头*/
+    HI_UNF_DMX_NORMAL_HEAD_SYNC = 0x1,    /** < tag sync signal at 47 heade*/ /** <CNcomment:sync信号在47头*/
+}HI_UNF_DMX_TAG_SYNC_MODE_E;
+
+/** TS Tag attributes */
+/** CNcomment: TS Tag 配置属性*/
+#define MAX_TAG_LENGTH (12)
+typedef struct hiUNF_DMX_TAG_PORT_ATTR_S
+{
+    HI_UNF_DMX_PORT_E enTSSource;                   /**<[IN]Source of this Tag port ,can choose from HI_UNF_DMX_PORT_TSI_XX*/ /**< CNcomment:Tag 端口数据源,可以从HI_UNF_DMX_PORT_TSI_XX中选择*/
+    HI_U8             au8Tag[MAX_TAG_LENGTH];       /** <[IN]tag index value*/ /**< CNcomment:端口的tag值 */
+    HI_U32            u32TagLen;   /** <[IN & OUT]Valid tag length(1 ~ 12bytes), which is an input para when setTagAttr, otherwise out para when getTagAttr*/ /** <CNcomment:有效tag长度(1~12字节),setTagAttr时作为输入参数,getTagAttr时作为输出参数*/
+    HI_BOOL           bEnabled;       /**<[IN & OUT]Port state(default disabled), which is an input para when setTagAttr, otherwise out para when getTagAttr*/ /**< CNcomment:端口使能(默认不使能),setTagAttr时作为输入参数,getTagAttr时作为输出参数*/
+    HI_UNF_DMX_TAG_SYNC_MODE_E enSyncMod; /** <[IN & OUT]Sync mode(default HI_UNF_DMX_TAG_HEAD_SYNC), which is an input para when setTagAttr, otherwise out para when getTagAttr*/ /**<CNcomment:同步模式(默认值为HI_UNF_DMX_TAG_HEAD_SYNC ),setTagAttr时作为输入参数,getTagAttr时作为输出参数*/
+}HI_UNF_DMX_TAG_PORT_ATTR_S;
+
+
+/**TS out port attributes*/
+/**CNcomment:TS Out 端口属性*/
+typedef struct hiUNF_DMX_TSO_PORT_ATTR_S
+{
+    HI_BOOL                     bEnable;       /**<Port enable, default value HI_TRUE means enable*/ /**< CNcomment:端口使能,默认使能*/
+    HI_BOOL                     bClkReverse;   /**<Clock phase reverse, default value HI_FALSE means do not reverse the phase of clock*/ /**< CNcomment:端口时钟反向,默认不反向*/
+    HI_UNF_DMX_PORT_E           enTSSource;    /**<Source of this TS Out port ,can choose from HI_UNF_DMX_PORT_IF_0 to HI_UNF_DMX_PORT_TSI_9*/  /**< CNcomment:TS Out 端口数据源,可以从HI_UNF_DMX_PORT_IF_0 到HI_UNF_DMX_PORT_TSI_9 之间选择*/
+    HI_UNF_DMX_TSO_CLK_MODE_E   enClkMode;     /**<Clock mode: HI_UNF_DMX_TSO_CLK_MODE_NORMAL is the default value*/ /**< CNcomment:时钟模式: 默认值为 HI_UNF_DMX_TSO_CLK_MODE_NORMAL*/
+    HI_UNF_DMX_TSO_VALID_MODE_E enValidMode;   /**<Wether valid signal always enable : HI_UNF_DMX_TSO_VALID_ACTIVE_OUTPUT is the default value */ /**< CNcomment:Valid 模式: 默认值为:HI_UNF_DMX_TSO_VALID_ACTIVE_OUTPUT  */
+    HI_BOOL                     bBitSync;       /**<The sync signal duration : HI_TRUE: only valid when output the first bit(default). HI_FALSE: keep when outputing the whole byte*/
+                                                /**< CNcomment:sync 信号有效期 : HI_TRUE: 只在输出第一个bit时有效 (默认) . HI_FALSE: 在输出整个字节时都有效  */
+    HI_UNF_DMX_PORT_TYPE_E      enPortType;     /**<Port out put mode: serial(HI_UNF_DMX_PORT_TYPE_SERIAL), parallel(HI_UNF_DMX_PORT_TYPE_PARALLEL_BURST) or serial 2bits(HI_UNF_DMX_PORT_TYPE_SERIAL2BIT) mode. default is serial(HI_UNF_DMX_PORT_TYPE_SERIAL)*/
+                                                /**< CNcomment:TSO模块输出模式:串行(HI_UNF_DMX_PORT_TYPE_SERIAL)，并行(HI_UNF_DMX_PORT_TYPE_PARALLEL_BURST) 或者串行2bit(HI_UNF_DMX_PORT_TYPE_SERIAL2BIT) 模式。 默认是串行(HI_UNF_DMX_PORT_TYPE_SERIAL)*/
+    HI_UNF_DMX_TSO_SERIAL_BIT_E enBitSelector;  /**<Port line sequence select In serial mode.only valid when using serial out put mode,HI_UNF_DMX_TSO_SERIAL_BIT_7 is the default value.*/
+                                                /**< CNcomment:端口串行模式线序选择,只有使用串行输出模式的时候有效,默认值为 HI_UNF_DMX_TSO_SERIAL_BIT_7*/
+    HI_BOOL                     bLSB;           /**<Out put byte endian .only valid when using serial out put mode: HI_FALSE: first output MSB (default). HI_TRUE:  first output LSB*/
+                                                /**< CNcomment:端口输出大小端模式,只有使用串行输出模式的时候有效: HI_FALSE: 首先输出最高位 (默认) . HI_TRUE: 首先输出最低位  */
+    HI_UNF_DMX_TSO_CLK_E        enClk;          /**<TS out mode clock frequency,default is HI_UNF_DMX_TSO_CLK_150M*/ /**< CNcomment:TS输出模块时钟频率,默认是 HI_UNF_DMX_TSO_CLK_150M*/
+    HI_U32                      u32ClkDiv;      /**<TS out mode clock frequency divider,must be times of 2 ,and must meet (2 <= u32ClkDiv <= 32) .default is 2*/ /**< CNcomment:TSO模块分频因子,必须是2的整数倍,取值范围在2与32之间*/
+} HI_UNF_DMX_TSO_PORT_ATTR_S;
+
+
+/**TS port attributes*/
+/**CNcomment:TS端口属性*/
+typedef struct hiUNF_DMX_PORT_ATTR_S
+{
+    HI_UNF_DMX_PORT_MODE_E enPortMod;       /**<Port mode.Readonly*/ /**< CNcomment:端口模式 只读*/
+    HI_UNF_DMX_PORT_TYPE_E enPortType;      /**<Port type*/ /**< CNcomment:端口类型 */
+    HI_U32 u32SyncLostTh;                   /**<Sync loss threshold.The default value is recommended.*/ /**< CNcomment:同步丢失门限，推荐使用默认值 */
+    HI_U32 u32SyncLockTh;                   /**<Sync lock threshold.The default value is recommended.*/ /**< CNcomment:同步锁定门限，推荐使用默认值 */
+    HI_U32 u32TunerInClk;                   /**<Whether to reverse the phase of the clock input from the tuner*/ /**< CNcomment:Tuner输入时钟是否反相.0: 同相(默认); 1: 反相*/
+    HI_U32 u32SerialBitSelector;            /**<Port line sequence select In parallel mode: 0: cdata[7] is the most significant bit (MSB) (default). 1: cdata[0] is the MSB.
+                                                            In serial mode: 1: cdata[0] is the data line (default). 0: cdata[7] is the data line.*/
+                                            /**< CNcomment:端口线序选择。并行时:0: 表示cdata[7]最高位(默认);1: 表示cdata[0]最高位。
+                                                            串行时:1: 表示cdata[0]为数据线(默认); 0: 表示cdata[7]为数据线*/
+
+    HI_U32 u32TunerErrMod;                  /**<Level mode of the cerr_n line from the tuner to a DEMUX.
+                                                       0: A data error occurs when the cerr_n line is high.
+                                                       1: A data error occurs when the cerr_n line is low (default).*/
+                                            /**< CNcomment:tuner到DEMUX的cerr_n线电平模式:
+                                                       0: 表示cerr_n线为高时表示数据错误;
+                                                       1: 表示cerr_n线为低时表示数据错误 (默认) */
+    HI_U32 u32UserDefLen1;                  /**<User defined length1,valid when enPortType is HI_UNF_DMX_PORT_TYPE_USER_DEFINED,188~255 *//**< CNcomment:用户自定义长度检测包长1，只有端口类型为用户自定义时有效，有效范围188~255 */
+    HI_U32 u32UserDefLen2;                  /**<User defined length2,valid when enPortType is HI_UNF_DMX_PORT_TYPE_USER_DEFINED,188~255 *//**< CNcomment:用户自定义长度检测包长2，只有端口类型为用户自定义时有效，有效范围188~255*/
+    HI_UNF_DMX_PORT_E enSerialPortShareClk; /**<Port of clock that this port shared, only valid for TSI port tpye *//**< CNcomment:指定该端口所复用时钟的对应端口，该成员仅对TSI端口类型有效*/
+} HI_UNF_DMX_PORT_ATTR_S;
+
+/**Status of the TS port*/
+/**CNcomment:TS端口的状态*/
+typedef struct hiUNF_DMX_PORT_PACKETNUM_S
+{
+    HI_U32  u32TsPackCnt;    /**<Number of TS packets received from the TS port*/ /**< CNcomment:端口收到的TS包计数*/
+    HI_U32  u32ErrTsPackCnt; /**<Number of error TS packets received from the TS port*/ /**< CNcomment:端口上错误TS包的计数*/
+    HI_U32  u32TsSyncByteErrCnt;  /**<Number of sync byte error TS packets received from the TS port*/  /**< CNcomment:端口接收到非法传输同步字节的TS包计数*/
+    HI_U32  u32TsSyncLossCnt;    /**<Number of sync loss TS packets received from the TS port*/ /**< CNcomment:端口接收到同步丢失的TS包计数*/
+    HI_U32  u32TsPackDrainedCnt;    /**<Number of Drained TS packets received from the TS port*/ /**< CNcomment:端口成功获取到的合法TS包计数*/
+    HI_U32  u32PackDisCCCnt;    /**<Number of Discontinuity TS packets received from the TS port*/ /**< CNcomment:解扰后端口收到的不连续错误TS包计数*/
+    HI_U32  u32PackDisCCCntCA;    /**<Number of Discontinuity TS packets received before descrambler from the TS port, the value is same as u32PackDisCCCnt*/ /**< CNcomment: 解扰前进入端口的TS包不连续错误次数,值与u32PackDisCCCnt一致*/
+} HI_UNF_DMX_PORT_PACKETNUM_S;
+
+/** Secure mode type*/
+/**CNcomment:安全模式类型*/
+typedef enum hiUNF_DMX_SECURE_MODE_E
+{
+    HI_UNF_DMX_SECURE_MODE_NONE = 0,        /** <no security protection*/ /**<CNcomment:无安全保护*/
+    HI_UNF_DMX_SECURE_MODE_TEE,             /** <trustedzone security protection*/ /**<CNcomment:trustedzone安全保护*/
+
+    HI_UNF_DMX_SECURE_MODE_BUTT
+} HI_UNF_DMX_SECURE_MODE_E;
+
+/** TS buffer attribute*/
+/**CNcomment:TS buffer 属性*/
+typedef struct hiUNF_DMX_TSBUF_ATTR_S
+{
+    HI_UNF_DMX_SECURE_MODE_E enSecureMode;  /**<Secure indication*/ /**<CNcomment:安全标示*/
+    HI_U32  u32BufSize;                     /**<Buffer size*/ /**< CNcomment:缓冲区大小*/
+}HI_UNF_DMX_TSBUF_ATTR_S;
+
+/**Status of a TS buffer of a DEMUX*/
+/**CNcomment:DEMUX的TS Buffer状态 */
+typedef struct hiUNF_DMX_TSBUF_STATUS_S
+{
+    HI_U32 u32BufSize;    /**<Buffer size*/ /**< CNcomment:缓冲区大小*/
+    HI_U32 u32UsedSize;   /**<Used buffer size*/ /**< CNcomment:缓冲区已使用大小,该值比实际使用值大0x100字节 */
+    HI_UNF_DMX_SECURE_MODE_E enSecureMode;  /**<Secure indication*/ /**<CNcomment:安全标示*/
+    HI_U32 u32HardwareUsedSize;             /**<Hardware Used Buffer Size, used for special scene*/ /**< CNcomment:硬件当前正在使用的buffer大小，特殊场景使用，外部客户不需要关心*/
+} HI_UNF_DMX_TSBUF_STATUS_S;
+
+/**Channel type*/
+/**CNcomment:通道类型 */
+typedef enum hiUNF_DMX_CHAN_TYPE_E
+{
+    HI_UNF_DMX_CHAN_TYPE_SEC = 0, /**<Channel that receives sections data such as program specific information (PSI) or service information (SI) data*/ /**< CNcomment:用于接收 PSI/SI等secitons数据的通道*/
+    HI_UNF_DMX_CHAN_TYPE_PES,     /**<Channel that receives packetized elementary stream (PES) data*/ /**< CNcomment:用于接收PES包数据的通道*/
+    HI_UNF_DMX_CHAN_TYPE_AUD,     /**<Channel that receives audio data*/ /**< CNcomment:用于接收音频数据的通道*/
+    HI_UNF_DMX_CHAN_TYPE_VID,     /**<Channel that receives video data*/ /**< CNcomment:用于接收视频数据的通道*/
+    HI_UNF_DMX_CHAN_TYPE_POST,      /**<Entire-packet posting channel that receives an entire TS packet with a specific packet identifier (PID). */ /**< CNcomment:整包上送通道，用于接收某PID的完整TS包*/
+    HI_UNF_DMX_CHAN_TYPE_ECM_EMM,   /**<Channel that receives entitlement control message (ECM) or entitlement management message (EMM) data*/ /**< CNcomment:用于接收ECM或EMM数据的通道*/
+
+    HI_UNF_DMX_CHAN_TYPE_BUTT
+} HI_UNF_DMX_CHAN_TYPE_E;
+
+/**Status of the channel*/
+/**CNcomment:channel的状态信息*/
+typedef struct hiUNF_DMX_CHAN_PACKETNUM_S
+{
+    HI_U32          u32CCDiscCnt;   /**<CC Discontinuity Count */ /**< CNcomment:CC不连续计数*/
+} HI_UNF_DMX_CHAN_PACKETNUM_S;
+
+/**Cyclic redundancy check (CRC) mode of a channel*/
+/**CNcomment:通道的CRC模式 */
+typedef enum hiUNF_DMX_CHAN_CRC_MODE_E
+{
+    HI_UNF_DMX_CHAN_CRC_MODE_FORBID = 0,                /**<The CRC check is disabled*/ /**< CNcomment:CRC校验禁止 */
+    HI_UNF_DMX_CHAN_CRC_MODE_FORCE_AND_DISCARD = 1,     /**<The CRC check is enabled, and the error Section data is discarded*/ /**< CNcomment:CRC校验使能，并丢弃错误Section */
+    HI_UNF_DMX_CHAN_CRC_MODE_FORCE_AND_SEND = 2,        /**<The CRC check is enabled, and the error Section data is received*/ /**< CNcomment:CRC校验使能，并上送错误Section */
+    HI_UNF_DMX_CHAN_CRC_MODE_BY_SYNTAX_AND_DISCARD = 3, /**<Whether the CRC check is performed depends on the syntax, and the error Section data is discarded*/ /**< CNcomment:根据语法判断是否进行CRC校验，并丢弃错误Section */
+    HI_UNF_DMX_CHAN_CRC_MODE_BY_SYNTAX_AND_SEND = 4,    /**<Whether the CRC check is performed depends on the syntax, and the error Section data is received*/ /**< CNcomment:根据语法判断是否进行CRC校验，并上送错误Section */
+
+    HI_UNF_DMX_CHAN_CRC_MODE_BUTT
+} HI_UNF_DMX_CHAN_CRC_MODE_E;
+
+/**Output mode of a channel*/
+/**CNcomment:通道的输出模式 */
+typedef enum hiUNF_DMX_CHAN_OUTPUT_MODE_E
+{
+    HI_UNF_DMX_CHAN_OUTPUT_MODE_PLAY = 0x1,     /**<Mode of playing audios/videos or receiving data*/ /**< CNcomment:音视频播放或数据接收 */
+    HI_UNF_DMX_CHAN_OUTPUT_MODE_REC  = 0x2,     /**<Recording mode*/ /**< CNcomment:录制 */
+    HI_UNF_DMX_CHAN_OUTPUT_MODE_PLAY_REC = 0x3, /**<Mode of recording and playing data or receiving data*/ /**< CNcomment:同时录制和播放或数据接收 */
+    HI_UNF_DMX_CHAN_OUTPUT_MODE_BUTT
+} HI_UNF_DMX_CHAN_OUTPUT_MODE_E;
+
+/**Channel attribute*/
+/**CNcomment:通道属性*/
+typedef struct hiUNF_DMX_CHAN_ATTR_S
+{
+    HI_U32 u32BufSize;                            /**<Buffer size used by channels*/ /**< CNcomment:通道硬件使用buffer大小*/
+    HI_UNF_DMX_CHAN_TYPE_E enChannelType;         /**<Channel type*/ /**< CNcomment:通道类型 */
+    HI_UNF_DMX_CHAN_CRC_MODE_E enCRCMode;         /**<CRC mode.It is valid for the DEMUX_CHAN_SEC channel.*/ /**< CNcomment:CRC模式，通道类型为DMX_CHAN_SEC 时有效 */
+    HI_UNF_DMX_CHAN_OUTPUT_MODE_E enOutputMode;   /**<Output mode of the channel data*/ /**< CNcomment:通道数据输出模式 */
+    HI_UNF_DMX_SECURE_MODE_E enSecureMode;        /**<Secure channel indication*/ /**<CNcomment:安全通道标示*/
+} HI_UNF_DMX_CHAN_ATTR_S;
+
+/**Scrambled flag of the channel data*/
+/**CNcomment:通道数据的加扰标志 */
+typedef enum hiUNF_DMX_SCRAMBLED_FLAG_E
+{
+    HI_UNF_DMX_SCRAMBLED_FLAG_TS,  /**<TS data is scrambled*/ /**< CNcomment:数据被TS级加扰*/
+    HI_UNF_DMX_SCRAMBLED_FLAG_PES, /**<PES data is scrambled*/ /**< CNcomment:数据被PES级加扰*/
+    HI_UNF_DMX_SCRAMBLED_FLAG_NO,  /**<Data is not scrambled*/ /**< CNcomment:数据未被加扰*/
+
+    HI_UNF_DMX_SCRAMBLED_FLAG_BUTT
+} HI_UNF_DMX_SCRAMBLED_FLAG_E;
+
+/**Channel status*/
+/**CNcomment:通道状态 */
+typedef enum hiUNF_DMX_CHAN_STATUS_E
+{
+    HI_UNF_DMX_CHAN_CLOSE = 0x0,        /**<The channel is stopped.*/ /**< CNcomment:通道处于关闭状态*/
+    HI_UNF_DMX_CHAN_PLAY_EN = 0x1,      /**<The channel is playing audios/videos or receiving data.*/ /**< CNcomment:通道处于音视频播放或数据接收状态*/
+    HI_UNF_DMX_CHAN_REC_EN = 0x2,       /**<The channel is recording data.*/ /**< CNcomment:通道处于数据录制状态*/
+    HI_UNF_DMX_CHAN_PLAY_REC_EN = 0x3,  /**<The channel is recording and receiving data.*/ /**< CNcomment:通道处于同时录制和数据接收状态*/
+} HI_UNF_DMX_CHAN_STATUS_E;
+
+/**Defines the channel status*/
+/** CNcomment:定义通道状态结构体*/
+typedef struct hiUNF_DMX_CHAN_STATUS_S
+{
+    HI_UNF_DMX_CHAN_STATUS_E enChanStatus;   /**<Channel status*/ /**< CNcomment:通道状态*/
+} HI_UNF_DMX_CHAN_STATUS_S;
+
+/**Filter attribute*/
+/**CNcomment:过滤器属性*/
+typedef struct hiUNF_DMX_FILTER_ATTR_S
+{
+    HI_U32  u32FilterDepth;                     /**<Depth of a filter.*/ /**< CNcomment:过滤器深度*/
+    HI_U8   au8Match[DMX_FILTER_MAX_DEPTH];     /**<Matched bytes of a filter.The data is compared by bit.*/ /**< CNcomment:过滤器匹配字节,按bit比较*/
+    HI_U8   au8Mask[DMX_FILTER_MAX_DEPTH];      /**<Masked bytes of a filter. The conditions are set by bit. 0: no mask. Comparison is required. 1: mask. Comparison is not required.*/ /**< CNcomment:过滤器屏蔽字节,按bit设置, 0:没有mask，要进行比较, 1:mask起作用，不进行比较*/
+    HI_U8   au8Negate[DMX_FILTER_MAX_DEPTH];    /**<Negated bytes of a filter. 0: not negated; 1: negated*/ /**< CNcomment:过滤器取反字节,按byte设置, 0:不取反,1:取反*/
+} HI_UNF_DMX_FILTER_ATTR_S;
+
+/**Type of the DEMUX data packet.*/
+/**CNcomment:DEMUX数据包的类型*/
+typedef enum hiUNF_DMX_DATA_TYPE_E
+{
+    HI_UNF_DMX_DATA_TYPE_WHOLE = 0,  /**<The data segment contains a complete data packet*/ /**< CNcomment:此段数据包含完整的数据包, 对于SECTION每个包都是完整的*/
+    HI_UNF_DMX_DATA_TYPE_HEAD,       /**<The data segment contains the head of a data packet, but the data packet may not be complete*/ /**< CNcomment:此段数据包含数据包的起始，但是不一定是完整的包, 只用于PES数据*/
+    HI_UNF_DMX_DATA_TYPE_BODY,       /**<This type is valid only for the PES data.The data segment contains the body of a data packet. */ /**< CNcomment:此段数据包含数据包的内容，不包含起始，可能有结尾, 只用于PES数据*/
+    HI_UNF_DMX_DATA_TYPE_TAIL,       /**<This type is valid only for the PES data.The data segment contains the tail of a data packet, and is used to identify the end of a data packet.*/ /**< CNcomment:此段数据包含数据包的结尾，用于指示可识别的包结束, 只用于PES数据*/
+
+    HI_UNF_DMX_DATA_TYPE_BUTT
+} HI_UNF_DMX_DATA_TYPE_E;
+
+/**DEMUX data packet*/
+/**CNcomment:DEMUX数据包结构*/
+typedef struct hiUNF_DMX_DATA_S
+{
+    HI_U8   *pu8Data;                   /**<Data pointer*/ /**< CNcomment:数据指针 */
+    HI_U32  u32Size;                    /**<Data length*/ /**< CNcomment:数据长度 */
+    HI_UNF_DMX_DATA_TYPE_E enDataType;  /**<Data packet type*/ /**< CNcomment:数据包的类型 */
+} HI_UNF_DMX_DATA_S;
+
+/**type of record*/
+/**CNcomment: 录制类型*/
+typedef enum hiUNF_DMX_REC_TYPE_E
+{
+    HI_UNF_DMX_REC_TYPE_SELECT_PID, /**<Record selected pid ts data *//**<CNcomment: 录制指定PID TS数据*/
+    HI_UNF_DMX_REC_TYPE_ALL_PID,    /**<Record all pid ts data *//**<CNcomment: 录制全码流TS数据*/
+    HI_UNF_DMX_REC_TYPE_ALL_DATA,   /**<Record raw data,TLV etc *//**<CNcomment: 录制原始数据，如TLV等*/
+    HI_UNF_DMX_REC_TYPE_BUTT
+} HI_UNF_DMX_REC_TYPE_E;
+
+/**type of index*/
+/**CNcomment: 索引类型 */
+typedef enum hiUNF_DMX_REC_INDEX_TYPE_E
+{
+    HI_UNF_DMX_REC_INDEX_TYPE_NONE,     /**<No index is created */  /**<CNcomment: 不建索引 */
+    HI_UNF_DMX_REC_INDEX_TYPE_VIDEO,    /**<Video index */          /**<CNcomment: 视频索引 */
+    HI_UNF_DMX_REC_INDEX_TYPE_AUDIO,    /**<Audio index */          /**<CNcomment: 音频索引 */
+    HI_UNF_DMX_REC_INDEX_TYPE_BUTT
+} HI_UNF_DMX_REC_INDEX_TYPE_E;
+
+/**<TS stream type.*/
+/**<CNcomment: ts码流的类型*/
+typedef enum hiUNF_DMX_TS_PACKET_TYPE_E
+{
+    HI_UNF_DMX_TS_PACKET_188,           /**<ts stream packet size of 188 bytes*//**<CNcomment: ts码流包大小为188字节*/
+    HI_UNF_DMX_TS_PACKET_192,           /**<ts stream packet size of 192 bytes*//**<CNcomment: ts码流包大小为192字节*/
+    HI_UNF_DMX_TS_PACKET_BUTT
+}HI_UNF_DMX_TS_PACKET_TYPE_E;
+
+/**record attribute*/
+/**CNcomment: 录制属性*/
+typedef struct hiUNF_DMX_REC_ATTR_S
+{
+    HI_U32                      u32DmxId;
+    HI_U32                      u32RecBufSize;  /**<Buffer size used by record */ /**< CNcomment: 录制缓存大小 */
+    HI_UNF_DMX_REC_TYPE_E       enRecType;      /**<Record type */ /**< CNcomment: 录制类型 */
+    HI_BOOL                     bDescramed;     /**<HI_TRUE is the descrambled TS. HI_FALSE is the original TS. */ /**<CNcomment: HI_TRUE表示录制解扰后的TS流，HI_FALSE表示录制原始流 */
+    HI_UNF_DMX_REC_INDEX_TYPE_E enIndexType;    /**<Index type */ /**< CNcomment: 索引类型 */
+    HI_U32                      u32IndexSrcPid; /**<The index information is formed according to the PID. when indexing video, it has to be set to the video of PID. when indexing audio, it has to be set to the audio of PID. */ /**< CNcomment: 根据此PID生成索引数据，视频索引时设置为视频的PID，音频索引时设置为音频的PID */
+    HI_UNF_VCODEC_TYPE_E        enVCodecType;   /**<Video encoding protocol. The protocol needs to be set only when the index type is HI_UNF_DMX_REC_INDEX_TYPE_VIDEO.*/ /**< CNcomment: 视频索引时设置视频的编码类型 */
+    HI_UNF_DMX_SECURE_MODE_E    enSecureMode;   /**<Secure record indication*/ /**<CNcomment:安全录制标示*/
+    HI_UNF_DMX_TS_PACKET_TYPE_E enTsPacketType; /**<TS stream type of recorded TS.*/ /**<CNcomment: 录制生成文件中码流的TS类型 */
+} HI_UNF_DMX_REC_ATTR_S;
+
+/**record data*/
+/**CNcomment: 录制数据*/
+typedef struct hiUNF_DMX_REC_DATA_S
+{
+    HI_U8  *pDataAddr;      /**<Data address*/          /**<CNcomment: 数据地址 */
+    HI_U32  u32DataPhyAddr; /**<Data physical address*/ /**<CNcomment: 数据的物理地址 */
+    HI_U32  u32Len;         /**<Data length*/           /**<CNcomment: 数据长度 */
+    HI_BOOL bLastDataFlag;  /**<Last Data Flag */       /**<CNcomment: 最后数据包标记 */
+} HI_UNF_DMX_REC_DATA_S;
+
+/**index data*/
+/**CNcomment: 索引数据*/
+typedef struct hiUNF_DMX_REC_INDEX_S
+{
+    HI_UNF_VIDEO_FRAME_TYPE_E   enFrameType;        /**< it is meaningless when indexing audio. */ /**<CNcomment: 音频索引时无意义 */
+    HI_U32                      u32PtsMs;
+    HI_U64                      u64GlobalOffset;
+    HI_U32                      u32FrameSize;       /**< it is meaningless when indexing audio. */ /**<CNcomment: 音频索引时无意义 */
+    HI_U32                      u32DataTimeMs;
+} HI_UNF_DMX_REC_INDEX_S;
+
+/**index and record data*/
+/**CNcomment: 索引数据和录制数据*/
+typedef struct hiUNF_DMX_REC_DATA_INDEX_S
+{
+    HI_U32 u32IdxNum;                                   /**< Number of index */ /**<CNcomment: 索引数据个数 */
+    HI_U32 u32RecDataCnt;                               /**< Number of record data block*/ /**<CNcomment: 录制数据块个数 ,一般为1个，只有在当前录制数据一部分在录制buffer尾部，一部分在头部的时候，会分成两个block 分别获取上来 */
+    HI_UNF_DMX_REC_INDEX_S stIndex[DMX_MAX_IDX_ACQUIRED_EACH_TIME];
+    HI_UNF_DMX_REC_DATA_S  stRecData[2];
+} HI_UNF_DMX_REC_DATA_INDEX_S;
+
+/**record buffer status*/
+/**CNcomment: 录制缓冲区状态结构*/
+typedef struct hiUNF_DMX_RECBUF_STATUS_S
+{
+    HI_U32  u32BufSize;     /**<Buffer size*/ /**< CNcomment:缓冲区大小 */
+    HI_U32  u32UsedSize;    /**<Used buffer*/ /**< CNcomment:缓冲区已使用大小 */
+} HI_UNF_DMX_RECBUF_STATUS_S;
+
+/**Repeat CC mode of channel*//**CNcomment:通道的CC重复模式 */
+typedef enum hiUNF_DMX_CHAN_CC_REPEAT_MODE
+{
+    HI_UNF_DMX_CHAN_CC_REPEAT_MODE_RSV   = 0x0,     /**<Receive CC repeat ts packet*/ /**< CNcomment:接收cc重复的ts包*/
+    HI_UNF_DMX_CHAN_CC_REPEAT_MODE_DROP  = 0x1,     /**<Drop CC repeat ts packet*/ /**< CNcomment:丢弃cc重复的ts包 */
+    HI_UNF_DMX_CHAN_CC_REPEAT_MODE_BUTT = -1
+}HI_UNF_DMX_CHAN_CC_REPEAT_MODE_E;
+
+typedef struct hiUNF_DMX_CHAN_CC_REPEAT_SET_S
+{
+    HI_HANDLE hChannel;                               /**<The channel handle*/ /**< CNcomment:通道句柄*/
+    HI_UNF_DMX_CHAN_CC_REPEAT_MODE_E enCCRepeatMode;   /**<Repeat CC mode of channel*/ /**< CNcomment:通道的CC模式*/
+}HI_UNF_DMX_CHAN_CC_REPEAT_SET_S;
+
+/** PUSI (Payload Unit Start Index) config structure*/
+/**CNcomment: PUSI 配置结构体 */
+typedef struct hiUNF_DMX_PUSI_SET_S
+{
+    HI_BOOL bPusi;                               /**< Value of Pusi , Default is HI_FALSE means receive ts packet without checking PUSI*/ /**< CNcomment:NoPusiEn 的值，默认为 HI_FALSE 表示接收TS包的时候不检测PUSI标志*/
+}HI_UNF_DMX_PUSI_SET_S;
+
+/** TEI (Transport Error Index) config structure*/
+/**CNcomment: TEI 配置结构体 */
+typedef struct hiUNF_DMX_TEI_SET_S
+{
+    HI_U32   u32DemuxID;                    /**<The Subdiviece ID*/ /**< CNcomment:Demux 子设备ID*/
+    HI_BOOL bTei;                                   /**< Value of bTei , Default is HI_FALSE means receive ts packet even TEI equal 1*/ /**< CNcomment:TEICfg 的值，默认为 HI_FALSE 表示接收TEI为1 的 TS包仍然接收*/
+}HI_UNF_DMX_TEI_SET_S;
+
+/** Define of how TSI and TSO to be attached */
+/**CNcomment: TSI/TSO绑定关系结构体 */
+typedef struct hiUNF_DMX_TSI_ATTACH_TSO_S
+{
+    HI_UNF_DMX_PORT_E       enTSI;              /**<The TSI ID*/ /**< CNcomment:TSI 端口ID*/
+    HI_UNF_DMX_TSO_PORT_E   enTSO;              /**<The TSO ID*/ /**< CNcomment:TSO 端口ID*/
+}HI_UNF_DMX_TSI_ATTACH_TSO_S;
+
+typedef enum hiUNF_DMX_INVOKE_TYPE
+{
+    HI_UNF_DMX_INVOKE_TYPE_CHAN_CC_REPEAT_SET  = 0,  /**<dmx set channel extra attr,param:HI_UNF_DMX_CHAN_CC_REPEAT_SET_S*//**<CNcomment: 设置通道附加属性，使用参数HI_UNF_DMX_CHAN_CC_REPEAT_SET_S */
+    HI_UNF_DMX_INVOKE_TYPE_PUSI_SET,                    /**<dmx set PUSI flag,param:HI_UNF_DMX_PUSI_SET_S*//**<CNcomment: 设置 NoPusiEn 标志，使用参数HI_UNF_DMX_PUSI_SET_S */
+    HI_UNF_DMX_INVOKE_TYPE_TEI_SET,             /**<dmx set TEI flag,param:HI_UNF_DMX_TEI_SET_S*//**<CNcomment: 设置Demux 子设备TEICfg 标志，使用参数HI_UNF_DMX_TEI_SET_S */
+    HI_UNF_DMX_INVOKE_TYPE_TSI_ATTACH_TSO,      /**<Attach TSI with TSO ,param:HI_UNF_DMX_TSI_ATTACH_TSO_S*//**<CNcomment: 将TSI 与 某个 TSO 绑定,即: TSI 的码流来自 TSO ，使用参数HI_UNF_DMX_TEI_SET_S */
+    HI_UNF_DMX_INVOKE_TYPE_BUTT
+} HI_UNF_DMX_INVOKE_TYPE_E;
+
+/** Define cb context type */
+/**CNcomment:定义回调上下文的类型*/
+typedef enum hiUNF_DMX_CB_CONTEXT_TYPE_E
+{
+    HI_UNF_DMX_CB_CONTEXT_TYPE_SHARED = 0, /**<public shared context thread*//**<CNcomment:共享的公共上下文 */
+    HI_UNF_DMX_CB_CONTEXT_TYPE_PRIVATE, /**<private context thread *//**<CNcomment:私有上下文*/
+    HI_UNF_DMX_CB_CONTEXT_TYPE_BUTT
+}HI_UNF_DMX_CB_CONTEXT_TYPE_E;
+
+/** Declare section/pes/post cb function interface */
+/**CNcomment:声明section/pes/post通道的回调函数接口*/
+typedef HI_S32 (*HI_UNF_DMX_CHAN_BUF_CB_FUNC)(HI_HANDLE hChannel, HI_U32 u32AcquiredNum, HI_UNF_DMX_DATA_S *pstBuf, HI_VOID *pUserData);
+
+/** Define cb descriptor */
+/**CNcomment:定义回调描述信息*/
+typedef struct hiUNF_DMX_CB_DESC_S
+{
+    HI_UNF_DMX_CB_CONTEXT_TYPE_E enContextType; /**<cb context type*//**<CNcomment:回调上下文类型*/
+    HI_UNF_DMX_CHAN_BUF_CB_FUNC pfnChanBufCb; /**<section/pes/post cb function *//**<CNcomment:section/pes/post通道回调函数*/
+    HI_VOID *pUserData; /** user private data *//**<CNcomment:用户私有信息 */
+}HI_UNF_DMX_CB_DESC_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      DEMUX */
+/** @{ */  /** <!-- [DEMUX] */
+
+/**
+\brief Initializes the DEMUX module.CNcomment:初始化DEMUX模块。CNend
+\attention \n
+Before using DEMUXs, you must call this application programming interface (API).\n
+Before using the personal video recorder (PVR) or audio/video player (AVPLAY), you need to initialize the DEMUX module.\n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:在进行DEMUX相关操作前应该首先调用本接口\n
+在使用PVR和AVPLAY前请提前进行DEMUX模块的初始化\n
+重复调用本接口返回成功。CNend
+\param  N/A.CNcomment:无。CNend
+\retval ::HI_SUCCESS Success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\see \n
+N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_Init(HI_VOID);
+
+
+/**
+\brief Deinitializes the DEMUX module. CNcomment:去初始化DEMUX模块。CNend
+\attention \n
+After this API is called, the DEMUX module is stopped, and the DEMUX resources used by the process are released.\n
+This API is valid when it is called for the first time. If this API is called repeatedly, the error code HI_SUCCESS is returned.
+CNcomment:调用本接口停止使用DEMUX模块，并释放本进程所占用的DEMUX资源\n
+本接口第一次调用起作用，重复调用返回成功。CNend
+\param  N/A.CNcomment:无。CNend
+\retval ::HI_SUCCESS Success CNcomment:成功。CNend
+\retval ::HI_FAILURE Calling this API fails. CNcomment:API系统调用失败。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_DeInit(HI_VOID);
+
+
+/**
+\brief Obtains the information about the service capabilities of the DEMUX module.The information includes the numbers of channels, filters, keys, ports, DEMUXs, and audio/video channels.
+CNcomment:查询DEMUX模块业务能力。业务功能包括通用通道数目、过滤器数目、密钥数目、端口数目、DEMUX设备数目和音视频通道数目等。CNend
+\attention \n
+N/A.CNcomment:无。CNend
+\param[out] pstCap   Pointer to the capability of the DEMUX module (output).CNcomment:指针类型，输出DEMUX模块能力。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null.CNcomment:指针参数为空。CNend
+\see \n
+::HI_UNF_DMX_CAPABILITY_S
+*/
+HI_S32 HI_UNF_DMX_GetCapability(HI_UNF_DMX_CAPABILITY_S *pstCap);
+
+
+/**
+\brief Obtains the attributes of a DEMUX port.CNcomment:获取DEMUX端口属性。CNend
+\attention \n
+ N/A.CNcomment:无。CNend
+\param[in] enPortId Port ID.CNcomment:端口号。CNend
+\param[out] pstAttr Pointer to the port attributes (output).CNcomment:指针类型，输出端口属性。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid.CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null.CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSPortAttr(HI_UNF_DMX_PORT_E enPortId, HI_UNF_DMX_PORT_ATTR_S *pstAttr);
+
+
+/**
+\brief Sets the attributes of a DEMUX port.CNcomment:设置DEMUX端口属性。CNend
+\attention \n
+It is recommended to query the default attributes of a DEMUX port by calling HI_UNF_DMX_GetTSPortAttr before modifying the attributes of the port.\n
+The port mode can be queried only, notice that it will lose TS data if call this function during receiving data.\n
+If the sync loss threshold and sync lock threshold are used, their default values are recommended.\n
+For details on how to set the input clock of the tuner, select the line sequence of the port, and set the level of the tuner error line, contact hardware engineers of HiSilicon\n
+and refer to tuner user manuals.
+CNcomment:建议先通过HI_UNF_DMX_GetTSPortAttr获取默认属性，然后对要改变的属性进行设置\n
+端口模式只支持查询，不支持修改，注意收数据过程调用该接口会引起丢TS包\n
+同步丢失和同步锁定门限，推荐使用默认值\n
+tuner输入时钟反向、端口线序选择和tuner error线电平模式的设置请咨询硬件工程师\n
+并参考tuner的用户手册，然后设置为合适的值。CNend
+\param[in] enPortId Port ID.CNcomment:端口号。CNend
+\param[in] pstAttr  Pointer to port attributes.CNcomment:指针类型，端口属性。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_SetTSPortAttr(HI_UNF_DMX_PORT_E enPortId, const HI_UNF_DMX_PORT_ATTR_S *pstAttr);
+
+
+/**
+\brief Obtains the attributes of a DEMUX TSO port.CNcomment:获取DEMUX TS输出端口属性。CNend
+\attention \n
+ N/A.CNcomment:无。CNend
+\param[in] enPortId Port ID.CNcomment:端口号。CNend
+\param[out] pstAttr Pointer to the port attributes (output).CNcomment:指针类型，输出端口属性。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid.CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null.CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSOPortAttr(HI_UNF_DMX_TSO_PORT_E enPortId, HI_UNF_DMX_TSO_PORT_ATTR_S *pstAttr);
+
+
+/**
+\brief Sets the attributes of a DEMUX TSO port.CNcomment:设置DEMUX TS 输出端口属性。CNend
+\attention \n
+It is recommended to query the default attributes of a DEMUX TSO port by calling HI_UNF_DMX_GetTSOPortAttr before modifying the attributes of the TSO port.
+CNcomment:建议先通过HI_UNF_DMX_GetTSPortAttr获取默认属性，然后对要改变的属性进行设置。CNend
+\param[in] enPortId Port ID.CNcomment:端口号。CNend
+\param[in] pstAttr  Pointer to port attributes.CNcomment:指针类型，端口属性。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_SetTSOPortAttr(HI_UNF_DMX_TSO_PORT_E enPortId, HI_UNF_DMX_TSO_PORT_ATTR_S *pstAttr);
+
+/**
+\brief Get the tag attributes.CNcomment:获取tag 的相关属性。CNend
+\attention \n
+pstAttr.au8Tag is a key index, this interface will return corresponding tag attrs if this key value has registered, otherwise return default tag attrs.
+ N/A.CNcomment:pstAttr.au8Tag参数是一个索引，这个接口会返回对应的tag参数如果这个索引已经被注册，否则的话返回默认的tag属性配置。CNend
+\param[in] enPortId  TagPort ID.CNcomment:TapPort ID号。CNend
+\param[in & out] pstAttr Pointer to the tag port attributes (output).CNcomment:指针类型，tag端口属性。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid.CNcomment:输入参数非法。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetTagPortAttr(HI_UNF_DMX_PORT_E enPortId, HI_UNF_DMX_TAG_PORT_ATTR_S *pstAttr);
+
+/**
+\brief Set the tag attributes.CNcomment:设置tag的相关属性。CNend
+\attention \n
+pstAttr.au8Tag is a key index, it will register this new tag if this key value has not registered. otherwise increase tag reference number.
+ N/A.CNcomment:pstAttr.au8Tag参数是一个索引，这个接口会注册新的tag值如果tag未被注册的话，否则会增加tag的应用计数。CNend
+\param[in] enPortId  TagPort ID.CNcomment:TapPort ID号。CNend
+\param[in] pstAttr Pointer to the tag port attributes (output).CNcomment:指针类型，tag端口属性。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid.CNcomment:输入参数非法。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+ */
+HI_S32 HI_UNF_DMX_SetTagPortAttr(HI_UNF_DMX_PORT_E enPortId, const HI_UNF_DMX_TAG_PORT_ATTR_S *pstAttr);
+
+
+/**
+\brief Attaches a DEMUX to a port.CNcomment:绑定DEMUX到端口上。CNend
+\attention \n
+Each DEMUX can be attached to only one port, but the data from a port can be delivered to multiple DEMUXs.\n
+After a DEMUX is attached to a port, the DEMUX starts to receive the data input from this port.\n
+If the DEMUX is not used, you can detach it by calling HI_UNF_DMX_DetachTSPort.\n
+The DEMUXs can be attached to different ports dynamically. That is, you can attach the DEMUXs without detaching them.\n
+If you call this API to attach a DEMUX to the same channel, the error code HI_SUCCESS is returned.
+CNcomment:每路DEMUX只能绑定到一个PORT，但是一个PORT的数据可以分发到多个DEMUX\n
+DEMUX绑定到端口上之后就开始接收这个端口上输入的数据\n
+不再使用这路DEMUX接收数据后，使用HI_UNF_DMX_DetachTSPort接口解绑定DEMUX\n
+可以动态的绑定到不同的端口上，不用先解绑定\n
+重复调用此接口绑定到相同通道上返回成功。CNend
+\param[in] u32DmxId  DEMUX ID.CNcomment:DEMUX号。CNend
+\param[in] enPortId  Port ID.CNcomment:端口号。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\see \n
+::HI_UNF_DMX_DetachTSPort
+*/
+HI_S32 HI_UNF_DMX_AttachTSPort(HI_U32 u32DmxId, HI_UNF_DMX_PORT_E enPortId);
+
+
+/**
+\brief Detaches a DEMUX from a port.CNcomment:从端口上解绑定DEMUX。CNend
+\attention \n
+If a DEMUX is not used, you can detach it from the corresponding port by calling this API.\n
+This API can be called dynamically, and can be used to disable the input sources of a DEMUX.\n
+If this API is called repeatedly, the error code HI_SUCCESS is returned.
+CNcomment:不再使用DEMUX接收任何数据时使用此接口将DEMUX从端口上解绑定\n
+可以动态使用解绑定接口，可以通过解绑定接口切断DEMUX的输入源\n
+重复解绑定返回成功。CNend
+\param[in] u32DmxId  DEMUX ID. CNcomment: DEMUX号。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\see \n
+::HI_UNF_DMX_AttachTSPort
+*/
+HI_S32 HI_UNF_DMX_DetachTSPort(HI_U32 u32DmxId);
+
+
+/**
+\brief Obtains the ID of the port that is attached to a DEMUX. CNcomment:获取DEMUX所绑定的端口的端口号。CNend
+\attention \n
+If a DEMUX is not attached to any port, an error code is returned.CNcomment:如果DEMUX没有绑定到任何端口上会返回错误码。CNend
+\param[in] u32DmxId  DEMUX ID. CNcomment: DEMUX号。CNend
+\param[out] penPortId  Pointer to the ID of the port that is attached to a DEMUX(output).CNcomment:指针类型，输出DEMUX绑定的端口号。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOATTACH_PORT  The DEMUX is not attached to any port.CNcomment:此路DEMUX没有绑定到任何端口上。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSPortId(HI_U32 u32DmxId, HI_UNF_DMX_PORT_E *penPortId);
+
+/**
+\brief Obtains the default attributes of a TS Buffer.CNcomment:获取TS Buffer默认属性。CNend
+\attention \n
+It is recommended to query the default TS Buffer attributes before creating a TS Buffer, and then modify the attributes,\n
+notice the secure mode of default attributes is None Secure Mode.
+CNcomment:最好在申请TS Buffer之前使用此接口获取默认属性，\n
+然后改变需要修改的属性即可，注意默认属性为非安全模式。CNend
+\param[out] pstTsBufAttr Pointer to the structure of the TS Buffer attributes.CNcomment:TS Buffer属性结构体指针。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSBufferDefaultAttr(HI_UNF_DMX_TSBUF_ATTR_S *pstTsBufAttr);
+
+/**
+\brief Creates a TS buffer for the RAM port to receive the TS data from Internet or local memory. CNcomment:为RAM端口创建TS Buffer用于接收从网络或本地存储中输入的TS数据。CNend
+\attention \n
+A TS buffer can be created for the RAM port only.\n
+The buffer size must range from 4 KB to 16 MB.\n
+It is recommended to set the buffer size to an integral multiple of 4 KB. Otherwise, bottom alignment is performed inside.\n
+The TS buffer cannot be created for the same port for multiple times; otherwise, an error code is returned.
+CNcomment:只有RAM端口可以创建TS Buffer\n
+buffer大小必须在4K和16M之间，单位为字节\n
+buffer大小最好为4K的整数倍，如果不是整数倍，内部会进行向下对齐操作\n
+同一个端口不能重复创建TS Buffer,否则返回错误码。CNend
+\param[in] enPortId  Port ID.CNcomment:端口号。CNend
+\param[in] u32TsBufSize Size of a TS buffer.CNcomment:TS Buffer大小。CNend
+\param[out] phTsBuffer  Pointer to the handle of a created TS buffer (output).CNcomment:指针类型，输出创建的TS Buffer 句柄。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_RECREAT_TSBUFFER  The TS buffer corresponding to the port is created.CNcomment:重复创建TS Buffer。CNend
+\see \n
+N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_CreateTSBuffer(HI_UNF_DMX_PORT_E enPortId, HI_U32 u32TsBufSize, HI_HANDLE *phTsBuffer);
+
+/**
+\brief Creates a TS buffer for the RAM port to receive the TS data from Internet or local memory. CNcomment:为RAM端口创建TS Buffer用于接收从网络或本地存储中输入的TS数据。CNend
+\attention \n
+A TS buffer can be created for the RAM port only.\n
+The buffer size must range from 4 KB to 16 MB.\n
+It is recommended to set the buffer size to an integral multiple of 4 KB. Otherwise, bottom alignment is performed inside.\n
+The TS buffer cannot be created for the same port for multiple times; otherwise, an error code is returned.
+CNcomment:只有RAM端口可以创建TS Buffer\n
+buffer大小必须在4K和16M之间，单位为字节\n
+buffer大小最好为4K的整数倍，如果不是整数倍，内部会进行向下对齐操作\n
+同一个端口不能重复创建TS Buffer,否则返回错误码。CNend
+\param[in] enPortId  Port ID.CNcomment:端口号。CNend
+\param[in] pstTsBufAttr Attributes of a TS buffer.CNcomment:TS Buffer创建属性。CNend
+\param[out] phTsBuffer  Pointer to the handle of a created TS buffer (output).CNcomment:指针类型，输出创建的TS Buffer 句柄。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_RECREAT_TSBUFFER  The TS buffer corresponding to the port is created.CNcomment:重复创建TS Buffer。CNend
+\see \n
+N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_CreateTSBufferExt(HI_UNF_DMX_PORT_E enPortId, const HI_UNF_DMX_TSBUF_ATTR_S *pstTsBufAttr, HI_HANDLE *phTsBuffer);
+
+/**
+\brief Destroys an existing TS buffer. CNcomment:销毁创建的TS Buffer。CNend
+\attention \n
+A TS buffer cannot be destroyed repeatedly. If a TS buffer is destroyed, its handle is also destroyed.\n
+In addition, if a buffer is destroyed, its data is cleared. In this case, the get and put operations are not available.\n
+However, the data in channels is retained when a TS buffer is destroyed. To switch streams, you need disable the channel, and then enable the channel again.
+CNcomment:不能重复销毁一个TS Buffer,销毁之后handle就不存在了\n
+销毁之后buffer中的数据就会被清空，不能再进行Get和Put操作\n
+销毁TS buffer并不能清空通道中数据，要切换码流，要注意关闭通道，重新打开。CNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS Buffer句柄。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_DestroyTSBuffer(HI_HANDLE hTsBuffer);
+
+/**
+\brief Behavior1, Default,need work with HI_UNF_DMX_PutTSBuffer. Obtains a TS buffer to input data.
+CNcomment:行为一，默认模式，需要和HI_UNF_DMX_PutTSBuffer配合使用。获取TS Buffer空间，用于数据输入。CNend
+\attention \n
+If you call this API repeatedly, the address of the same buffer is returned.\n
+The input data length must be appropriate. If the data length is too large, data cannot be input in time.\n
+If the data length is too small, the buffer is scheduled frequently, which causes the system performance to deteriorate.\n
+If the size of the available space is smaller than the requested data length, an error code is returned.\n
+To be specific, the requested data length must be smaller than the size of the available space, that is, the buffer cannot be full.\n
+In addition, the requested data length cannot be 0; otherwise, the error code HI_ERR_DMX_INVALID_PARA is returned.\n
+If u32TimeOutMs is set to 0, it indicates that the waiting time is 0; if u32TimeOutMs is set to 0XFFFFFFFF, it indicates infinite wait; if u32TimeOutMs is set to other values, it indicates that the waiting time is u32TimeOutMs ms.\n
+If no buffer can be applied for during the block period, the error code HI_ERR_DMX_TIMEOUT is returned.\n
+If u32TimeOutMs is set to 0, and no buffer can be applied for, it indicates that the internal TS buffer is full. In this case, you need to call the usleep(10000) function to release the CPU. Therefore, other threads can be scheduled.
+CNcomment:重复get返回同一个buffer地址\n
+输入数据时注意每次输入的数据长度，太长可能会导致输入数据不及时\n
+太短可能会导致调度太频繁，性能下降\n
+当剩余空间小于等于请求的长度时，返回错误码\n
+每次申请的长度要小于剩余剩余长度，即buffer不可能被填满\n
+请求长度不允许为0，否则返回参数非法错误码\n
+u32TimeOutMs设置为0表示不等待，设置为0xffffffff表示一直等待，设置为其他值表示等待u32TimeOutMs毫秒。\n
+若超过阻塞时间，还无法申请到Buffer，则返回HI_ERR_DMX_TIMEOUT错误码\n
+u32TimeOutMs配置为0时，如果申请不到Buffer，说明此时内部TS Buffer空间已满，需要通过usleep(10000)释放cpu
+以使其它线程能够得到调度。CNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS Buffer句柄。CNend
+\param[in] u32ReqLen Requested data length.CNcomment:请求数据的长度。CNend
+\param[out] pstData  Data buffer.CNcomment:数据buffer结构。CNend
+\param[in] u32TimeOutMs      Wait timeout, in ms.CNcomment:等待超时时间，单位ms。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_TIMEOUT  The wait times out. CNcomment:等待超时。CNend
+\retval ::HI_ERR_DMX_NOAVAILABLE_BUF  The size of the available buffer is smaller than the requested data length.CNcomment:剩余buffer空间小于请求长度。CNend
+
+\Behavior2,Support multrtherad operate one tsbuffer,Only Valid wen CFG_HI_DMX_TSBUF_MULTI_THREAD_SUPPORT=y, need work with HI_UNF_DMX_PushTSBuffer and HI_UNF_DMX_ReleaseTSBuffer. Obtains a TS buffer to input data.
+CNcomment:行为二，支持多线程操作同一个TSbuffer模式，仅当CFG_HI_DMX_TSBUF_MULTI_THREAD_SUPPORT=y有效，需要和HI_UNF_DMX_PushTSBuffer、HI_UNF_DMX_ReleaseTSBuffer配合使用。获取TS Buffer空间，用于数据输入。CNend
+\attention \n
+If you call this API repeatedly and didn't call HI_UNF_DMX_ReleaseTSBuffer, the address of the different buffer block is
+returned and memory leak will be happened, this function must be couple with HI_UNF_DMX_ReleaseTSBuffer.\n
+The input data length must be appropriate. If the data length is too large, data cannot be input in time.\n
+If the data length is too small, the buffer is scheduled frequently, which causes the system performance to deteriorate.\n
+If the size of the available space is smaller than the requested data length, an error code is returned.\n
+To be specific, the requested data length must be smaller than the size of the available space, that is, the buffer cannot be full.\n
+In addition, the requested data length cannot be 0; otherwise, the error code HI_ERR_DMX_INVALID_PARA is returned.\n
+If u32TimeOutMs is set to 0, it indicates that the waiting time is 0; if u32TimeOutMs is set to 0XFFFFFFFF, it indicates infinite wait; if u32TimeOutMs is set to other values, it indicates that the waiting time is u32TimeOutMs ms.\n
+If no buffer can be applied for during the block period, the error code HI_ERR_DMX_TIMEOUT is returned.\n
+If u32TimeOutMs is set to 0, and no buffer can be applied for, it indicates that the internal TS buffer is full. In this case, you need to call the usleep(10000) function to release the CPU. Therefore, other threads can be scheduled.
+CNcomment:重复get返回不同buffer块的地址，并且如果本接口调用成功而不调用HI_UNF_DMX_ReleaseTSBuffer，
+则会引起内存泄漏，所以只要本接口调用成功，必须调用HI_UNF_DMX_ReleaseTSBuffer确保buffer块正确释放。\n
+输入数据时注意每次输入的数据长度，太长可能会导致输入数据不及时\n
+太短可能会导致调度太频繁，性能下降\n
+当剩余空间小于等于请求的长度时，返回错误码\n
+每次申请的长度要小于剩余剩余长度，即buffer不可能被填满\n
+请求长度不允许为0，否则返回参数非法错误码\n
+u32TimeOutMs设置为0表示不等待，设置为0xffffffff表示一直等待，设置为其他值表示等待u32TimeOutMs毫秒。\n
+若超过阻塞时间，还无法申请到Buffer，则返回HI_ERR_DMX_TIMEOUT错误码\n
+u32TimeOutMs配置为0时，如果申请不到Buffer，说明此时内部TS Buffer空间已满，需要通过usleep(10000)释放cpu
+以使其它线程能够得到调度。CNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS Buffer句柄。CNend
+\param[in] u32ReqLen Requested data length.CNcomment:请求数据的长度。CNend
+\param[out] pstData  Data buffer.CNcomment:数据buffer结构。CNend
+\param[in] u32TimeOutMs      Wait timeout, in ms.CNcomment:等待超时时间，单位ms。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_TIMEOUT  The wait times out. CNcomment:等待超时。CNend
+\retval ::HI_ERR_DMX_NOAVAILABLE_BUF  The size of the available buffer is smaller than the requested data length.CNcomment:剩余buffer空间小于请求长度。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSBuffer(HI_HANDLE hTsBuffer, HI_U32 u32ReqLen,
+            HI_UNF_STREAM_BUF_S *pstData, HI_U32 u32TimeOutMs);
+
+/**
+\brief Obtains a TS buffer to input data.CNcomment:获取TS Buffer空间，用于数据输入。CNend
+\attention \n
+If you call this API repeatedly, the address of the same buffer is returned.\n
+The input data length must be appropriate. If the data length is too large, data cannot be input in time.\n
+If the data length is too small, the buffer is scheduled frequently, which causes the system performance to deteriorate.\n
+If the size of the available space is smaller than the requested data length, an error code is returned.\n
+To be specific, the requested data length must be smaller than the size of the available space, that is, the buffer cannot be full.\n
+In addition, the requested data length cannot be 0; otherwise, the error code HI_ERR_DMX_INVALID_PARA is returned.\n
+If u32TimeOutMs is set to 0, it indicates that the waiting time is 0; if u32TimeOutMs is set to 0XFFFFFFFF, it indicates infinite wait; if u32TimeOutMs is set to other values, it indicates that the waiting time is u32TimeOutMs ms.\n
+If no buffer can be applied for during the block period, the error code HI_ERR_DMX_TIMEOUT is returned.\n
+If u32TimeOutMs is set to 0, and no buffer can be applied for, it indicates that the internal TS buffer is full. In this case, you need to call the usleep(10000) function to release the CPU. Therefore, other threads can be scheduled.
+CNcomment:重复get返回同一个buffer地址\n
+输入数据时注意每次输入的数据长度，太长可能会导致输入数据不及时\n
+太短可能会导致调度太频繁，性能下降\n
+当剩余空间小于等于请求的长度时，返回错误码\n
+每次申请的长度要小于剩余剩余长度，即buffer不可能被填满\n
+请求长度不允许为0，否则返回参数非法错误码\n
+u32TimeOutMs设置为0表示不等待，设置为0xffffffff表示一直等待，设置为其他值表示等待u32TimeOutMs毫秒。\n
+若超过阻塞时间，还无法申请到Buffer，则返回HI_ERR_DMX_TIMEOUT错误码\n
+u32TimeOutMs配置为0时，如果申请不到Buffer，说明此时内部TS Buffer空间已满，需要通过usleep(10000)释放cpu
+以使其它线程能够得到调度。CNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS Buffer句柄。CNend
+\param[in] u32ReqLen Requested data length.CNcomment:请求数据的长度。CNend
+\param[out] pstData  Data buffer.CNcomment:数据buffer结构。CNend
+\param[out] pu32PhyAddr buffer physical address.CNcomment:buffer的物理地址。CNend
+\param[in] u32TimeOutMs      Wait timeout, in ms.CNcomment:等待超时时间，单位ms。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_TIMEOUT  The wait times out. CNcomment:等待超时。CNend
+\retval ::HI_ERR_DMX_NOAVAILABLE_BUF  The size of the available buffer is smaller than the requested data length.CNcomment:剩余buffer空间小于请求长度。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSBufferEx(HI_HANDLE hTsBuffer, HI_U32 u32ReqLen,
+            HI_UNF_STREAM_BUF_S *pstData, HI_U32 *pu32PhyAddr, HI_U32 u32TimeOutMs);
+
+/**
+\brief Updates the write pointer of a TS buffer after the TS data is input.CNcomment:TS数据输入完毕，用于更新TS Buffer写指针。CNend
+\attention \n
+This API must work with HI_UNF_DMX_GetTSBuffer. That is, if you call HI_UNF_DMX_PutTSBuffer without calling HI_UNF_DMX_GetTSBuffer, no operation takes effect, but the error code HI_SUCCESS is returned.\n
+If the valid data length is 0, no operation takes effect, and the error code HI_SUCCESS.\n
+The valid data length cannot be greater than data length queried by calling HI_UNF_DMX_GetTSBuffer. Otherwise, the error code HI_ERR_DMX_INVALID_PARA is returned.\n
+If the valid data length is smaller than the data length queried by calling HI_UNF_DMX_GetTSBuffer, it indicates that a part of data is stored.
+CNcomment:此接口必须和Get接口配对使用，如果没有Get则进行Put操作，则不会进行任何操作，但返回成功\n
+Put的长度如果为0，也不会进行任何操作直接返回成功\n
+不允许Put长度大于实际Get到的长度，否则返回参数非法错误码\n
+允许Put长度小于Get长度，表明只输入了一部分数据\n
+为提高效率，Put的长度尽量不要太短，尽量保持在10个ts包以上Put一次，数据太短会导致性能下降\n。CNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS Buffer句柄。CNend
+\param[in] u32ValidDataLen Valid data length.CNcomment:有效数据的长度。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_PutTSBuffer(HI_HANDLE hTsBuffer, HI_U32 u32ValidDataLen);
+
+/**
+\brief Updates the write pointer of a TS buffer after the TS data is input.CNcomment:TS数据输入完毕，用于更新TS Buffer写指针。CNend
+\attention \n
+This API must work with HI_UNF_DMX_GetTSBuffer. That is, if you call HI_UNF_DMX_PutTSBuffer without calling HI_UNF_DMX_GetTSBuffer, no operation takes effect, but the error code HI_SUCCESS is returned.\n
+If the valid data length is 0, no operation takes effect, and the error code HI_SUCCESS.\n
+The valid data length cannot be greater than data length queried by calling HI_UNF_DMX_GetTSBuffer. Otherwise, the error code HI_ERR_DMX_INVALID_PARA is returned.\n
+If the valid data length is smaller than the data length queried by calling HI_UNF_DMX_GetTSBuffer, it indicates that a part of data is stored.
+CNcomment:此接口必须和Get接口配对使用，如果没有Get则进行Put操作，则不会进行任何操作，但返回成功\n
+Put的长度如果为0，也不会进行任何操作直接返回成功\n
+不允许Put长度大于实际Get到的长度，否则返回参数非法错误码\n
+允许Put长度小于Get长度，表明只输入了一部分数据\n
+为提高效率，Put的长度尽量不要太短，尽量保持在10个ts包以上Put一次，数据太短会导致性能下降\n。CNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS Buffer句柄。CNend
+\param[in] u32ValidDataLen Valid data length.CNcomment:有效数据的长度。CNend
+\param[in] u32StartPos start position of the valid data. CNcomment:有效数据的起始位置。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_PutTSBufferEx(HI_HANDLE hTsBuffer, HI_U32 u32ValidDataLen, HI_U32 u32StartPos);
+
+/**
+\brief Only valid when CFG_HI_DMX_TSBUF_MULTI_THREAD_SUPPORT=y Updates the write pointer of a TS buffer after the TS data is input.CNcomment:TS数据输入完毕，用于更新TS Buffer写指针。CNend
+\attention \n
+This API must work after HI_UNF_DMX_GetTSBuffer success. That is, if you call HI_UNF_DMX_PushTSBuffer without calling HI_UNF_DMX_GetTSBuffer, no operation takes effect, but the error code HI_SUCCESS is returned.\n
+If the valid data length is 0, no operation takes effect, and the error code HI_SUCCESS.\n
+The valid data length cannot be greater than data length queried by calling HI_UNF_DMX_GetTSBuffer. Otherwise, the error code HI_ERR_DMX_INVALID_PARA is returned.\n
+If the valid data length is smaller than the data length queried by calling HI_UNF_DMX_GetTSBuffer, it indicates that a part of data is stored.
+CNcomment:此接口必须在Get接口调用成功后使用，如果没有Get则进行Push操作，则不会进行任何操作，但返回成功\n
+Put的长度如果为0，也不会进行任何操作直接返回成功\n
+不允许Push长度大于实际Get到的长度，否则返回参数非法错误码\n
+允许Push长度小于Get长度，表明只输入了一部分数据\n
+为提高效率，Push的长度尽量不要太短，尽量保持在10个ts包以上Push一次，数据太短会导致性能下降\n。CNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS Buffer句柄。CNend
+\param[in] pstData, the pointer of HI_UNF_STREAM_BUF_S.CNcomment:buffer描述结构体指针。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_PushTSBuffer(HI_HANDLE hTsBuffer, const HI_UNF_STREAM_BUF_S *pstData);
+
+/**
+\brief Only valid when CFG_HI_DMX_TSBUF_MULTI_THREAD_SUPPORT=y Release the Ts buffer Get by  HI_UNF_DMX_GetTSBuffer.CNcomment:释放由HI_UNF_DMX_GetTSBuffer接口申请的TS buffer空间。
+\attention \n
+This API must work with HI_UNF_DMX_GetTSBuffer. That is, you must call HI_UNF_DMX_ReleaseTSBuffer if HI_UNF_DMX_GetTSBuffer has success,
+if not, there will be memory leak happened.\n
+The valid data length cannot be greater than data length queried by calling HI_UNF_DMX_GetTSBuffer. Otherwise, the error code HI_ERR_DMX_INVALID_PARA is returned.\n
+If the valid data length must be same as the data length queried by calling HI_UNF_DMX_GetTSBuffer.
+CNcomment:此接口必须和Get接口配对使用，换句话说HI_UNF_DMX_GetTSBuffer调用成功后必须调用本接口释放buffer，
+否则将有内存泄漏发生。\n
+不允许Release长度大于实际Get到的长度，否则返回参数非法错误码\n
+Release长度必须和Get的长度一致。\n
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS Buffer句柄。CNend
+\param[in] pstData, the pointer of HI_UNF_STREAM_BUF_S.CNcomment:buffer描述结构体指针。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_ReleaseTSBuffer(HI_HANDLE hTsBuffer, const HI_UNF_STREAM_BUF_S *pstData);
+
+/**
+\brief Resets a TS buffer to clear its data.CNcomment:复位TS Buffer，清空TS Buffer中的数据。CNend
+\attention \n
+If a TS buffer is reset, you can call HI_UNF_DMX_PutTSBuffer only after calling HI_UNF_DMX_GetTSBuffer.CNcomment:TS Buffer复位后需要重新get才能执行put操作。CNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS Buffer句柄。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_ResetTSBuffer(HI_HANDLE hTsBuffer);
+
+/**
+\brief Obtains the status of a TS buffer. CNcomment:获取TS Buffer状态。CNend
+\attention \n
+You can query the size of a TS buffer and the used buffer size by calling this API. CNcomment:可以查询TS Buffer大小和已用的空间大小。CNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS Buffer句柄。CNend
+\param[out] pStatus  TS buffer status.CNcomment:TS Buffer状态结构。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSBufferStatus(HI_HANDLE hTsBuffer, HI_UNF_DMX_TSBUF_STATUS_S *pStatus);
+
+/**
+\brief Obtains the ID of the port corresponding to a TS buffer.CNcomment:获取TS Buffer对应的Port ID。CNend
+\attention \n
+If you query the ID of the port corresponding to a TS buffer that is not applied for successfully, an error code is returned.
+CNcomment:对于没有申请的TS buffer,查询会返回错误。CNend
+\param[in] hTsBuffer Handle of a TS buffer.CNcomment:TS Buffer句柄。CNend
+\param[out] penPortId  ID of the port.corresponding to a TS buffer  CNcomment:TS Buffer对应的Port ID。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSBufferPortId(HI_HANDLE hTsBuffer, HI_UNF_DMX_PORT_E *penPortId);
+
+/**
+\brief Obtains the handle of the TS buffer corresponding to a port ID.CNcomment:获取Port ID对应的TS Buffer handle。CNend
+\attention \n
+If you obtain the handle of a TS buffer that is not created, an error code is returned.CNcomment:对于没有申请的TS buffer,查询会返回错误。CNend
+\param[in] enPortId   Port ID. CNcomment:端口号。CNend
+\param[out] phTsBuffer Handle of a TS buffer.CNcomment:TS Buffer句柄。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSBufferHandle(HI_UNF_DMX_PORT_E enPortId, HI_HANDLE *phTsBuffer);
+
+/**
+\brief Obtains the information about TS packets of a port.CNcomment:获取端口的TS包信息。CNend
+\attention \n
+If you query the information about an unattached port, an error code is returned.
+CNcomment:对于没有绑定的端口,查询会返回错误。CNend
+\param[in] enPortId    Port ID. CNcomment:端口号。CNend
+\param[out] sPortStat   Number of TS packets .CNcomment:TS包计数信息。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetTSPortPacketNum(HI_UNF_DMX_PORT_E enPortId, HI_UNF_DMX_PORT_PACKETNUM_S *sPortStat);
+
+/**
+\brief Obtains the information of a channel.CNcomment:获取指定channel的信息。CNend
+\attention \n
+\param[in] hChannel    Channel handle. CNcomment:Channel句柄 CNend
+\param[out] sChStat   Status of the channel .CNcomment:channel的状态信息。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetChannelPacketNum(HI_HANDLE hChannel, HI_UNF_DMX_CHAN_PACKETNUM_S *sChStat);
+
+/**
+\brief Obtains the default attributes of a channel.CNcomment:获取通道默认属性。CNend
+\attention \n
+It is recommended to query the default channel attributes before creating a channel, and then modify the attributes.\n
+By default, the attributes of the Section channel are returned. If other channels are used, you need to modify the attributes.
+CNcomment:最好在申请通道之前使用此接口获取默认属性，然后改变需要修改的属性即可\n
+默认属性按一般的section通道返回的，如果要使用其他类型的通道注意修改属性值。CNend
+\param[out] pstChAttr Pointer to the structure of the channel attributes.CNcomment:通道属性结构体指针。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetChannelDefaultAttr(HI_UNF_DMX_CHAN_ATTR_S *pstChAttr);
+
+
+/**
+\brief Creates a PID channel based on channel attributes.CNcomment:根据通道属性创建一个PID通道。CNend
+\attention \n
+It is recommended to call HI_UNF_DMX_GetChannelDefaultAttr to query default channel attributes before calling HI_UNF_DMX_CreateChannel.
+For the Section channel and ECM/EMM channel, you can set the CRC mode, and dynamically change the CRC mode by calling HI_UNF_DMX_SetChannelAttr.\n
+For other channels, the CRC check is always disabled. If you select other CRC modes, the CRC disable mode takes effect by default.\n
+You need to set the buffer size when creating a channel. The buffer size is in the unit of byte and the default size is 16 KB.\n
+It is recommended to set the buffer size to a value greater than 4 KB for the Section channel, ECM/EMM channel, or post channel. If the buffer size is smaller than 4 KB, the size of 4 KB is used by default.\n
+It is recommended to set the buffer size to a value greater than 64 KB for the PES channel. If the buffer size is smaller than 64 KB, the size of 64 KB is used by default.\n
+The playing channel and playing/recording channel cannot be created at the same time./n
+The audio/video playing channels are allocated and managed by the player.
+CNcomment:建议调用此接口之前，建议先调用HI_UNF_DMX_GetChannelDefaultAttr获取通道默认属性\n
+只有section类型的通道和ecm emm类型的通道支持设置CRC模式，并且可以通过属性设置接口动态修改CRC模式\n
+其他类型通道只支持设置为CRC禁止，如果选择了其他类型的CRC会被默认修改为CRC禁止\n
+在申请通道时注意Buffer大小的配置，默认大小为16K，buffer大小的单位为字节\n
+Section、ecm emm和POST通道的buffer大小至少为4K，如果小于4K会被默认修改为4K\n
+PES通道建议使用64K以上的buffer大小，如果小于64K会被默认修改为64K\n
+播放类型和同时播放与录制类型的音视频通道是不能申请的\n
+音视频的播放通道由Player统一分配和管理。CNend
+\param[in] u32DmxId  DEMUX ID. CNcomment: DEMUX号。CNend
+\param[in] pstChAttr  Pointer to the attributes of an input channel. For details, see the description of HI_UNF_DMX_CHAN_ATTR_S.CNcomment:指针类型，输入通道属性。请参见::HI_UNF_DMX_CHAN_ATTR_S。CNend
+\param[out] phChannel  Pointer to the handle of an allocated channel.CNcomment:指针类型，输出分配的通道Handle。。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOFREE_CHAN  There is no available channel.CNcomment:没有空闲通道。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_CreateChannel(HI_U32 u32DmxId, const HI_UNF_DMX_CHAN_ATTR_S *pstChAttr,
+            HI_HANDLE *phChannel);
+
+/**
+\brief Creates or reuse a channel based on PID.CNcomment:根据PID 创建或复用一个通道。CNend
+\attention \n
+It is recommended to call HI_UNF_DMX_GetChannelDefaultAttr to query default channel attributes before calling HI_UNF_DMX_CreateChannel.
+For the Section channel and ECM/EMM channel, you can set the CRC mode, and dynamically change the CRC mode by calling HI_UNF_DMX_SetChannelAttr.\n
+For other channels, the CRC check is always disabled. If you select other CRC modes, the CRC disable mode takes effect by default.\n
+You need to set the buffer size when creating a channel. The buffer size is in the unit of byte and the default size is 16 KB.\n
+It is recommended to set the buffer size to a value greater than 4 KB for the Section channel, ECM/EMM channel, or post channel. If the buffer size is smaller than 4 KB, the size of 4 KB is used by default.\n
+It is recommended to set the buffer size to a value greater than 64 KB for the PES channel. If the buffer size is smaller than 64 KB, the size of 64 KB is used by default.\n
+The playing channel and playing/recording channel cannot be created at the same time./n
+The audio/video playing channels are allocated and managed by the player.
+CNcomment:建议调用此接口之前，建议先调用HI_UNF_DMX_GetChannelDefaultAttr获取通道默认属性\n
+只有section类型的通道和ecm emm类型的通道支持设置CRC模式，并且可以通过属性设置接口动态修改CRC模式\n
+其他类型通道只支持设置为CRC禁止，如果选择了其他类型的CRC会被默认修改为CRC禁止\n
+在申请通道时注意Buffer大小的配置，默认大小为16K，buffer大小的单位为字节\n
+Section、ecm emm和POST通道的buffer大小至少为4K，如果小于4K会被默认修改为4K\n
+PES通道建议使用64K以上的buffer大小，如果小于64K会被默认修改为64K\n
+播放类型和同时播放与录制类型的音视频通道是不能申请的\n
+音视频的播放通道由Player统一分配和管理。CNend
+\param[in] u32DmxId  DEMUX ID. CNcomment: DEMUX号。CNend
+\param[in] u32Pid  PID. CNcomment: PID 值。CNend
+\param[in] pstChAttr  Pointer to the attributes of an input channel. For details, see the description of HI_UNF_DMX_CHAN_ATTR_S.CNcomment:指针类型，输入通道属性。请参见::HI_UNF_DMX_CHAN_ATTR_S。CNend
+\param[out] phChannel  Pointer to the handle of an allocated channel.CNcomment:指针类型，输出分配的通道Handle。。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOFREE_CHAN  There is no available channel.CNcomment:没有空闲通道。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_CreateChannelWithPID(HI_U32 u32DmxId, HI_U32 u32Pid, const HI_UNF_DMX_CHAN_ATTR_S *pstChAttr, HI_HANDLE *phChannel);
+
+/**
+\brief Destroys an existing PID channel.CNcomment:销毁创建的PID通道。CNend
+\attention \n
+If you release an enabled channel, the channel is disabled automatically. If you release a channel that is attached to a filter or key area, the channel is detached from the filter or key area automatically.\n
+However, the filter or key area is not released.\n
+It is recommended to explicitly detach channels by calling corresponding detach APIs. In this way, resources are managed in a unified manner.
+CNcomment:释放通道时如果通道处于打开状态会自动关闭通道，如果通道上绑定了过滤器或密钥区，会自动解绑定\n
+但是并不会释放过滤器和密钥区
+建议使用解绑定接口进行显式的解绑定操作，对资源的使用进行清晰的管理。CNend
+\param[in] hChannel  Channel handle.CNcomment:通道句柄。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_DestroyChannel(HI_HANDLE hChannel);
+
+
+/**
+\brief Obtains the attributes of a channel.CNcomment:获取通道属性。CNend
+\attention \n
+The API can be called only after a channel is allocated.CNcomment:本接口必须在通道分配以后才可以调用。CNend
+\param[in] hChannel   Channel handle.CNcomment:通道Handle。CNend
+\param[out] pstChAttr  Pointer to the attributes of a specified channel. For details, see the description of HI_UNF_DMX_CHAN_ATTR_S.CNcomment:指针类型，输出指定通道属性。请参见::HI_UNF_DMX_CHAN_ATTR_S。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid.CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetChannelAttr(HI_HANDLE hChannel, HI_UNF_DMX_CHAN_ATTR_S *pstChAttr);
+
+
+/**
+\brief Sets the attributes of a channel.CNcomment:设置通道属性。CNend
+\attention \n
+The API can be called only after a channel is allocated.\n
+You cannot dynamically modify all attributes except the CRC mode by calling HI_UNF_DMX_SetChannelAttr.\n
+To be specific, the CRC mode can be changed dynamically after a channel is created.\n
+If you modify other attributes, the error code HI_ERR_DMX_INVALID_PARA is returned.
+CNcomment:本接口必须在通道分配以后才可以调用\n
+除了CRC模式其他属性都不允许使用HI_UNF_DMX_SetChannelAttr接口进行动态修改\n
+CRC模式可以在通道申请后的任意时刻修改，动态生效\n
+要修改其他属性会返回参数非法错误码。CNend
+\param[in] hChannel   Channel handle.CNcomment:通道句柄。CNend
+\param[in] pstChAttr    Pointer to the attributes of an input channel. For details, see the description of HI_UNF_DMX_CHAN_ATTR_S.  CNcomment:指针类型，输入通道属性。请参见 ::HI_UNF_DMX_CHAN_ATTR_S。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_SetChannelAttr(HI_HANDLE hChannel, const HI_UNF_DMX_CHAN_ATTR_S *pstChAttr);
+
+
+/**
+\brief Sets the PID of a channel.CNcomment:设置通道PID。CNend
+\attention \n
+If you set the same PID for two channels of a DEMUX, the PID of the second channel is valid, and the PID of the first channel is changed to 0x1FFF.\n
+You must set the PID of a channel after the channel is disabled.\n
+If you set the PID of a channel to 0x1FFF, the channel cannot receive data. That is, the channel is disabled.
+CNcomment:同一路DEMUX的两个通道设置相同的PID。后设置的通道有效，先设置的通道的PID被修改为0x1fff\n
+必须在通道关闭的状态下配置通道的PID\n
+允许将通道的PID配置为0x1fff,配置为0x1fff后不接收任何数据，相当于关闭通道。CNend
+\param[in] hChannel   Channel handle.CNcomment:通道句柄。CNend
+\param[in] u32Pid     Channel PID.CNcomment:通道PID。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_OPENING_CHAN  The channel is enabled.CNcomment:通道处于打开状态。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_SetChannelPID(HI_HANDLE hChannel, HI_U32 u32Pid);
+
+
+/**
+\brief Obtains the PID of a channel.CNcomment:获取通道配置的PID。CNend
+\attention \n
+If no PID is set for a channel, the obtained value is 0x1FFF.\n
+You can obtain the channel PID after a channel is created.
+CNcomment:没有配置PID前，获取到的PID为0x1fff\n
+可以在通道申请后的任意时刻获取通道PID。CNend
+\param[in] hChannel  Channel handle.CNcomment:通道句柄。CNend
+\param[out] pu32Pid   Pointer to the PID of a channel (output).CNcomment:指针类型，输出通道的PID。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetChannelPID(HI_HANDLE hChannel, HI_U32 *pu32Pid);
+
+
+/**
+\brief Enables a channel.CNcomment:打开通道。CNend
+\attention \n
+If you call this API to enable a PID channel that has been enabled, no error occurs.\n
+If you call this API to enable a Section channel that is not attached to a filter, the channel cannot receive data.\n
+If you want to receive data without filter, you can create a filter and then set its filter depth to 0.
+CNcomment:在PID通道打开状态下，调用本接口打开通道不会发生错误\n
+对于section通道，在通道没有绑定过滤器时调用本接口，通道不能接收数据\n
+如果不想使用filter接收数据，可以申请一个filter将过滤深度配置为0，进行数据接收。CNend
+\param[in] hChannel  Channel handle.CNcomment:通道句柄。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_OpenChannel(HI_HANDLE hChannel);
+
+
+/**
+\brief Disables a channel.CNcomment:关闭通道。CNend
+\attention \n
+If you this API to disable a PID channel that has been disabled, no error occurs.CNcomment:在PID通道关闭状态下，调用本接口关闭通道不会发生错误。CNend
+\param[in] hChannel   Channel handle.CNcomment:通道句柄。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_CloseChannel(HI_HANDLE hChannel);
+
+
+/**
+\brief Obtains the status of a channel.CNcomment:获取通道状态。CNend
+\attention \n
+You can call this API after a channel is created.CNcomment:可以在通道申请后的任意时刻调用。CNend
+\param[in] hChannel   Channel handle.CNcomment:通道句柄。CNend
+\param[out] pstStatus  Pointer to the status of a channel (output). For details, see the description of ::HI_UNF_DMX_CHAN_STATUS_S.CNcomment:指针类型，输出通道状态。请参见::HI_UNF_DMX_CHAN_STATUS_S。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetChannelStatus(HI_HANDLE hChannel, HI_UNF_DMX_CHAN_STATUS_S *pstStatus);
+
+/**
+\brief Obtains the ts count of a channel.CNcomment:获取通道ts包计数。CNend
+\attention \n
+You can call this API after a channel is created.CNcomment:可以在通道申请后的任意时刻调用。CNend
+\param[in] hChannel   Channel handle.CNcomment:通道句柄。CNend
+\param[out] pu32TsCount  Pointer to the count of a channel (output).CNcomment:指针类型，输出通道ts包计数。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+ */
+HI_S32 HI_UNF_DMX_GetChannelTsCount(HI_HANDLE hChannel, HI_U32 *pu32TsCount);
+
+
+
+/**
+\brief Obtains the handle of the channel with a specific PID.CNcomment:获取配置某PID的通道句柄。CNend
+\attention \n
+You must specify the DEMUX ID when calling this API, because the channel PIDs of different DEMUXs can be the same.\n
+You cannot query the PID that is equal to or greater than 0x1FFF; otherwise, the error code HI_ERR_DMX_INVALID_PARA is returned.\n
+If no channel with a specific PID is found, an error code is returned.
+CNcomment:因不同DEMUX设备的通道允许设置相同的PID，调用本接口需要指定DEMUX ID\n
+不允许查询0x1fff及以上的非法PID值，否则返回参数非法错误码\n
+如果没有查询到任何通道设置了要查询的PID，将返回错误码。CNend
+\param[in] u32DmxId    DEMUX ID. CNcomment: DEMUX号。CNend
+\param[in] u32Pid      Channel PID.CNcomment:通道PID。CNend
+\param[out] phChannel Pointer to channel handle.CNcomment: 指针类型，输出通道Handle。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_UNMATCH_CHAN  No matched channel is found.CNcomment:没有查询到匹配通道。CNend
+\retval ::HI_ERR_DMX_OCCUPIED_PID  The same pid was found on multiple channels.CNcomment:在多个通道上发现了相同的PID。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetChannelHandle(HI_U32 u32DmxId , HI_U32 u32Pid, HI_HANDLE *phChannel);
+
+
+/**
+\brief Obtains the number of available channels of a DEMUX.CNcomment:获取DEMUX设备可用的空闲通道的数量。CNend
+\attention \n
+The returned number is the number of all remaining channels including the used audio/video channels.\n
+Because channels are allocated in a unified manner, the parameter u32DmxId is invalid.
+CNcomment:返回的数量为所有通道剩余的数量，包括已被使用的音视频通道\n
+由于通道资源统一分配所以参数u32DmxId已经没有意义。CNend
+\param[in] u32DmxId         DEMUX ID. CNcomment: DEMUX号。CNend
+\param[out] pu32FreeCount   Pointer to the number of available channels of a DEMUX.CNcomment:指针类型，输出DEMUX空闲通道数目。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetFreeChannelCount (HI_U32 u32DmxId, HI_U32 *pu32FreeCount);
+
+
+/**
+\brief Obtains the scrambled flag of the channel data.CNcomment:获取通道数据加扰标志。CNend
+\attention \n
+You can query the scrambled PES data and ES data.CNcomment:支持PES级加扰和TS级加扰的查询。CNend
+\param[in] hChannel   Channel handle.CNcomment:通道句柄。CNend
+\param[out] penScrambleFlag   Pointer to the scrambled flag of the channel data (output). For details, see the description of ::HI_UNF_DMX_SCRAMBLED_FLAG_E.CNcomment:指针类型，输出通道数据加扰标志。请参见::HI_UNF_DMX_SCRAMBLED_FLAG_E。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetScrambledFlag(HI_HANDLE hChannel, HI_UNF_DMX_SCRAMBLED_FLAG_E *penScrambleFlag);
+
+/**
+\brief Creates a data filter.CNcomment:创建一个数据过滤器。CNend
+\attention \n
+The maximum depth of a filter is 16 bytes.\n
+For details on how to set the attributes of a filter, see the description of ::HI_UNF_DMX_FILTER_ATTR_S.\n
+You can set a filter when creating it. If you do not want to filter data, you can set the filter depth to 0.\n
+To modify the attributes of a filter, call HI_UNF_DMX_SetFilterAttr.\n
+The attributes can be modified dynamically.\n
+If a filter is used to filter the Section data, the valid byte is byte 1 and byte 4 to byte 18.\n
+If a filter is used to filter the PES data, the valid byte is byte 4 and byte 7 to byte 21.\n
+The filter can be used to filter the data of general-purpose channels only, including the Section channel, ECM/EMM channel, and PES channel.\n
+If a filter is allocated successfully, phFilter returns the handle of the created filter.
+CNcomment:过滤器深度最大为16\n
+过滤器属性配置请参考::HI_UNF_DMX_FILTER_ATTR_S\n
+创建过滤器时，同时实现对过滤器的设置；若不需要数据过滤，设置过滤器深度为0即可\n
+若需要修改过滤器属性，可调用HI_UNF_DMX_SetFilterAttr进行属性修改\n
+支持属性的动态修改\n
+过滤器用于过滤Section数据时，有效过滤字节为第1字节及第4字节～第18字节\n
+过滤器用于过滤PES数据时，有效过滤字节为第4字节及第7字节～第21字节\n
+过滤器只适用于通用通道的数据过滤，包括section通道、ECM/EMM通道和PES通道\n
+若分配成功，phFilter返回获取的过滤器Handle。CNend
+\param[in] u32DmxId    DEMUX ID. CNcomment: DEMUX号。CNend
+\param[in] pstFilterAttr   Pointer to the attributes of a filter (input).CNcomment:指针类型，输入过滤器属性。CNend
+\param[out] phFilter   Pointer to the handle of the created filter (output).CNcomment:指针类型，输出申请的过滤器Handle。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOFREE_FILTER There is no available filter.CNcomment:没有空闲filter。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_CreateFilter(HI_U32 u32DmxId, const HI_UNF_DMX_FILTER_ATTR_S  *pstFilterAttr,
+            HI_HANDLE *phFilter);
+
+
+/**
+\brief Destroys an existing data filter.CNcomment:销毁创建的数据过滤器。CNend
+\attention \n
+If a filter is attached to a general-purpose channel, you can call this API to release the filter when the channel is enabled or disabled.\n
+If no filter is attached to a Section channel, the channel cannot receive data. This restriction is not applicable to other channels.
+CNcomment:若过滤器和通用通道绑定，允许在通道打开或者关闭状态下，调用本接口释放过滤器\n
+对于section通道当通道上没有任何过滤器绑定时，则不再接收数据，其他通道没有此限制。CNend
+\param[in] hFilter  Filter handle.CNcomment:过滤器句柄。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_DestroyFilter(HI_HANDLE hFilter);
+
+
+/**
+\brief Releases all the filters attached to a channel.CNcomment:释放绑定在某个通道上的所有过滤器。CNend
+\attention \n
+You can call this API to release all filters attached to a channel when the channel is enabled or disabled.CNcomment:允许在通道打开或者关闭状态下，调用本接口释放通道上绑定的所有过滤器。CNend
+\param[in] hChannel  Channel handle.CNcomment:通道句柄。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is valid.CNcomment:输入参数非法。CNend
+\see \n
+N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_DeleteAllFilter(HI_HANDLE hChannel);
+
+
+/**
+\brief Sets the filter criteria of a filter.CNcomment:设置过滤器的过滤条件。CNend
+\attention \n
+The maximum filter depth u32FilterDepth is 16.\n
+For details on how to set the attributes of a filter, see the description of ::HI_UNF_DMX_FILTER_ATTR_S.\n
+If a filter is used to filter the Section data, the valid byte is byte 1 and byte 4 to byte 18.\n
+If a filter is used to filter the PES data, the valid byte is byte 4 and byte 7 to byte 21.\n
+The attributes can be modified dynamically.
+CNcomment:过滤器的深度属性u32FilterDepth最大为16\n
+过滤器属性配置请参考::HI_UNF_DMX_FILTER_ATTR_S\n
+过滤器用于过滤Section数据时，有效过滤字节为第1字节及第4字节～第18字节\n
+过滤器用于过滤PES数据时，有效过滤字节为第4字节及第7字节～第21字节\n
+支持属性的动态修改。CNend
+\param[in] hFilter   Filter handle.CNcomment:过滤器句柄。CNend
+\param[in] pstFilterAttr   Pointer to the attributes of a filter (input).CNcomment:指针类型，输入过滤器属性。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_ATTACHED_FILTER  The attributes cannot be set dynamically, because the filter is attached to a channel.CNcomment:过滤器绑定在通道上，不能动态设置。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_SetFilterAttr(HI_HANDLE hFilter, const HI_UNF_DMX_FILTER_ATTR_S *pstFilterAttr);
+
+
+/**
+\brief Obtains the filter criteria of a filter.CNcomment:获取过滤器的过滤条件。CNend
+\attention \n
+If you call the API before a filter is allocated, an error code is returned.
+CNcomment:在过滤器未分配时调用该接口，返回错误。CNend
+\param[in] hFilter   Filter handle.CNcomment:过滤器句柄。CNend
+\param[out] pstFilterAttr   Pointer to the attributes of a filter (output). For details, see the description of ::HI_UNF_DMX_FILTER_ATTR_S.CNcomment:指针类型，输出过滤器属性。请参见::HI_UNF_DMX_FILTER_ATTR_S。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetFilterAttr(HI_HANDLE hFilter, HI_UNF_DMX_FILTER_ATTR_S *pstFilterAttr);
+
+
+/**
+\brief  Attaches filters to a specific channel.CNcomment:绑定过滤器到指定的通道。CNend
+\attention \n
+One or more filters can be attached to a general-purpose channel. All filters are ORed.\n
+That is, if the data meets the filter criteria of a filter, the data is transmitted to the DMA buffer.\n
+Filters cannot be attached to the audio/video channel and post channel.\n
+If a filter is used, it cannot be attached to one or more channels repeatedly.\n
+If a filter and a channel do not belong to the same DEMUX, the filter cannot be detached from the channel.\n
+A filter can be attached to a general-purpose channel when the channel is enabled or disabled.
+CNcomment:一个通用通道可以绑定一个或者多个数据过滤器，所有过滤器之间的过滤关系是或。\n
+即只要满足其中任何一个过滤器的过滤条件，当前过滤的数据都将通过过滤而被送入DMA缓冲区\n
+不支持音视频通道和POST通道的过滤器绑定\n
+不能将一个过滤器重复绑定到一个或多个通道上\n
+过滤器与通道不属于同一路DEMUX时，不能进行绑定操作\n
+支持通用通道打开或者关闭状态下的过滤器绑定。CNend
+\param[in] hFilter  Filter handle.CNcomment:过滤器句柄。CNend
+\param[in] hChannel   Channel handle.CNcomment:通道句柄。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_ATTACHED_FILTER  The filter is attached.CNcomment:过滤器已经处于绑定状态。CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT   No filter can be attached to the channel.CNcomment:此类型通道不支持绑定过滤器。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_AttachFilter(HI_HANDLE hFilter, HI_HANDLE hChannel);
+
+
+
+/**
+\brief Detaches a filter from a specific channel.CNcomment:将过滤器从指定通道上解绑定。CNend
+\attention \n
+If no filter is attached to a channel, the error code HI_FAILURE is returned when you call this API.\n
+If a filter and a channel do not belong to the same DEMUX, an error code is returned.\n
+A filter can be detached from a general-purpose channel when the channel is enabled or disabled.
+CNcomment:通道上没有绑定过滤器进行解绑定返回失败\n
+过滤器与通道不属于同一路DEMUX维护时，返回错误\n
+支持通用通道打开或者关闭状态下的过滤器解绑定。CNend
+\param[in] hFilter   Filter handle.CNcomment:过滤器句柄。CNend
+\param[in] hChannel  Channel handle.CNcomment:通道句柄。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NOATTACH_FILTER  No filter is attached to any channel.CNcomment:filter没有绑定在任何通道上。CNend
+\retval ::HI_ERR_DMX_UNMATCH_FILTER  No filter is attached to the channel.CNcomment:filter没有绑定在此通道上。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_DetachFilter(HI_HANDLE hFilter, HI_HANDLE hChannel);
+
+
+/**
+\brief Obtains the handle of the channel to which a filter is attached.CNcomment:获取过滤器所绑定的通道句柄。CNend
+\attention \n
+Each filter corresponds to a channel. If a filter is not attached to a channel, the error code HI_ERR_DMX_NOATTACH_FILTER is returned.CNcomment:每个过滤器唯一对应一个通道。若过滤器没有绑定任何到通道上，则返回HI_ERR_DMX_NOATTACH_FILTER错误码。CNend
+\param[in] hFilter    Filter handle.CNcomment:过滤器句柄。CNend
+\param[out] phChannel   Pointer to the handle of the channel to which a filter is attached (output).CNcomment:指针类型，输出过滤器绑定的通道句柄。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOATTACH_FILTER  No filter is attached to any channel.CNcomment:filter没有绑定在任何通道上。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetFilterChannelHandle(HI_HANDLE hFilter, HI_HANDLE *phChannel);
+
+
+/**
+\brief Obtains the number of available filters of a DEMUX.CNcomment:获取DEMUX设备可用的空闲过滤器数量。CNend
+\attention \n
+The number of unallocated filters is returned. The filters that are allocated but not attached to channels are excluded.
+CNcomment:返回当前未分配的过滤器数目，已分配但未绑定到通道上的过滤器不统计。CNend
+\param[in] u32DmxId   DEMUX ID. CNcomment: DEMUX号。CNend
+\param[out]  pu32FreeCount  Pointer to the number of allocated filters (output).CNcomment:指针类型，输出当前未分配的过滤器数目。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetFreeFilterCount(HI_U32 u32DmxId ,  HI_U32 * pu32FreeCount);
+
+
+/**
+\brief Obtains the handles of all channels that receive new data.CNcomment:获取有新数据到达的所有通道的句柄。CNend
+\attention \n
+When you call this API, the parameter pu32ChNum serves as the input parameter and is used to specify the data length pointed by phChannel. pu32ChNum indicates the number of channels to be queried.\n
+The number of channels must be initialized, and the initial value cannot be 0.\n
+It is recommended to set the number of channels to the total number. For details about the total number of channels.\n
+After you call this API successfully, the parameter pu32ChNum serves as the output parameter and is used to specify the valid data length pointed by phChannel.\n
+The block time is configurable (in ms). If u32TimeOutMs is set to 0, it indicates that the block time is 0; if u32TimeOutMs is set to 0xFFFFFFFF, it indicates infinite wait.\n
+If no data is received when the block time is exceeded, the error code HI_ERR_DMX_TIMEOUT is returned.\n
+If the wait time is 0, and no data is received in any channel, ::HI_ERR_DMX_NOAVAILABLE_DATA is returned.
+CNcomment:调用该接口时，pu32ChNum作为输入参数，用于指定phChannel指向数组的长度，表示要查询的通道个数；\n
+通道个数必须初始化，且初始值必须为非0值\n
+建议将通道个数设置为通道的总个数\n
+当该接口调用成功时，pu32ChNum作为输出参数，指定phChannel指向数组的有效长度\n
+阻塞时间可以设置，时间单位为毫秒，设置为0不等待，设置为0xffffffff一直等待。\n
+若超过阻塞时间，所有通道都没有数据到达，则返回等待超时错误\n
+如果等待时间为0，而且没有任何通道有数据则返回::HI_ERR_DMX_NOAVAILABLE_DATA。CNend
+\param[out] phChannel      Pointer to the number of channels. The number of channels depends on the value of pu32ChNum.CNcomment:指针类型，指向通道句柄数组。数组长度有pu32ChNum决定。CNend
+\param[in] pu32ChNum    Pointer type
+                           Input: indicates the number of channel handles to which pChannelHandle points.
+                           Output: indicates the number of lower-layer channels that receive new data. The maximum value cannot be greater than the input value.
+                           CNcomment: 指针类型。注意:该参数同时作为输入和输出。CNend
+                           CNcomment: 输入：pChannelHandle指向数组的长度。CNend
+                           CNcomment: 输出：底层有新数据通道的数目；最多不超过输入的数值。CNend
+\param[in] u32TimeOutMs      Wait timeout, in ms.CNcomment:等待超时时间，单位ms。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOAVAILABLE_DATA  No data is received in any channel.CNcomment:没有任何通道有数据到达。CNend
+\retval ::HI_ERR_DMX_TIMEOUT  The wait times out.CNcomment:等待超时。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_GetDataHandle(HI_HANDLE *phChannel, HI_U32 *pu32ChNum,
+            HI_U32 u32TimeOutMs);
+
+/**
+\brief Obtains whether data is received in some channels.CNcomment:查询部分通道是否有数据到达。CNend
+\attention \n
+This API is a supplementary interface of ::HI_UNF_DMX_GetDataHandle. You can call this API when you only want to check whether data is received in some channels.
+The handles of the channels to be queried are specified by phWatchChannel, and the number of channels to be queried is specified by u32WatchNum.\n
+If phWatchChannel is NULL, all channels are queried. The value of u32WatchNum cannot be 0.\n
+The block time is configurable (in ms). If u32TimeOutMs is set to 0, it indicates that the block time is 0; if u32TimeOutMs is set to 0xFFFFFFFF, it indicates infinite wait.\n
+If no data is received when the block time is exceeded, the error code HI_ERR_DMX_TIMEOUT is returned.\n
+If the wait time is 0, and no data is received in any channel, ::HI_ERR_DMX_NOAVAILABLE_DATA is returned.
+CNcomment:用来作为::HI_UNF_DMX_GetDataHandle的补充，当应用中只关注部分通道的数据到达情况时使用此接口\n
+被监视通道的句柄由phWatchChannel指定，个数由u32WatchNum指定\n
+phWatchChannel为NULL,查询所有通道的数据到达情况，u32WatchNum必须为非0值\n
+阻塞时间可以设置，时间单位为毫秒，设置为0不等待，设置为0xffffffff一直等待。\n
+若超过阻塞时间，所有通道都没有数据到达，则返回等待超时错误\n
+如果等待时间为0，而且没有任何通道有数据则返回::HI_ERR_DMX_NOAVAILABLE_DATA。CNend
+\param[in] phWatchChannel   Pointer to the number of handles of the channels to be queried. The number depends on the value of u32WatchNum.CNcomment:指针类型，指向被监视通道的句柄数组。数组长度有u32WatchNum决定。CNend
+\param[in] u32WatchNum      Number of channels to be queried.CNcomment:监视通道的个数。CNend
+\param[in] phDataChannel    Pointer to the number of handles of the channels that contain data The number depends on the value of pu32ChNum.CNcomment:指针类型，指向存在数据的通道的句柄数组。数组长度有pu32ChNum决定。CNend
+\param[out] pu32ChNum       Pointer to the number of lower-layer channels that receive new data. The maximum value cannot be greater than the input value.CNcomment:指针类型。底层有新数据通道的数目；最多不超过被监视的通道的数值。CNend
+\param[in] u32TimeOutMs     Wait timeout, in ms.CNcomment:等待超时时间，单位ms。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR   The pointer is null.CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOAVAILABLE_DATA   No data is received in any channel.CNcomment:没有任何通道有数据到达。CNend
+\retval ::HI_ERR_DMX_TIMEOUT   The wait times out.CNcomment:等待超时。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_SelectDataHandle(HI_HANDLE *phWatchChannel, HI_U32 u32WatchNum,
+            HI_HANDLE *phDataChannel, HI_U32 *pu32ChNum, HI_U32 u32TimeOutMs);
+
+/**
+\brief Obtains the received data packets from a specific channel.CNcomment:从指定通道中获取输出的数据包。CNend
+\attention \n
+Before calling this API, you need to set the value of u32AcquireNum to specify the maximum number of buffers that can be queried. The number of buffers depends on the value of u32AcquireNum.\n
+The value of pu32AcquiredNum is not greater than that of u32AcquireNum.\n
+For the Section channel, ECM channel, or EMM channel, each data packet contains a complete Section.\n
+For the PES channel, each data packet may contain a complete PES. If the PES is too large, it is divided into multiple PES packets to transfer.\n
+The enDataType field determines whether a transferred data packet is complete.\n
+For the post channel, each data packet may contain one or more complete TS packets. Each TS packet consists of 188 bytes.\n
+For the audio/video channel, data cannot be obtained by calling this API. The audio data and video data are transferred to the decoder through internal interfaces.
+You cannot call this API repeatedly, but you can call this API once and release buffers for several times. Note that you must release buffers in sequence, and the address and size of the buffer to be released must be consistent with those obtained by calling HI_UNF_DMX_AcquireBuf.
+In addition, you can call HI_UNF_DMX_AcquireBuf again only after all data packets are released. Otherwise, the error code HI_ERR_DMX_REACQUIRE_BUF is returned.
+CNcomment:在调用本接口之前，给u32AcquireNum赋值，指定允许查询的缓冲区信息最大数目。消息缓冲区数组的长度由u32AcquireNum决定\n
+实际获取的缓冲区信息数目pu32AcquiredNum数值不会超过u32AcquireNum\n
+对于section通道和ECM/EMM通道，每个数据包包含一个完整的section\n
+对于PES通道，每个数据包尽量包含完整的pes，但是如果pes太大，可能要分多个pes包输出，\n
+输出的数据是否完整通过数据包结构的enDataType字段指定\n
+对于POST类型的通道，每个数据包包含一个或多个完整的TS包，TS包长188字节\n
+对于音视频通道是不能通过此接口获取数据的，音视频数据会通过内部接口直接送给解码器进行解码\n
+不允许重复调用此接口，可以一次请求多次释放，但是释放必须按顺序，而且释放的地址和长度必须和请求的一致\n
+并且只有释放完所有的数据包才能再次请求，否则返回重复请求错误码。CNend
+\param[in] hChannel            Channel handle.CNcomment:通道句柄。CNend
+\param[in] u32AcquireNum       Maximum number of obtained data packets.CNcomment:请求的数据包的最大个数。CNend
+\param[out] pu32AcquiredNum    Pointer to the actual number of obtained data packets.CNcomment:指针类型，输出实际请求到的数据包个数。CNend
+\param[out] pstBuf             Pointer to the number of data packets. The number depends on the value of pu32AcquiredNum.CNcomment:指针类型，指向数据包信息数组，数组个数由pu32AcquiredNum决定。CNend
+\param[in] u32TimeOutMs        Wait timeout, in ms.CNcomment:等待超时时间，单位为ms。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOAVAILABLE_DATA  There is no valid data in the channel.CNcomment:通道中没有有效数据。CNend
+\retval ::HI_ERR_DMX_TIMEOUT  The wait times out.CNcomment:等待超时。CNend
+\retval ::HI_ERR_DMX_REACQUIRE_BUF  The data packet has been obtained.CNcomment:重复请求数据包。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_AcquireBuf(HI_HANDLE hChannel, HI_U32 u32AcquireNum,
+            HI_U32 * pu32AcquiredNum, HI_UNF_DMX_DATA_S *pstBuf,
+            HI_U32 u32TimeOutMs);
+
+
+/**
+\brief Releases the buffers for storing data packets after data packets are processed.CNcomment:处理完数据包的数据后，释放数据包占用的缓冲空间。CNend
+\attention \n
+If you release buffers by calling this API, the buffers must be those obtained by calling ::HI_UNF_DMX_AcquireBuf, and the addresses and sizes of these buffers cannot be changed.\n
+The number of released buffers can be less than the number of obtained buffers.
+CNcomment:本接口释放的缓冲区一定是通过::HI_UNF_DMX_AcquireBuf获取的缓冲区，缓冲区的地址和长度不能更改\n
+释放的缓冲区个数可以小于获取的缓冲区个数。CNend
+\param[in] hChannel        Channel handl.CNcomment:通道句柄。CNend
+\param[in] u32ReleaseNum   Number of released buffers.CNcomment:释放数据包个数。CNend
+\param[in] pstBuf          Pointer to the number of released buffers. The number depends on the value of u32ReleaseNum.CNcomment:指针类型，指向释放缓冲区信息数组，长度由u32ReleaseNum决定。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_ReleaseBuf(HI_HANDLE hChannel, HI_U32 u32ReleaseNum,
+            HI_UNF_DMX_DATA_S *pstBuf);
+
+/**
+\brief Obtains the received es data packets from a specific channel.CNcomment:从指定通道中获取输出的es数据包。CNend
+\attention \n
+You can call this API to obtain video or audio es data.\n
+It's allowed to call repeatedly and then release in the same order.
+CNcomment:音视频通道通过此接口获取es数据.\n
+允许重复调用此接口获取有效数据，然后按相同顺序释放。CNend
+\param[in] hChannel            Channel handle.CNcomment:通道句柄。CNend
+\param[out] pEsBuf             Pointer to the es data packets.CNcomment:指针类型，指向es数据包。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOAVAILABLE_DATA  There is no valid data in the channel。CNcomment:通道中没有有效数据。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_AcquireEs(HI_HANDLE hChannel, HI_UNF_ES_BUF_S *pEsBuf);
+
+/**
+\brief Releases the es buffers after processed.CNcomment:处理完es数据包的数据后，释放数据包所在buffer。CNend
+\attention \n
+If you release buffers by calling this API, the buffers must be those obtained by calling ::HI_UNF_DMX_AcquireEs, and the addresses and sizes of these buffers cannot be changed.
+CNcomment:本接口释放的缓冲区一定是通过::HI_UNF_DMX_AcquireEs获取的缓冲区，缓冲区的地址和长度不能更改.CNend
+\param[in] hChannel        Channel handl.CNcomment:通道句柄。CNend
+\param[in] pEsBuf          Pointer to the es data packets.CNcomment:指针类型，指向es数据包。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_ReleaseEs(HI_HANDLE hChannel, const HI_UNF_ES_BUF_S *pEsBuf);
+
+/**
+\brief Creates a record channel. CNcomment: 创建一个录制通道。CNend
+\attention \n
+A demux can be set only one recording channe.
+CNcomment: 一个DEMUX上只能创建一个录制通道。CNend
+\param[in]  pstRecAttr  record attribute.   CNcomment: 录制属性。CNend
+\param[out] phRecChn    record handle.      CNcomment: 录制句柄。CNend
+\retval ::HI_SUCCESS  Success. CNcomment: 成功。CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment: API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment: 模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment: 输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment: 指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOFREE_CHAN  There is no available channel. CNcomment: 没有空闲的通道。CNend
+\retval ::HI_ERR_DMX_ALLOC_MEM_FAILED  memory allocate failure. CNcomment: 内存分配失败。CNend
+\retval ::HI_ERR_DMX_MMAP_FAILED  memory map failed. CNcomment: 内存映射失败。CNend
+\see \n
+ N/A. CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_CreateRecChn(HI_UNF_DMX_REC_ATTR_S *pstRecAttr, HI_HANDLE *phRecChn);
+
+/**
+\brief Destroys an existing record channel. CNcomment: 销毁创建的录制通道。CNend
+\attention \n
+ N/A. CNcomment: 无。CNend
+\param[in] hRecChn  record handle. CNcomment: 录制句柄。CNend
+\retval ::HI_SUCCESS  Success. CNcomment: 成功。CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment: API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment: 模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment: 输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment: 指针参数为空。CNend
+\see \n
+ N/A. CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_DestroyRecChn(HI_HANDLE hRecChn);
+
+/**
+\brief if the type of record were the HI_UNF_DMX_REC_TYPE_SELECT_PID, it would increase the recorded PID that we need. CNcomment: 录制类型为HI_UNF_DMX_REC_TYPE_SELECT_PID时增加需要录制的PID。CNend
+\attention \n
+ N/A. CNcomment: 无。CNend
+\param[in]  hRecChn     record handle.  CNcomment: 录制句柄。CNend
+\param[in]  u32Pid      pid value.      CNcomment: PID值。CNend
+\param[out] phChannel   channel handle. CNcomment: 通道句柄。CNend
+\retval ::HI_SUCCESS  Success. CNcomment: 成功。CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment: API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment: 模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment: 输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment: 指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  This function is not supported. CNcomment: 不支持此功能。CNend
+\see \n
+ N/A. CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_AddRecPid(HI_HANDLE hRecChn, HI_U32 u32Pid, HI_HANDLE *phChannel);
+
+/**
+\brief if the type of record were the HI_UNF_DMX_REC_TYPE_SELECT_PID, it would delete increase PID. CNcomment: 录制类型为HI_UNF_DMX_REC_TYPE_SELECT_PID时删除已增加的PID。CNend
+\attention \n
+ N/A. CNcomment: 无。CNend
+\param[in]  hRecChn     record handle.  CNcomment: 录制句柄。CNend
+\param[in]  hChannel    channel handle. CNcomment: 通道句柄。CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A. CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_DelRecPid(HI_HANDLE hRecChn, HI_HANDLE hChannel);
+
+/**
+\brief if the type of record were the HI_UNF_DMX_REC_TYPE_SELECT_PID, it would delete all increase PID. CNcomment: 录制类型为HI_UNF_DMX_REC_TYPE_SELECT_PID时删除所有已增加的PID。CNend
+\attention \n
+ N/A. CNcomment: 无。CNend
+\param[in] hRecChn  record handle. CNcomment: 录制句柄。CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A. CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_DelAllRecPid(HI_HANDLE hRecChn);
+
+/**
+\brief if the type of record were the HI_UNF_DMX_REC_TYPE_ALL_PID, it would remove the specified PID. CNcomment: 录制类型为HI_UNF_DMX_REC_TYPE_ALL_PID时排除指定的PID。CNend
+\attention \n
+chips do not support the function.
+CNcomment: 芯片不支持此功能时返回不支持。CNend
+\param[in]  hRecChn record handle.  CNcomment: 录制句柄。CNend
+\param[in]  u32Pid  pid value.      CNcomment: PID值。CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  This function is not supported. CNcomment: 不支持此功能。CNend
+\see \n
+ N/A. CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_AddExcludeRecPid(HI_HANDLE hRecChn, HI_U32 u32Pid);
+
+/**
+\brief if the type of record were the HI_UNF_DMX_REC_TYPE_ALL_PID, it would cancel the PID that have been removed. CNcomment: 录制类型为HI_UNF_DMX_REC_TYPE_ALL_PID时取消已排除的PID。CNend
+\attention \n
+chips do not support the function.
+CNcomment: 芯片不支持此功能时返回不支持。CNend
+\param[in]  hRecChn record handle.  CNcomment: 录制句柄。CNend
+\param[in]  u32Pid  pid value.      CNcomment: PID值。CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  This function is not supported. CNcomment: 不支持此功能。CNend
+\see \n
+ N/A. CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_DelExcludeRecPid(HI_HANDLE hRecChn, HI_U32 u32Pid);
+
+/**
+\brief if the type of record were the HI_UNF_DMX_REC_TYPE_ALL_PID, it would cancel all the PID that have been removed. CNcomment: 录制类型为HI_UNF_DMX_REC_TYPE_ALL_PID时取消所有已排除的PID。CNend
+\attention \n
+chips do not support the function.
+CNcomment: 芯片不支持此功能时返回不支持。CNend
+\param[in] hRecChn  record handle. CNcomment: 录制句柄。CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  This function is not supported. CNcomment: 不支持此功能。CNend
+\see \n
+ N/A. CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_DelAllExcludeRecPid(HI_HANDLE hRecChn);
+
+/**
+\brief Starts a recording channel. CNcomment: 启动录制通道。CNend
+\attention \n
+when the recording channel has been activated, it should use the interface to come back success.
+CNcomment: 在录制通道已启动的状态下调用本接口返回成功。CNend
+\param[in] hRecChn  record handle. CNcomment: 录制句柄。CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A. CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_StartRecChn(HI_HANDLE hRecChn);
+
+/**
+\brief Stops a recording channel. CNcomment: 停止录制通道。CNend
+\attention \n
+when the recording channel has been stopped, it should use the interface to come back success.
+CNcomment: 在录制通道已停止的状态下调用本接口返回成功。CNend
+\param[in] hRecChn  record handle. CNcomment: 录制句柄。CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A. CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_StopRecChn(HI_HANDLE hRecChn);
+
+/**
+\brief Obtains record data. CNcomment: 获取录制数据。CNend
+\attention \n
+The obtained data must use the ::HI_UNF_DMX_ReleaseRecData function to release.
+CNcomment: 调用本接口获取到的数据必须使用::HI_UNF_DMX_ReleaseRecData接口进行释放。CNend
+\param[in]  hRecChn         record handle.          CNcomment: 录制句柄。CNend
+\param[out] pstRecData      record data.            CNcomment: 录制数据。CNend
+\param[in]  u32TimeOutMs    Wait timeout, in ms.    CNcomment: 等待超时时间，单位为毫秒。CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A. CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_AcquireRecData(HI_HANDLE hRecChn, HI_UNF_DMX_REC_DATA_S *pstRecData, HI_U32 u32TimeoutMs);
+
+/**
+\brief Releases record data. CNcomment: 释放获取到的录制数据。CNend
+\attention \n
+ N/A. CNcomment:无。CNend
+\param[in] hRecChn      record handle.  CNcomment: 录制句柄。CNend
+\param[in] pstRecData   record data.    CNcomment: 录制数据。CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A. CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_ReleaseRecData(HI_HANDLE hRecChn, const HI_UNF_DMX_REC_DATA_S *pstRecData);
+
+/**
+\brief Obtains index data. CNcomment: 获取索引数据。CNend
+\attention \n
+when indexing video or audio, it would use the interface to gain indexing data, or it will not support if you return.
+CNcomment: 音频或视频索引时才能获取索引数据，否则返回不支持。CNend
+\param[in]  hRecChn         record handle.          CNcomment: 录制句柄。CNend
+\param[out] pstRecIndex     index data.             CNcomment: 索引数据。CNend
+\param[in]  u32TimeOutMs    Wait timeout, in ms.    CNcomment: 等待超时时间，单位为毫秒。CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOT_START_REC_CHAN  CNcomment: 录制通道未启动。CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  This function is not supported. CNcomment: 不支持此功能。CNend
+\retval ::HI_ERR_DMX_NOAVAILABLE_DATA  no data. CNcomment: 无数据。CNend
+\retval ::HI_ERR_DMX_TIMEOUT  The wait times out. CNcomment:等待超时。CNend
+\see \n
+ N/A. CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_AcquireRecIndex(HI_HANDLE hRecChn, HI_UNF_DMX_REC_INDEX_S *pstRecIndex, HI_U32 u32TimeoutMs);
+
+/**
+\brief Obtains index and rec data with synchronous. CNcomment: 同步获取索引和录制数据 。CNend
+\attention \n
+1. when indexing video or audio, it would use the interface to gain indexing data and record TS data with synchronous, \n
+2. when recording all ts without index, .it would use the interface to gain only record TS data, as there is no index. \n
+3. Length of each block of record data is Alligned with 188 and 16 if it is not 0.
+CNcomment:
+1. 音频或视频索引时，可以获取索引数据和与之对应的录制TS数据\n
+2.如果是allts 录制，则只可以获取录制的TS数据，此时无索引数据\n
+3. 获取上来的每一个数据块的长度如果不为0，都是188 与 16 对齐的。CNend
+\param[in]  hRecChn         record handle.          CNcomment: 录制句柄。CNend
+\param[out] pstRecDataIdx     index and record data.             CNcomment: 索引数据和录制TS数据。CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOT_START_REC_CHAN  CNcomment: 录制通道未启动。CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  This function is not supported. CNcomment: 不支持此功能。CNend
+\retval ::HI_ERR_DMX_NOAVAILABLE_DATA  no data. CNcomment: 无数据。CNend
+\see \n
+ N/A. CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_AcquireRecDataAndIndex(HI_HANDLE hRecChn, HI_UNF_DMX_REC_DATA_INDEX_S* pstRecDataIdx);
+
+/**
+\brief Releases record data. CNcomment: 释放获取到的索引数据和录制数据。CNend
+\attention \n
+ N/A. CNcomment:无。CNend
+\param[in] hRecChn      record handle.  CNcomment: 录制句柄。CNend
+\param[in] pstRecDataIdx   record data and index.    CNcomment: 录制数据和索引数据。CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_MDX_REC_BUFNOTMATCH  The param is not mattched . CNcomment:参数不匹配，例如释放的地址或者长度非法。CNend
+\see \n
+ N/A. CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_ReleaseRecDataAndIndex(HI_HANDLE hRecChn, HI_UNF_DMX_REC_DATA_INDEX_S* pstRecDataIdx);
+/**
+\brief Obtains the status of a record buffer. CNcomment: 获取录制缓存的状态。CNend
+\attention \n
+ N/A. CNcomment:无。CNend
+\param[in]  hRecChn         record handle.          CNcomment: 录制句柄。CNend
+\param[out] pstBufStatus    record buffer status.   CNcomment: 录制缓存的状态。CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A. CNcomment:无。CNend
+*/
+HI_S32  HI_UNF_DMX_GetRecBufferStatus(HI_HANDLE hRecChn, HI_UNF_DMX_RECBUF_STATUS_S *pstBufStatus);
+
+/**
+\brief register channel callback .CNcomment:注册通道回调。CNend
+\attention \n
+ N/A. CNcomment:无。CNend
+\param[in] hChannel   Channel handle.CNcomment:通道Handle。CNend
+\param[out] pstCbDesc  Pointer to the descriptor of a specified cb. For details, see the description of HI_UNF_DMX_CB_DESC_S.CNcomment:指针类型，输出指定通道 回调描述信息。请参见::HI_UNF_DMX_CB_DESC_S。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid.CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_RegisterCallback(HI_HANDLE hChannel, HI_UNF_DMX_CB_DESC_S *pstCbDesc);
+
+/**
+\brief unregister channel callback.CNcomment:注销通道回调。CNend
+\attention \n
+ N/A. CNcomment:无。CNend
+\param[in] hChannel   Channel handle.CNcomment:通道句柄。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_UnRegisterCallback(HI_HANDLE hChannel);
+
+/**
+\brief Set or get the extra attributes of a demux through the commands.CNcomment:通过命令设置或获取DMX附加属性CNend
+\attention \n
+Diffrent CMD use diffrent param, for details see the description of HI_UNF_DMX_INVOKE_TYPE_E.\n
+CNcomment:不同的命令使用的参数不同，具体信息请参考命令枚举的定义HI_UNF_DMX_INVOKE_TYPE_E\n CNend
+\param[in] enCmd   Command type.CNcomment:命令类型。CNend
+\param[in] pCmdPara    Pointer to command param.  CNcomment:命令参数CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空CNend
+\see \n
+ N/A. CNcomment:无。CNend
+ */
+HI_S32 HI_UNF_DMX_Invoke(HI_UNF_DMX_INVOKE_TYPE_E enCmd, const HI_VOID *pCmdPara);
+
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif  /* __HI_UNF_DEMUX_H__ */
+
diff -uNr a/include/hi_unf_descrambler.h b/include/hi_unf_descrambler.h
--- a/include/hi_unf_descrambler.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_descrambler.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,360 @@
+/******************************************************************************
+ Copyright (C), 2009-2014, Hisilicon Tech. Co., Ltd.
+ ******************************************************************************
+ File Name     : hi_unf_descrambler.h
+ Version       : Initial Draft
+ Author        : Hisilicon multimedia software group
+ Created       : 2013/04/16
+ Description   :
+******************************************************************************/
+
+#ifndef __HI_UNF_DESCRAMBLER_H__
+#define __HI_UNF_DESCRAMBLER_H__
+
+#include "hi_error_mpi.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      Descrambler */
+/** @{ */  /** <!-- [Descrambler] */
+
+/**Conditional access (CA) type, indicating whether advanced CA is used.*/
+/**CNcomment:CA类型，是否使用高安全CA*/
+typedef enum hiUNF_DMX_CA_TYPE_E
+{
+    HI_UNF_DMX_CA_NORMAL = 0,    /**<Common CA*/ /**< CNcomment:普通CA*/
+    HI_UNF_DMX_CA_ADVANCE,       /**<Advanced CA*/ /**< CNcomment:高安全CA*/
+
+    HI_UNF_DMX_CA_BUTT
+} HI_UNF_DMX_CA_TYPE_E;
+
+/**CA Entropy reduction mode*/
+/**CNcomment:熵减少模式*/
+typedef enum hiUNF_DMX_CA_ENTROPY_REDUCTION_E
+{
+    HI_UNF_DMX_CA_ENTROPY_REDUCTION_CLOSE = 0,  /**<64bit*/
+    HI_UNF_DMX_CA_ENTROPY_REDUCTION_OPEN,       /**<48bit*/
+
+    HI_UNF_DMX_CA_ENTROPY_REDUCTION_BUTT
+} HI_UNF_DMX_CA_ENTROPY_E;
+
+
+/**Type of the descrambler protocol.*/
+/**CNcomment:解扰器协议类型*/
+typedef enum hiUNF_DMX_DESCRAMBLER_TYPE_E
+{
+    HI_UNF_DMX_DESCRAMBLER_TYPE_CSA2      = 0,       /**<CSA2.0*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_CSA3      ,          /**<CSA3.0*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_IPTV  ,          /**<AES IPTV of SPE*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_ECB   ,          /**<SPE AES ECB*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_CI    ,          /**<SPE AES CIPLUS*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_DES_CI    ,          /**<DES CIPLUS*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_DES_CBC   ,          /**<DES CBC*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_NS    ,          /**<AES NS-Mode, AES NOVEL*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_SMS4_NS   ,          /**<SMS4 NS-Mode, SMS4 NOVEL*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_SMS4_IPTV ,          /**<SMS4 IPTV*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_SMS4_ECB  ,          /**<SMS4 ECB*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_SMS4_CBC  ,          /**<SMS4 CBC*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_CBC   ,          /**<AES CBC*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_DES_IPTV,            /**<DES IPTV*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_TDES_IPTV,           /**<TDES IPTV*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_TDES_ECB,            /**<TDES ECB */
+    HI_UNF_DMX_DESCRAMBLER_TYPE_TDES_CBC,            /**<TDES CBC */
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_ECB_L,           /**<AES_ECB_L the clear stream left in the leading */
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_CBC_L,           /**<AES_CBC_L the clear stream left in the leading */
+    HI_UNF_DMX_DESCRAMBLER_TYPE_ASA,                 /**<ASA 64/128 Algorithm */
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_CISSA,           /**<Common IPTV Software-oriented Scrambling Algorithm (CISSA) */
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_CBC_IDSA,        /**<AES128 CBC Payload / ATIS IIF Default Scrambling Algorithm (IDSA), the difference between AES_CBC_IDSA and AES_IPTV is AES_CBC_IDSA only support 0 IV */
+    HI_UNF_DMX_DESCRAMBLER_TYPE_AES_CTR,             /**<AES CTR */
+    HI_UNF_DMX_DESCRAMBLER_TYPE_BUTT
+} HI_UNF_DMX_DESCRAMBLER_TYPE_E;
+
+/**Attribute of the key area.*/
+/**CNcomment:密钥区属性*/
+typedef struct hiUNF_DMX_DESCRAMBLER_ATTR_S
+{
+    HI_UNF_DMX_CA_TYPE_E enCaType;                    /**<Whether the descrambler adopts advanced CA.*/ /**< CNcomment:解扰器是否使用高安全CA*/
+    HI_UNF_DMX_DESCRAMBLER_TYPE_E enDescramblerType;  /**<Descrambling protocol type of the descrambler*/ /**< CNcomment:解扰器解扰协议类型*/
+    HI_UNF_DMX_CA_ENTROPY_E enEntropyReduction;       /**<CA Entropy reduction mode,for CSA2.0*/ /**< CNcomment:熵减少模式，CSA2.0有效*/
+} HI_UNF_DMX_DESCRAMBLER_ATTR_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      Descrambler */
+/** @{ */  /** <!--[Descrambler]*/
+
+/**
+\brief Creates a key area.CNcomment:创建一个密钥区。CNend
+\attention \n
+When creating a key area, you can ignore the DUMUX to which the key area belongs, because all DEMUXs share all key areas.
+CNcomment:申请密钥区，不用关心属于哪路DEMUX，所有DEMUX共用所有密钥区。CNend
+\param[in] u32DmxId   DEMUX ID. CNcomment: DEMUX号。CNend
+\param[out] phKey     Pointer to the handle of a created key area.CNcomment:指针类型，输出申请到的密钥区Handle。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOFREE_KEY There is no available key area. CNcomment:没有空闲的密钥区。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_CreateDescrambler(HI_U32 u32DmxId, HI_HANDLE *phKey);
+
+
+/**
+\brief Creates a key area. The key area type and descrambling protocol type can be selected.CNcomment:创建一个密钥区,支持选择高安全CA和解扰协议类型。CNend
+\attention \n
+When an advanced CA key area is created, the descrambling protocol depends on the hardware and interface settings are ignored.\n
+CNcomment:如果是高安全CA，解扰协议已经由硬件决定，接口的设置被忽略。CNend
+\param[in] u32DmxId   DEMUX ID. CNcomment: DEMUX号。CNend
+\param[in] pstDesramblerAttr  Pointer to the attributes of a key area.CNcomment:密钥区属性指针。CNend
+\param[out] phKey      Pointer to the handle of a created key area.CNcomment:指针类型，输出申请到的密钥区Handle。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOFREE_KEY  There is no available key area.CNcomment:没有空闲的密钥区。CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  Not support HI_UNF_DMX_DESCRAMBLER_ATTR_S type.CNcomment:不支持的HI_UNF_DMX_DESCRAMBLER_ATTR_S类型。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_CreateDescramblerExt(HI_U32 u32DmxId, const HI_UNF_DMX_DESCRAMBLER_ATTR_S *pstDesramblerAttr, HI_HANDLE *phKey);
+
+/**
+\brief Destroys an existing key area.CNcomment:销毁创建的密钥区。CNend
+\attention \n
+If a key area is attached to a channel, the key area needs to be detached from the channel first, but the channel is not disabled.\n
+If a key area is detached or destroyed before the attached channel is disabled, an error may occur during data receiving.
+CNcomment:如果密钥区绑定在通道上，会先从通道上解绑定密钥区，但是注意不会关闭通道\n
+如果没有关闭通道则进行密钥区的解绑定或销毁操作，可能导致数据接收的错误。CNend
+\param[in] hKey  Handle of the key area to be destroyed.CNcomment:待删除的密钥区Handle。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_DestroyDescrambler(HI_HANDLE hKey);
+
+/**
+\brief Gets the attributes of a Descrambler.CNcomment:获取密钥配置属性。CNend
+\attention \n
+NA.\n
+CNcomment:无。CNend
+\param[in] hKey   key handle. CNcomment: key句柄。CNend
+\param[out] pstAttr  Pointer to the attributes of a key area.CNcomment:密钥区属性指针。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOFREE_KEY  There is no available key area.CNcomment:没有空闲的密钥区。CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  Not support HI_UNF_DMX_DESCRAMBLER_ATTR_S type.CNcomment:不支持的HI_UNF_DMX_DESCRAMBLER_ATTR_S类型。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetDescramblerAttr(HI_HANDLE hKey, HI_UNF_DMX_DESCRAMBLER_ATTR_S *pstAttr);
+
+/**
+\brief Sets the attributes of a Descrambler.CNcomment:设置密钥配置属性。CNend
+\attention \n
+NA.\n
+CNcomment:无。CNend
+\param[in] hKey   key handle. CNcomment: key句柄。CNend
+\param[out] pstAttr  Pointer to the attributes of a key area.CNcomment:密钥区属性指针。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOFREE_KEY  There is no available key area.CNcomment:没有空闲的密钥区。CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  Not support HI_UNF_DMX_DESCRAMBLER_ATTR_S type.CNcomment:不支持的HI_UNF_DMX_DESCRAMBLER_ATTR_S类型。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_SetDescramblerAttr(HI_HANDLE hKey, HI_UNF_DMX_DESCRAMBLER_ATTR_S *pstAttr);
+
+/**
+\brief Sets the even keys of a key area. This API is used to configure the DEMUX descrambler based on even keys after the CA system obtains control words.CNcomment:设置密钥区的偶密钥。CA系统得到控制字后，可调用本接口将偶密钥配置到DEMUX解扰模块。CNend
+\attention \n
+pEvenKey points to the even key data to be set. The data consists of 16 bytes: CW1, CW2, ..., and CW16.\n
+The key value can be set dynamically, that is, the key value can be set at any time after a key area is created.\n
+The initial value of each key is 0, which indicates that data is not descrambled.
+CNcomment:pEvenKey指向要设置的偶密钥数据。数据共16byte，byte依次是CW1、CW2、……、CW16\n
+支持密钥区的动态设置，可以在密钥区申请后的任意时刻设置密钥值\n
+当设置密钥之前，密钥的初时值都是0，表示不做解扰。CNend
+\param[in] hKey  Handle of the key area to be set.CNcomment:待设置的密钥区句柄。CNend
+\param[in] pu8EvenKey  Pointer to the 16-byte even key data to be set.CNcomment:指针类型，指向要设置的偶密钥数据，必须是16个字节的数组。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_SetDescramblerEvenKey(HI_HANDLE hKey, const HI_U8 *pu8EvenKey);
+
+
+/**
+\brief Sets the odd keys of a key area. This API is used to configure the DEMUX descrambler based on odd keys after the CA system obtains control words.CNcomment:设置密钥区的奇密钥。CA系统得到控制字后，可调用本接口将奇密钥配置到DEMUX解扰模块。CNend
+\attention \n
+pOddKey points to the odd key data to be set. The data consists of 16 bytes: CW1, CW2, ..., and CW16.\n
+The key value can be set dynamically, that is, the key value can be set at any time after a key area is created.\n
+The initial value of each key is 0, which indicates that data is not descrambled.
+CNcomment:pOddKey指向要设置的奇密钥数据。奇密钥数据共16byte，byte依次是CW1、CW2、……、CW16\n
+支持密钥区的动态设置，可以在密钥区申请后的任意时刻设置密钥值\n
+当设置密钥之前，密钥的初时值都是0，表示不做解扰。CNend
+\param[in] hKey  Handle of the key area to be set.CNcomment:待设置的密钥区句柄。CNend
+\param[in] pu8OddKey   Pointer to the 16-byte odd key data to be set.CNcomment:指针类型，指向要设置的奇密钥数据，必须是16个字节的数组。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_SetDescramblerOddKey(HI_HANDLE hKey, const HI_U8 *pu8OddKey);
+
+
+/**
+\brief Set Even IV.For algs do not use IV,do not care.CNcomment:设置偶密钥区的初始化向量。对于不涉及初始化向量的解扰算法可以不关注。CNend
+\attention \n
+pu8IVKey points to the iv key data to be set.The data consists of 16 bytes: CW1, CW2, ..., and CW16.\n
+The key value can be set dynamically, that is, the key value can be set at any time after a key area is created.
+CNcomment:pu8IVKey指向要设置的初始化向量数据。奇密钥数据共16byte，byte依次是CW1、CW2、……、CW16\n
+支持密钥区的动态设置，可以在密钥区申请后的任意时刻设置。CNend
+\param[in] hKey  Handle of the key area to be set.CNcomment:待设置的密钥区句柄。CNend
+\param[in] pu8IVKey   Pointer to the 16-byte IV key data to be set.CNcomment:指针类型，指向要设置的奇密钥数据，必须是16个字节的数组。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_SetDescramblerEvenIVKey(HI_HANDLE hKey, const HI_U8 *pu8IVKey);
+
+/**
+\brief Set Odd IV.For algs do not use IV,do not care.CNcomment:设置奇密钥区的初始化向量。对于不涉及初始化向量的解扰算法可以不关注。CNend
+\attention \n
+pu8IVKey points to the iv key data to be set.The data consists of 16 bytes: CW1, CW2, ..., and CW16.\n
+The key value can be set dynamically, that is, the key value can be set at any time after a key area is created.
+CNcomment:pu8IVKey指向要设置的初始化向量数据。奇密钥数据共16byte，byte依次是CW1、CW2、……、CW16\n
+支持密钥区的动态设置，可以在密钥区申请后的任意时刻设置。CNend
+\param[in] hKey  Handle of the key area to be set.CNcomment:待设置的密钥区句柄。CNend
+\param[in] pu8IVKey    Pointer to the 16-byte IV key data to be set.CNcomment:指针类型，指向要设置的奇密钥数据，必须是16个字节的数组。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_SetDescramblerOddIVKey(HI_HANDLE hKey, const HI_U8 *pu8IVKey);
+
+/**
+\brief Attaches a key area to a specific channel.CNcomment:绑定密钥区到指定通道。CNend
+\attention \n
+A key area can be attached to multiple channels that belong to different DEMUXs.\n
+The static loading data in the key areas that are attached to all types of channels can be descrambled.\n
+The same key area or different key areas cannot be attached to the same channel.
+CNcomment:一个密钥区可以绑定到多个通道上，通道可以属于不同的DEMUX\n
+可以对所有类型的通道绑定密钥区进行数据的解扰\n
+不允许重复绑定相同或不同的密钥区到同一个通道上。CNend
+\param[in] hKey    Handle of the key area to be attached.CNcomment:待绑定的密钥区句柄。CNend
+\param[in] hChannel   Channel handle.CNcomment:通道句柄。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_ATTACHED_KEY  A key area is attached to the channel.CNcomment:通道上已经有一个密钥区绑定在上面。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_AttachDescrambler(HI_HANDLE hKey, HI_HANDLE hChannel);
+
+
+/**
+\brief Detaches a key area from a channel.CNcomment:将密钥区从通道上解绑定。CNend
+\attention \n
+The key area used by a channel can be detached dynamically. That is, you can call this API to detach a key area at any time after it is attached.\n
+The scrambled data, however, may not be descrambled after the key area is detached, which causes data error.\n
+The value of a key area retains even after it is detached. If the key area is attached again, its value is still the previously configured value.\n
+If you do not want to descramble data, you can detach the corresponding key area or set all key values to 0.
+CNcomment:可以动态的解绑定通道使用的密钥区，可以在绑定后的任意时刻使用此接口解绑定密钥区\n
+但是解绑定后可能导致加扰数据没有被解扰，导致数据错误\n
+解绑定密钥区并不能改变密钥区的值，如果重新绑定密钥区，密钥值仍然是上次设置的值\n
+如果不想进行解扰，除了解绑定密钥区之外，也可以直接将密钥值全部设置为0来实现。CNend
+\param[in] hKey    Handle of the key area to be detached.CNcomment:待解绑定的密钥区句柄。CNend
+\param[in] hChannel  Channel handle.CNcomment:通道句柄。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NOATTACH_KEY  No key areas are attached to the channel.CNcomment:通道上没有绑定任何密钥区。CNend
+\retval ::HI_ERR_DMX_UNMATCH_KEY  The specified key area is not attached to the specified channel.CNcomment:指定的密钥区没有绑定在指定的通道上。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_DetachDescrambler(HI_HANDLE hKey, HI_HANDLE hChannel);
+
+
+/**
+\brief Obtains the handle of the key area that is attached to a channel.CNcomment:获取通道绑定的密钥区句柄。CNend
+\attention \n
+If no key area is attached to the channel, the error code HI_ERR_DMX_NOATTACH_KEY is returned when you call this API.
+CNcomment:当通道没有绑定密钥区时，调用本接口返回HI_ERR_DMX_NOATTACH_KEY错误码。CNend
+\param[in] hChannel  Handle of the channel to be queried.CNcomment:要查询的通道句柄。CNend
+\param[out] phKey     Pointer to the handle of the key area that is attached to a channel (output).CNcomment:指针类型，输出通道绑定的密钥区句柄。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOATTACH_KEY  No key areas are attached to the channel.CNcomment:通道上没有绑定任何密钥区。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetDescramblerKeyHandle(HI_HANDLE hChannel, HI_HANDLE *phKey);
+
+
+/**
+\brief Obtains the number of available key areas.CNcomment:获取空闲密钥区数量。CNend
+\attention \n
+Because key areas are shared by multiple DEMUXs, the first parameter is meaningless. Therefore, you only need to enter a valid value.CNcomment:密钥区在几路DEMUX之间共用，所以第一个参数没有意义，只要输入一个合法值就可以了。CNend
+\param[in] u32DmxId   DEMUX ID. CNcomment: DEMUX号。CNend
+\param[out]  pu32FreeCount   Pointer to the number of available key areas (output).CNcomment:指针类型，输出空闲密钥区数目。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_DMX_GetFreeDescramblerKeyCount(HI_U32 u32DmxId , HI_U32 * pu32FreeCount);
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif  /* __HI_UNF_DESCRAMBLER_H__ */
+
diff -uNr a/include/hi_unf_disp.h b/include/hi_unf_disp.h
--- a/include/hi_unf_disp.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_disp.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,1588 @@
+/******************************************************************************
+
+   Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+   File Name     : hi_unf_disp.h
+   Version       : Initial Draft
+   Author        : Hisilicon multimedia software group
+   Created       : 2009/12/15
+   Description   :
+   History       :
+   1.Date        : 2009/12/15
+    Author      : sdk
+    Modification: Created file
+
+ *******************************************************************************/
+
+
+/**
+ * \file
+ **\brief : define DISPLAY module information
+ * \brief supply infor about display.
+ */
+
+#ifndef  __HI_UNF_DISP_H__
+#define  __HI_UNF_DISP_H__
+
+#include "hi_unf_common.h"
+#include "hi_unf_hdmi.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      DISPLAY */
+/** @{ */  /** <!-- [DISPLAY] */
+
+/**enum define about DISPLAY channel*/
+/**CNcomment:定义DISPLAY通道枚举*/
+typedef enum hiUNF_DISP_E
+{
+    HI_UNF_DISPLAY0 = 0x0,  /**< DISPLAY0,Compatible with SD */ /**<CNcomment:高清DISPLAY0，兼容标清 */
+    HI_UNF_DISPLAY1,        /**< DISPLAY1 *//**<CNcomment: 高清DISPLAY1 */
+    HI_UNF_DISPLAY2,        /**< DISPLAY2 *//**<CNcomment: 高清DISPLAY2 */
+    HI_UNF_DISPLAY_BUTT
+}HI_UNF_DISP_E;
+
+/**max DAC count*/
+/**CNcomment:最大的DAC数目*/
+#define MAX_DAC_NUM ( 6 )
+
+/**define the LCD data format*/
+/**CNcomment:定义LCD的数据格式*/
+typedef enum hiHI_UNF_DISP_INTF_DATA_FMT
+{
+    HI_UNF_DISP_INTF_DATA_FMT_YUV422   = 0,         /**<YUV422,data width is 16*//**<CNcomment:YUV422，位宽为16*/
+    HI_UNF_DISP_INTF_DATA_FMT_RGB565   = 0x8,       /**<RGB565,data width is 16*//**<CNcomment:RGB565，位宽为16*/
+    HI_UNF_DISP_INTF_DATA_FMT_RGB444   = 0xa,       /**<RGB444,data width is 16*//**<CNcomment:RGB444，位宽为16*/
+    HI_UNF_DISP_INTF_DATA_FMT_RGB666   = 0xb,       /**<RGB666,data width is 24*//**<CNcomment:RGB666，位宽为24*/
+    HI_UNF_DISP_INTF_DATA_FMT_RGB888   = 0xc,       /**<RGB888,data widht is 24*//**<CNcomment:RGB888，位宽为24*/
+    HI_UNF_DISP_INTF_DATA_FMT_BUTT
+}HI_UNF_DISP_INTF_DATA_FMT_E;
+
+/**define LCD output data width*/
+/**CNcomment:定义LCD输出的数据位宽*/
+typedef enum hiUNF_DISP_INTF_DATA_WIDTH_E
+{
+    HI_UNF_DISP_INTF_DATA_WIDTH8 = 0,       /**<8 bits*//**<CNcomment:8位*/
+    HI_UNF_DISP_INTF_DATA_WIDTH16,          /**<16 bits*//**<CNcomment:16位*/
+    HI_UNF_DISP_INTF_DATA_WIDTH24,          /**<24 bits*//**<CNcomment:24位*/
+    HI_UNF_DISP_INTF_DATA_WIDTH_BUTT
+}HI_UNF_DISP_INTF_DATA_WIDTH_E;
+
+/**define LCD timing */
+/**CNcomment:定义LCD的时序参数*/
+typedef struct hiUNF_DISP_TIMING_S
+{
+    HI_U32                        VFB;            /**<vertical front blank*//**<CNcomment:垂直前消隐*/
+    HI_U32                        VBB;            /**<vertical back blank*//**<CNcomment:垂直后消隐*/
+    HI_U32                        VACT;           /**<vertical active area*//**<CNcomment:垂直有效区*/
+    HI_U32                        HFB;            /**<horizonal front blank*//**<CNcomment:水平前消隐*/
+    HI_U32                        HBB;            /**<horizonal back blank*//**<CNcomment:水平后消隐*/
+    HI_U32                        HACT;           /**<horizonal active area*/ /**<CNcomment:水平有效区*/
+    HI_U32                        VPW;            /**<vertical sync pluse width*//**<CNcomment:垂直脉冲宽度*/
+    HI_U32                        HPW;            /**<horizonal sync pluse width*/ /**<CNcomment:水平脉冲宽度*/
+    HI_BOOL                       IDV;            /**< flag of data valid signal is needed flip*//**<CNcomment:有效数据信号是否翻转*/
+    HI_BOOL                       IHS;            /**<flag of horizonal sync pluse is needed flip*//**<CNcomment:水平同步脉冲信号是否翻转*/
+    HI_BOOL                       IVS;            /**<flag of vertical sync pluse is needed flip*//**<CNcomment:垂直同步脉冲信号是否翻转*/
+    HI_BOOL                       ClockReversal;  /**<flag of clock is needed flip*//**<CNcomment:时钟是否翻转*/
+    HI_UNF_DISP_INTF_DATA_WIDTH_E DataWidth;      /**<data width*/ /**<CNcomment:数据位宽*/
+    HI_UNF_DISP_INTF_DATA_FMT_E   ItfFormat;      /**<data format.*//**<CNcomment:数据格式.*/
+
+    HI_BOOL DitherEnable;                           /**< flag of is enable Dither*//**<CNcomment:数据格式.*/
+    HI_U32  ClkPara0;                               /**<PLL  register SC_VPLL1FREQCTRL0  value *//**<CNcomment:PLL  SC_VPLL1FREQCTRL0  寄存器*/
+    HI_U32  ClkPara1;                               /**<PLL  register SC_VPLL1FREQCTRL1 value*//**<CNcomment:PLL   SC_VPLL1FREQCTRL1寄存器*/
+
+    HI_BOOL bInterlace;                             /**<progressive or interlace*//**<CNcomment:逐行或者隔行*/
+    HI_U32  PixFreq;                                /**<pixel clock*//**<CNcomment:像素时钟*/
+    HI_U32  VertFreq;                               /**<display rate*//**<CNcomment:刷新率*/
+    HI_U32  AspectRatioW;                           /**<width of screen*//**<CNcomment:屏幕宽度*/
+    HI_U32  AspectRatioH;                           /**<height of screen*//**<CNcomment:屏幕高度*/
+    HI_BOOL bUseGamma;                              /**<gamma modulation*//**<CNcomment:伽马调节*/
+    HI_U32  Reserve0;                               /**<reserved byte*//**<CNcomment:保留位*/
+    HI_U32  Reserve1;                               /**<reserved byte*//**<CNcomment:保留位*/
+} HI_UNF_DISP_TIMING_S;
+
+/**define video and graphics layers */
+/**CNcomment:视频和图形层*/
+typedef enum hiUNF_DISP_LAYER_E
+{
+    HI_UNF_DISP_LAYER_VIDEO = 0,                   /**<video layer *//**<CNcomment:视频层*/
+    HI_UNF_DISP_LAYER_GFX,                  /**<graphics layer *//**<CNcomment:图形层*/
+    HI_UNF_DISP_LAYER_BUTT
+}HI_UNF_DISP_LAYER_E;
+
+/**bt1120 interface ID */
+/**CNcomment:bt1120 接口ID  */
+typedef enum hiUNF_DISP_BT1120_E
+{
+    HI_UNF_DISP_BT1120_0,    /**<BT1120 interface 0 *//**<CNcomment:BT1120接口0 */
+    HI_UNF_DISP_BT1120_BUTT,
+}HI_UNF_DISP_BT1120_E;
+
+/**BT656 interface ID */
+/**CNcomment:BT656 接口ID  */
+typedef enum hiUNF_DISP_BT656_E
+{
+    HI_UNF_DISP_BT656_0,    /**<BT656 interface 0 *//**<CNcomment:BT656接口0 */
+    HI_UNF_DISP_BT656_BUTT,
+}HI_UNF_DISP_BT656_E;
+
+/**LCD interface ID */
+/**CNcomment:LCD 接口ID  */
+typedef enum hiUNF_LCD_E
+{
+    HI_UNF_DISP_LCD_0,    /**<LCD interface 0 *//**<CNcomment:LCD接口0 */
+    HI_UNF_DISP_LCD_BUTT,
+}HI_UNF_DISP_LCD_E;
+
+/**define the type of interface*/
+/**CNcomment:定义接口类型*/
+typedef enum  hiUNF_DISP_INTF_TYPE_E
+{
+    HI_UNF_DISP_INTF_TYPE_HDMI,     /**<HDMI interface type *//**<CNcomment:HDMI接口类型*/
+    HI_UNF_DISP_INTF_TYPE_LCD,      /**<LCD interface type *//**<CNcomment:LCD接口类型*/
+    HI_UNF_DISP_INTF_TYPE_BT1120,   /**<bt1120 digital interface type *//**<CNcomment:BT1120数字接口类型*/
+    HI_UNF_DISP_INTF_TYPE_BT656,    /**<bt656 digital interface type*//**<CNcomment:BT656数字接口类型*/
+    HI_UNF_DISP_INTF_TYPE_YPBPR,    /**<YPBPR interface type*//**<CNcomment:YPBPR接口类型*/
+    HI_UNF_DISP_INTF_TYPE_RGB,      /**<RGB interface type*//**<CNcomment:RGB接口类型*/
+    HI_UNF_DISP_INTF_TYPE_CVBS,     /**<CVBS interface type*//**<CNcomment:CVBS接口类型*/
+    HI_UNF_DISP_INTF_TYPE_SVIDEO,   /**<SVIDEO interface type*//**<CNcomment:SVIDEO接口类型*/
+    HI_UNF_DISP_INTF_TYPE_VGA,      /**<VGA interface type*//**<CNcomment:VGA接口类型*/
+    HI_UNF_DISP_INTF_TYPE_BUTT
+}HI_UNF_DISP_INTF_TYPE_E;
+
+/**define the YPBPR type struct of interface*/
+/**CNcomment:定义YPBPR接口结构*/
+typedef struct  hiUNF_DISP_INTF_YPBPR_S
+{
+    HI_U8 u8DacY;             /**<DAC num of Y  *//**<CNcomment:Y分量dac端口号*/
+    HI_U8 u8DacPb;            /**<DAC num of Pb  *//**<CNcomment:Pb分量dac端口号*/
+    HI_U8 u8DacPr;            /**<DAC num of Pr  *//**<CNcomment:Pr分量dac端口号*/
+}HI_UNF_DISP_INTF_YPBPR_S;
+
+/**define the RGB type struct of interface*/
+/**CNcomment:定义RGB接口结构*/
+typedef struct  hiUNF_DISP_INTF_RGB_S
+{
+    HI_U8  u8DacR;            /**<DAC num of R  *//**<CNcomment:R分量dac端口号*/
+    HI_U8  u8DacG;            /**<DAC num of G  *//**<CNcomment:G分量dac端口号*/
+    HI_U8  u8DacB;            /**<DAC num of B  *//**<CNcomment:B分量dac端口号*/
+    HI_BOOL bDacSync;         /**<G without sync signal  *//**<CNcomment:G分量不带同步信号*/
+}HI_UNF_DISP_INTF_RGB_S;
+
+/**define the VGA type struct of interface*/
+/**CNcomment:定义VGA接口结构*/
+typedef struct  hiUNF_DISP_INTF_VGA_S
+{
+    HI_U8  u8DacR;            /**<DAC num of R  *//**<CNcomment:R分量dac端口号*/
+    HI_U8  u8DacG;            /**<DAC num of G  *//**<CNcomment:G分量dac端口号*/
+    HI_U8  u8DacB;            /**<DAC num of B  *//**<CNcomment:B分量dac端口号*/
+}HI_UNF_DISP_INTF_VGA_S;
+
+/**define the CVBS type struct of interface*/
+/**CNcomment:定义CVBS接口结构*/
+typedef struct  hiUNF_DISP_INTF_CVBS_S
+{
+    HI_U8 u8Dac;              /**<DAC num of CVBS  *//**<CNcomment:CVBS端子dac端口号*/
+}HI_UNF_DISP_INTF_CVBS_S;
+
+/**define the SVIDEO type struct of interface*/
+/**CNcomment:定义SVIDEO接口结构*/
+typedef struct  hiUNF_DISP_INTF_SVIDEO_S
+{
+    HI_U8 u8DacY;             /**<DAC num of Y  *//**<CNcomment:Y分量dac端口号*/
+    HI_U8 u8DacC;             /**<DAC num of C   *//**<CNcomment:C分量dac端口号*/
+}HI_UNF_DISP_INTF_SVIDEO_S;
+
+/**define display interface struct*/
+/**CNcomment:定义显示接口结构*/
+typedef struct  hiUNF_DISP_INTF_S
+{
+    HI_UNF_DISP_INTF_TYPE_E enIntfType;         /**<interface type *//**<CNcomment:接口类型*/
+    union
+    {
+        HI_UNF_HDMI_ID_E        enHdmi;         /**<hdmi id *//**<CNcomment:HDMI 序号*/
+        HI_UNF_DISP_BT1120_E    enBT1120;       /**<bt1120 id *//**<CNcomment:BT1120序号*/
+        HI_UNF_DISP_BT656_E     enBT656;        /**<bt656 id *//**<CNcomment:BT656序号*/
+        HI_UNF_DISP_LCD_E       enLcd;          /**<lcd id *//**<CNcomment:LCD序号*/
+
+        HI_UNF_DISP_INTF_YPBPR_S    stYPbPr;    /**<intf config of YPBPR  *//**<CNcomment:YPBPR接口配置*/
+        HI_UNF_DISP_INTF_RGB_S      stRGB;      /**<intf config of RGB  *//**<CNcomment:RGB接口配置*/
+        HI_UNF_DISP_INTF_VGA_S      stVGA;      /**<intf config of VGA  *//**<CNcomment:VGA接口配置*/
+        HI_UNF_DISP_INTF_CVBS_S     stCVBS;     /**<intf config of CVBS  *//**<CNcomment:CVBS接口配置*/
+        HI_UNF_DISP_INTF_SVIDEO_S   stSVideo;   /**<intf config of SVIDEO  *//**<CNcomment:SVIDEO接口配置*/
+    }unIntf;
+}HI_UNF_DISP_INTF_S;
+
+
+/**Defines the device aspect ratio.*/
+/**CNcomment: 定义设备宽高比枚举*/
+typedef enum hiUNF_DISP_ASPECT_RATIO_E
+{
+    HI_UNF_DISP_ASPECT_RATIO_AUTO,              /**<aspect ratio as device Resolution*//**<CNcomment: 宽高比与设备分辨率一致*/
+    HI_UNF_DISP_ASPECT_RATIO_4TO3,              /**<4:3*//**<CNcomment: 4比3*/
+    HI_UNF_DISP_ASPECT_RATIO_16TO9,             /**<16:9*//**<CNcomment: 16比9*/
+    HI_UNF_DISP_ASPECT_RATIO_221TO1,            /**<221:100*//**<CNcomment: 221比100*/
+    HI_UNF_DISP_ASPECT_RATIO_USER,              /**<user define*//**<CNcomment: 用户定义*/
+
+    HI_UNF_DISP_ASPECT_RATIO_BUTT
+}HI_UNF_DISP_ASPECT_RATIO_E;
+
+/**Defines the device aspect ratio struct.*/
+/**CNcomment: 定义设备宽高比结构*/
+typedef struct hiUNF_DISP_ASPECT_RATIO_S
+{
+    HI_UNF_DISP_ASPECT_RATIO_E enDispAspectRatio;   /**<aspect ratio type of device*//**<CNcomment: 设备宽高比类型*/
+    HI_U32                     u32UserAspectWidth;  /**<user define width of device*//**<CNcomment: 用户定义设备宽度*/
+    HI_U32                     u32UserAspectHeight; /**<user define height of device*//**<CNcomment: 用户定义设备高度*/
+}HI_UNF_DISP_ASPECT_RATIO_S;
+
+/**Defines algorithmic  control struct of display device.*/
+/**CNcomment: 定义显示设备算法控制结构*/
+typedef struct hiUNF_DISP_ALG_CFG_S
+{
+    HI_BOOL bAccEnable;                             /**<acc alg*//**<CNcomment: acc算法*/
+    HI_BOOL bSharpEnable;                           /**<sharp alg*//**<CNcomment: sharp算法*/
+}HI_UNF_DISP_ALG_CFG_S;
+
+/**Defines VBI type.*/
+/**CNcomment: 定义VBI数据类型*/
+typedef enum hiUNF_DISP_VBI_TYPE_E
+{
+    HI_UNF_DISP_VBI_TYPE_TTX = 0,                   /**<Teltext type*//**<CNcomment:teltext类型*/
+    HI_UNF_DISP_VBI_TYPE_CC,                        /**<Closed caption/V-Chip type *//**<CNcomment: 隐藏字幕/V-Chip类型*/
+    HI_UNF_DISP_VBI_TYPE_WSS,                       /**<Wide screen signal*//**<CNcomment:宽屏信令*/
+    HI_UNF_DISP_VBI_TYPE_BUTT
+} HI_UNF_DISP_VBI_TYPE_E;
+
+/**Defines VBI config struct.*/
+/**CNcomment: 定义VBI配置结构*/
+typedef struct hiUNF_DISP_VBI_CFG_S
+{
+    HI_UNF_DISP_VBI_TYPE_E  enType;                  /**<VBI type*//**<CNcomment: VBI 类型*/
+    HI_U32                  u32InBufferSize;        /**<VBI data(pes) buffer size,more than 4K,suggest 4K*//**<CNcomment:VBI pes 数据输入缓冲大小,不小于4K，推荐值4K*/
+    HI_U32                  u32WorkBufferSize;      /**<VBI data buffer size used in driver,more than 2K,suggest 2K*//**<CNcomment:VBI解析后数据在驱动中接收缓冲大小不小于2K，推荐值2K*/
+} HI_UNF_DISP_VBI_CFG_S;
+
+/** define VBI information structure*/
+/**CNcomment: 定义VBI信息数据结构*/
+typedef struct hiUNF_DISP_VBI_DATA_S
+{
+    HI_UNF_DISP_VBI_TYPE_E  enType;                  /**<VBI type*//**<CNcomment: VBI 类型*/
+    HI_U8                   *pu8DataAddr;           /**<Vbi data buffer virtual address*//**<CNcomment:Vbi数据用户虚拟地址*/
+    HI_U32                  u32DataLen;             /**<Vbi data lenght*//**<CNcomment:Vbi数据长度*/
+} HI_UNF_DISP_VBI_DATA_S;
+
+/**Defines the MAX buffer number.*/
+/** CNcomment:定义最大的buffer 分配数*/
+#define HI_DISP_CAST_BUFFER_MAX_NUMBER ( 16 )
+
+/**define CAST config */
+/**CNcomment:定义屏幕投影配置*/
+typedef struct hiUNF_DISP_CAST_ATTR_S
+{
+    HI_UNF_VIDEO_FORMAT_E enFormat;                                        /**<the output video format.*//**<CNcomment:定义输出视频格式*/
+    HI_U32                u32Width;                                       /**<the output video width.*//**<CNcomment:定义输出视频的宽*/
+    HI_U32                u32Height;                                      /**<the output video height.*//**<CNcomment:定义输出视频的高*/
+    HI_BOOL               bLowDelay;                                      /**<work at low delay mode.*//**<CNcomment:启用低延迟模式*/
+    HI_U32                u32BufNum;                                      /**<the buffer number.*//**<CNcomment:定义分配buffer 数*/
+    HI_BOOL               bUserAlloc;                                     /**<whether is user alloc memory*//**<CNcomment:定义是否用户分配内存*/
+    HI_U32                u32BufSize;                                     /**<each the buffer size.*//**<CNcomment:定义用户分配每个buffer 大小*/
+    HI_U32                u32BufStride;                                   /**<the horizonal stride.*//**<CNcomment:定义行对齐*/
+    HI_U32                u32BufPhyAddr[HI_DISP_CAST_BUFFER_MAX_NUMBER];  /**<the buffer physics address.*//**<CNcomment:分配内存buffer 成员的物理地址*/
+    HI_BOOL               bCrop;                                          /**<whether enable crop .*//**<CNcomment:定义是否进行crop*/
+    HI_UNF_CROP_RECT_S    stCropRect;                                     /**<the crop wise .*//**<CNcomment:定义crop 范围*/
+} HI_UNF_DISP_CAST_ATTR_S;
+
+/**define color setting */
+/**CNcomment:定义色彩设置*/
+typedef struct hiUNF_DISP_COLOR_SETTING_S
+{
+    HI_BOOL bGammaEnable;         /**<whether Gamma enable.*//**<CNcomment:定义Gamma 使能*/
+    HI_BOOL bUseCustGammaTable;   /**<whether use custom GammaTable.*//**<CNcomment:是否使用用户Gamma表*/
+    HI_BOOL bColorCorrectEnable;  /**<whether Color Correct.*//**<CNcomment:是否色彩校正*/
+    HI_S32  s32ColorTemp;         /**<color Temp.*//**<CNcomment:色温*/
+    HI_U32  u32Reserve;           /**<Reserve.*//**<CNcomment:保留*/
+    HI_VOID *pPrivate;            /**<Private.*//**<CNcomment:私有体指针*/
+}HI_UNF_DISP_COLOR_SETTING_S;
+
+/**define the struct about color */
+/**CNcomment:定义显示颜色的结构体 */
+typedef struct  hiUNF_DISP_BG_COLOR_S
+{
+    HI_U8 u8Red;                  /**<red *//**<CNcomment:红色分量*/
+    HI_U8 u8Green;                /**<green*//**<CNcomment:绿色分量*/
+    HI_U8 u8Blue;                 /**<blue*//**<CNcomment:蓝色分量*/
+} HI_UNF_DISP_BG_COLOR_S;
+
+/**define the struct about isogeny attributes */
+/**CNcomment:定义同源属性 */
+typedef struct  hiUNF_DISP_ISOGENY_ATTR_S
+{
+    HI_UNF_DISP_E          enDisp; /**<channel id*//**<CNcomment: 通道号*/
+    HI_UNF_ENC_FMT_E       enFormat;/**<format type*//**<CNcomment:制式类型*/
+}HI_UNF_DISP_ISOGENY_ATTR_S ;
+
+
+/********************************ENCODER STRUCT********************************/
+/** define the enum of Macrovision output type*/
+/** CNcomment:显示输出Macrovision模式枚举定义*/
+typedef enum hiUNF_DISP_MACROVISION_MODE_E
+{
+    HI_UNF_DISP_MACROVISION_MODE_TYPE0,     /**<type 0:no protect process *//**<CNcomment:无保护处理*/
+    HI_UNF_DISP_MACROVISION_MODE_TYPE1,     /**<type 1:AGC (automatic gain control) process only *//**<CNcomment:仅自动增益控制 */
+    HI_UNF_DISP_MACROVISION_MODE_TYPE2,     /**<type 2:AGC + 2-line color stripe *//**<CNcomment:自动增益控制和两线色 度干扰*/
+    HI_UNF_DISP_MACROVISION_MODE_TYPE3,     /**<type 3:AGC + aggressive 4-line color stripe *//**<CNcomment:自动增益和四线强色度干扰*/
+    HI_UNF_DISP_MACROVISION_MODE_CUSTOM,    /**<type of configure by user *//**<CNcomment:用户自定义配置 */
+    HI_UNF_DISP_MACROVISION_MODE_BUTT
+} HI_UNF_DISP_MACROVISION_MODE_E;
+
+/** CGMS type select */
+/**CNcomment:CGMS 类型选择*/
+typedef enum hiUNF_DISP_CGMS_TYPE_E
+{
+    HI_UNF_DISP_CGMS_TYPE_A = 0x00,     /**<CGMS type  A*//**<CNcomment:CGMS 类型A*/
+    HI_UNF_DISP_CGMS_TYPE_B,            /**<CGMS type  B*//**<CNcomment:CGMS 类型B*/
+
+    HI_UNF_DISP_CGMS_TYPE_BUTT
+}HI_UNF_DISP_CGMS_TYPE_E;
+
+/** definition of CGMS mode */
+/**CNcomment:定义CGMS 模式*/
+typedef enum hiUNF_DISP_CGMS_MODE_E
+{
+    HI_UNF_DISP_CGMS_MODE_COPY_FREELY  = 0,     /**<copying is permitted without restriction *//**<CNcomment:无限制拷贝*/
+    HI_UNF_DISP_CGMS_MODE_COPY_NO_MORE = 0x01,  /**<No more copies are allowed (one generation copy has been made)*//**<CNcomment:拷贝一次后不允许再被拷贝*/
+    HI_UNF_DISP_CGMS_MODE_COPY_ONCE    = 0x02,  /**<One generation of copies may be made *//**<CNcomment:仅允许拷贝一次*/
+    HI_UNF_DISP_CGMS_MODE_COPY_NEVER   = 0x03,  /**<No copying is permitted *//**<CNcomment:不允许拷贝*/
+
+    HI_UNF_DISP_CGMS_MODE_BUTT
+}HI_UNF_DISP_CGMS_MODE_E;
+
+/** definition of CGMS configuration */
+typedef struct hiUNF_DISP_CGMS_CFG_S
+{
+    HI_BOOL                 bEnable;            /**<HI_TRUE:CGMS is enabled; HI_FALSE:CGMS is disabled *//**<CNcomment:CGMS 使能选项*/
+    HI_UNF_DISP_CGMS_TYPE_E enType;             /**<type-A or type-B or None(BUTT) *//**<CNcomment:CGMS 类型*/
+    HI_UNF_DISP_CGMS_MODE_E enMode;             /**<CGMS mode. *//**<CNcomment:CGMS 模式*/
+}HI_UNF_DISP_CGMS_CFG_S;
+
+/**define WSS information structure*/
+/**CNcomment:定义图文信息数据结构 */
+typedef struct hiUNF_DISP_WSS_DATA_S
+{
+    HI_BOOL bEnable;                            /**<WSS configure enable HI_TRUE: enable,HI_FALSE: disnable*//**<CNcomment:WSS配置使能。HI_TRUE：使能；HI_FALSE：禁止*/
+    HI_U16  u16Data;                            /**<Wss data */ /**<CNcomment:Wss数据*/
+}HI_UNF_DISP_WSS_DATA_S;
+
+
+/**define display 3D mode stucture*/
+/**CNcomment:定义显示模式结构体 */
+typedef enum hiUNF_DISP_3D_E
+{
+    HI_UNF_DISP_3D_NONE = 0,
+    HI_UNF_DISP_3D_FRAME_PACKING,                   /**<3d type:Frame Packing*//**<CNcomment:3d 模式:帧封装*/
+    HI_UNF_DISP_3D_SIDE_BY_SIDE_HALF,               /**<3d type:Side by side half*//**<CNcomment:3d 模式:并排式 左右半边*/
+    HI_UNF_DISP_3D_TOP_AND_BOTTOM,                  /**<3d type:Top and Bottom*//**<CNcomment:3d 模式:上下模式*/
+    HI_UNF_DISP_3D_FIELD_ALTERNATIVE,               /**<3d type:Field alternative*//**<CNcomment:3d 模式:场交错*/
+    HI_UNF_DISP_3D_LINE_ALTERNATIVE,                /**<3d type:Field alternative*//**<CNcomment:3d 模式:行交错*/
+    HI_UNF_DISP_3D_SIDE_BY_SIDE_FULL,               /**<3d type:Side by side full*//**<CNcomment:3d 模式:并排式 左右全场*/
+    HI_UNF_DISP_3D_L_DEPTH,                         /**<3d type:L+depth*//**<CNcomment:3d 模式:L+DEPTH*/
+    HI_UNF_DISP_3D_L_DEPTH_GRAPHICS_GRAPHICS_DEPTH, /**<3d type:L+depth+Graphics+Graphics-depth*//**<CNcomment:3d 模式:L+depth+Graphics+Graphics-depth*/
+    HI_UNF_DISP_3D_BUTT
+}HI_UNF_DISP_3D_E;
+
+/**define display margin stucture*/
+/**CNcomment:定义显示空白区域结构体 */
+typedef struct hiUNF_DISP_OFFSET_S
+{
+    HI_U32 u32Left;    /**<left offset *//**<CNcomment:左侧偏移*/
+    HI_U32 u32Top;     /**<top offset *//**<CNcomment:上方偏移*/
+    HI_U32 u32Right;   /**<right offset *//**<CNcomment:右侧偏移*/
+    HI_U32 u32Bottom;  /**<bottom offset *//**<CNcomment:下方偏移*/
+}HI_UNF_DISP_OFFSET_S;
+
+/**define output signal type.*/
+/**CNcomment:定义输出信号类型*/
+typedef enum hiUNF_DISP_HDR_TYPE_E
+{
+    HI_UNF_DISP_HDR_TYPE_NONE = 0,      /**<Normal SDR signal output type *//**<CNcomment:普通SDR 信号输出*/
+    HI_UNF_DISP_HDR_TYPE_AUTO,          /**<Optimum signal output type automatically *//**<CNcomment:自动适配最佳信号输出*/
+    HI_UNF_DISP_HDR_TYPE_AUTO_FOLLOW_FIRSTFRAME, /**<signal output type follow first frame type.*//**<CNcomment:根据首帧类型自动选择输出*/
+    HI_UNF_DISP_HDR_TYPE_DOLBY,         /**<DolbyVision signal output type *//**<CNcomment:DolbyVision 信号输出*/
+    HI_UNF_DISP_HDR_TYPE_HDR10,         /**<HDR10 signal output type *//**<CNcomment:HDR10 信号输出*/
+    HI_UNF_DISP_HDR_TYPE_HLG,           /**<HLG signal output type *//**<CNcomment:HLG 信号输出*/
+    HI_UNF_DISP_HDR_TYPE_DOLBY_LOW_LATENCY,/**<DolbyVision low latency output type *//**<CNcomment:DolbyVision 低延时信号输出*/
+
+    HI_UNF_DISP_HDR_TYPE_BUTT
+} HI_UNF_DISP_HDR_TYPE_E;
+
+/**SD format should use BT601*/
+/**CNcomment:标清制式强制使用色彩空间BT601*/
+typedef enum hiHI_UNF_DISP_COLOR_SPACE_E
+{
+    HI_UNF_DISP_COLOR_SPACE_AUTO = 0x0,     /**<  optimum output color space *//**<CNcomment:最佳色彩空间输出*/
+    HI_UNF_DISP_COLOR_SPACE_BT601,          /**< output  color space BT601, Not support*//**<CNcomment:输出色彩空间BT601, 不支持设置*/
+    HI_UNF_DISP_COLOR_SPACE_BT709,          /**< output  color space BT709*//**<CNcomment:输出色彩空间BT709*/
+    HI_UNF_DISP_COLOR_SPACE_BT2020,         /**< output  color space BT2020*//**<CNcomment:输出色彩空间BT2020*/
+    HI_UNF_DISP_COLOR_SPACE_BUTT
+}HI_UNF_DISP_COLOR_SPACE_E;
+
+/** definition of output hdr infomation */
+/**CNcomment:实际输出的信号类型及色域类型*/
+typedef struct hiUNF_DISP_OUTPUT_STATUS_S
+{
+    HI_UNF_DISP_HDR_TYPE_E enActualOutHDRType;
+    HI_UNF_DISP_COLOR_SPACE_E enActualOutColorSpace;
+}HI_UNF_DISP_OUTPUT_STATUS_S;
+
+/**define the struct about hdr mixed priority mode. */
+/**CNcomment:定义hdr的叠加优先模式 */
+typedef enum hiUNF_DISP_HDR_PRIORITY_MODE{
+    HI_UNF_DISP_HDR_PRIORITY_VIDEO = 0,  /**< video and graphic tomapping to video   luminance.  */
+    HI_UNF_DISP_HDR_PRIORITY_GRAPHIC,    /**< video and graphic tomapping to graphic luminance. */
+    HI_UNF_DISP_HDR_PRIORITY_AUTO,       /**< video and graphic tomapping automatically according to scene.  Not support currently. */
+    HI_UNF_DISP_HDR_PRIORITY_MAX,
+} HI_UNF_DISP_HDR_PRIORITY_MODE;
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      DISPLAY */
+/** @{ */  /** <!-- [DISPLAY] */
+
+
+/**
+   \brief Initiallization DISP module.CNcomment:初始化DISP模块 CNend
+   \attention \n
+   Please call this API function, before call anyother API of DISP module.
+   CNcomment:调用DISP模块其它接口前要求首先调用本接口 CNend
+   \param  none.CNcomment:无 CNend
+   \retval ::HI_SUCCESS  operation success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_DEV_NOT_EXIST DISP device not exist.CNcomment:设备不存在 CNend
+   \retval ::HI_ERR_DISP_NOT_DEV_FILE  DISP  not device file .CNcomment:非设备 CNend
+   \retval ::HI_ERR_DISP_DEV_OPEN_ERR  DISP  open fail.CNcomment:打开失败 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_Init( HI_VOID );
+
+
+/**
+   \brief deinital.CNcomment:去初始化DISP模块 CNend
+   \attention \n
+   please call API HI_UNF_DISP_Close and open all the DISP device, before call this API.
+   CNcomment:在调用::HI_UNF_DISP_Close接口关闭所有打开的DISP后调用本接口 CNend
+   \param none.CNcomment:无 CNend
+   \retval ::HI_SUCCESS success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_DEV_CLOSE_ERR  DISP close fail.CNcomment:关闭失败 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_DeInit( HI_VOID );
+
+
+/**
+   \brief Attach one DISP channel to anoter.CNcomment:将两个DISP通道绑定 CNend
+   \attention \n
+   Please finish the attach operation before the DISP channel has been open, and currently we only support HD channel attach to SD channel.
+   CNcomment:目前支持将高清DISP绑定到标清DISP通道上，绑定在打开DISP通道前必须完成绑定操作。 CNend
+   \param[in] enDstDisp   Destination DISP channel.CNcomment:目标DISP通道号 CNend
+   \param[in] enSrcDisp   source DISP channel.CNcomment:  源DISP通道号 CNend
+   \retval ::HI_SUCCESS  operation success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT  display not be initialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT   invalid opeation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_Attach( HI_UNF_DISP_E enDstDisp, HI_UNF_DISP_E enSrcDisp );
+
+
+/**
+   \brief dettach DISP.CNcomment:将两个DISP通道解绑定 CNend
+   \attention \n
+   should  close the DISP channels, before do detach operation.
+   CNcomment:只有在关闭两个DISP通道后才能进行解绑定操作。 CNend
+   \param[in] enDstDisp   Destination DISP channel.CNcomment:目标DISP通道号 CNend
+   \param[in] enSrcDisp    source DISP channel.CNcomment: 源DISP通道号 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT   DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT   invalid operation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_Detach( HI_UNF_DISP_E enDstDisp, HI_UNF_DISP_E enSrcDisp );
+
+
+/**
+   \brief open DISP channel.CNcomment:打开指定DISP通道 CNend
+   \attention \n
+   Please config the valid parameters before open DISP.
+   CNcomment:在打开DISP之前，先完成对其的参数设置，避免画面闪烁 CNend
+   \param[in] enDisp   DISP channel ID, please reference the define of HI_UNF_DISP_E.CNcomment:DISP通道号，请参见::HI_UNF_DISP_E CNend
+   \retval ::HI_SUCCESS success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT   DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_CREATE_ERR    DISP create fail.CNcomment:DISP创建失败 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_Open( HI_UNF_DISP_E enDisp );
+
+
+/**
+   \brief  coase DISP channel.CNcomment:关闭指定DISP CNend
+   \attention \n
+   none.
+   CNcomment:无 CNend
+   \param[in] enDisp DISP channel ID.CNcomment:DISP通道号 CNend
+   \retval ::HI_SUCCESS success. CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_Close( HI_UNF_DISP_E enDisp );
+
+
+/**
+   \brief  set DISP interface parameter.CNcomment:设置DISP的接口参数 CNend
+   \attention \n
+   The API is uesed for set  interface attach .If the interface has been attached,must be detach it ,or return HI_ERR_DISP_INVALID_OPT;\n
+   There are 4 DAC provided by SOC 3712 v300. suggest, DAC 0/1/2 used by HD channel, DAC3 used by SD channel CVBS. \n
+   There are 6 DAC provided by SOC 3716 v100/v200/v300. suggest, DAC 0/1/2 used by HD channel, DAC3/4/5 used by SD channel.
+   CNcomment:该API 用来设置输出接口的绑定关系，如果设置已被绑定过的接口，则需要先进行Detach操作\n
+   解除绑定关系，否则返回错误HI_ERR_DISP_INVALID_OPT;\n
+   3712 v300 芯片共有4个DAC，推荐0，1，2用作高清输出，3用作标清CVBS输出。\n
+   3716 v100/v200/v300 芯片共有6个DAC，推荐0，1，2用作高清输出，3，4，5用作标清输出。CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] u32IntfNum  DISP intf num of DISP channel.CNcomment:DISP通道上的接口数目 CNend
+   \param[in] pstIntf  DISP intf para.CNcomment:DISP接口参数 CNend
+   \retval ::HI_SUCCESS   success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT   DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR      Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT   invalid operation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_AttachIntf( HI_UNF_DISP_E enDisp, HI_UNF_DISP_INTF_S *pstIntf, HI_U32 u32IntfNum );
+
+
+/**
+   \brief cancel DISP interface parameter.CNcomment:取消DISP的接口参数 CNend
+   \attention \n
+   The API is uesed to  detach  interface.
+   CNcomment:这个API 用来解除接口的绑定关系。 CNend
+   \param[in] enDisp        DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] u32IntfNum  DISP interface number of DISP channel.CNcomment:DISP通道上的接口数目 CNend
+   \param[in] pstIntf  DISP interface para.CNcomment:DISP接口参数 CNend
+   \retval ::HI_SUCCESS   success. CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT   DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR        Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA  invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT   invalid operation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_DetachIntf( HI_UNF_DISP_E enDisp, HI_UNF_DISP_INTF_S *pstIntf, HI_U32 u32IntfNum );
+
+
+/**
+   \brief set DISP output format.CNcomment:设置DISP的制式 CNend
+   \attention \n
+   for HD DISP channel please set HD display format, and for SD DISP channel please set SD display format.\n
+   for scenario of HD,SD use same source, only support format which frame rate is 50Hz or 60Hz. \n
+   for scenario of HD,SD use same source, when this UNF API sets up HD DISP channel, \n
+   the SD DISP channel will be temporarily affected, and vice versa. \n
+   It is recommended to use HI_UNF_DISP_SetIsogenyAttr to set up both HD and SD DISP channels to avoid this impact.
+   CNcomment:对高清的DISP，只能设置高清的制式；对标清的DISP，只能设置标清的制式。\n
+   在同源显示场景下，暂不支持刷新率非50Hz/60Hz的制式，如：暂不支持1080P24/1080P25/1080P30。\n
+   在同源显示场景下，该接口设置高清通道时，标清通道显示会受到短暂影响，反之亦然。\n
+   推荐使用HI_UNF_DISP_SetIsogenyAttr接口同时设置高清与标清通道，以避免这种影响。 CNend
+   \param[in] enDisp               DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] enEncodingFormat    DISP format.CNcomment:DISP的制式 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetFormat( HI_UNF_DISP_E enDisp, HI_UNF_ENC_FMT_E enEncodingFormat );
+
+
+/**
+   \brief get DISP format.CNcomment:获取DISP的制式 CNend
+   \attention \n
+   none.CNcomment:无 CNend
+   \param[in] enDisp               DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] penEncodingFormat    poiner of DISP format.DCNcomment:ISP的制式指针 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetFormat( HI_UNF_DISP_E enDisp, HI_UNF_ENC_FMT_E *penEncodingFormat );
+
+
+/**
+   \brief set user define LCD clock parameter.CNcomment:设置用户定义的LCD时序参数 CNend
+   \attention \n
+   only 3716 v100 v200 is  supported LCD.
+   CNcomment:只有3716 v100 v200 支持LCD CNend
+   \param[in] enDisp               DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pstTiming    poiner of DISP format.CNcomment:LCD时序参数 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetCustomTiming( HI_UNF_DISP_E enDisp, HI_UNF_DISP_TIMING_S *pstTiming );
+
+
+/**
+   \brief  get LCD parameter which had been config.CNcomment:获取DISP的LCD参数 CNend
+   \attention \n
+   only 3716 v100 v200 is  supported LCD.
+   CNcomment:只有3716 v100 v200 支持LCD CNend
+   \param[in] enDisp          DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pstTiming      pointer of LCD paramter.CNcomment:指针类型，LCD参数 CNend
+   \retval ::HI_SUCCESS success.CNcomment: 成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetCustomTiming( HI_UNF_DISP_E enDisp, HI_UNF_DISP_TIMING_S *pstTiming );
+
+
+/**
+   \brief   set DISP layers Z order.CNcomment:设置DISP上叠加层的Z序 CNend
+   \attention \n
+   only 3716 v100 v200 is  supported LCD.
+   CNcomment:只有3716 v100 v200 支持LCD CNend
+   \param[in] enDisp          DISP channel ID.CNcomment: DISP通道号 CNend
+   \param[in] enLayer        layer ID which needed overlay to the DISP channel.CNcomment: DISP上的叠加层 CNend
+   \param[in] enZFlag        the way of overlay.CNcomment:Z序调节方式 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetLayerZorder( HI_UNF_DISP_E enDisp, HI_UNF_DISP_LAYER_E enLayer, HI_LAYER_ZORDER_E enZFlag );
+
+
+/**
+   \brief  get DISP overlay z order.CNcomment:获取DISP上叠加层的Z序 CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.
+   CNcomment:在高标清绑定情况下，高清DISP的设置会自动同步到标清DISP；标清DISP的设置会自动同步到高清DISP。 CNend
+   \param[in] enDisp            DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] enLayer           CNcomment:DISP上的叠加层 CNend
+   \param[in] pu32Zorder        CNcomment:叠加层Z序数值，数值越大优先级越高 CNend
+   \retval ::HI_SUCCESS success.CNcomment: 成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation.CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetLayerZorder( HI_UNF_DISP_E enDisp, HI_UNF_DISP_LAYER_E enLayer, HI_U32 *pu32Zorder );
+
+
+/**
+   \brief set DISP back ground color.CNcomment:设置DISP背景色 CNend
+   \attention \n
+   none.
+   CNcomment:无 CNend
+   \param[in] enDisp       CNcomment:DISP通道号 CNend
+   \param[in] pstBgColor   CNcomment:指针类型，待配置的显示输出背景色。请参见::HI_UNF_BG_COLOR_S CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetBgColor( HI_UNF_DISP_E enDisp, const HI_UNF_DISP_BG_COLOR_S *pstBgColor );
+
+
+/**
+   \brief  set DISP back ground color.CNcomment:获取DISP背景色 CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.
+   CNcomment:在高标清绑定情况下，高清DISP的设置会自动同步到标清DISP；标清DISP的设置会自动同步到高清DISP。 CNend
+   \param[in] enDisp          DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] pstBgColor   pointer of back ground color.CNcomment: 指针类型，显示输出背景色 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetBgColor( HI_UNF_DISP_E enDisp, HI_UNF_DISP_BG_COLOR_S *pstBgColor );
+
+
+/**
+   \brief  set DISP brightness.CNcomment:设置DISP亮度 CNend
+   \attention \n
+   if the value seted more than 100, we clip it to 100.CNcomment:大于100的值按100处理 CNend
+   \param[in] enDisp            DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] u32Brightness   brightness value. the range is 0~100, 0 means the min brightness value.
+   CNcomment:待设置的显示输出亮度值。取值范围为0～100。0：最小亮度；100：最大亮度 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetBrightness( HI_UNF_DISP_E enDisp, HI_U32 u32Brightness );
+
+
+/**
+   \brief   get the DISP brightness.CNcomment:获取DISP亮度 CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.
+   CNcomment:查询的默认亮度值为50。\n
+   在高标清绑定情况下，高清DISP的设置会自动同步到标清DISP；标清DISP的设置会自动同步到高清DISP。 CNend
+   \param[in] enDisp              DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] pu32Brightness    pointer of brightness. CNcomment:指针类型，显示输出亮度值 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetBrightness( HI_UNF_DISP_E enDisp, HI_U32 *pu32Brightness );
+
+
+/**
+   \brief  set DISP contrast value.CNcomment:设置DISP对比度 CNend
+   \attention \n
+   If the value is more than 100, we clip it to 100.
+   CNcomment:大于100的值按100处理 CNend
+   \param[in] enDisp          DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] u32Contrast    contrast value. the range is 0~100, 0 means the min contrast value. \n
+   CNcomment:待设置的显示输出对比度值。取值范围为0～100。0：最小对比度；100：最大对比度 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetContrast( HI_UNF_DISP_E enDisp, HI_U32 u32Contrast );
+
+
+/**
+   \brief  get DISP contrast value.CNcomment:获取DISP对比度 CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.\n
+   CNcomment:查询的默认对比度值为50。\n
+   在高标清绑定情况下，高清DISP的设置会自动同步到标清DISP；标清DISP的设置会自动同步到高清DISP。 CNend
+   \param[in] enDisp           DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] pu32Contrast   pointer of contrast. CNcomment:指针类型，显示输出对比度值 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetContrast( HI_UNF_DISP_E enDisp, HI_U32 *pu32Contrast );
+
+
+/**
+   \brief   set DISP saturation.CNcomment:设置DISP饱和度 CNend
+   \attention \n
+   If the value is more than 100, we clip it to 100.
+   CNcomment:大于100的值按100处理 CNend
+   \param[in] enDisp             DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] u32Saturation      saturation value. the range is 0~100, 0 means the min saturation value. \n
+   CNcomment:待设置的显示输出饱和度值。取值范围为0～100。0：最小饱和度；100：最大饱和度 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_DISP_SetSaturation( HI_UNF_DISP_E enDisp, HI_U32 u32Saturation );
+
+
+/**
+   \brief   get DISP saturation.CNcomment:获取DISP饱和度 CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.\n
+   CNcomment:查询的默认饱和度值为50。\n
+   在高标清绑定情况下，高清DISP的设置会自动同步到标清DISP；标清DISP的设置会自动同步到高清DISP。 CNend
+   \param[in] enDisp                 DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] pu32Saturation    pointer of saturation. CNcomment:指针类型，显示输出饱和度值 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetSaturation( HI_UNF_DISP_E enDisp, HI_U32 *pu32Saturation );
+
+
+/**
+   \brief  set DISP hueplus.CNcomment:设置DISP色调 CNend
+   \attention \n
+   none.CNcomment:无 CNend
+   \param[in] enDisp              DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] u32HuePlus       hueplus value. the range is 0~100, 0 means the min hueplus value. \n
+   CNcomment:显示输出色调增益值。范围为0～100。0：表示最小色调增益；100：表示最大色调增益 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetHuePlus( HI_UNF_DISP_E enDisp, HI_U32 u32HuePlus );
+
+
+/**
+   \brief get DISP hueplus.CNcomment:获取DISP色调 CNend
+   \attention \n
+   In the case of HD atach to SD. the Z order configuration of HD will auto sync to SD, also the configuration of SD will auto sync to HD.\n
+   CNcomment:查询的默认色调值为50。\n
+   在高标清绑定情况下，高清DISP的设置会自动同步到标清DISP；标清DISP的设置会自动同步到高清DISP。 CNend
+   \param[in] enDisp          DISP channel ID.CNcomment: DISP通道号 CNend
+   \param[out] pu32HuePlus     pointer of hueplus. CNcomment:指针类型，显示输出色调增益值 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetHuePlus( HI_UNF_DISP_E enDisp, HI_U32 *pu32HuePlus );
+
+
+/**
+   \brief  set Wss.CNcomment:直接设置WSS（Wide Screen Singnalling）数据 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp           DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pstWssData        pointer of Wss data description structure.CNcomment:指针类型，指向WSS数据的指针 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetWss( HI_UNF_DISP_E enDisp, const HI_UNF_DISP_WSS_DATA_S *pstWssData );
+
+
+/**
+   \brief  set Macrovision mode.CNcomment:设置Macrovision模式 CNend
+   \attention \n
+   none.CNcomment:无 CNend
+   \param[in] enDisp          DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] enMode        Macrovision mode.  CNcomment:Macrovision模式，请参见::HI_UNF_MACROVISION_MODE_E CNend
+   \param[in] pData          pointer of Macrovision control data CNcomment: 指针类型，自定义的Macrovision控制数据 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetMacrovision( HI_UNF_DISP_E enDisp, HI_UNF_DISP_MACROVISION_MODE_E enMode, const HI_VOID *pData );
+
+
+/**
+   \brief get Macrovision mode.CNcomment: 获取Macrovision模式 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] penMode    pointer of Macrovision mode. CNcomment:指针类型，MACROVISION模式 CNend
+   \param[out] pData      a data pointer only valid whenpenMode=HI_MACROVISION_MODE_CUSTOM.\n
+   CNcomment:指针类型，仅当penMode=HI_MACROVISION_MODE_CUSTOM时有效 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetMacrovision( HI_UNF_DISP_E enDisp, HI_UNF_DISP_MACROVISION_MODE_E *penMode, const HI_VOID *pData );
+
+
+/**
+   \brief   set CGMS data.CNcomment:设置CGMS（Copy Generation Management System）数据 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp                   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pstCgmsCfg             pointer of CGMS configuration  CNcomment:指针类型，指向CGMS配置数据的指针 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetCgms( HI_UNF_DISP_E enDisp, const HI_UNF_DISP_CGMS_CFG_S *pstCgmsCfg );
+
+
+/**
+   \brief chip do or not support Macrovision.CNcomment: 获取芯片是否支持Macrovision CNend
+   \attention \n
+   none.CNcomment:无 CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] pbSupport    pointer of Macrovision flag. CNcomment:指针类型，Macrovision 标志 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetMacrovisionSupport( HI_UNF_DISP_E enDisp, HI_BOOL *pbSupport );
+
+/**
+   \brief set aspect ratio attribute of display device.CNcomment: 设置设备宽高比 CNend
+   \attention \n
+   If set AspectRatio USER mode ,must be set u32UserAspectWidth and u32UserAspectHeight \n
+   (theWidth/Height range is 1/64~64,if set zero means using current screen AspectRatio.) \n
+   If not AspectRatio USER mode ,it will be set value by enumeration means;In this mode u32UserAspectWidth and u32UserAspectHeight are invalid ;\n
+   If set AspectRatio AUTO mode , use current screen AspectRatio;
+   CNcomment:如果设置USER模式则需设置u32UserAspectWidth 和u32UserAspectHeight的值，\n
+   赋值范围为两者比值1/64~64,如果设置0则表示使用当前屏幕的宽高比；\n
+   非USER模式则按照对应的比值起效u32UserAspectWidth 和u32UserAspectHeight的值无效\n
+   其中设置AUTO模式则设备宽高比值自动设置为当前屏幕的宽高比。 CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pstDispAspectRatio    pointer of aspect ratio attribute of display device . CNcomment:指针类型，显示设备宽高比信息 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetAspectRatio( HI_UNF_DISP_E enDisp, HI_UNF_DISP_ASPECT_RATIO_S *pstDispAspectRatio );
+
+
+/**
+   \brief get aspect ratio attribute of display device.CNcomment: 获得设备宽高比属性 CNend
+   \attention \n
+   none.
+   CNcomment:无 CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] pstDispAspectRatio    pointer of aspect ratio attribute of display device . CNcomment:指针类型，显示设备宽高比信息 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetAspectRatio( HI_UNF_DISP_E enDisp, HI_UNF_DISP_ASPECT_RATIO_S *pstDispAspectRatio );
+
+
+/**
+   \brief set algorithmic attribute of display device.CNcomment: 设置设备算法属性 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pstAlg    pointer of algorithmic attribute of display device . CNcomment:指针类型，显示设备算法属性 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetAlgCfg( HI_UNF_DISP_E enDisp, HI_UNF_DISP_ALG_CFG_S *pstAlg );
+
+
+/**
+   \brief get algorithmic status of display device.CNcomment: 获取设备算法属性 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] pstAlg    pointer of algorithmic attribute of display device . CNcomment:指针类型，显示设备算法属性 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetAlgCfg( HI_UNF_DISP_E enDisp, HI_UNF_DISP_ALG_CFG_S *pstAlg );
+
+
+/**
+   \brief create VBI data channel.CNcomment: 创建VBI数据通道 CNend
+   \attention \n
+   Each VBI type can not  created  repeatedly,if created more than one time,it will be return HI_ERR_DISP_CREATE_ERR;
+   CNcomment:每种VBI类型只能创建一次，多次创建则返回HI_ERR_DISP_CREATE_ERR CNend
+   \param[in] enDisp      DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pstCfg    pointer of parameter of VBI channel . CNcomment:指针类型，VBI通道参数 CNend
+   \param[out] phVbi    pointer of VBI handle . CNcomment:指针类型，VBI通道句柄 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \retval ::HI_ERR_DISP_CREATE_ERR    invalid operation. CNcomment:创建失败 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_CreateVBI( HI_UNF_DISP_E enDisp, HI_UNF_DISP_VBI_CFG_S *pstCfg, HI_HANDLE *phVbi );
+
+
+/**
+   \brief destroy VBI data channel.CNcomment: 销毁VBI数据通道 CNend
+   \attention \n
+   none.
+   CNcomment:无 CNend
+   \param[in] hVbi      VBI handle ID.CNcomment:VBI 通道句柄 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_DestroyVBI( HI_HANDLE hVbi );
+
+
+/**
+   \brief send data to vbi channel.CNcomment: 发送数据到VBI通道 CNend
+   \attention \n
+   After  call HI_UNF_DISP_CreateVBI creat VBI handle sucess,you can call API HI_UNF_DISP_SendVBIData send VBI data .
+   CNcomment:调用HI_UNF_DISP_CreateVBI 创建VBI通道成功后，才能调用HI_UNF_DISP_SendVBIData  发送数据 CNend
+   \param[in] hVbi      VBI handle ID.CNcomment:VBI 通路句柄 CNend
+   \param[in] pstVbiData      pointer of VBI data.CNcomment:VBI数据指针 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SendVBIData(HI_HANDLE hVbi, HI_UNF_DISP_VBI_DATA_S *pstVbiData);
+
+/**
+   \brief Get default attributes of screen share channel.CNcomment: 获取屏幕投影通道的默认属性 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      display channel.CNcomment:显示通路 CNend
+   \param[out]pstAttr     pointer of parameter .CNcomment:指针,配置参数 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetDefaultCastAttr(HI_UNF_DISP_E enDisp,HI_UNF_DISP_CAST_ATTR_S *pstAttr);
+
+
+/**
+   \brief create screen share channel.CNcomment: 创建屏幕投影通道 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      display channel.CNcomment:显示通路 CNend
+   \param[in] pstAttr      pointer of parameter .CNcomment:指针,配置参数 CNend
+   \param[out] phCast      handle of screen share .CNcomment:屏幕投影句柄 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_CreateCast(HI_UNF_DISP_E enDisp, HI_UNF_DISP_CAST_ATTR_S * pstAttr, HI_HANDLE *phCast);
+
+
+/**
+   \brief destroy screen share channel.CNcomment: 销毁屏幕投影通道 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] phCast      handle of screen share .CNcomment:屏幕投影句柄 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_DestroyCast( HI_HANDLE hCast );
+
+
+/**
+   \brief enable screen share.CNcomment: 使能屏幕投影功能 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] phCast      handle of screen share .CNcomment:屏幕投影句柄 CNend
+   \param[in] bEnable      enable screen share .CNcomment:使能屏幕投影 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetCastEnable( HI_HANDLE hCast, HI_BOOL bEnable );
+
+
+/**
+   \brief get enable flag of screen share.CNcomment: 获取屏幕投影是否使能 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] phCast      handle of screen share .CNcomment:屏幕投影句柄 CNend
+   \param[out] bEnable     flag .CNcomment:标志 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetCastEnable( HI_HANDLE hCast, HI_BOOL *pbEnable );
+
+
+/**
+   \brief get frame info of screen share.CNcomment: 获取屏幕投影帧信息 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] hCast      handle of screen share .CNcomment:屏幕投影句柄 CNend
+   \param[out] pstFrameInfo        frame info.CNcomment:帧信息 CNend
+   \param[in] u32TimeoutMs wait time in ms.CNcomment:等待时间，毫秒为单位 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \retval ::HI_ERR_DISP_TIMEOUT          operation timeout. CNcomment:操作超时 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_AcquireCastFrame(HI_HANDLE hCast, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameInfo, HI_U32 u32TimeoutMs);
+
+
+/**
+   \brief release frame info of screen share.CNcomment: 释放屏幕投影帧信息 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] hCast      handle of screen share .CNcomment:屏幕投影句柄 CNend
+   \param[in] pstFrameInfo     frame info.CNcomment:帧信息 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_ReleaseCastFrame( HI_HANDLE hCast, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameInfo );
+
+
+/**
+   \brief professional color modulation.CNcomment: 专业色彩调节 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      display channel.CNcomment:显示通路 CNend
+   \param[in] pstCS      struct of color modulation.CNcomment:色彩调节结构 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetColor( HI_UNF_DISP_E enDisp, HI_UNF_DISP_COLOR_SETTING_S *pstCS );
+
+
+/**
+   \brief get color modulation parameter.CNcomment: 获取色彩调节信息 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      display channel.CNcomment:显示通路 CNend
+   \param[in] pstCS      struct of color modulation.CNcomment:色彩调节结构 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetColor( HI_UNF_DISP_E enDisp, HI_UNF_DISP_COLOR_SETTING_S *pstCS );
+
+
+/**
+   \Snapshot truncation screen connection, intercepts the screen complete picture;CNcomment:截取屏幕完整画面; CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      display channel.CNcomment:显示通路 CNend
+   \param[out] pstFrameInfo     frame info.CNcomment:帧信息 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_AcquireSnapshot(HI_UNF_DISP_E enDisp, HI_UNF_VIDEO_FRAME_INFO_S * pstFrameInfo);
+
+/**
+   \Release Snapshot picture;CNcomment:释放截屏画面; CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      display channel.CNcomment:显示通路 CNend
+   \param[in] pstFrameInfo     frame info.CNcomment:帧信息 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_ReleaseSnapshot(HI_UNF_DISP_E enDisp, HI_UNF_VIDEO_FRAME_INFO_S * pstFrameInfo);
+
+
+/**
+   \brief get color modulation parameter.CNcomment:设置DISP的默认属性 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp      display channel.CNcomment:显示通路 CNend
+   \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \retval ::HI_ERR_DISP_INVALID_OPT    invalid operation. CNcomment:操作非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetDefaultPara( HI_UNF_DISP_E enDisp);
+
+
+/**
+   \brief set DISP 3D format.CNcomment:设置DISP的3D制式 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp           DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] en3D             DISP 3D mode.CNcomment:DISP 3D模式 CNend
+   \param[in] enEncodingFormat DISP format.CNcomment:DISP的制式 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_Set3DMode(HI_UNF_DISP_E enDisp, HI_UNF_DISP_3D_E en3D, HI_UNF_ENC_FMT_E enEncFormat);
+
+/**
+   \brief get DISP 3D format.CNcomment:查询DISP的3D制式 CNend
+   \attention \n
+   none. CNcomment:无 CNend
+   \param[in] enDisp           DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] pen3D           DISP 3D mode.CNcomment:DISP 3D模式 CNend
+   \param[out] penEncFormat    DISP format.CNcomment:DISP的制式 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_Get3DMode(HI_UNF_DISP_E enDisp, HI_UNF_DISP_3D_E *pen3D, HI_UNF_ENC_FMT_E *penEncFormat);
+
+/**
+   \brief set right eye first for 3D output.CNcomment:设置3D输出右眼优先 CNend
+   \attention \n
+   Only take effect in 3D output mode. CNcomment: 仅在3D输出时有效 CNend
+   \param[in] enDisp     DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] bEnable   Right-Eye-First.CNcomment:右眼优先 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetRightEyeFirst(HI_UNF_DISP_E enDisp, HI_BOOL bEnable);
+
+/**
+   \brief set virtual screen size of display.CNcomment:设置显示通道的虚拟屏幕大小 CNend
+   \attention \n
+   if not set ,default value is 1280*720. CNcomment: 如果不设置此函数，默认的虚拟屏幕大小是720p. CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] u32Width  virtual screen width, the range is [480, 3840].CNcomment:虚拟屏幕宽度，取值范围为[480, 3840]. CNend
+   \param[in] u32Height  virtual screen height, the range is [480, 3840].CNcomment:虚拟屏幕高度，取值范围为[480, 3840]. CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetVirtualScreen(HI_UNF_DISP_E enDisp, HI_U32 u32Width, HI_U32 u32Height);
+
+/**
+   \brief get virtual screen size of display.CNcomment:获取显示通道的虚拟屏幕大小 CNend
+   \attention \n
+   none. CNcomment: 无 CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] u32Width  virtual screen width, the range is [480, 3840].CNcomment:虚拟屏幕宽度，取值范围为[480, 3840]. CNend
+   \param[out] u32Height  virtual screen height, the range is [480, 3840].CNcomment:虚拟屏幕高度，取值范围为[480, 3840]. CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetVirtualScreen(HI_UNF_DISP_E enDisp, HI_U32 *u32Width, HI_U32 *u32Height);
+
+
+/**
+   \brief set offset of display area in real screen.CNcomment:设置显示区域在实体屏幕上的偏移量,为物理像素点 CNend
+   \attention \n
+   must be 4 pixels aligned,if not set, the default value is 0. CNcomment: offset 值必须是4对齐,如果不设置默认的值为0. CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pstOffset  offset in pixel, the range is [0, 200].CNcomment:偏移像素数目，取值范围为[0, 200]. CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetScreenOffset(HI_UNF_DISP_E enDisp, HI_UNF_DISP_OFFSET_S *pstOffset);
+
+/**
+   \brief get offset of display area in real screen.CNcomment:获取显示区域在实体屏幕上的偏移量,为物理像素点 CNend
+   \attention \n
+   none. CNcomment: 无 CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] pstOffset  offset in pixel, the range is [0, 200].CNcomment:偏移像素数目，取值范围为[0, 200]. CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetScreenOffset(HI_UNF_DISP_E enDisp, HI_UNF_DISP_OFFSET_S *pstOffset);
+
+/**
+   \brief set isogeny attributes. It is recommended to use HI_UNF_DISP_SetIsogenyAttr to \n
+   set up both HD and SD DISP channels format when they have the same source.
+   \attention \n
+   none. CNcomment: 设置同源属性，同源模式下推荐使用该接口替代HI_UNF_DISP_SetFormat \n
+    来同时设置高清通道与标清通道的制式。 CNend
+   \param[in] pstIsogeny isogenous attributes.CNcomment:同源模式下，要设置的属性信息 CNend
+   \param[in] u32ChannelNum  channel counts to be set in isogenous mode.CNcomment:同源模式下，要设置属性的通道个数 CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetIsogenyAttr(const HI_UNF_DISP_ISOGENY_ATTR_S *pstIsogeny, const HI_U32 u32ChannelNum);
+
+/**
+   \brief set display output type.CNcomment: 设置显示输出类型 CNend
+   \attention \n
+   none. CNcomment: 无 CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] enHDRType   DISP type.CNcomment:HDR 输出类型CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetHDRType(HI_UNF_DISP_E enDisp, const HI_UNF_DISP_HDR_TYPE_E enHDRType);
+
+/**
+   \brief Get display output type.CNcomment: 获取显示输出类型 CNend
+   \attention \n
+   none. CNcomment: 无 CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] penHDRType   DISP type.CNcomment:HDR输出类型CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetHDRType(HI_UNF_DISP_E enDisp, HI_UNF_DISP_HDR_TYPE_E *penHDRType);
+
+/**
+   \brief Set display output color space.CNcomment: 设置输出色彩空间 CNend
+   \attention \n
+   should set sink capability with HI_UNF_DISP_SetSinkCapability api when set auto out color space.
+   CNcomment: 设置AUTO输出时，必须先调用HI_UNF_DISP_SetSinkCapability接口 CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] enColorSpace output color space.CNcomment:设置输出色彩空间CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetOutputColorSpace(HI_UNF_DISP_E enDisp, const HI_UNF_DISP_COLOR_SPACE_E enColorSpace);
+
+/**
+   \brief Get display output color space.CNcomment: 获取输出色彩空间 CNend
+   \attention \n
+   none. CNcomment: 无 CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] penColorSpace output color space.CNcomment:获取输出色彩空间CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetOutputColorSpace(HI_UNF_DISP_E enDisp, HI_UNF_DISP_COLOR_SPACE_E *penColorSpace);
+
+/**
+   \brief Set capability of sink .CNcomment: 设置Sink端能力集CNend
+   \attention \n
+    Sink capability can acquire from hdmi, Strongly recommend to set sink capability when detect hdmi hot-plot event .
+    CNcomment: 可从HDMI接口中获取到Sink端的能力集，强烈建议在每一次热插拔事件被检测到时重新设置Sink 能力集 CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pstSinkCap output color space.CNcomment:设置Sink端能力集CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetSinkCapability( HI_UNF_DISP_E enDisp, const HI_UNF_EDID_BASE_INFO_S *pstSinkCap);
+
+/**
+   \brief Set alpha of video .CNcomment: 设置视频alpha值CNend
+   \attention \n
+    none  CNcomment: 无CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] u32Alpha video alpha value.CNcomment:视频的alpha值CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetVideoAlpha( HI_UNF_DISP_E enDisp, HI_U32 u32Alpha );
+
+/**
+   \brief Get alpha of video .CNcomment: 获取视频alpha值CNend
+   \attention \n
+    none CNcomment: 无 CNend
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] pu32Alpha video alpha value.CNcomment:获取的视频alpha值CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetVideoAlpha(HI_UNF_DISP_E enDisp, HI_U32 *pu32Alpha);
+
+
+/**
+   \brief Get display output status Information.CNcomment: 获取显示输出状态信息 CNend
+   \attention \n
+   none. CNcomment: 无 CNend
+   \param[in] enDisp DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[out] pstOutputStatus.CNcomment: 输出状态信息CNend
+   \retval ::HI_SUCCESS success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetOutputStatus(HI_UNF_DISP_E enDisp, HI_UNF_DISP_OUTPUT_STATUS_S *pstOutputStatus);
+
+
+/**
+   \brief set hdr mixed priority mode.CNcomment:设置hdr的叠加优先级模式 CNend
+   \attention: only take effect when output type is DolbyVision.CNcomment:当前仅在DolbyVision输出场景下才生效 CNend\n
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] enPriorityMode hdr priority mode.CNcomment:hdr优先级模式. CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_SetHDRPriorityMode(HI_UNF_DISP_E enDisp, HI_UNF_DISP_HDR_PRIORITY_MODE enPriorityMode);
+
+/**
+   \brief get hdr mixed priority mode.CNcomment:获取hdr的叠加优先级模式 CNend
+   \attention \n
+   \param[in] enDisp   DISP channel ID.CNcomment:DISP通道号 CNend
+   \param[in] penPriorityMode hdr priority mode.CNcomment:hdr优先级模式. CNend
+   \retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+   \retval ::HI_ERR_DISP_NO_INIT    DISP uninitialization.CNcomment:DISP未初始化 CNend
+   \retval ::HI_ERR_DISP_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+   \see \n
+   none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_DISP_GetHDRPriorityMode(HI_UNF_DISP_E enDisp, HI_UNF_DISP_HDR_PRIORITY_MODE *penPriorityMode);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+#endif
+/************************************** The End Of File **************************************/
diff -uNr a/include/hi_unf_ecs.h b/include/hi_unf_ecs.h
--- a/include/hi_unf_ecs.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_ecs.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,28 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+ ******************************************************************************
+ File Name     : hi_unf_ecs.h
+ Version       : Initial draft
+ Author        : HiSilicon multimedia software group
+ Created Date  : 2008-06-05
+ Last Modified by:
+ Description   : Application programming interfaces (APIs) of the external chip software (ECS)
+ Function List :
+ Change History:
+ ******************************************************************************/
+#ifndef __HI_UNF_ECS_H__
+#define __HI_UNF_ECS_H__
+
+#include "hi_common.h"
+#include "hi_error_mpi.h"
+#include "hi_unf_frontend.h"
+#include "hi_unf_gpio.h"
+#include "hi_unf_ir.h"
+#include "hi_unf_pmoc.h"
+#include "hi_unf_wdg.h"
+#include "hi_unf_i2c.h"
+#include "hi_unf_otp.h"
+
+#endif /* __HI_UNF_ECS_H__ */
+
diff -uNr a/include/hi_unf_edid.h b/include/hi_unf_edid.h
--- a/include/hi_unf_edid.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_edid.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,500 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_edid.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2013-8-28
+  Description   :
+  History       :
+  1.Date        : 2013-8-28
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+#ifndef __HI_UNF_EDID_H__
+#define __HI_UNF_EDID_H__
+
+#include "hi_unf_common.h"
+#include "hi_unf_audio.h"
+#include "hi_unf_video.h"
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      EDID */
+/** @{*/  /** <!-- [EDID] */
+
+/**EDID Audio type enum*//**CNcomment:HDMI 音频类型 枚举 */
+typedef enum hiUNF_EDID_AUDIO_FORMAT_CODE_E
+{
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_RESERVED  = 0x00,  /**<Audio coding type, refer stream,default type*//**<CNcomment:音频编码类型，参考数据流，缺省格式 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_PCM,               /**<Audio coding PCM type*//**<CNcomment:音频编码PCM格式 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_AC3,               /**<Audio coding AC3 type*//**<CNcomment:音频编码AC3格式 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_MPEG1,             /**<Audio coding MPEG1 type*//**<CNcomment:音频编码MPEG1格式 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_MP3,               /**<Audio coding MP3 type*//**<CNcomment:音频编码MP3格式 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_MPEG2,             /**<Audio coding MPEG2 type*//**<CNcomment:音频编码MPEG2格式 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_AAC,               /**<Audio coding AAC type*//**<CNcomment:音频编码AAC格式 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_DTS,               /**<Audio coding DTS type*//**<CNcomment:音频编码DTS格式 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_ATRAC,             /**<Audio coding ATRAC type*//**<CNcomment:音频编码ATRAC格式 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_ONE_BIT,           /**<Audio coding ONE BIT AUDIO type*//**<CNcomment:音频编码ONE_BIT格式 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_DDP,               /**<Audio coding DDPLUS type*//**<CNcomment:音频编码DDPLUS格式 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_DTS_HD,            /**<Audio coding DTS HD type*//**<CNcomment:音频编码DTS HD格式 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_MAT,               /**<Audio coding MAT type*//**<CNcomment:音频编码MAT格式 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_DST,               /**<Audio coding DST type*//**<CNcomment:音频编码DST格式 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_WMA_PRO,           /**<Audio coding WMA PRO type*//**<CNcomment:音频编码WMA PRO格式 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_BUTT,
+}HI_UNF_EDID_AUDIO_FORMAT_CODE_E;
+
+/**the max audio smprate count*//**CNcomment:最大音频采样率个数 */
+#define MAX_SAMPE_RATE_NUM 8
+
+/**the max audio bit depth count*//**CNcomment:最大音频比特深度个数 */
+#define MAX_BIT_DEPTH_NUM  6
+
+/**EDID Audio Info struct*//**CNcomment:EDID 音频信息结构体 */
+typedef struct hiUNF_EDID_AUDIO_INFO_S
+{
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_E enAudFmtCode; /**<Audio coding type*//**<CNcomment:音频编码类型 */
+    HI_UNF_SAMPLE_RATE_E            enSupportSampleRate[MAX_SAMPE_RATE_NUM]; /**<Audio sample rate*//**<CNcomment:音频采样率 */
+    HI_U32                          u32SupportSampleRateNum; /**<Audio sample rate num*//**<CNcomment:音频采样率类型 */
+    HI_U8                           u8AudChannel;      /**<Aud Channel of the coding type*//**<CNcomment:编码类型对应的音频通道能力 */
+
+    HI_UNF_BIT_DEPTH_E              bSupportBitDepth[MAX_BIT_DEPTH_NUM];/*sample bit depth,when audio format code is HI_UNF_EDID_AUDIO_FORMAT_CODE_PCM*//**<CNcomment:PCM类型下扩展信息为比特深度 */
+    HI_U32                          u32SupportBitDepthNum; /*sample bit depth Num,when audio format code is HI_UNF_EDID_AUDIO_FORMAT_CODE_PCM*//**<CNcomment:PCM类型下扩展信息为比特深度个数 */
+    HI_U32                          u32MaxBitRate;  /**enter max bit rate,when audio format code is HI_UNF_EDID_AUDIO_FORMAT_CODE_AC3 - HI_UNF_EDID_AUDIO_FORMAT_CODE_ATRAC**//**<CNcomment:AC3-ATRAC时 扩展信息类型为最大比特速率*/
+    HI_BOOL                         bSupportDolbyAtmos;/**<Dolby Atmos support or not*//**CNcomment:是否支持Dolby Atmos */
+}HI_UNF_EDID_AUDIO_INFO_S;
+
+/**EDID Audio speaker enum*//**CNcomment:EDID 音频扬声器配置枚举 */
+typedef enum hiUNF_EDID_AUDIO_SPEAKER_E
+{
+    HI_UNF_EDID_AUDIO_SPEAKER_FL_FR   ,
+    HI_UNF_EDID_AUDIO_SPEAKER_LFE     ,
+    HI_UNF_EDID_AUDIO_SPEAKER_FC      ,
+    HI_UNF_EDID_AUDIO_SPEAKER_RL_RR   ,
+    HI_UNF_EDID_AUDIO_SPEAKER_RC      ,
+    HI_UNF_EDID_AUDIO_SPEAKER_FLC_FRC ,
+    HI_UNF_EDID_AUDIO_SPEAKER_RLC_RRC ,
+    HI_UNF_EDID_AUDIO_SPEAKER_FLW_FRW ,
+    HI_UNF_EDID_AUDIO_SPEAKER_FLH_FRH ,
+    HI_UNF_EDID_AUDIO_SPEAKER_TC      ,
+    HI_UNF_EDID_AUDIO_SPEAKER_FCH     ,
+    HI_UNF_EDID_AUDIO_SPEAKER_BUTT    ,
+} HI_UNF_EDID_AUDIO_SPEAKER_E;
+
+/**EDID MANUFACTURE Info struct*//**CNcomment:EDID制造商信息 */
+typedef struct hiUNF_EDID_MANUFACTURE_INFO_E
+{
+    HI_U8      u8MfrsName[4];            /**<Manufacture name*//**<CNcomment:设备厂商标识 */
+    HI_U32     u32ProductCode;           /**<Product code*//**<CNcomment:设备ID */
+    HI_U32     u32SerialNumber;          /**<Serial numeber of Manufacture*//**<CNcomment:设备序列号 */
+    HI_U32     u32Week;                  /**<the week of manufacture*//**<CNcomment:设备生产日期(周) */
+    HI_U32     u32Year;                  /**<the year of manufacture*//**<CNcomment:设备生产日期(年) */
+    HI_U8      u8pSinkName[14];          /**<Sink Name*//**<CNcomment:设备名称*/
+}HI_UNF_EDID_MANUFACTURE_INFO_S;
+
+
+/**EDID Display Base Parameters struct*//**CNcomment:EDID 显示屏基本参数 */
+typedef struct hiUNF_EDID_BASE_PARA_S
+{
+    HI_U8      u8MaxImageWidth;               /**<The disp image max width  (0~255)cm*//**<CNcomment: 可显示图像最大宽 */
+    HI_U8      u8MaxImageHeight;              /**<The disp image max height (0~255)cm*//**<CNcomment: 可显示图像最大高 */
+} HI_UNF_EDID_BASE_DISP_PARA_S;
+
+
+/**EDID Colorimety Info struct*//**CNcomment:EDID 色调信息结构体 */
+typedef struct hiUNF_EDID_COLORIMETRY_S
+{
+    HI_BOOL    bxvYCC601      ;          /**<The sink is support xcYCC601 or not flag*//**<CNcomment:是否支持xvYCC601颜色格式 */
+    HI_BOOL    bxvYCC709      ;          /**<The sink is support xvYCC709 or not flag*//**<CNcomment:是否支持xvYCC709颜色格式 */
+    HI_BOOL    bsYCC601       ;          /**<The sink is support sYCC601 or not flag*//**<CNcomment:是否支持sYCC601颜色格式 */
+    HI_BOOL    bAdobleYCC601  ;          /**<The sink is support AdobleYCC601 or not flag*//**<CNcomment:是否支持AdobleYCC601颜色格式 */
+    HI_BOOL    bAdobleRGB     ;          /**<The sink is support AdobleRGB or not flag*//**<CNcomment:是否支持AdobleRGB颜色格式 */
+    HI_BOOL    bBT2020cYCC    ;          /**<The sink is support BT2020cYCC or not flag*//**<CNcomment:是否支持BT2020cYCC颜色格式 */
+    HI_BOOL    bBT2020YCC     ;          /**<The sink is support BT2020YCC or not flag*//**<CNcomment:是否支持BT2020YCC颜色格式 */
+    HI_BOOL    bBT2020RGB     ;          /**<The sink is support BT2020RGB or not flag*//**<CNcomment:是否支持BT2020RGB颜色格式 */
+} HI_UNF_EDID_COLORIMETRY_S;
+
+/**EDID color space Info struct*//**CNcomment:EDID 色彩空间信息结构体 */
+typedef struct hiUNF_EDID_COLOR_SPACE_S
+{
+    HI_BOOL    bRGB444        ;          /**<The sink is support RGB444 or not flag*//**<CNcomment:< 是否支持RGB444显示 */
+    HI_BOOL    bYCbCr422      ;          /**<The sink is support YCbCr422 or not flag*//**<CNcomment:< 是否支持YCbCr422显示 */
+    HI_BOOL    bYCbCr444      ;          /**<The sink is support YCbCr444 or not flag*//**<CNcomment:< 是否支持YCbCr444显示 */
+    HI_BOOL    bYCbCr420      ;          /**<The sink is support YCbCr420 or not flag*//**<CNcomment:< 是否支持YCbCr420显示 */
+} HI_UNF_EDID_COLOR_SPACE_S;
+
+/**EDID cec address Info struct*//**CNcomment:EDID cec地址信息结构体 */
+typedef struct hiUNF_EDID_CEC_ADDRESS_S
+{
+    HI_BOOL    bPhyAddrValid   ;          /**<the flag of phyiscs address is valid or not*//**<CNcomment:CEC物理地址是否有效标志 */
+    HI_U8      u8PhyAddrA      ;          /**<phyiscs address A of CEC*//**<CNcomment:CEC物理地址A */
+    HI_U8      u8PhyAddrB      ;          /**<phyiscs address B of CEC*//**<CNcomment:CEC物理地址B */
+    HI_U8      u8PhyAddrC      ;          /**<phyiscs address C of CEC*//**<CNcomment:CEC物理地址C */
+    HI_U8      u8PhyAddrD      ;          /**<phyiscs address D of CEC*//**<CNcomment:CEC物理地址D */
+} HI_UNF_EDID_CEC_ADDRESS_S;
+
+/**EDID deep color Info struct*//**CNcomment:EDID 深色信息结构体 */
+typedef struct hiUNF_EDID_DEEP_COLOR_S
+{
+    HI_BOOL    bDeepColorY444   ;         /**<the Deep Color support YCBCR444-bits same with RGB-bits or not*//**<CNcomment:是否支持 YCBCR 4:4:4  Deep Color 与RGB的bit数一致 */
+    HI_BOOL    bDeepColor30Bit  ;         /**<the Deep Color support RGB 30 bit  or not *//**<CNcomment:是否支持RGB Deep Color 30bit 模式 */
+    HI_BOOL    bDeepColor36Bit  ;         /**<the Deep Color support RGB 36 bit  or not *//**<CNcomment:是否支持RGB Deep Color 36bit 模式 */
+    HI_BOOL    bDeepColor48Bit  ;         /**<the Deep Color support RGB 48 bit  or not *//**<CNcomment:是否支持RGB Deep Color 48bit 模式 */
+} HI_UNF_EDID_DEEP_COLOR_S;
+
+typedef struct hiUNF_EDID_DEEP_COLOR_Y420_S
+{
+    HI_BOOL    bY420DeepColor30Bit  ;     /**<the Deep Color support YCBCR420  30 bit  or not *//**<CNcomment:是否支持YCBCR420 Deep Color 30bit 模式 */
+    HI_BOOL    bY420DeepColor36Bit  ;     /**<the Deep Color support YCBCR420  36 bit  or not *//**<CNcomment:是否支持YCBCR420 Deep Color 36bit 模式 */
+    HI_BOOL    bY420DeepColor48Bit  ;     /**<the Deep Color support YCBCR420  48 bit  or not *//**<CNcomment:是否支持YCBCR420 Deep Color 48bit 模式 */
+} HI_UNF_EDID_DEEP_COLOR_Y420_S;
+
+typedef struct hiUNF_EDID_HDCP_S
+{
+    HI_BOOL     bHdcp14Support  ;         /**<the HDCP support HDCP1.4 or not *//**<CNcomment:是否支持HDCP1.4 */
+    HI_BOOL     bHdcp22Support  ;         /**<the HDCP support HDCP2.2 or not *//**<CNcomment:是否支持HDCP2.2 */
+} HI_UNF_EDID_HDCP_S;
+
+/**HDMI 3d enum type*/
+/**CNcomment: HDMI 3d 枚举类型 */
+typedef enum hiUNF_EDID_3D_TYPE_E
+{
+    HI_UNF_EDID_3D_FRAME_PACKETING                 = 0x00, /**<3d type:Frame Packing*//**<CNcomment:3d 模式:帧封装*/
+    HI_UNF_EDID_3D_FIELD_ALTERNATIVE               = 0x01, /**<3d type:Field alternative*//**<CNcomment:3d 模式:场交错*/
+    HI_UNF_EDID_3D_LINE_ALTERNATIVE                = 0x02, /**<3d type:Line alternative*//**<CNcomment:3d 模式:行交错*/
+    HI_UNF_EDID_3D_SIDE_BY_SIDE_FULL               = 0x03, /**<3d type:Side by side full*//**<CNcomment:3d 模式:并排式 左右全场*/
+    HI_UNF_EDID_3D_L_DEPTH                         = 0x04, /**<3d type:L+depth*//**<CNcomment:3d 模式:L+DEPTH*/
+    HI_UNF_EDID_3D_L_DEPTH_GRAPHICS_GRAPHICS_DEPTH = 0x05, /**<3d type:L+depth+Graphics+Graphics-depth*//**<CNcomment:3d 模式:L+depth+Graphics+Graphics-depth*/
+    HI_UNF_EDID_3D_TOP_AND_BOTTOM                  = 0x06, /**<3d type:Top and Bottom*//**<CNcomment:3d 模式:上下模式*/
+    HI_UNF_EDID_3D_SIDE_BY_SIDE_HALF               = 0x08, /**<3d type:Side by side half*//**<CNcomment:3d 模式:并排式 左右半边*/
+    HI_UNF_EDID_3D_BUTT,
+}HI_UNF_EDID_3D_TYPE_E;
+
+/**3d Info struct*//**CNcomment: 3d 信息结构体 */
+typedef struct hiUNF_EDID_3D_INFO_S
+{
+    HI_BOOL    bSupport3D  ;                         /**<flag of 3d*//**<CNcomment:是否支持3d*/
+    HI_BOOL    bSupport3DType[HI_UNF_EDID_3D_BUTT] ; /**<supported 3d type*//**<CNcomment:支持的3d类型*/
+} HI_UNF_EDID_3D_INFO_S;
+
+/**EDID detailed Timing Info struct*//**CNcomment: EDID 详细时序*/
+typedef struct hiUNF_EDID_TIMING_S
+{
+    HI_U32                        u32VFB;          /**<vertical front blank*//**<CNcomment:垂直前消隐*/
+    HI_U32                        u32VBB;          /**<vertical back blank*//**<CNcomment:垂直后消隐*/
+    HI_U32                        u32VACT;         /**<vertical active area*//**<CNcomment:垂直有效区*/
+    HI_U32                        u32HFB;          /**<horizonal front blank*//**<CNcomment:水平前消隐*/
+    HI_U32                        u32HBB;          /**<horizonal back blank*//**<CNcomment:水平后消隐*/
+    HI_U32                        u32HACT;         /**<horizonal active area*/ /**<CNcomment:水平有效区*/
+    HI_U32                        u32VPW;          /**<vertical sync pluse width*//**<CNcomment:垂直脉冲宽度*/
+    HI_U32                        u32HPW;          /**<horizonal sync pluse width*/ /**<CNcomment:水平脉冲宽度*/
+    HI_BOOL                       bIDV;            /**< flag of data valid signal is needed flip*//**<CNcomment:有效数据信号是否翻转*/
+    HI_BOOL                       bIHS;            /**<flag of horizonal sync pluse is needed flip*//**<CNcomment:水平同步脉冲信号是否翻转*/
+    HI_BOOL                       bIVS;            /**<flag of vertical sync pluse is needed flip*//**<CNcomment:垂直同步脉冲信号是否翻转*/
+    HI_U32                        u32ImageWidth;   /**<image width *//**<CNcomment:图像宽*/
+    HI_U32                        u32ImageHeight;  /**<image height *//**<CNcomment:图像高 */
+    HI_U32                        u32AspectRatioW; /**<aspect ratio width *//**<CNcomment:宽高比 */
+    HI_U32                        u32AspectRatioH; /**<aspect ratio height *//**<CNcomment:宽高比 */
+    HI_BOOL                       bInterlace;      /**<flag of interlace *//**<CNcomment:逐隔行检测标记 */
+    HI_S32                        u32PixelClk;     /**<pixelc clk for this timing *//**<CNcomment:当前制式对应的时钟 */
+} HI_UNF_EDID_TIMING_S;
+
+/**the max audio capability count*//**CNcomment:最大音频能力集个数 */
+#define HI_UNF_EDID_MAX_AUDIO_CAP_COUNT  16
+
+/**EDID Dolby capability in VSVDB version 0*//**CNcomment: EDID VSVDB版本0中Dolby能力描述*/
+typedef struct hiUNF_EDID_DOLBY_CAPS_VER_0_S
+{
+    HI_BOOL     bYUV422_12Bit;          /* support(HI_TRUE) or not support(HI_FALSE) a YUV422-12Bit dolby singal *//**<CNcomment:是否支持YUV422-12Bit的Dolby信号*/
+    HI_BOOL     b2160P60;               /* capable of processing a max timming 3840X2160p60(HI_TRUE) /3840X2160p30(HI_FALSE) *//**<CNcomment:最大能力是到4kp60还是4kp30 */
+    HI_BOOL     bGlobalDimming;         /**<support(HI_TRUE) or not support(HI_FALSE) global dimming. *//**<CNcomment:是否支持global dimming，支持(HI_TRUE)，不支持(HI_FALSE)*/
+    HI_U16      u16White_X;             /* white point chromaticity coordinate x   ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N), only support when u8VSVDBVersion = 0. */
+    HI_U16      u16White_Y;             /* white point  chromaticity coordinate y  ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N), only support when u8VSVDBVersion = 0.*/
+    HI_U8       u8DMmajorVersion;       /* the major version of display management implemented. only support when u8VSVDBVersion = 0.*/
+    HI_U8       u8DMminorVersion;       /* the minor version of display management implemented. only support when u8VSVDBVersion = 0.*/
+    HI_U16      u16TargetMinPQ;         /* Perceptual quantization(PQ)-encoded value of minimum display luminance */
+    HI_U16      u16TargetMaxPQ;         /* PQ-encoded value of maximum display luminance */
+    HI_U16      u16Red_X;               /**<red primary chromaticity coordinate x   ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Red_Y;               /**<red primary chromaticity coordinate y   ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Green_X;             /**<green primary chromaticity coordinate x ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Green_Y;             /**<green primary chromaticity coordinate y ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Blue_X;              /**<blue primary chromaticity coordinate x  ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Blue_Y;              /**<blue primary chromaticity coordinate y  ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+}HI_UNF_EDID_DOLBY_CAPS_VER_0_S;
+
+/**EDID Dolby capability in VSVDB version 1*//**CNcomment: EDID VSVDB版本1中Dolby能力描述*/
+typedef struct hiUNF_EDID_DOLBY_CAPS_VER_1_S
+{
+    HI_BOOL     bYUV422_12Bit;          /* support(HI_TRUE) or not support(HI_FALSE) a YUV422-12Bit dolby singal; For low-latency dolbyvision this flag is ingnored *//**<CNcomment:是否支持YUV422-12Bit的Dolby信号, 当Low-latency杜比下该标志忽略 */
+    HI_BOOL     b2160P60;               /* capable of processing a max timming 3840X2160p60(HI_TRUE) /3840X2160p30(HI_FALSE); For low-latency dolbyvision this bit maybe ingnored,relay on supported video format from the E-EDID *//**<CNcomment:最大能力是到4kp60还是4kp30, 当Low-latency杜比下该标志需参考制式能力 */
+    HI_BOOL     bGlobalDimming;         /**<support(HI_TRUE) or not support(HI_FALSE) global dimming. *//**<CNcomment:是否支持global dimming，支持(HI_TRUE)，不支持(HI_FALSE)*/
+    HI_BOOL     bColorimetry;           /* this bit is valid only u8VSVDBVersion = 1. 0: Dolby Vision HDMI sink's colorimetry is close to Rec.709, 1: EDR HDMI sink's colorimetry is close to P3, if Byte[9] to Byte[14] are present, ignores this bit. *//**<CNcomment:若为0，Dolby Vision Sink设备色域接近Rec.709，若为1，Dolby Vision Sink设备色域接近P3，但如果Byte[9]到Byte[14]有声明，则忽略此标志。*/
+    HI_U8       u8DMVersion;            /* 0:based on display management v2.x; 1:based on the video and blending pipeline v3.x; 2-7: reserved. only support when u8VSVDBVersion = 1. */
+    HI_U8       u8LowLatency;           /* 0:supports only standard DolbyVison; 1: Supports low latency with 12-bit YCbCr 4:2:2 interface using the HDMI native 12-bit YCbCr4:2:2 pixel encoding and standard Dolby Vision interface; 2-3:reserved */
+    HI_U16      u16TargetMinLuminance;  /* minimum display luminance = (100+50*CV)cd/m2, where CV is the value */
+    HI_U16      u16TargetMaxLuminance;  /* maximum display luminance = (CV/127)^2cd/m2, where CV is the value */
+    HI_U16      u16Red_X;               /**<red primary chromaticity coordinate x   ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Red_Y;               /**<red primary chromaticity coordinate y   ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Green_X;             /**<green primary chromaticity coordinate x ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Green_Y;             /**<green primary chromaticity coordinate y ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Blue_X;              /**<blue primary chromaticity coordinate x  ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Blue_Y;              /**<blue primary chromaticity coordinate y  ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+}HI_UNF_EDID_DOLBY_CAPS_VER_1_S;
+
+/**EDID Dolby capability in VSVDB version 2*//**CNcomment: EDID VSVDB版本2中Dolby能力描述*/
+typedef struct hiUNF_EDID_DOLBY_CAPS_VER_2_S
+{
+    HI_BOOL     bYUV422_12Bit;          /* support(HI_TRUE) or not support(HI_FALSE) a YUV422-12Bit dolby singal */
+    HI_BOOL     bBackLightContol;       /* supports Backlight Control */
+    HI_BOOL     bGlobalDimming;         /**<support(HI_TRUE) or not support(HI_FALSE) global dimming. *//**<CNcomment:是否支持global dimming，支持(HI_TRUE)，不支持(HI_FALSE)*/
+    HI_U8       u8DMVersion;            /* 0:based on display management v2.x; 1:based on the video and blending pipeline v3.x; 2-7: reserved. only support when u8VSVDBVersion = 1. */
+    HI_U8       u8BackLtMinLuma;        /* minimum luminance level 0:25cd/m2 1:50cd/m2 2:75cd/m2 3:100cd/m2 */
+    HI_U8       u8Interface;            /* 0:support only "low latency with YUV422" 1:support both "low latency with YUV422" and YUV444/RGB_10/12bit* 2:support both "standard DolbyVision" and "low latency with YUV422" 3:support "standard DolbyVision" "low latency YUV422 YUV444/RGB_10/12bit" */
+    HI_U8       u8YUV444RGB444_10b12b;  /* 0:not support 1:support YUV444/RGB444_10bit 2:support YUV444/RGB444_12bit 3:reserved */
+    HI_U16      u16TargetMinPQv2;       /* maximum display luminance, in the PQ-encoded value= u16TargetMinPQv2*20. A code value of 31 is approximately equivalent to 1cd/m2 */
+    HI_U16      u16TargetMaxPQv2;       /* minimum display luminance, in the PQ-encoded value= 2055+u16TargetMaxPQv2*65. */
+    HI_U16      u16Red_X;               /**<red primary chromaticity coordinate x   ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Red_Y;               /**<red primary chromaticity coordinate y   ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Green_X;             /**<green primary chromaticity coordinate x ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Green_Y;             /**<green primary chromaticity coordinate y ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Blue_X;              /**<blue primary chromaticity coordinate x  ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+    HI_U16      u16Blue_Y;              /**<blue primary chromaticity coordinate y  ,bit[11:0]valid.Real value =SUM OF bit[N]*2^-(12-N) */
+}HI_UNF_EDID_DOLBY_CAPS_VER_2_S;
+
+/**EDID union of Dolby capability.*//**CNcomment: EDID Dolby能力集联合体*/
+typedef union hiUNF_EDID_DOLBY_CAPS_U
+{
+    HI_UNF_EDID_DOLBY_CAPS_VER_0_S stVer0;
+    HI_UNF_EDID_DOLBY_CAPS_VER_1_S stVer1;
+    HI_UNF_EDID_DOLBY_CAPS_VER_2_S stVer2;
+}HI_UNF_EDID_DOLBY_CAPS_U;
+
+/**EDID Dolby capability.see <Dolby  Vision  HDMI Transmission Specification> *//**CNcomment: EDID Dolby能力集，参考Dolby  Vision  HDMI Transmission Specification*/
+typedef struct hiUNF_EDID_DOLBY_CAP_S
+{
+    HI_U8       u8VSVDBVersion;         /**<the version of VSVDB, value of 0-version0, 1-version1 2-version2, others means we not support at present. see <Dolby Vision HDMI Transmission Specification issue 2.9>*//**<CNcomment:VSVDB版本,0表示版本0,1表示版本1,2表示版本2，其他目前暂不支持*/
+    HI_UNF_EDID_DOLBY_CAPS_U unVersionCaps; /**<DolbyVision capability in Dolby VSVDB. stVer0(u8VSVDBVersion=0) and stVer1(u8VSVDBVersion=1) and stVer2(u8VSVDBVersion=2).*//**<CNcomment:Dolby各版本能力，依据Dolby VSVDB版本stVer0对应(u8VSVDBVersion=0),stVer1对应(u8VSVDBVersion=1),stVer2对应(u8VSVDBVersion=2),其他暂不支持*/
+}HI_UNF_EDID_DOLBY_CAP_S;
+
+/**EDID EOTF support. *//**CNcomment:EDID 支持的EOTF类型 */
+typedef struct hiUNF_EDID_EOTF_S
+{
+    HI_BOOL bEotfSdr;               /**<Traditional gamma - SDR Luminance Range. *//**<CNcomment:Sink设备是否支持SDR EOTF。*/
+    HI_BOOL bEotfHdr;               /**<Traditional gamma - HDR Luminance Range. *//**<CNcomment:Sink设备是否支持HDR EOTF。*/
+    HI_BOOL bEotfSmpteSt2084;       /**<SMPTE ST 2084 *//**<CNcomment:Sink设备是否支持SmpteSt2084 EOTF。*/
+    HI_BOOL bEotfHLG;               /**<Hybrid Log-Gamma(HLG) based on Recommendation ITU-R BT.2100-0 *//**<CNcomment:Sink设备是否支持Hybrid Log-Gamma(HLG) */
+    HI_BOOL bEotfFuture;            /**<Future EOTF *//**<CNcomment:Sink设备是否支持其他EOTF类型。*/
+}HI_UNF_EDID_EOTF_S;
+
+/**EDID Supported Static Metadata Descriptor *//**CNcomment:EDID 支持的Metadata类型 */
+typedef struct hiUNF_EDID_HDR_METADATA_TYPE_S
+{
+    HI_BOOL bDescriptorType1;       /**<Support Static Metadata Type 1 or not.*//**<CNcomment:Sink设备是否支持metadata类型1。*/
+}HI_UNF_EDID_HDR_METADATA_TYPE_S;
+
+/**EDID HDR capability,see <CEA-861.3-2015> *//**CNcomment:EDID HDR能力集，参考CEA-861.3-2015 */
+typedef struct hiUNF_EDID_HDR_CAP_S{
+
+    HI_UNF_EDID_EOTF_S                  stEotf;                 /**<EOTF support. *//**<CNcomment:Sink设备支持的EOTF类型。*/
+    HI_UNF_EDID_HDR_METADATA_TYPE_S     stMetadata;             /**<static metadata descriptor type(ID) support. *//**<CNcomment:Sink设备支持的metadata类型。*/
+    HI_U8                               u8MaxLuminance_CV;      /**<Desired Content Max Luminance Data. Real value(in 1cd/m^2) = 50.2^(CV/32) *//**<CNcomment:Sink设备支持最大亮度值。*/
+    HI_U8                               u8AverageLumin_CV;      /**<Desired Content Max Frame-average Luminance. Real value(in 1cd/m^2) = 50.2^(CV/32) *//**<CNcomment:Sink设备支持平均亮度值。*/
+    HI_U8                               u8MinLuminance_CV;      /**<Desired Content Min Luminance Data. Real value(in 1cd/m^2) = u8MaxLuminance_CV * (u8MinLuminance_CV/255)^2 / 100  *//**<CNcomment:Sink设备支持最小亮度值。*/
+}HI_UNF_EDID_HDR_CAP_S;
+
+/**EDID Latency capability,see <HDMI1.4b> Page154 *//**CNcomment:Latency能力，参考<HDMI1.4b> 154页 */
+typedef struct hiUNF_EDID_LATENCY_S{
+    HI_BOOL  bLatencyPresent;                  /**<Latency info is valid. *//**<CNcomment:Latency信息有效。*/
+    HI_U32   u32PVideoLatency;                 /**<video latency for progressive video formats.in milliseconds *//**<CNcomment:逐行扫描视频的视频latency。单位ms*/
+    HI_U32   u32PAudioLatency;                 /**<audio latency for progressive video formats.in milliseconds *//**<CNcomment:逐行扫描视频的音频latency。单位ms*/
+    HI_U32   u32IVideoLatency;                 /**<video latency for interlaced video formats.in milliseconds *//**<CNcomment:逐行扫描视频的视频latency。单位ms*/
+    HI_U32   u32IAudioLatency;                 /**<audio latency for interlaced video formats.in milliseconds *//**<CNcomment:隔行扫描视频的音频latency。单位ms*/
+}HI_UNF_EDID_LATENCY_S;
+
+
+/**HDMI sink capability of interface*/
+/**CNcomment: HDMI sink 接口能力集 */
+typedef struct hiUNF_EDID_BASE_INFO_S
+{
+    HI_BOOL                         bSupportHdmi;           /**<The Device suppot HDMI or not,the device is DVI when nonsupport HDMI*//**<CNcomment:设备是否支持HDMI，如果不支持，则为DVI设备.*/
+    HI_UNF_ENC_FMT_E                enNativeFormat;         /**<The sink native video format*//**<CNcomment:显示设备物理分辨率 */
+    HI_BOOL                         bSupportFormat[HI_UNF_ENC_FMT_BUTT]; /**<video capability,HI_TRUE:support the video display format;HI_FALSE:nonsupport the video display foramt*//**<CNcomment:视频能力集,HI_TRUE表示支持这种显示格式，HI_FALSE表示不支持 */
+    HI_UNF_EDID_3D_INFO_S           st3DInfo;               /**<3d Info*//**<CNcomment:3d 能力集 */
+    HI_UNF_EDID_DEEP_COLOR_S        stDeepColor;            /**<YCBCR/RGB deep color Info*//**<CNcomment:YCBCR/RGB deep color 能力集*/
+    HI_UNF_EDID_COLORIMETRY_S       stColorMetry;           /**<colorimetry Info*//**<CNcomment:色域能力集 */
+    HI_UNF_EDID_COLOR_SPACE_S       stColorSpace;           /**<color space Info*//**<CNcomment:颜色空间能力集 */
+    HI_BOOL                         bYccQrangeSelectable;   /**<flag of YCC Quantization Range selectable.when HI_TRUE,sink expect full/limited range is selectable;or sink expect default range. *//**<CNcomment:Sink要求RGB量化范围是否满/限制 范围可选。HI_TRUE表示sink要求范围可选，HI_FALSE表示sink要求默认范围。*/
+    HI_BOOL                         bRgbQrangeSelectable;   /**<flag of RGB Quantization Range selectable.when HI_TRUE,sink expect full/limited range is selectable;or sink expect default range. *//**<CNcomment:Sink要求YCC量化范围是否满/限制 范围可选。HI_TRUE表示sink要求范围可选，HI_FALSE表示sink要求默认范围。*/
+
+    HI_UNF_EDID_AUDIO_INFO_S        stAudioInfo[HI_UNF_EDID_MAX_AUDIO_CAP_COUNT];   /**<audio Info*//**<CNcomment:音频能力集 */
+    HI_U32                          u32AudioInfoNum;                                /**<num of audio Info*//**<CNcomment:音频 能力集个数 */
+    HI_BOOL                         bSupportAudioSpeaker[HI_UNF_EDID_AUDIO_SPEAKER_BUTT];/**<speaker Info*//**<CNcomment:speaker 能力集 */
+
+    HI_U8                           u8ExtBlockNum;          /**<edid extend block num Info*//**<CNcomment:edid扩展块个数 */
+
+    HI_U8                           u8Version;              /**<the version of manufacture*//**<CNcomment:设备版本号 */
+    HI_U8                           u8Revision;             /**<the revision of manufacture*//**<CNcomment:设备子版本号 */
+    HI_UNF_EDID_MANUFACTURE_INFO_S  stMfrsInfo;
+
+    HI_UNF_EDID_CEC_ADDRESS_S       stCECAddr;              /**<cec address Info*//**<CNcomment:cec地址信息 */
+    HI_BOOL                         bSupportDVIDual;        /**<the DVI support dual-link or not *//**<CNcomment:是否支持 DVI dual-link 操作 */
+    HI_BOOL                         bSupportsAI;            /**<support AI or not *//**<CNcomment:是否支持 Supports_AI 模式 */
+    HI_UNF_EDID_TIMING_S            stPerferTiming;         /**<first detailed timing Info*//**<CNcomment:VESA最佳详细制式信息 */
+    HI_U32                          u32MaxTMDSClock;        /**<Max TMDS clock in MHz*//**<CNcomment:支持的最大TMDS时钟(MHz) */
+    HI_BOOL                         bSupportY420Format[HI_UNF_ENC_FMT_BUTT];/**<video capability,HI_TRUE:support the video display format in YCBCR420;HI_FALSE:nonsupport the video display foramt  in YCBCR420*//**<CNcomment:视频能力集,HI_TRUE表示支持这种显示格式的YCBCR420模式，HI_FALSE表示不支持 */
+    HI_UNF_EDID_DEEP_COLOR_Y420_S   stY420DeepColor;        /**<YCBCR deep color Info*//**<CNcomment:YCBCR420 deep color 能力集 */
+
+    HI_BOOL                         bDolbySupport;          /**<Dolby support flag.When VSVDB is indicated,flag HI_TRUE;or,HI_FALSE.*//**<CNcomment:读到VSVDB，为HI_TRUE;否则为HI_FALSE.*/
+    HI_UNF_EDID_DOLBY_CAP_S         stDolby;                /**<Dolby capability*//**<CNcomment:Dolby能力集 */
+    HI_BOOL                         bHdrSupport;            /**<HDR support flag.When HDR Static Metadata Data Block is indicated,flag HI_TRUE;or,HI_FALSE.*//**<CNcomment:读到HDR 静态元数据块(HI_UNF_EDID_EOTF_S中列的四种之一为HI_TRUE)，为HI_TRUE;否则为HI_FALSE.*/
+    HI_UNF_EDID_HDR_CAP_S           stHdr;                  /**<HDR capability*//**<CNcomment:HDR能力集 */
+    HI_UNF_EDID_HDCP_S              stHDCPSupport;          /**<HDCP capability,HI_TRUE:support the HDCP version;HI_FALSE:nonsupport the HDCP version*//**<CNcomment:HDCP能力,HI_TRUE表示支持这种HDCP版本，HI_FALSE表示不支持 */
+    HI_UNF_EDID_BASE_DISP_PARA_S    stBaseDispPara;         /**<the parameters of display*//**<CNcomment: 显示屏参数 */
+    HI_UNF_EDID_LATENCY_S           stLatency;              /**<Latency information*//**<CNcomment: Latency 信息 */
+
+} HI_UNF_EDID_BASE_INFO_S;
+
+/**enum define about Video port*/
+/**CNcomment:定义视频接口*/
+typedef enum hiUNF_EDID_VIDEO_PORT_E
+{
+    HI_UNF_EDID_VIDEO_PORT_VGA   = 0x00,/**<VGA port *//**<CNcomment: VGA接口 */
+    HI_UNF_EDID_VIDEO_PORT_DVI,         /**<DVI port *//**<CNcomment: DVI接口 */
+    HI_UNF_EDID_VIDEO_PORT_HDMI,        /**<HDMI port *//**<CNcomment: HDMI 接口 */
+    HI_UNF_EDID_VIDEO_PORT_BUTT
+} HI_UNF_EDID_VIDEO_PORT_E;
+
+/**enum define about timing protocol type*/
+/**CNcomment:定义时序的协议类型*/
+typedef enum hiUNF_EDID_TIMING_TYPE_E
+{
+    HI_UNF_EDID_TIMING_TYPE_DMT= 0x00,/**< DMT  protocol Timing *//**<CNcomment: DMT协议时序 */
+    HI_UNF_EDID_TIMING_TYPE_861,/**< 861D  protocol Timing *//**<CNcomment: 861D协议时序 */
+    HI_UNF_EDID_TIMING_TYPE_CVT,/**< CVT  protocol Timing *//**<CNcomment: CVT协议时序 */
+    HI_UNF_EDID_TIMING_TYPE_CVT_RB,/**< CVT_RB  protocol Timing *//**<CNcomment: CVT_RB协议时序 */
+    HI_UNF_EDID_TIMING_TYPE_GTF,/**< GTF  protocol Timing *//**<CNcomment: GTF协议时序 */
+    HI_UNF_EDID_TIMING_TYPE_BUTT
+} HI_UNF_EDID_TIMING_TYPE_E;
+
+/**enum define about timing type*/
+/**CNcomment:定义时序的类型*/
+typedef enum hiUNF_EDID_TIMING_ATTR_E
+{
+    HI_UNF_EDID_TIMING_ATTR_NONE = 0x00,/**< None *//**<CNcomment: 无 */
+    HI_UNF_EDID_TIMING_ATTR_PREFERRED_TIMING,/**< None *//**<CNcomment: 最佳时序*/
+    HI_UNF_EDID_TIMING_ATTR_PREFERRED_VERTICAL_FREQ,/**< None *//**<CNcomment: 最佳刷新率*/
+    HI_UNF_EDID_TIMING_ATTR_BUTT
+} HI_UNF_EDID_TIMING_ATTR_E;
+
+/**Detailed Timing Definitions Sync Signal Definitions*/
+/**CNcomment:详细时序中定义同步类型*/
+typedef enum hiUNF_EDID_SYNC_TYPE_E
+{
+    /*Analog Sync Signal Definitions*/
+    HI_UNF_EDID_SYNC_ACS_WS_GREEN    = 0x00,     /**<Analog Composite Sync - Without Serrations - Sync On Green Signal only*//**<CNcomment: 模拟复合同步去垂直同步时期的水平锯齿，绿色通道叠加同步*/
+    HI_UNF_EDID_SYNC_ACS_WS_ALL,                 /**<Analog Composite Sync - Without Serrations - Sync On all three (RGB) video signals*//**<CNcomment: 模拟复合同步去垂直同步时期的水平锯齿，三个通道叠加同步*/
+    HI_UNF_EDID_SYNC_ACS_DS_GREEN,               /**<Analog Composite Sync - With Serrations (H-sync during V-sync); - Sync On Green Signal only*//**<CNcomment: 模拟复合同步保持垂直同步时期的水平锯齿，绿色通道叠加同步*/
+    HI_UNF_EDID_SYNC_ACS_DS_ALL,                 /**<Analog Composite Sync - With Serrations (H-sync during V-sync); - Sync On all three (RGB) video signals*//**<CNcomment: 模拟复合同步保持垂直同步时期的水平锯齿，三个通道叠加同步*/
+    HI_UNF_EDID_SYNC_BACS_WS_GREEN,              /**<Bipolar Analog Composite Sync - Without Serrations; - Sync On Green Signal only*//**<CNcomment: 模拟复合同步去垂直同步时期的水平锯齿，三个通道叠加同步*/
+    HI_UNF_EDID_SYNC_BACS_WS_ALL,                /**<Bipolar Analog Composite Sync - Without Serrations; - Sync On all three (RGB) video signals*//**<CNcomment: 模拟复合同步去垂直同步时期的水平锯齿，三个通道叠加同步*/
+    HI_UNF_EDID_SYNC_BACS_DS_GREEN,              /**<Bipolar Analog Composite Sync - With Serrations (H-sync during V-sync); - Sync On Green Signal only*//**<CNcomment:  极性模拟复合同步保持垂直同步时期的水平锯齿，绿色通道叠加同步*/
+    HI_UNF_EDID_SYNC_BACS_DS_ALL,                /**<Bipolar Analog Composite Sync - With Serrations (H-sync during V-sync); - Sync On all three (RGB) video signals*//**<CNcomment:  极性模拟复合同步保持垂直同步时期的水平锯齿，绿色通道叠加同步*/
+    /*Digital Sync Signal Definitions*/
+    HI_UNF_EDID_SYNC_DCS_WS,                     /**<Digital Composite Sync - Without Serrations*//**<CNcomment: 数字复合同步，去垂直同步期间行同步锯齿信号*/
+    HI_UNF_EDID_SYNC_DCS_DS,                     /**<Digital Composite Sync - With Serrations (H-sync during V-sync)*//**<CNcomment: 数字复合同步，保持垂直同步期间行同步锯齿信号*/
+    HI_UNF_EDID_SYNC_DSS_VN_HN,                  /**<Digital Separate Sync Vsync(-) Hsync(-)*//**<CNcomment: 数字复合同步，水平和垂直同步极性(-)(-)*/
+    HI_UNF_EDID_SYNC_DSS_VN_HP,                  /**<Digital Separate Sync Vsync(-) Hsync(+)*//**<CNcomment: 数字复合同步，水平和垂直同步极性(-)(+)*/
+    HI_UNF_EDID_SYNC_DSS_VP_HN,                  /**<Digital Separate Sync Vsync(+) Hsync(-)*//**<CNcomment: 数字复合同步，水平和垂直同步极性(+)(-)*/
+    HI_UNF_EDID_SYNC_DSS_VP_HP,                  /**<Digital Separate Sync Vsync(+) Hsync(+)*//**<CNcomment: 数字复合同步，水平和垂直同步极性(+)(+)*/
+    HI_UNF_EDID_SYNC_BUTT
+} HI_UNF_EDID_SYNC_TYPE_E;
+
+
+/**Simple Timing Definitions*/
+/**CNcomment:定义简要时序*/
+typedef struct hiUNF_EDID_SIMPLE_TIMING_S
+{
+    HI_U32              u32Vact;    /**<  Active Line *//**<CNcomment: 有效行*/
+    HI_U32              u32Hact;/**< Active Pixels *//**<CNcomment: 有效像素*/
+    HI_U32              u32VerFreq;/**<Ver Frequency *//**<CNcomment: 刷新率 */
+    HI_UNF_EDID_TIMING_TYPE_E          enTimingType;/**< Timing protocol type *//**<CNcomment: 定义时序的协议类型*/
+    HI_UNF_EDID_TIMING_ATTR_E          enTimingAttr;/**<timing type *//**<CNcomment: :定义时序的类型*/
+} HI_UNF_EDID_SIMPLE_TIMING_S;
+
+/**Detailed Timing Definitions*/
+/**CNcomment:定义详细时序*/
+typedef struct hiUNF_EDID_DETAIL_TIMING_S
+{
+    HI_UNF_EDID_TIMING_S                stTiming; /**<  Detailed Timing *//**<CNcomment: 详细时序*/
+    HI_UNF_EDID_SYNC_TYPE_E             enSyncType;/**Detailed Timing Definitions Sync Signal Definitions*//**CNcomment:详细时序中定义同步类型*/
+    HI_UNF_EDID_TIMING_ATTR_E           enTimingAttr;/**<timing type *//**<CNcomment: :定义时序的类型*/
+} HI_UNF_EDID_DETAIL_TIMING_S;
+
+/**EDID information*/
+/**CNcomment:EDID解析信息*/
+typedef struct hiUNF_EDID_INFO_S
+{
+    HI_UNF_EDID_BASE_INFO_S         stEDIDBaseInfo;/**< EDID base information *//**<CNcomment: EDID基本信息 */
+    HI_UNF_EDID_VIDEO_PORT_E        enVideoPort;                  /**<video port  *//**<CNcomment: 视频接口类型 */
+    HI_UNF_EDID_SIMPLE_TIMING_S*    pstSimpleTiming;    /**<Simple timing   *//**<CNcomment: 简要时序*/
+    HI_U32                          u32SimpleTimingNum;/**<Simple timing number *//**<CNcomment: 简要时序个数*/
+    HI_UNF_EDID_DETAIL_TIMING_S*    pstDetailTiming;    /**<Simple timing *//**<CNcomment: 详细时序个数*/
+    HI_U32                          u32DetailTimingNum;/**<Simple timing number *//**<CNcomment: 详细时序个数*/
+} HI_UNF_EDID_INFO_S;
+
+
+
+/** @}*/  /** <!-- ==== Structure Definition End ====*/
+
+
+
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      EDID*/
+/** @{*/  /** <!-- [EDID] */
+
+
+/**
+\brief parse the edid information. CNcomment:解析EDID数据 CNend
+\attention \n
+\param[in]  u32EdidLength EDID data length . CNcomment:EDID数据 的结构 长度 CNend
+\param[in]  *pu8Edid  EDID data point . CNcomment:EDID数据 的指针CNend
+\param[in]  *pstEdidInfo  EDID parse information . CNcomment:EDID解析信息指针CNend
+
+\retval HI_SUCCESS   success.   CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_EDID_EdidParse(HI_U8* pu8Edid, HI_U32 u32EdidLength, HI_UNF_EDID_INFO_S* pstEdidInfo);
+
+/**
+\brief release the edid information. CNcomment:释放EDID信息 CNend
+\attention \n
+\param[in]  *pstEdidInfo  EDID parse information . CNcomment:EDID解析信息指针CNend
+\retval HI_SUCCESS   success.   CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_VOID HI_UNF_EDID_EdidRelease(HI_UNF_EDID_INFO_S * pstEdidInfo);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_EDID_H__ */
+
diff -uNr a/include/hi_unf_frontend.h b/include/hi_unf_frontend.h
--- a/include/hi_unf_frontend.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_frontend.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,2547 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+ ******************************************************************************
+File Name       : hi_unf_frontend.h
+Version         : Initial draft
+Author          : HiSilicon multimedia software group
+Created Date    : 2008-06-05
+Description     : Application programming interfaces (APIs) of the external chip software (ECS)
+Function List   :
+Change History  :
+ ******************************************************************************/
+#ifndef __HI_UNF_FRONTEND_H__
+#define __HI_UNF_FRONTEND_H__
+
+#include "hi_common.h"
+
+#include "hi_unf_i2c.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+#define HI_I2C_MAX_NUM_USER (15)    /** Maximum I2C channel ID*/ /** CNcomment:最大I2C通道号*/
+
+#define HI_UNF_DISEQC_MSG_MAX_LENGTH    (6)     /** DiSEqC message length*/  /** CNcomment:DiSEqC消息长度*/
+#define HI_UNF_DISEQC_MAX_REPEAT_TIMES  (4)     /** DiSEqC message max repeat times*/ /** CNcomment:DiSEqC消息最大重复发送次数*/
+#define MAX_TS_LINE 11                      /** The NO of ts lines that can be configured*/ /** CNcomment:可配置的ts信号线数量*/
+#define TER_MAX_TP              (20)
+
+#define DISEQC_MAX_MOTOR_PISITION (255) /** DiSEqC motor max stored position*/ /** CNcomment:DiSEqC马达最大存储星位个数*/
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      FRONTEND */
+/** @{ */  /** <!-- [FRONTEND] */
+
+/** Sample data, complex format*/
+/** CNcomment: 采集数据, 复格式*/
+typedef struct  hiUNF_TUNER_SAMPLE_DATA_S
+{
+    HI_S32 s32DataIP;   /*sample data, i component*/    /**<CNcomment:采集数据的I分量*/
+    HI_S32 s32DataQP;   /*sample data, q component*/    /**<CNcomment:采集数据的Q分量*/
+} HI_UNF_TUNER_SAMPLE_DATA_S;
+
+/** Sample data length*/
+/** CNcomment: 采数长度*/
+typedef enum hiUNF_TUNER_SAMPLE_DATALEN_E
+{
+    HI_UNF_TUNER_SAMPLE_DATALEN_32,         /*sample 32 pts*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_64,         /*sample 64 pts*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_128,        /*sample 128 pts*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_256,        /*sample 256 pts*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_512,        /*sample 512 pts*/      /**<CNcomment:采集512点*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_1024,       /*sample 1024 pts*/     /**<CNcomment:采集1024点*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_2048,       /*sample 2048 pts*/     /**<CNcomment:采集2048点*/
+    HI_UNF_TUNER_SAMPLE_DATALEN_BUTT        /**<Invalid value*/     /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_SAMPLE_DATALEN_E;
+
+/** Modulation mode*/
+/** CNcomment: 调制方式*/
+typedef enum hiUNF_QAM_TYPE_E
+{
+    HI_UNF_MOD_TYPE_DEFAULT,          /**<Default QAM mode. The default QAM mode is HI_UNF_MOD_TYPE_QAM_64 at present.*/                /**<CNcomment:默认的QAM类型, 当前系统默认为HI_UNF_MOD_TYPE_QAM_64 */
+    HI_UNF_MOD_TYPE_QAM_16 = 0x100,   /**<Enumeration corresponding to the 16QAM mode*/                                                 /**<CNcomment:16QAM对应的枚举值*/
+    HI_UNF_MOD_TYPE_QAM_32,           /**<Enumeration corresponding to the 32QAM mode*/                                                 /**<CNcomment:32QAM对应的枚举值*/
+    HI_UNF_MOD_TYPE_QAM_64,           /**<Enumeration corresponding to the 64QAM mode*/                                                 /**<CNcomment:64QAM对应的枚举值*/
+    HI_UNF_MOD_TYPE_QAM_128,          /**<Enumeration corresponding to the 128QAM mode*/                                                /**<CNcomment:128QAM对应的枚举值*/
+    HI_UNF_MOD_TYPE_QAM_256,          /**<Enumeration corresponding to the 256QAM mode*/                                                /**<CNcomment:256QAM对应的枚举值*/
+    HI_UNF_MOD_TYPE_QAM_512,          /**<Enumeration corresponding to the 512QAM mode*/                                                /**<CNcomment:512QAM对应的枚举值*/
+
+    HI_UNF_MOD_TYPE_BPSK = 0x200,     /**<Enumeration corresponding to the binary phase shift keying (BPSK) mode. */                    /**<CNcomment:BPSK对应的枚举值*/
+    HI_UNF_MOD_TYPE_QPSK = 0x300,     /**<Enumeration corresponding to the quaternary phase shift keying (QPSK) mode. */                /**<CNcomment:QPSK对应的枚举值*/
+    HI_UNF_MOD_TYPE_DQPSK,
+    HI_UNF_MOD_TYPE_8PSK,             /**<Enumeration corresponding to the 8 phase shift keying (8PSK) mode*/                           /**<CNcomment:8PSK对应的枚举值*/
+    HI_UNF_MOD_TYPE_16APSK,           /**<Enumeration corresponding to the 16-Ary Amplitude and Phase Shift Keying (16APSK) mode*/      /**<CNcomment:16APSK对应的枚举值*/
+    HI_UNF_MOD_TYPE_32APSK,           /**<Enumeration corresponding to the 32-Ary Amplitude and Phase Shift Keying (32APSK) mode*/      /**<CNcomment:32APSK对应的枚举值*/
+    HI_UNF_MOD_TYPE_64APSK,           /**<Enumeration corresponding to the 64-Ary Amplitude and Phase Shift Keying (64APSK) mode*/      /**<CNcomment:64APSK对应的枚举值*/
+    HI_UNF_MOD_TYPE_128APSK,          /**<Enumeration corresponding to the 128-Ary Amplitude and Phase Shift Keying (128APSK) mode*/    /**<CNcomment:128APSK对应的枚举值*/
+    HI_UNF_MOD_TYPE_256APSK,          /**<Enumeration corresponding to the 256-Ary Amplitude and Phase Shift Keying (256APSK) mode*/    /**<CNcomment:256APSK对应的枚举值*/
+    HI_UNF_MOD_TYPE_8VSB,             /**<Enumeration corresponding to (8VSB) mode*/                                                    /**<CNcomment:8VSB对应的枚举值*/
+    HI_UNF_MOD_TYPE_16VSB,            /**<Enumeration corresponding to (16VSB) mode*/                                                   /**<CNcomment:16VSB对应的枚举值*/
+    HI_UNF_MOD_TYPE_VLSNR_SET1,         /**<Enumeration corresponding to (VLSNR_SET1) mode,only used in DVB-S2X*/                       /**<CNcomment:VLSNR_SET1对应的枚举值，DVB-S2X新增*/
+    HI_UNF_MOD_TYPE_VLSNR_SET2,         /**<Enumeration corresponding to (VLSNR_SET2) mode,only used in DVB-S2X*/                       /**<CNcomment:VLSNR_SET2对应的枚举值，DVB-S2X新增*/
+    HI_UNF_MOD_TYPE_8APSK,              /**<Enumeration corresponding to (8APSK) mode,only used in DVB-S2x*/                            /**<CNcomment:8APSK对应的枚举值，DVB-S2X新增*/
+
+    /**<Enumeration corresponding to the auto mode. For DVB-S/S2, if detect modulation type fail, it will return auto*/
+    /**<CNcomment:卫星信号调制方式自动检测，如果检测失败返回AUTO*/
+    HI_UNF_MOD_TYPE_AUTO,
+
+    HI_UNF_MOD_TYPE_BUTT              /**<Invalid Modulation mode*/       /**<CNcomment:非法的调制类型枚举值*/
+} HI_UNF_MODULATION_TYPE_E;
+
+/** Frequency locking status of the tuner*/
+/** CNcomment:TUNER锁频状态*/
+typedef enum  hiUNF_TUNER_LOCK_STATUS_E
+{
+    HI_UNF_TUNER_SIGNAL_DROPPED = 0,       /**<The signal is not locked.*/  /**<CNcomment:信号未锁定*/
+    HI_UNF_TUNER_SIGNAL_LOCKED,            /**<The signal is locked.*/      /**<CNcomment:信号已锁定*/
+    HI_UNF_TUNER_SIGNAL_BUTT               /**<Invalid value*/              /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_LOCK_STATUS_E;
+
+/** Output mode of the tuner*/
+/** CNcomment:TUNER输出模式*/
+typedef enum hiUNF_TUNER_OUTPUT_MODE_E
+{
+    HI_UNF_TUNER_OUTPUT_MODE_DEFAULT               = 0,   /**<Default mode*/                       /**<CNcomment:默认模式*/
+    HI_UNF_TUNER_OUTPUT_MODE_PARALLEL_MODE_A       = 1,   /**<Parallel mode A*/                    /**<CNcomment:并行模式A*/
+    HI_UNF_TUNER_OUTPUT_MODE_PARALLEL_MODE_B       = 2,   /**<Parallel mode B*/                    /**<CNcomment:并行模式B*/
+    HI_UNF_TUNER_OUTPUT_MODE_SERIAL                = 3,   /**<Serial mode 74.25M*/                 /**<CNcomment:串行模74.25M*/
+    HI_UNF_TUNER_OUTPUT_MODE_SERIAL_50             = 4,   /**<Serial mode 50M*/                    /**<CNcomment:串行模50M*/
+    HI_UNF_TUNER_OUTPUT_MODE_SERIAL_2BIT           = 5,   /**<Serial mode witch 2 bit data line*/  /**<CNcomment:2bit串行*/
+    HI_UNF_TUNER_OUTPUT_MODE_FULLBAND_PARALLEL     = 6,   /**<FULLBAND Parallel mode */            /**<CNcomment:FULLBAND 并行模式*/
+    HI_UNF_TUNER_OUTPUT_MODE_FULLBAND_SERIAL_3WIRE = 7,   /**<FULLBAND SERIAL three wire mode */   /**<CNcomment:FULLBAND 串行三线模式*/
+    HI_UNF_TUNER_OUTPUT_MODE_FULLBAND_SERIAL_4WIRE = 8,   /**<FULLBAND SERIAL four wire mode */    /**<CNcomment:FULLBAND 串行四线模式*/
+    HI_UNF_TUNER_OUTPUT_MODE_BUTT                         /**<Invalid value*/                      /**<CNcomment:非法值*/
+} HI_UNF_TUNER_OUPUT_MODE_E;
+
+/** Output order*/
+/** CNcomment:TUNER输出线序 */
+typedef enum hiUNF_TUNER_OUTPUT_TS_E
+{
+    HI_UNF_TUNER_OUTPUT_TSDAT0,        /**<data0*/                       /**<CNcomment:数据线0bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT1,        /**<data1*/                       /**<CNcomment:数据线1bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT2,        /**<data2*/                       /**<CNcomment:数据线2bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT3,        /**<data3*/                       /**<CNcomment:数据线3bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT4,        /**<data4*/                       /**<CNcomment:数据线4bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT5,        /**<data5*/                       /**<CNcomment:数据线5bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT6,        /**<data6*/                       /**<CNcomment:数据线6bit*/
+    HI_UNF_TUNER_OUTPUT_TSDAT7,        /**<data7*/                       /**<CNcomment:数据线7bit*/
+    HI_UNF_TUNER_OUTPUT_TSSYNC,        /**<sync*/                        /**<CNcomment:sync信号线*/
+    HI_UNF_TUNER_OUTPUT_TSVLD,         /**<valid*/                       /**<CNcomment:valid信号线*/
+    HI_UNF_TUNER_OUTPUT_TSERR,         /**<err*/                         /**<CNcomment:err信号线*/
+    HI_UNF_TUNER_OUTPUT_BUTT           /**<Invalid value*/               /**<CNcomment:非法值*/
+} HI_UNF_TUNER_OUTPUT_TS_E;
+
+/** ts output port order*/
+/** CNcomment:ts接口输出线序 */
+typedef struct hiUNF_TUNER_TSOUT_SET_S
+{
+    HI_UNF_TUNER_OUTPUT_TS_E enTSOutput[MAX_TS_LINE];   /**<ts output port order*/    /**<CNcomment:ts接口输出线序*/
+} HI_UNF_TUNER_TSOUT_SET_S;
+
+/** Signal type of the tuner*/
+/** CNcomment:TUNER信号类型*/
+typedef enum    hiTUNER_SIG_TYPE_E
+{
+    HI_UNF_TUNER_SIG_TYPE_CAB       = 1,        /**<Cable signal*/          /**<CNcomment:ITU-T J.83 ANNEX A/C(DVB_C)信号信号*/
+    HI_UNF_TUNER_SIG_TYPE_SAT       = 2,        /**<Satellite signal*/      /**<CNcomment:卫星信号*/
+    HI_UNF_TUNER_SIG_TYPE_DVB_T     = 4,        /**<Terrestrial signal*/    /**<CNcomment:地面信号*/
+    HI_UNF_TUNER_SIG_TYPE_DVB_T2    = 8,        /**<Terrestrial signal*/    /**<CNcomment:地面信号*/
+    HI_UNF_TUNER_SIG_TYPE_ISDB_T    = 16,       /**<Terrestrial signal*/    /**<CNcomment:地面信号*/
+    HI_UNF_TUNER_SIG_TYPE_ATSC_T    = 32,       /**<Terrestrial signal*/    /**<CNcomment:地面信号*/
+    HI_UNF_TUNER_SIG_TYPE_DTMB      = 64,       /**<Terrestrial signal*/    /**<CNcomment:地面信号*/
+    HI_UNF_TUNER_SIG_TYPE_J83B      = 128,      /**<Cable signal*/          /**<CNcomment:ITU-T J.83 ANNEX B(US Cable)信号*/
+    HI_UNF_TUNER_SIG_TYPE_ABSS      = 256,      /**ABS-S signal */          /**<CNcomment: 直播星卫星信号*/
+    HI_UNF_TUNER_SIG_TYPE_BUTT                  /**<Invalid value*/         /**<CNcomment:非法值*/
+} HI_UNF_TUNER_SIG_TYPE_E;
+
+/** type of TUNER device*/
+/** CNcomment:TUNER设备类型*/
+typedef enum    hiUNF_TUNER_DEV_TYPE_E
+{
+    HI_UNF_TUNER_DEV_TYPE_XG_3BL        = 0,    /**<XG_3BL,                 Not supported*/    /**<CNcomment:不支持*/
+    HI_UNF_TUNER_DEV_TYPE_CD1616        = 1,    /**<CD1616,                 Not supported*/    /**<CNcomment:不支持*/
+    HI_UNF_TUNER_DEV_TYPE_ALPS_TDAE     = 2,    /**<ALPS_TDAE,              Not supported*/    /**<CNcomment:不支持*/
+    HI_UNF_TUNER_DEV_TYPE_TDCC          = 3,    /**<TDCC,                   Not supported*/    /**<CNcomment:不支持*/
+    HI_UNF_TUNER_DEV_TYPE_TDA18250      = 4,    /**<TDA18250*/                                 /**<CNcomment:支持TDA18250射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_CD1616_DOUBLE = 5,    /**<CD1616 with double agc, Not supported*/    /**<CNcomment:不支持*/
+    HI_UNF_TUNER_DEV_TYPE_MT2081        = 6,    /**<MT2081,                 Not supported*/    /**<CNcomment:不支持*/
+    HI_UNF_TUNER_DEV_TYPE_TMX7070X      = 7,    /**<THOMSON7070X,           Not supported*/    /**<CNcomment:不支持*/
+    HI_UNF_TUNER_DEV_TYPE_R820C         = 8,    /**<R820C*/                                    /**<CNcomment:支持R820C射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_MXL203        = 9,    /**<MXL203 */                                  /**<CNcomment:支持MXL203射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_AV2011        = 10,   /**<AV2011*/                                   /**<CNcomment:支持AV2011射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_SHARP7903     = 11,   /**<SHARP7903,              Not supported*/    /**<CNcomment:不支持*/
+    HI_UNF_TUNER_DEV_TYPE_MXL101        = 12,   /**<MXL101,                 Not supported*/    /**<CNcomment:不支持*/
+    HI_UNF_TUNER_DEV_TYPE_MXL603        = 13,   /**<MXL603*/                                   /**<CNcomment:支持MXL603射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_IT9170        = 14,   /**<IT9170,                 Not supported*/    /**<CNcomment:不支持*/
+    HI_UNF_TUNER_DEV_TYPE_IT9133        = 15,   /**<IT9133,                 Not supported*/    /**<CNcomment:不支持*/
+    HI_UNF_TUNER_DEV_TYPE_TDA6651       = 16,   /**<TDA6651,                Not supported*/    /**<CNcomment:不支持*/
+    HI_UNF_TUNER_DEV_TYPE_TDA18250B     = 17,   /**<TDA18250B*/                                /**<CNcomment:支持TDA18250B射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_M88TS2022     = 18,   /**<M88TS2022,              Not supported*/    /**<CNcomment:不支持*/
+    HI_UNF_TUNER_DEV_TYPE_RDA5815       = 19,   /**<RDA5815*/                                  /**<CNcomment:支持RDA5815射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_MXL254        = 20,   /**<MXL254*/                                   /**<CNcomment:支持MXL254射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_CXD2861       = 21,   /**<CXD2861,                Not supported*/    /**<CNcomment:不支持*/
+    HI_UNF_TUNER_DEV_TYPE_SI2147        = 22,   /**<Si2147*/                                   /**<CNcomment:支持Si2147射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_RAFAEL836     = 23,   /**<Rafael836*/                                /**<CNcomment:支持Rafael836射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_MXL608        = 24,   /**<MXL608*/                                   /**<CNcomment:支持MXL608射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_MXL214        = 25,   /**<MXL214*/                                   /**<CNcomment:支持MXL214射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_TDA18280      = 26,   /**<TDA18280*/                                 /**<CNcomment:支持TDA18280射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_TDA182I5A     = 27,   /**<TDA182I5A*/                                /**<CNcomment:支持TDA182I5A芯片*/
+    HI_UNF_TUNER_DEV_TYPE_SI2144        = 28,   /**<Si2144*/                                   /**<CNcomment:支持Si2144芯片*/
+    HI_UNF_TUNER_DEV_TYPE_AV2018        = 29,   /**<AV2018*/                                   /**<CNcomment:支持AV2018芯片*/
+    HI_UNF_TUNER_DEV_TYPE_MXL251        = 30,   /**<MXL251*/                                   /**<CNcomment:支持MXL251芯片*/
+    HI_UNF_TUNER_DEV_TYPE_M88TC3800     = 31,   /**<M88TC3800,              Not supported*/    /**<CNcomment:不支持*/
+    HI_UNF_TUNER_DEV_TYPE_MXL601        = 32,   /**< MXL601 */                                 /**<CNcomment:支持MXL601射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_MXL683        = 33,   /**<MXL683*/                                   /**<CNcomment:支持MXL683射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_AV2026        = 34,   /**<AV2026*/                                   /**<CNcomment:支持AV2026射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_R850          = 35,   /**<R850*/                                     /**<CNcomment:支持R850射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_R858          = 36,   /**<R858*/                                     /**<CNcomment:支持R858射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_MXL541        = 37,   /**<MXL541*/                                   /**<CNcomment:支持MXL541射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_MXL581        = 38,   /**<MXL581*/                                   /**<CNcomment:支持MXL581射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_MXL582        = 39,   /**<MXL582*/                                   /**<CNcomment:支持MXL582射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_MXL661        = 40,   /**<MXL661*/                                   /**<CNcomment:支持MXL661射频芯片*/
+    HI_UNF_TUNER_DEV_TYPE_BUTT                  /**<Invalid value*/                            /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_DEV_TYPE_E ;
+
+/** Type of the demod device*/
+/** CNcomment:demod设备类型*/
+typedef enum    hiUNF_DEMOD_DEV_TYPE_E
+{
+    HI_UNF_DEMOD_DEV_TYPE_NONE,                 /**<Not supported*/                         /**<CNcomment:不支持*/
+    HI_UNF_DEMOD_DEV_TYPE_3130I       = 0x100,  /**<Internal QAM, same as HI_UNF_DEMOD_DEV_TYPE_INTERNAL0*/
+                                                /**<CNcomment:内部QAM,与HI_UNF_DEMOD_DEV_TYPE_INTERNAL0相同*/
+    HI_UNF_DEMOD_DEV_TYPE_3130E       = 0x101,  /**<External Hi3130*/                       /**<CNcomment:外部QAM hi3130芯片*/
+    HI_UNF_DEMOD_DEV_TYPE_J83B        = 0x102,  /**<suppoort j83b*/                         /**<CNcomment:支持j83b*/
+    HI_UNF_DEMOD_DEV_TYPE_AVL6211     = 0x103,  /**<Avalink 6211*/                          /**<CNcomment:支持Avalink 6211*/
+    HI_UNF_DEMOD_DEV_TYPE_MXL101      = 0x104,  /**<Maxlinear mxl101,    Not supported*/    /**<CNcomment:不支持*/
+    HI_UNF_DEMOD_DEV_TYPE_MN88472     = 0x105,  /**<PANASONIC mn88472*/                     /**<CNcomment:支持PANASONIC mn88472*/
+    HI_UNF_DEMOD_DEV_TYPE_IT9170      = 0x106,  /**<ITE it9170,          Not supported*/    /**<CNcomment:不支持*/
+    HI_UNF_DEMOD_DEV_TYPE_IT9133      = 0x107,  /**<ITE it9133,          Not supported*/    /**<CNcomment:不支持*/
+    HI_UNF_DEMOD_DEV_TYPE_3136        = 0x108,  /**<External Hi3136*/                       /**<CNcomment:外部hi3136芯片*/
+    HI_UNF_DEMOD_DEV_TYPE_MXL254      = 0x10A,  /**<External mxl254*/                       /**<CNcomment:外部MXL254芯片*/
+    HI_UNF_DEMOD_DEV_TYPE_CXD2837     = 0x10B,  /**Sony cxd2837,         Not supported*/    /**<CNcomment:不支持*/
+    HI_UNF_DEMOD_DEV_TYPE_3137        = 0x10C,  /**External Hi3137*/                        /**<CNcomment:支持外部hi3137芯片*/
+    HI_UNF_DEMOD_DEV_TYPE_MXL214      = 0x10D,  /**<External mxl214*/                       /**<CNcomment:外部MXL214芯片*/
+    HI_UNF_DEMOD_DEV_TYPE_TDA18280    = 0x10E,  /**<External tda18280*/                     /**<CNcomment:外部tda18280芯片*/
+    HI_UNF_DEMOD_DEV_TYPE_MXL251      = 0x111,  /**<External mxl251*/                       /**<CNcomment:外部MXL251芯片*/
+    HI_UNF_DEMOD_DEV_TYPE_ATBM888X    = 0x113,  /**External ATBM888X*/                      /**<CNcomment:支持外部ATBM888X芯片*/
+    HI_UNF_DEMOD_DEV_TYPE_MN88473     = 0x114,  /**< Panasonic 88473 */                     /**<CNcomment:支持Panasonic 88473 */
+    HI_UNF_DEMOD_DEV_TYPE_MXL683      = 0x115,  /**<External mxl683*/                       /**<CNcomment:外部mxl683芯片*/
+    HI_UNF_DEMOD_DEV_TYPE_TP5001      = 0x116,  /**External TP5001*/                        /**<CNcomment:支持外部TP5001芯片*/
+    HI_UNF_DEMOD_DEV_TYPE_HD2501      = 0x117,  /**External HD2501*/                        /**<CNcomment:支持外部HD2501芯片*/
+    HI_UNF_DEMOD_DEV_TYPE_AVL6381     = 0x118,  /**External AVL6381*/                       /**<CNcomment:支持外部AVL6381芯片*/
+    HI_UNF_DEMOD_DEV_TYPE_MXL541      = 0x119,  /**External MXL541*/                        /**<CNcomment:支持外部MXL541芯片*/
+    HI_UNF_DEMOD_DEV_TYPE_MXL581      = 0x11A,  /**External MXL581*/                        /**<CNcomment:支持外部MXL581芯片*/
+    HI_UNF_DEMOD_DEV_TYPE_MXL582      = 0x11B,  /**External MXL582*/                        /**<CNcomment:支持外部MXL582芯片*/
+    HI_UNF_DEMOD_DEV_TYPE_INTERNAL0   = 0x11C,  /**Internal Demod*/                         /**<CNcomment:支持内部解调芯片*/
+    HI_UNF_DEMOD_DEV_TYPE_BUTT                  /**<Invalid value*/                         /**<CNcomment:非法边界值*/
+} HI_UNF_DEMOD_DEV_TYPE_E;
+
+/** Defines the cable transmission signal.*/
+/** CNcomment:定义CABLE传输信号*/
+typedef struct  hiUNF_CAB_CONNECT_PARA_S
+{
+    HI_U32                      u32Freq;            /**<Frequency, in kHz*/         /**<CNcomment:频率，单位：kHz*/
+    HI_U32                      u32SymbolRate;      /**<Symbol rate, in bit/s*/     /**<CNcomment:符号率，单位bps */
+    HI_UNF_MODULATION_TYPE_E    enModType;          /**<QAM mode*/                  /**<CNcomment:QAM调制方式*/
+    HI_BOOL                     bReverse;           /**<Spectrum reverse mode*/     /**<CNcomment:频谱倒置处理方式*/
+    HI_U32                      u32BandWidth;       /**<bandwidth in KHz*/          /**<CNcomment:带宽，单位kHz*/
+} HI_UNF_CAB_CONNECT_PARA_S;
+
+/** Guard interval of OFDM*/
+/** CNcomment:多载波调制下的保护间隔*/
+typedef enum hiUNF_TUNER_FE_GUARD_INTV_E
+{
+    HI_UNF_TUNER_FE_GUARD_INTV_DEFALUT = 0,     /**<default guard interval mode*/   /**<CNcomment:保护间隔默认模式*/
+    HI_UNF_TUNER_FE_GUARD_INTV_1_128,           /**<1/128*/                         /**<CNcomment:保护间隔1/128模式*/
+    HI_UNF_TUNER_FE_GUARD_INTV_1_32,            /**<1/32*/                          /**<CNcomment:保护间隔1/32模式*/
+    HI_UNF_TUNER_FE_GUARD_INTV_1_16,            /**<1/16*/                          /**<CNcomment:保护间隔1/16模式*/
+    HI_UNF_TUNER_FE_GUARD_INTV_1_8,             /**<1/8*/                           /**<CNcomment:保护间隔1/8模式*/
+    HI_UNF_TUNER_FE_GUARD_INTV_1_4,             /**<1/4*/                           /**<CNcomment:保护间隔1/4模式*/
+    HI_UNF_TUNER_FE_GUARD_INTV_19_128,          /**<19/128*/                        /**<CNcomment:保护间隔19/128模式*/
+    HI_UNF_TUNER_FE_GUARD_INTV_19_256,          /**<19/256*/                        /**<CNcomment:保护间隔19/256模式*/
+    HI_UNF_TUNER_FE_GUARD_INTV_BUTT             /**<Invalid value*/                 /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_FE_GUARD_INTV_E;
+
+/** OFDM Mode, used in multi-carrier modulation*/
+/** CNcomment:OFDM模式，用于多载波调制模式下*/
+typedef enum hiUNF_TUNER_FE_FFT_E
+{
+    HI_UNF_TUNER_FE_FFT_DEFAULT = 0,   /**<default mode*/     /**<CNcomment:默认模式*/
+    HI_UNF_TUNER_FE_FFT_1K ,           /**<1k mode*/          /**<CNcomment:1k模式*/
+    HI_UNF_TUNER_FE_FFT_2K ,           /**<2k mode*/          /**<CNcomment:2k模式*/
+    HI_UNF_TUNER_FE_FFT_4K ,           /**<4k mode*/          /**<CNcomment:4k模式*/
+    HI_UNF_TUNER_FE_FFT_8K ,           /**<8k mode*/          /**<CNcomment:8k模式*/
+    HI_UNF_TUNER_FE_FFT_16K ,          /**<16k mode*/         /**<CNcomment:16k模式*/
+    HI_UNF_TUNER_FE_FFT_32K ,          /**<32k mode*/         /**<CNcomment:32k模式*/
+    HI_UNF_TUNER_FE_FFT_64K ,          /**<64k mode*/         /**<CNcomment:64k模式*/
+    HI_UNF_TUNER_FE_FFT_BUTT           /**<Invalid value*/    /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_FE_FFT_E;
+
+/** Hierarchical modulation mode, only used in DVB-T*/
+/** CNcomment:仅用于DVB-T*/
+typedef enum hiUNF_TUNER_FE_HIERARCHY_E
+{
+    HI_UNF_TUNER_FE_HIERARCHY_DEFAULT = 0,      /**<hierarchical modulation default mode*/      /**<CNcomment:默认模式*/
+    HI_UNF_TUNER_FE_HIERARCHY_NO,               /**<no hierarchical modulation mode*/           /**<CNcomment:不分级别模式*/
+    HI_UNF_TUNER_FE_HIERARCHY_ALHPA1,           /**<hierarchical mode, alpha = 1*/              /**<CNcomment:分级别模式, alpha = 1*/
+    HI_UNF_TUNER_FE_HIERARCHY_ALHPA2,           /**<hierarchical mode, alpha = 2*/              /**<CNcomment:分级别模式, alpha = 2*/
+    HI_UNF_TUNER_FE_HIERARCHY_ALHPA4,           /**<hierarchical mode, alpha = 4*/              /**<CNcomment:分级别模式, alpha = 4*/
+    HI_UNF_TUNER_FE_HIERARCHY_BUTT              /**<Invalid value*/                             /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_FE_HIERARCHY_E;
+
+/** TS Priority, only used in DVB-T*/
+/** CNcomment:仅用于DVB-T*/
+typedef enum hiUNF_TUNER_TS_PRIORITY_E
+{
+    HI_UNF_TUNER_TS_PRIORITY_NONE = 0,      /**<no priority mode*/          /**<CNcomment:无优先级模式*/
+    HI_UNF_TUNER_TS_PRIORITY_HP,            /**<high priority mode*/        /**<CNcomment:高优先级模式*/
+    HI_UNF_TUNER_TS_PRIORITY_LP,            /**<low priority mode*/         /**<CNcomment:低优先级模式*/
+    HI_UNF_TUNER_TS_PRIORITY_BUTT           /**<Invalid value*/             /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_TS_PRIORITY_E;
+
+/** base channel or lite channel, only used in DVB-T2*/
+/** CNcomment:仅用于DVB-T2*/
+typedef enum hiUNF_TUNER_TER_MODE_E
+{
+    HI_UNF_TUNER_TER_MODE_BASE = 0,     /**< the channel is base mode*/         /**<CNcomment:通道中仅支持base信号*/
+    HI_UNF_TUNER_TER_MODE_LITE,         /**< the channel is lite mode*/         /**<CNcomment:通道中需要支持lite信号*/
+    HI_UNF_TUNER_TER_MODE_BUTT      /**<Invalid value*/            /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_TER_MODE_E;
+
+/** Stream type*/
+/** CNcomment:流类型*/
+typedef enum hiUNF_TUNER_TER_STREAM_TYPE_E
+{
+    HI_UNF_TUNER_TER_STREAM_TYPE_GFPS = 0,    /**< Generic Fixed Packet size Stream*/     /**<CNcomment:通用固定包长流类型*/
+    HI_UNF_TUNER_TER_STREAM_TYPE_GCS,         /**< Generic Continuous Stream*/            /**<CNcomment:通用连续流类型*/
+    HI_UNF_TUNER_TER_STREAM_TYPE_GSE,         /**< Generic Stream Encapsulated*/          /**<CNcomment:GSE流类型*/
+    HI_UNF_TUNER_TER_STREAM_TYPE_TS,          /**< Trasport Stream*/                      /**<CNcomment:TS流类型*/
+    HI_UNF_TUNER_TER_STREAM_TYPE_GSE_HEM,     /**< GSE in High Efficiency Mode*/          /**<CNcomment:GSE流HEM模式*/
+    HI_UNF_TUNER_TER_STREAM_TYPE_TS_HEM,      /**< TS in High Efficiency Mode*/           /**<CNcomment:TS流HEM模式*/
+    HI_UNF_TUNER_TER_STREAM_TYPE_BUTT         /**< Invalid value*/                        /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_TER_STREAM_TYPE_E;
+
+/** DVB-T2 data PLP's ISSY type*/
+/** CNcomment:仅用于DVB-T2*/
+typedef enum hiUNF_TUNER_DVBT2_ISSY_E
+{
+    HI_UNF_TUNER_DVBT2_ISSY_NO = 0,   /**< No Input Stream SYnchronizer*/        /**<CNcomment:无ISSY*/
+    HI_UNF_TUNER_DVBT2_ISSY_SHORT,    /**< Short Input Stream SYnchronizer*/     /**<CNcomment:短ISSY*/
+    HI_UNF_TUNER_DVBT2_ISSY_LONG,     /**< Long Input Stream SYnchronizer*/      /**<CNcomment:长ISSY*/
+    HI_UNF_TUNER_DVBT2_ISSY_BUTT      /**< Invalid value*/                       /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_DVBT2_ISSY_E;
+
+/** TS clock polarization*/
+/** CNcomment:TS时钟极性*/
+typedef enum hiUNF_TUNER_TSCLK_POLAR_E
+{
+    HI_UNF_TUNER_TSCLK_POLAR_FALLING,       /**<Falling edge*/      /**<CNcomment:下降沿*/
+    HI_UNF_TUNER_TSCLK_POLAR_RISING,        /**<Rising edge*/       /**<CNcomment:上升沿*/
+    HI_UNF_TUNER_TSCLK_POLAR_BUTT           /**<Invalid value*/     /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_TSCLK_POLAR_E;
+
+/** TS format*/
+/** CNcomment:TS格式*/
+typedef enum hiUNF_TUNER_TS_FORMAT_E
+{
+    HI_UNF_TUNER_TS_FORMAT_TS,              /**<188*/               /**<CNcomment:188字节格式*/
+    HI_UNF_TUNER_TS_FORMAT_TSP,             /**<204*/               /**<CNcomment:204字节格式*/
+    HI_UNF_TUNER_TS_FORMAT_BUTT             /**<Invalid value*/     /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_TS_FORMAT_E;
+
+/** TS serial PIN*/
+/** CNcomment:串行TS数据管脚*/
+typedef enum hiUNF_TUNER_TS_SERIAL_PIN_E
+{
+    HI_UNF_TUNER_TS_SERIAL_PIN_0,           /**<Serial pin 0, default*/  /**<CNcomment:串行模式，数据线使用第0bit*/
+    HI_UNF_TUNER_TS_SERIAL_PIN_7,           /**<Serial pin 7*/           /**<CNcomment:串行模式，数据线使用第7bit*/
+    HI_UNF_TUNER_TS_SERIAL_PIN_BUTT         /**<Invalid value*/          /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_TS_SERIAL_PIN_E;
+
+/** ISDBT layer information,each layer can be received indepent*/
+/** CNcomment:ISDBT层信息，每层都可以独立接收*/
+typedef enum hiUNF_TUNER_ISDBT_MONITOR_LAYER_E
+{
+    HI_UNF_TUNER_ISDBT_MONITOR_LAYER_ALL,
+    HI_UNF_TUNER_ISDBT_MONITOR_LAYER_A,
+    HI_UNF_TUNER_ISDBT_MONITOR_LAYER_B,
+    HI_UNF_TUNER_ISDBT_MONITOR_LAYER_C,
+    HI_UNF_TUNER_ISDBT_MONITOR_LAYER_BUTT
+}HI_UNF_TUNER_ISDBT_MONITOR_LAYER_E;
+/** Tuner RF AGC mode*/
+/** CNcomment:agc控制模式*/
+typedef enum hiUNF_TUNER_RFAGC_MODE_E
+{
+    /**< Inverted polarization, default.This setting is used for a tuner whose gain decreases with increased AGC voltage*/   /**<CNcomment:agc反向控制模式*/
+    HI_UNF_TUNER_RFAGC_INVERT,
+
+    /**< Normal polarization. This setting is used for a tuner whose gain increases with increased AGC voltage*/             /**<CNcomment:agc正向控制模式*/
+    HI_UNF_TUNER_RFAGC_NORMAL,
+    HI_UNF_TUNER_RFAGC_BUTT                  /**<Invalid value*/                                                             /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_RFAGC_MODE_E;
+
+/** TS sync head length */
+typedef enum hiUNF_TUNER_TS_SYNC_HEAD_E
+{
+    HI_UNF_TUNER_TS_SYNC_HEAD_AUTO,
+    HI_UNF_TUNER_TS_SYNC_HEAD_8BIT,
+    HI_UNF_TUNER_TS_SYNC_HEAD_BUTT
+} HI_UNF_TUNER_TS_SYNC_HEAD_E;
+
+/** Tuner IQ spectrum mode*/
+/** CNcomment:IQ模式*/
+typedef enum hiUNF_TUNER_IQSPECTRUM_MODE_E
+{
+    HI_UNF_TUNER_IQSPECTRUM_NORMAL,         /**<The received signal spectrum is not inverted*/    /**<CNcomment:IQ不反转*/
+    HI_UNF_TUNER_IQSPECTRUM_INVERT,         /**<The received signal spectrum is inverted*/        /**<CNcomment:IQ反转*/
+    HI_UNF_TUNER_IQSPECTRUM_BUTT            /**<Invalid value*/                                   /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_IQSPECTRUM_MODE_E;
+
+/** DiSEqC Wave Mode*/
+/** CNcomment:DiSEqC模式*/
+typedef enum hiUNF_TUNER_DISEQCWAVE_MODE_E
+{
+    HI_UNF_TUNER_DISEQCWAVE_NORMAL,         /**<Waveform produced by demod*/                 /**<CNcomment:波形由demod产生*/
+    HI_UNF_TUNER_DISEQCWAVE_ENVELOPE,       /**<Waveform produced by LNB control device*/    /**<CNcomment:波形由控制芯片产生*/
+    HI_UNF_TUNER_DISEQCWAVE_BUTT            /**<Invalid value*/                              /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_DISEQCWAVE_MODE_E;
+
+/** LNB power supply and control device*/
+/** CNcomment:LNB供电和控制芯片*/
+typedef enum hiUNF_LNBCTRL_DEV_TYPE_E
+{
+    HI_UNF_LNBCTRL_DEV_TYPE_NONE,           /**<No LNB control device*/      /**<CNcomment:无控制芯片*/
+    HI_UNF_LNBCTRL_DEV_TYPE_MPS8125,        /**<MPS8125*/                    /**<CNcomment:MPS8125*/
+    HI_UNF_LNBCTRL_DEV_TYPE_ISL9492,        /**<ISL9492*/                    /**<CNcomment:ISL9492*/
+    HI_UNF_LNBCTRL_DEV_TYPE_A8300,          /**<A8300*/                      /**<CNcomment:A8300*/
+    HI_UNF_LNBCTRL_DEV_TYPE_A8297,
+    HI_UNF_LNBCTRL_DEV_TYPE_TPS65233,       /**<TPS65233*/                   /**<CNcomment:TPS65233*/
+    HI_UNF_LNBCTRL_DEV_TYPE_BUTT            /**<Invalid value*/              /**<CNcomment:非法边界值*/
+} HI_UNF_LNBCTRL_DEV_TYPE_E;
+
+/** FEC code Rate*/
+/** CNcomment:FEC码率*/
+typedef enum hiUNF_TUNER_FE_FECRATE_E
+{
+    HI_UNF_TUNER_FE_FEC_AUTO = 0,
+    HI_UNF_TUNER_FE_FEC_1_2,           /**<1/2*/           /**<CNcomment:1/2码率*/
+    HI_UNF_TUNER_FE_FEC_2_3,           /**<2/3*/           /**<CNcomment:2/3码率*/
+    HI_UNF_TUNER_FE_FEC_3_4,           /**<3/4*/           /**<CNcomment:3/4码率*/
+    HI_UNF_TUNER_FE_FEC_4_5,           /**<4/5*/           /**<CNcomment:4/5码率*/
+    HI_UNF_TUNER_FE_FEC_5_6,           /**<5/6*/           /**<CNcomment:5/6码率*/
+    HI_UNF_TUNER_FE_FEC_6_7,           /**<6/7*/           /**<CNcomment:6/7码率*/
+    HI_UNF_TUNER_FE_FEC_7_8,           /**<7/8*/           /**<CNcomment:7/8码率*/
+    HI_UNF_TUNER_FE_FEC_8_9,           /**<8/9*/           /**<CNcomment:8/9码率*/
+    HI_UNF_TUNER_FE_FEC_9_10,          /**<9/10*/          /**<CNcomment:9/10码率*/
+    HI_UNF_TUNER_FE_FEC_1_4,           /**<1/4*/           /**<CNcomment:1/4码率*/
+    HI_UNF_TUNER_FE_FEC_1_3,           /**<1/3*/           /**<CNcomment:1/3码率*/
+    HI_UNF_TUNER_FE_FEC_2_5,           /**<2/5*/           /**<CNcomment:2/5码率*/
+    HI_UNF_TUNER_FE_FEC_3_5,           /**<3/5*/           /**<CNcomment:3/5码率*/
+    HI_UNF_TUNER_FE_FEC_13_45,         /**<13/45*/         /**<CNcomment:13/45码率*/
+    HI_UNF_TUNER_FE_FEC_9_20,          /**<9/20*/          /**<CNcomment:9/20码率*/
+    HI_UNF_TUNER_FE_FEC_11_20,         /**<11/20*/         /**<CNcomment:11/20码率*/
+    HI_UNF_TUNER_FE_FEC_5_9_L,         /**<5/9L*/          /**<CNcomment:5/9L码率*/
+    HI_UNF_TUNER_FE_FEC_26_45_L,       /**<26/45L*/        /**<CNcomment:26/45L码率*/
+    HI_UNF_TUNER_FE_FEC_23_36,         /**<23/36*/         /**<CNcomment:23/36码率*/
+    HI_UNF_TUNER_FE_FEC_25_36,         /**<25/36*/         /**<CNcomment:25/36码率*/
+    HI_UNF_TUNER_FE_FEC_13_18,         /**<13/18*/         /**<CNcomment:13/18码率*/
+    HI_UNF_TUNER_FE_FEC_1_2_L,         /**<1/2L*/          /**<CNcomment:1/2L码率*/
+    HI_UNF_TUNER_FE_FEC_8_15_L,        /**<8/15L*/         /**<CNcomment:8/15L码率*/
+    HI_UNF_TUNER_FE_FEC_26_45,         /**<26/45*/         /**<CNcomment:26/45码率*/
+    HI_UNF_TUNER_FE_FEC_3_5_L,         /**<3/5L*/          /**<CNcomment:3/5L码率*/
+    HI_UNF_TUNER_FE_FEC_28_45,         /**<28/45*/         /**<CNcomment:28/45码率*/
+    HI_UNF_TUNER_FE_FEC_2_3_L,         /**<2/3L*/          /**<CNcomment:2/3L码率*/
+    HI_UNF_TUNER_FE_FEC_7_9,           /**<7/9*/           /**<CNcomment:7/9码率*/
+    HI_UNF_TUNER_FE_FEC_77_90,         /**<77/90*/         /**<CNcomment:77/90码率*/
+    HI_UNF_TUNER_FE_FEC_32_45,         /**<32/45*/         /**<CNcomment:32/45码率*/
+    HI_UNF_TUNER_FE_FEC_11_15,         /**<11/15*/         /**<CNcomment:11/15码率*/
+    HI_UNF_TUNER_FE_FEC_32_45_L,       /**<32/45*/         /**<CNcomment:32/45L码率*/
+    HI_UNF_TUNER_FE_FEC_29_45_L,       /**<29/45L*/        /**<CNcomment:29/45L码率*/
+    HI_UNF_TUNER_FE_FEC_31_45_L,       /**<31/45*/         /**<CNcomment:31/45L码率*/
+    HI_UNF_TUNER_FE_FEC_11_15_L,       /**<11/15L*/        /**<CNcomment:11/15L码率*/
+    HI_UNF_TUNER_FE_FEC_11_45,         /**<11/45*/         /**<CNcomment:11/45码率*/
+    HI_UNF_TUNER_FE_FEC_4_15,          /**<4/15*/          /**<CNcomment:4/15码率*/
+    HI_UNF_TUNER_FE_FEC_14_45,         /**<14/45*/         /**<CNcomment:14/45码率*/
+    HI_UNF_TUNER_FE_FEC_7_15,          /**<7/15*/          /**<CNcomment:7/15码率*/
+    HI_UNF_TUNER_FE_FEC_8_15,          /**<8/15*/          /**<CNcomment:8/15码率*/
+    HI_UNF_TUNER_FE_FEC_2_9,           /**<2/9*/           /**<CNcomment:2/9码率*/
+    HI_UNF_TUNER_FE_FEC_1_5,           /**<2/9*/           /**<CNcomment:2/9码率*/
+    HI_UNF_TUNER_FE_FECRATE_BUTT       /**<Invalid value*/ /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_FE_FECRATE_E;
+
+/** Parameter for ISDB-T layer exist or not*/
+/** CNcomment:ISDB-T模式下，层是否存在信息*/
+typedef union hiUNF_TUNER_ISDBT_LAYERS_IDENTIFY_U
+{
+    struct
+    {
+        HI_U8 u8LayerAExist:1;  /*[0]*/
+        HI_U8 u8LayerBExist:1;  /*[1]*/
+        HI_U8 u8LayerCExist:1;  /*[2]*/
+        HI_U8 reserved:5;       /*[7:3]*/
+    }bits;
+
+    HI_U8 ExistanceFlag;
+}HI_UNF_TUNER_ISDBT_LAYERS_IDENTIFY_U;
+
+/** Parameter for ISDB-T layer configuration*/
+/** CNcomment:ISDB-T模式下，层配置信息*/
+typedef struct hiUNF_TUNER_MONITOR_LAYERS_CONFIG_S
+{
+    HI_UNF_TUNER_ISDBT_MONITOR_LAYER_E enMonitorLayer;  /**<ISDB-T layer exist or not*/ /**<CNcomment:ISDB-T模式下，层是否存在配置信息*/
+} HI_UNF_TUNER_MONITOR_LAYERS_CONFIG_S;
+
+
+/** Parameter for ISDB-T layer information*/
+/** CNcomment:ISDB-T模式下，层 信号属性信息*/
+typedef struct hiUNF_TUNER_ISDBT_LAYERS_INFO_S
+{
+    HI_U8 u8LayerSegNum;            /**<layer segment number*/              /**<CNcomment:层segment个数*/
+    HI_U8 u8LayerReserved[3];
+    HI_UNF_TUNER_FE_HIERARCHY_E enLayerHierMod; /**<layer hierarchy mode*/  /**<CNcomment:层时间交织模式*/
+    HI_UNF_TUNER_FE_FECRATE_E   enLayerFECRate; /**<layer FEC rate*/        /**<CNcomment:层码率*/
+    HI_UNF_MODULATION_TYPE_E    enLayerModType; /**<layer modulation type*/ /**<CNcomment:层调制模式*/
+}HI_UNF_TUNER_ISDBT_LAYERS_INFO_S;
+
+/** Parameter for ISDB-T TMCC information*/
+/** CNcomment:ISDB-T模式下，TMCC 信息*/
+typedef struct hiUNF_TUNER_TMCC_INFO_S
+{
+    HI_U8 u8EmergencyFlag;  /**<the start flag for emergency alarm broadcasting*/                   /**<CNcomment:紧急报警播报开始标志*/
+    HI_U8 u8PartialFlag;    /**<partial reception flag*/                                            /**<CNcomment:部分接收标志*/
+    HI_U8 u8PhaseShiftCorr; /**<phase shift correction value for connected segment transmission*/   /**<CNcomment:相位偏移值*/
+    HI_U8 u8IsdbtSystemId;  /**<system identification[0 = ISDB_T,1 = ISDB_T_SB]*/                   /**<CNcomment:系统标识*/
+
+    HI_UNF_TUNER_ISDBT_LAYERS_INFO_S stIsdbtLayersAInfoBits;
+    HI_UNF_TUNER_ISDBT_LAYERS_INFO_S stIsdbtLayersBInfoBits;
+    HI_UNF_TUNER_ISDBT_LAYERS_INFO_S stIsdbtLayersCInfoBits;
+
+    HI_U8 u8TMCCReserved[4];    /**<Reserve*/                                                       /**<CNcomment:保留参数*/
+} HI_UNF_TUNER_TMCC_INFO_S;
+
+/** ADC port select*/
+/** CNcomment:ADC端口选择*/
+typedef enum hiUNF_TUNER_ADC_PORT_E
+{
+    HI_UNF_TUNER_ADC0,          /**<ADC0 port*/   /**<CNcomment:ADC0端口*/
+    HI_UNF_TUNER_ADC1,          /**<ADC1 port*/   /**<CNcomment:ADC1端口*/
+    HI_UNF_TUNER_ADC_BUTT
+}HI_UNF_TUNER_ADC_PORT_E;
+
+/** Satellite extended attribution*/
+/** CNcomment:卫星机附加属性*/
+typedef struct  hiUNF_TUNER_SAT_ATTR_S
+{
+    HI_U32                         u32DemodClk;     /**<Demod reference clock frequency, KHz*/    /**<CNcomment:demod参考时钟频率，单位MHz*/
+    HI_U16                         u16TunerMaxLPF;  /**<Tuner max LPF, MHz*/                      /**<CNcomment:tuner低通滤波器通带频率，单位MHz*/
+    HI_U16                         u16TunerI2CClk;  /**<Tuner I2C clock, kHz*/                    /**<CNcomment:tuner i2c时钟频率*/
+    HI_UNF_TUNER_RFAGC_MODE_E      enRFAGC;         /**<Tuner RF AGC mode*/                       /**<CNcomment:agc模式*/
+    HI_UNF_TUNER_IQSPECTRUM_MODE_E enIQSpectrum;    /**<Tuner IQ spectrum mode*/                  /**<CNcomment:IQ模式*/
+    HI_UNF_TUNER_TSCLK_POLAR_E     enTSClkPolar;    /**<TS clock polarization*/                   /**<CNcomment:ts时钟极性*/
+    HI_UNF_TUNER_TS_FORMAT_E       enTSFormat;      /**<TS format*/                               /**<CNcomment:ts格式*/
+    HI_UNF_TUNER_TS_SERIAL_PIN_E   enTSSerialPIN;   /**<TS serial PIN*/                           /**<CNcomment:ts串行数据线*/
+    HI_UNF_TUNER_DISEQCWAVE_MODE_E enDiSEqCWave;    /**<DiSEqC Wave Mode*/                        /**<CNcomment:DiSEqC模式*/
+    HI_UNF_LNBCTRL_DEV_TYPE_E      enLNBCtrlDev;    /**<LNB power supply and control device*/     /**<CNcomment:LNB控制芯片*/
+    HI_U16                         u16LNBDevAddress;/**<LNB control device address*/              /**<CNcomment:LNB控制芯片i2c地址*/
+} HI_UNF_TUNER_SAT_ATTR_S;
+
+/** Terrestrial extended attribution*/
+/** CNcomment:地面机附加属性*/
+typedef struct  hiUNF_TUNER_TER_ATTR_S
+{
+    HI_U32                         u32DemodClk;     /**<Demod reference clock frequency, KHz*/    /**<CNcomment:demod参考时钟频率，单位MHz*/
+    HI_U32                         u32ResetGpioNo;  /**< Demod reset GPIO NO. */
+    HI_U16                         u16TunerMaxLPF;  /**<Tuner max LPF, MHz*/                      /**<CNcomment:tuner低通滤波器通带频率，单位MHz*/
+    HI_U16                         u16TunerI2CClk;  /**<Tuner I2C clock, kHz*/                    /**<CNcomment:tuner i2c时钟频率*/
+    HI_UNF_TUNER_RFAGC_MODE_E      enRFAGC;         /**<Tuner RF AGC mode*/                       /**<CNcomment:agc模式*/
+    HI_UNF_TUNER_IQSPECTRUM_MODE_E enIQSpectrum;    /**<Tuner IQ spectrum mode*/                  /**<CNcomment:IQ模式*/
+    HI_UNF_TUNER_TSCLK_POLAR_E     enTSClkPolar;    /**<TS clock polarization*/                   /**<CNcomment:ts时钟极性*/
+    HI_UNF_TUNER_TS_FORMAT_E       enTSFormat;      /**<TS format*/                               /**<CNcomment:ts格式*/
+    HI_UNF_TUNER_TS_SERIAL_PIN_E   enTSSerialPIN;   /**<TS serial PIN*/                           /**<CNcomment:ts串行数据线*/
+    HI_UNF_TUNER_TS_SYNC_HEAD_E    enTSSyncHead;    /**<TS sync head length*/                     /**<CNcomment:ts同步头长度*/
+} HI_UNF_TUNER_TER_ATTR_S;
+
+/** Cable extended attribution*/
+/** CNcomment:有线附加属性*/
+typedef struct  hiUNF_TUNER_CAB_ATTR_S
+{
+    HI_U32                         u32ResetGpioNo;  /**< Demod reset GPIO NO. */
+    HI_U32                         u32DemodClk;     /**< Demod reference clock frequency, KHz */
+    HI_UNF_TUNER_TSCLK_POLAR_E     enTSClkPolar;    /**< TS clock polarization */
+    HI_UNF_TUNER_TS_FORMAT_E       enTSFormat;      /**< TS format */
+    HI_UNF_TUNER_TS_SERIAL_PIN_E   enTSSerialPIN;   /**< TS serial PIN */
+    HI_UNF_TUNER_TS_SYNC_HEAD_E    enTSSyncHead;    /**<TS sync head length*/                   /**<CNcomment:ts同步头长度*/
+} HI_UNF_TUNER_CAB_ATTR_S;
+
+/** Polarization type*/
+/** CNcomment:极化方式*/
+typedef enum hiUNF_TUNER_FE_POLARIZATION_E
+{
+    HI_UNF_TUNER_FE_POLARIZATION_H,     /**<Horizontal Polarization*/           /**<CNcomment:水平极化*/
+    HI_UNF_TUNER_FE_POLARIZATION_V,     /**<Vertical Polarization*/             /**<CNcomment:垂直极化*/
+    HI_UNF_TUNER_FE_POLARIZATION_L,     /**<Left-hand circular Polarization*/   /**<CNcomment:左旋圆极化*/
+    HI_UNF_TUNER_FE_POLARIZATION_R,     /**<Right-hand circular Polarization*/  /**<CNcomment:右旋圆极化*/
+    HI_UNF_TUNER_FE_POLARIZATION_BUTT,  /**<Invalid value*/                     /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_FE_POLARIZATION_E;
+
+/** Pilot type*/
+/** CNcomment:导频*/
+typedef enum hiUNF_TUNER_PILOT_E
+{
+    HI_UNF_TUNER_PILOT_OFF,         /**<Pilot off*/               /**<CNcomment:导频关闭*/
+    HI_UNF_TUNER_PILOT_ON,          /**<Pilot on*/                /**<CNcomment:导频打开*/
+    HI_UNF_TUNER_PILOT_BUTT         /**<Invalid value*/           /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_PILOT_E;
+
+/** FEC length*/
+/** CNcomment:FEC帧 长度*/
+typedef enum hiUNF_TUNER_SAT_FEC_FRAME_MODE_E
+{
+    HI_UNF_TUNER_SAT_FEC_FRAME_NORMAL,  /**<nomal FEC Frame*/       /**<CNcomment:普通长度FEC帧，适用于DVB-S/S2/S2X*/
+    HI_UNF_TUNER_SAT_FEC_FRAME_SHORT,   /**<short FEC Frame*/       /**<CNcomment:短FEC帧，适用于DVB-S2X*/
+    HI_UNF_TUNER_SAT_FEC_FRAME_MEDIUM,  /**<medium FEC Fream*/      /**<CNcomment:中等FEC帧，适用于DVB-S2X*/
+    HI_UNF_TUNER_SAT_FEC_FRAME_BUTT     /**<Invalid value*/         /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_SAT_FEC_FRAME_MODE_E;
+
+/** Roll off*/
+/** CNcomment:滚降系数*/
+typedef enum hiUNF_TUNER_ROLLOFF_E
+{
+    HI_UNF_TUNER_ROLLOFF_35,        /**<Roll off 0.35*/           /**<CNcomment:滚降系数0.35*/
+    HI_UNF_TUNER_ROLLOFF_25,        /**<Roll off 0.25*/           /**<CNcomment:滚降系数0.25*/
+    HI_UNF_TUNER_ROLLOFF_20,        /**<Roll off 0.20*/           /**<CNcomment:滚降系数0.20*/
+    HI_UNF_TUNER_ROLLOFF_15,        /**<Roll off 0.15*/           /**<CNcomment:滚降系数0.15*/
+    HI_UNF_TUNER_ROLLOFF_10,        /**<Roll off 0.10*/           /**<CNcomment:滚降系数0.10*/
+    HI_UNF_TUNER_ROLLOFF_05,        /**<Roll off 0.05*/           /**<CNcomment:滚降系数0.05*/
+    HI_UNF_TUNER_ROLLOFF_BUTT       /**<Invalid value*/           /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_ROLLOFF_E;
+
+/** Stream typef*/
+/** CNcomment:流类型*/
+typedef enum hiUNF_TUNER_SAT_STREAM_TYPE_E
+{
+    HI_UNF_TUNER_SAT_STREAM_TYPE_GENERIC_PACKETIZED,  /**< Generic Packetized Stream*/         /**<CNcomment:通用打包流类型*/
+    HI_UNF_TUNER_SAT_STREAM_TYPE_GENERIC_CONTINUOUS,  /**< Generic Continuous Stream*/         /**<CNcomment:通用连续流类型*/
+    HI_UNF_TUNER_SAT_STREAM_TYPE_GSE_HEM,             /**< GSE in High Efficiency Mode*/       /**<CNcomment:GSE流类型HEM模式*/
+    HI_UNF_TUNER_SAT_STREAM_TYPE_TRANSPORT,           /**< Trensport Stream*/                  /**<CNcomment:TS流类型*/
+    HI_UNF_TUNER_SAT_STREAM_TYPE_GSE_LITE,            /**< GSE-Lite*/                          /**<CNcomment:GSE-Lite流类型*/
+    HI_UNF_TUNER_SAT_STREAM_TYPE_GSE_LITE_HEM,        /**< GSE-Lite in High Efficiency Mode*/  /**<CNcomment:GSE-Lite流HEM模式*/
+    HI_UNF_TUNER_SAT_STREAM_TYPE_T2MI,                /**< T2MI Stream*/                       /**<CNcomment:T2MI流类型*/
+    HI_UNF_TUNER_SAT_STREAM_TYPE_BUTT                 /**< Invalid value*/                     /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_SAT_STREAM_TYPE_E;
+
+/** FEC Type*/
+/** CNcomment:卫星标准*/
+typedef enum hiUNF_TUNER_FE_FECTYPE_E
+{
+    HI_UNF_TUNER_FE_DVBS,               /**<DVB-S*/                         /**<CNcomment:DVB-S标准*/
+    HI_UNF_TUNER_FE_DVBS2,              /**<DVB-S2*/                        /**<CNcomment:DVB-S2标准*/
+    HI_UNF_TUNER_FE_DIRECTV,            /**<DIRECTV*/                       /**<CNcomment:DIRECTV标准*/
+    HI_UNF_TUNER_FE_DVBS2X,             /**<DVB-S2X*/                       /**<CNcomment:DVB-S2X标准*/
+    HI_UNF_TUNER_FE_BUTT                /**<Invalid value*/                 /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_FE_FECTYPE_E;
+
+/** LNB type*/
+/** CNcomment:LNB类型*/
+typedef enum hiUNF_TUNER_FE_FE_LNBTYPE_E
+{
+    HI_UNF_TUNER_FE_LNB_SINGLE_FREQUENCY,   /**<Single LO frequency*/       /**<CNcomment:单本振*/
+    HI_UNF_TUNER_FE_LNB_DUAL_FREQUENCY,     /**<Dual LO frequency*/         /**<CNcomment:双本振*/
+    HI_UNF_TUNER_FE_LNB_UNICABLE,           /**<Unicable LNB */             /**<CNcomment:unicable高频头*/
+    HI_UNF_TUNER_FE_LNB_TRIPLE_FREQUENCY,   /**<Triple LO frequency*/       /**<CNcomment:三本振*/
+    HI_UNF_TUNER_FE_LNB_UNICABLE2,          /**<Unicable2 LNB */             /**<CNcomment:unicable2高频头*/
+    HI_UNF_TUNER_FE_LNB_TYPE_BUTT           /**<Invalid value*/             /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_FE_LNB_TYPE_E;
+
+/** LNB band type*/
+/** CNcomment:卫星信号频段*/
+typedef enum hiUNF_TUNER_FE_LNB_BAND_E
+{
+    HI_UNF_TUNER_FE_LNB_BAND_C,             /**<C */                        /**<CNcomment:C波段*/
+    HI_UNF_TUNER_FE_LNB_BAND_KU,            /**<Ku */                       /**<CNcomment:Ku波段*/
+    HI_UNF_TUNER_FE_LNB_BAND_KA,            /**<Ka */                       /**<CNcomment:Ka波段*/
+    HI_UNF_TUNER_FE_LNB_BAND_BUTT           /**<Invalid value*/             /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_FE_LNB_BAND_E;
+
+/** LNB power control*/
+/** CNcomment:高频头供电控制*/
+typedef enum hiUNF_TUNER_FE_LNB_POWER_E
+{
+    HI_UNF_TUNER_FE_LNB_POWER_OFF,          /**<LNB power off*/                                                     /**<CNcomment:关断*/
+    HI_UNF_TUNER_FE_LNB_POWER_ON,           /**<LNB power auto, 13V/18V, default*/                                  /**<CNcomment:默认的13/18V供电*/
+    HI_UNF_TUNER_FE_LNB_POWER_ENHANCED,     /**<LNB power auto, 14V/19V, some LNB control device can support.*/     /**<CNcomment:加强供电*/
+    HI_UNF_TUNER_FE_LNB_POWER_BUTT          /**<Invalid value*/                                                     /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_FE_LNB_POWER_E;
+
+/** Antenna power control*/
+/** CNcomment:天线供电控制*/
+typedef enum hiUNF_TUNER_TER_ANTENNA_POWER_E
+{
+    HI_UNF_TUNER_TER_ANTENNA_POWER_OFF,     /**<Antenna power off*/          /**<CNcomment:天线电源关断*/
+    HI_UNF_TUNER_TER_ANTENNA_POWER_ON,      /**<Antenna power on*/           /**<CNcomment:天线电源打开*/
+    HI_UNF_TUNER_TER_ANTENNA_POWER_BUTT     /**<Invalid value*/              /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_TER_ANTENNA_POWER_E;
+
+/** Demod standby or wake up status*/
+/** CNcomment:解调芯片待机唤醒状态*/
+typedef enum hiUNF_TUNER_DEMOD_STATUS_E
+{
+    HI_UNF_TUNER_DEMODE_WAKE_UP = 0,        /**<Demod wake up*/              /**<CNcomment:解调芯片唤醒*/
+    HI_UNF_TUNER_DEMODE_STANDBY,            /**<Demod standby*/              /**<CNcomment:解调芯片待机*/
+    HI_UNF_TUNER_DEMOD_STATUS_BUTT          /**<Invalid value*/              /**<CNcomment:非法边界值*/
+}HI_UNF_TUNER_DEMOD_STATUS_E;
+
+/** LNB 22K tone status, for Ku band LNB*/
+/** CNcomment:22k信号状态，用于Ku双本振*/
+typedef enum hiUNF_TUNER_FE_LNB_22K_E
+{
+    HI_UNF_TUNER_FE_LNB_22K_OFF,            /**<22k off*/                    /**<CNcomment:22k信号关，选择低本振*/
+    HI_UNF_TUNER_FE_LNB_22K_ON,             /**<22k on*/                     /**<CNcomment:22k信号开，选择高本振*/
+    HI_UNF_TUNER_FE_LNB_22K_BUTT            /**<Invalid value*/              /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_FE_LNB_22K_E;
+
+/** 0/12V switch*/
+/** CNcomment:0/12V开关*/
+typedef enum hiUNF_TUNER_SWITCH_0_12V_E
+{
+    HI_UNF_TUNER_SWITCH_0_12V_NONE,         /**< None, default*/            /**<CNcomment:不接开关状态*/
+    HI_UNF_TUNER_SWITCH_0_12V_0,            /**< 0V*/                       /**<CNcomment:0V状态*/
+    HI_UNF_TUNER_SWITCH_0_12V_12,           /**< 12V*/                      /**<CNcomment:12V状态*/
+    HI_UNF_TUNER_SWITCH_0_12V_BUTT          /**<Invalid value*/             /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_SWITCH_0_12V_E;
+
+/** 22KHz switch*/
+/** CNcomment:22K开关*/
+typedef enum hiUNF_TUNER_SWITCH_22K_E
+{
+    HI_UNF_TUNER_SWITCH_22K_NONE,           /**< None, default*/            /**<CNcomment:不接开关状态*/
+    HI_UNF_TUNER_SWITCH_22K_0,              /**< 0*/                        /**<CNcomment:0kHz端口*/
+    HI_UNF_TUNER_SWITCH_22K_22,             /**< 22KHz*/                    /**<CNcomment:22kHz端口*/
+    HI_UNF_TUNER_SWITCH_22K_BUTT            /**<Invalid value*/             /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_SWITCH_22K_E;
+
+/** Tone burst switch*/
+/** CNcomment:Tone burst开关*/
+typedef enum hiUNF_TUNER_SWITCH_TONEBURST_E
+{
+    HI_UNF_TUNER_SWITCH_TONEBURST_NONE,     /**< Don't send tone burst, default*/ /**<CNcomment:不接开关状态*/
+    HI_UNF_TUNER_SWITCH_TONEBURST_0,        /**< Tone burst 0*/                   /**<CNcomment:0 port*/
+    HI_UNF_TUNER_SWITCH_TONEBURST_1,        /**< Tone burst 1*/                   /**<CNcomment:1 port*/
+    HI_UNF_TUNER_SWITCH_TONEBURST_BUTT      /**<Invalid value*/                   /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_SWITCH_TONEBURST_E;
+
+/** pilot pattern */
+typedef enum hiUNF_TUNER_TER_PILOT_PATTERN_E
+{
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP1 = 0,  /**< pilot pattern pp1 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP2,      /**< pilot pattern pp2 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP3,      /**< pilot pattern pp3 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP4,      /**< pilot pattern pp4 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP5,      /**< pilot pattern pp5 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP6,      /**< pilot pattern pp6 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP7,      /**< pilot pattern pp7 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_PP8,      /**< pilot pattern pp8 */
+    HI_UNF_TUNER_T2_PILOT_PATTERN_BUTT
+} HI_UNF_TUNER_TER_PILOT_PATTERN_E;
+
+/** information for channel mode*/
+/** CNcomment:通道模式信息*/
+typedef enum hiUNF_TUNER_TER_CHANNEL_MODE_E
+{
+    HI_UNF_TUNER_TER_PURE_CHANNEL = 0,      /**< pure channel*/     /**<CNcomment:纯通道模式*/
+    HI_UNF_TUNER_TER_MIXED_CHANNEL,         /**< mixed channel*/    /**<CNcomment:混合通道模式*/
+    HI_UNF_TUNER_TER_CHANNEL_MODE_BUTT      /**<Invalid value*/     /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_TER_CHANNEL_MODE_E;
+
+/** information for carrier mode*/
+/** CNcomment:载波模式信息*/
+typedef enum hiUNF_TUNER_TER_CARRIER_MODE_E
+{
+    HI_UNF_TUNER_TER_EXTEND_CARRIER = 0,    /**< extend carrier*/   /**<CNcomment:扩展载波*/
+    HI_UNF_TUNER_TER_NORMAL_CARRIER,        /**< normal carrier*/   /**<CNcomment:正常载波*/
+    HI_UNF_TUNER_TER_CARRIER_MODE_BUTT      /**<Invalid value*/     /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_TER_CARRIER_MODE_E;
+
+/** CNcomment:code and modulation 模式*/
+typedef enum hiUNF_TUNER_CODE_MODULATION_E
+{
+    HI_UNF_TUNER_CODE_MODULATION_VCM_ACM,       /**< VCM/ACM*/      /**<CNcomment:可变码率和调制/自适应码率和调制模式*/
+    HI_UNF_TUNER_CODE_MODULATION_CCM,           /**< CCM*/          /**<CNcomment:固定码率和调制模式*/
+    HI_UNF_TUNER_CODE_MODULATION_MULTISTREAM,   /**< MultiStream*/  /**<CNcomment:不变调制模式下的多流*/
+    HI_UNF_TUNER_CODE_MODULATION_BUTT           /**<Invalid value*/ /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_CODE_MODULATION_E;
+
+/** information for constellation mode*/
+/** CNcomment:星座是否旋转*/
+typedef enum hiUNF_TUNER_CONSTELLATION_MODE_E
+{
+    HI_UNF_TUNER_CONSTELLATION_STANDARD = 0,    /**< standard constellation*/   /**<CNcomment:不旋转星座*/
+    HI_UNF_TUNER_CONSTELLATION_ROTATION,        /**< rotation constellation*/   /**<CNcomment:旋转星座*/
+    HI_UNF_TUNER_CONSTELLATION_MODE_BUTT        /**<Invalid value*/             /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_CONSTELLATION_MODE_E;
+
+/** FEC frame length*/
+/** CNcomment:FEC帧长*/
+typedef enum hiUNF_TUNER_TER_FEC_FRAME_MODE_E
+{
+    HI_UNF_TUNER_TER_FEC_FRAME_NORMAL = 0,      /**< normal fec frame*/ /**<CNcomment:普通长度的fec帧*/
+    HI_UNF_TUNER_TER_FEC_FRAME_SHORT,           /**< short fec frame*/  /**<CNcomment:fec短帧*/
+    HI_UNF_TUNER_TER_FEC_FRAME_MODE_BUTT        /**<Invalid value*/     /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_TER_FEC_FRAME_MODE_E;
+
+/** Structure of the satellite transmission signal.*/
+/** CNcomment:定义Satellite传输信号*/
+typedef struct  hiUNF_SAT_CONNECT_PARA_S
+{
+    HI_U32                         u32Freq;         /**<Downlink frequency, in kHz*/ /**<CNcomment:下行频率，单位：kHz*/
+    HI_U32                         u32SymbolRate;   /**<Symbol rate, in Symb/s*/     /**<CNcomment:符号率，单位：Symb/s */
+    HI_UNF_TUNER_FE_POLARIZATION_E enPolar;         /**<Polarization type*/          /**<CNcomment:极化方式*/
+    HI_U32                         u32ScrambleValue; /**<Physical layer initial scrambling code,range 0~262141,the default value must be 0,when signal sender config some TP using not 0,
+    then receiver must modify this value the same as sender,if not,signal will be unlock,the modified value maybe told by signal sender.*/
+    /**<CNcomment:物理层扰码初始值，范围0~262141.该值的默认设置值为0,个别频点发端没有使用默认值0，收端接收时需修改该值和发端一致，否则会引起信号失锁，该值可由发端告知。*/
+} HI_UNF_SAT_CONNECT_PARA_S;
+
+/** configure lock tp PLP parameter,only in DVB-T2 */
+/** CNcomment:在DVB-T2时，配置要锁频点的物理层管道属性*/
+typedef struct hiUNF_TUNER_TER_PLP_PARA_S
+{
+    HI_U8                       u8PlpId;            /**<PLP id*/                /**<CNcomment:物理层管道ID*/
+    HI_U8                       u8CommPlpId;        /**<common PLP id*/         /**<CNcomment:共享物理层管道ID*/
+    HI_U8                       u8Combination;      /**<PLP combination*/       /**<CNcomment:数据物理层管道和共享物理层管道是否组合标志*/
+} HI_UNF_TUNER_TER_PLP_PARA_S;
+
+/** Terestrial connect param*/
+/** CNcomment:地面信号锁台参数*/
+typedef struct  hiUNF_TER_CONNECT_PARA_S
+{
+    HI_U32                      u32Freq;            /**<freq in KHz*/               /**<CNcomment:频率，单位kHz*/
+    HI_U32                      u32BandWidth;       /**<bandwidth in KHz*/          /**<CNcomment:带宽，单位kHz*/
+    HI_UNF_MODULATION_TYPE_E    enModType;          /**<modulation type*/           /**<CNcomment:调制方式*/
+    HI_BOOL                     bReverse;           /**<Spectrum reverse mode*/     /**<CNcomment:频谱翻转处理方式*/
+    HI_UNF_TUNER_TER_MODE_E     enChannelMode;      /**<dvb-t2 channel mode*/       /**<CNcomment:dvb-t2信道接收模式*/
+    HI_UNF_TUNER_TS_PRIORITY_E  enDVBTPrio;         /**<dvb-t TS priority*/         /**<CNcomment:dvb-t码流优先级*/
+    HI_UNF_TUNER_TER_PLP_PARA_S stPLPParam;         /**< PLP parameter*/            /**<CNcomment:物理层管道参数*/
+} HI_UNF_TER_CONNECT_PARA_S;
+
+/** Structure of the satellite transmission signal's detailed information.*/
+/** CNcomment:卫星信号详细信息*/
+typedef struct  hiUNF_TUNER_SAT_SIGNALINFO_S
+{
+    HI_U32                         u32Freq;         /**<Downlink frequency, in kHz*/              /**<CNcomment:下行频率，单位：kHz*/
+    HI_U32                         u32SymbolRate;   /**<Symbol rate, in Symb/s*/                  /**<CNcomment:符号率，单位Symb/s*/
+    HI_UNF_MODULATION_TYPE_E       enModType;       /**<Modulation type*/                         /**<CNcomment:调制方式*/
+    HI_UNF_TUNER_FE_POLARIZATION_E enPolar;         /**<Polarization type*/                       /**<CNcomment:极化方式*/
+    HI_UNF_TUNER_FE_FECTYPE_E      enSATType;       /**<Saterllite standard, DVB-S/S2/DIRECTV*/   /**<CNcomment:卫星标准， 支持DVB-S/S2/DIRECTV*/
+    HI_UNF_TUNER_FE_FECRATE_E      enFECRate;       /**<FEC rate*/                                /**<CNcomment:前向纠错码率*/
+    HI_UNF_TUNER_CODE_MODULATION_E enCodeModulation;
+    HI_UNF_TUNER_ROLLOFF_E         enRollOff;       /**<Rolloff*/                                 /**<CNcomment:滚降系数*/
+    HI_UNF_TUNER_PILOT_E           enPilot;         /**<Pilot*/                                   /**<CNcomment:导频*/
+    HI_UNF_TUNER_SAT_FEC_FRAME_MODE_E    enFECFrameMode;     /**<FEC fream mode*/                 /**<CNcomment:FEC帧长度*/
+    HI_UNF_TUNER_SAT_STREAM_TYPE_E enStreamType;    /**<Stream type*/                             /**<CNcomment:流类型*/
+} HI_UNF_TUNER_SAT_SIGNALINFO_S;
+
+/** PLP type of DVB-T2.*/
+/** CNcomment:T2下物理层管道类型*/
+typedef enum hiUNF_TUNER_T2_PLP_TYPE_E
+{
+    HI_UNF_TUNER_T2_PLP_TYPE_COM=0,         /**<common type*/              /**<CNcomment:普通*/
+    HI_UNF_TUNER_T2_PLP_TYPE_DAT1,          /**<data1 type*/               /**<CNcomment:数据1*/
+    HI_UNF_TUNER_T2_PLP_TYPE_DAT2,          /**<data2 type*/               /**<CNcomment:数据2*/
+    HI_UNF_TUNER_T2_PLP_TYPE_BUTT           /**<Invalid value*/            /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_T2_PLP_TYPE_E;
+
+/** Structure of the terrestrial transmission signal's detailed information.*/
+/** CNcomment:地面信号详细信息*/
+typedef struct  hiUNF_TUNER_TER_SIGNALINFO_S
+{
+    HI_U32                              u32Freq;                /**<Frequency, in kHz*/         /**<CNcomment:频率，单位：kHz*/
+    HI_U32                              u32BandWidth;           /**<Band width, in KHz*/        /**<CNcomment:带宽，单位KHz */
+    HI_UNF_MODULATION_TYPE_E            enModType;              /**<Modulation type*/           /**<CNcomment:调制方式*/
+    HI_UNF_TUNER_FE_FECRATE_E           enFECRate;              /**<FEC rate*/                  /**<CNcomment:前向纠错码率*/
+    HI_UNF_TUNER_FE_FECRATE_E           enLowPriFECRate;
+    HI_UNF_TUNER_FE_GUARD_INTV_E        enGuardIntv;            /**<GI mode*/                   /**<CNcomment:保护间隔模式*/
+    HI_UNF_TUNER_FE_FFT_E               enFFTMode;              /**<FFT mode*/                  /**<CNcomment:FFT模式*/
+    HI_UNF_TUNER_FE_HIERARCHY_E         enHierMod;              /**<Hierarchical Modulation and alpha, only used in DVB-T*/
+                                                                /**<CNcomment:hierachical模式和alpha值*/
+    HI_UNF_TUNER_TS_PRIORITY_E          enTsPriority;           /**<The TS priority, only used in DVB-T*/
+                                                                /**<CNcomment:ts priority, 仅用于DVB-T模式下*/
+    HI_UNF_TUNER_T2_PLP_TYPE_E          enPLPType;              /**<PLP type*/                  /**<CNcomment:物理层管道类型*/
+    HI_UNF_TUNER_TER_PILOT_PATTERN_E    enPilotPattern;         /**<pilot pattern*/             /**<CNcomment:导频模式*/
+    HI_UNF_TUNER_TER_CARRIER_MODE_E     enCarrierMode;          /**<carrier mode*/              /**<CNcomment:载波模式*/
+    HI_UNF_TUNER_CONSTELLATION_MODE_E   enConstellationMode;    /**<constellation mode*/        /**<CNcomment:星座是否旋转*/
+    HI_UNF_TUNER_TER_FEC_FRAME_MODE_E   enFECFrameMode;         /**<FEC frame length*/          /**<CNcomment:FEC帧长*/
+    HI_UNF_TUNER_TER_MODE_E             enChannelMode;          /**<Base channel or Lite channel, only used in DVB-T2 */            /**<CNcomment:Base或Lite模式，仅用于DVB-T2模式下*/
+    HI_UNF_TUNER_DVBT2_ISSY_E           enDVBT2ISSY;            /**<DVB-T2 ISSY type */        /**<CNcomment:ISSY类型*/
+    HI_UNF_TUNER_TER_STREAM_TYPE_E      enStreamType;           /**<Stream type */             /**<CNcomment:流类型*/
+    HI_U16                              u16CellID;              /**< Cell ID*/                 /**<CNcomment:单元ID*/
+    HI_U16                              u16NetworkID;           /**< NetWork ID*/              /**<CNcomment:网络ID*/
+    HI_U16                              u16SystemID;            /**< System ID*/               /**<CNcomment:系统ID*/
+} HI_UNF_TUNER_TER_SIGNALINFO_S;
+
+/** Structure of the ISDB-T terrestrial transmission signal's detailed information.*/
+/** CNcomment:地面ISDB-T信号详细信息*/
+typedef struct  hiUNF_TUNER_ISDB_T_SIGNALINFO_S
+{
+    HI_U32                                  u32Freq;            /**<Frequency, in kHz */        /**<CNcomment:频率，单位: kHz */
+    HI_U32                                  u32BandWidth;       /**<Band width, in KHz */       /**<CNcomment:带宽，单位KHz */
+    HI_UNF_TUNER_ISDBT_LAYERS_IDENTIFY_U    unISDBTLayers;      /**<the transmission and used information of ISDBT layer*/          /**<CNcomment:ISDBT层正在传输使用信息*/
+    HI_UNF_TUNER_TMCC_INFO_S                stISDBTTMCCInfo;    /**<the para of ISDBT layer*/   /**<CNcomment:ISDBT层参数信息*/
+    HI_UNF_TUNER_FE_GUARD_INTV_E            enGuardIntv;        /**<GI mode*/                   /**<CNcomment:保护间隔模式*/
+    HI_UNF_TUNER_FE_FFT_E                   enFFTMode;          /**<FFT mode*/                  /**<CNcomment:FFT模式*/
+} HI_UNF_TUNER_ISDB_T_SIGNALINFO_S;
+
+/** signal information.*/
+/** CNcomment:TUNER信号属性*/
+typedef struct hiUNF_TUNER_SIGNALINFO_S
+{
+    HI_UNF_TUNER_SIG_TYPE_E enSigType;              /**<Signal transmission type*/    /**<CNcomment:信号类型*/
+
+    union
+    {
+        HI_UNF_TUNER_SAT_SIGNALINFO_S stSat;        /**<Signal info of satellite*/    /**<CNcomment:卫星信号信息*/
+        HI_UNF_TUNER_TER_SIGNALINFO_S stTer;        /**<Signal info of terrestrial*/  /**<CNcomment:地面信号信息*/
+        HI_UNF_TUNER_ISDB_T_SIGNALINFO_S stIsdbT;/**<Signal info of ISDB-T terrestrial*/  /**<CNcomment:地面ISDB-T信号信息*/
+    } unSignalInfo;
+} HI_UNF_TUNER_SIGNALINFO_S;
+
+/** unicable multi-switch port.*/
+/** CNcomment:unicable开关端口枚举*/
+typedef enum hiUNF_TUNER_SATPOSITION_E
+{
+    HI_UNF_TUNER_SATPOSN_A,    /**<unicable switch port A*/    /**<CNcomment:端口A*/
+    HI_UNF_TUNER_SATPOSN_B,    /**<unicable switch port B*/    /**<CNcomment:端口B*/
+    HI_UNF_TUNER_SATPOSN_BUT   /**<Invalid value*/             /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_SATPOSITION_E;
+
+/** LNB configurating parameters*/
+/** CNcomment:LNB配置参数*/
+typedef struct hiUNF_TUNER_FE_LNB_CONFIG_S
+{
+    HI_UNF_TUNER_FE_LNB_TYPE_E  enLNBType;      /**<LNB type*/                              /**<CNcomment:LNB类型*/
+    HI_U32                      u32LowLO;       /**< Low Local Oscillator Frequency, MHz */ /**<CNcomment:LNB低本振频率，单位MHz*/
+    HI_U32                      u32HighLO;      /**< High Local Oscillator Frequency, MHz*/ /**<CNcomment:LNB高本振频率，单位MHz*/
+    HI_U32                      u32MediumLO;      /**< Medium Local Oscillator Frequency, MHz*/ /**<CNcomment:LNB中本振频率，单位MHz*/
+    HI_UNF_TUNER_FE_LNB_BAND_E  enLNBBand;      /**< LNB band, C or Ku */                   /**<CNcomment:LNB波段：C或Ku*/
+
+    /** Structure of the unicable device attribute.*/
+    /** CNcomment:卫星Unicable设备属性*/
+    HI_U8 u8UNIC_SCRNO;                         /**< SCR number, 0-31 */                     /**<CNcomment:SCR序号，取值为0-31*/
+    HI_U32 u32UNICIFFreqMHz;                    /**< SCR IF frequency, unit MHz */          /**<CNcomment:SCR中频频率， 单位MHz*/
+    HI_UNF_TUNER_SATPOSITION_E enSatPosn;       /**< unicable multi-switch port */          /**<CNcomment:unicable开关端口号*/
+    HI_BOOL bPinProtect;                        /**< UB with pin protect */                     /**<CNcomment:用户频段pin码保护*/
+} HI_UNF_TUNER_FE_LNB_CONFIG_S;
+
+/** tuner attribution.*/
+/** CNcomment:TUNER属性*/
+typedef struct  hiHI_UNF_TUNER_ATTR_S
+{
+    HI_UNF_TUNER_SIG_TYPE_E     enSigType;          /**<Signal type*/                               /**<CNcomment:信号类型*/
+    HI_UNF_TUNER_DEV_TYPE_E     enTunerDevType;     /**<Tuner type*/                                /**<CNcomment:TUNER类型*/
+    HI_U32                      u32TunerAddr;       /*The i2c address of tuner, if demod type is 3130I,3130E or J83B, you cannot set it*/
+    HI_UNF_DEMOD_DEV_TYPE_E     enDemodDevType;     /**<QAM type*/                                  /**<CNcomment:QAM类型*/
+    HI_U32                      u32DemodAddr;       /*The i2c address of demod, if demod type is 3130I,3130E or J83B, you cannot set it*/
+    HI_UNF_TUNER_OUPUT_MODE_E   enOutputMode ;      /**<Output mode of transport streams (TSs)*/    /**<CNcomment:TS流输出模式*/
+    HI_U8                       enI2cChannel;       /**<I2C channel used by the demod*/             /**<CNcomment:DEMOD使用的I2C通道*/
+    HI_U8                       enTunerI2cChannel;  /**<I2C channel used by the tuner*/             /**<CNcomment:TUNER使用的I2C通道，当 tuner和 demod使用不同I2C通道时使用，目前仅限于R858模块使用*/
+    HI_U32                      u32ResetGpioNo;     /**<Demod reset GPIO NO.*/                      /**<CNcomment:复位使用的gpio管脚号*/
+    HI_U32                      u32MemoryMode;      /**<Only valid in Hi3716MV430 DVBT2,0 is low memory mode,1 is high memory mode.Low memory mode default,COMMON PLP is not supported in this mode.*/
+                                                    /**<CNcomment: 仅对Hi3716MV430的DVB-T2有效。 0表示低内存模式，1表示高内存模式。默认为低内存模式，此模式不支持COMMON PLP*/
+} HI_UNF_TUNER_ATTR_S;
+
+/** Frequency locking parameters of the tuner*/
+/** CNcomment:TUNER锁频参数*/
+typedef struct  hiUNF_TUNER_CONNECT_PARA_S
+{
+    HI_UNF_TUNER_SIG_TYPE_E enSigType;          /**<Signal type*/                       /**<CNcomment:信号类型*/
+
+    union
+    {
+        HI_UNF_CAB_CONNECT_PARA_S stCab;        /**<Cable transmission signal*/         /**<CNcomment:CABLE传输信号*/
+        HI_UNF_TER_CONNECT_PARA_S stTer;        /**<Terrestrial transmission signal*/   /**<CNcomment:地面传输信号*/
+        HI_UNF_SAT_CONNECT_PARA_S stSat;        /**<Satellite transmission signal*/     /**<CNcomment:卫星传输信号*/
+    } unConnectPara;
+} HI_UNF_TUNER_CONNECT_PARA_S ;
+
+/** Frequency locking status and parameters of the tuner*/
+/** CNcomment:TUNER锁频状态和锁频参数*/
+typedef struct  hiUNF_TUNER_STATUS_S
+{
+    HI_UNF_TUNER_LOCK_STATUS_E  enLockStatus ;  /**<Frequency locking status*/               /**<CNcomment:锁频状态*/
+    HI_UNF_TUNER_CONNECT_PARA_S stConnectPara;  /**<Actual frequency locking parameters*/    /**<CNcomment:实际锁频参数*/
+} HI_UNF_TUNER_STATUS_S;
+
+/** Tuner blind scan type*/
+/** CNcomment:TUNER盲扫方式*/
+typedef enum hiUNF_TUNER_BLINDSCAN_MODE_E
+{
+    HI_UNF_TUNER_BLINDSCAN_MODE_AUTO = 0,       /**<Blind scan automatically*/  /**<CNcomment:自动扫描*/
+    HI_UNF_TUNER_BLINDSCAN_MODE_MANUAL,         /**<Blind scan manually*/       /**<CNcomment:手动扫描*/
+    HI_UNF_TUNER_BLINDSCAN_MODE_BUTT            /**<Invalid value*/             /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_BLINDSCAN_MODE_E;
+
+/** Definition of blind scan event type*/
+/** CNcomment:TUNER盲扫事件*/
+typedef enum hiUNF_TUNER_BLINDSCAN_EVT_E
+{
+    HI_UNF_TUNER_BLINDSCAN_EVT_STATUS,          /**<New status*/        /**<CNcomment:状态变化*/
+    HI_UNF_TUNER_BLINDSCAN_EVT_PROGRESS,        /**<New Porgress */     /**<CNcomment:进度变化*/
+    HI_UNF_TUNER_BLINDSCAN_EVT_NEWRESULT,       /**<Find new channel*/  /**<CNcomment:新频点*/
+    HI_UNF_TUNER_BLINDSCAN_EVT_BUTT             /**<Invalid value*/     /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_BLINDSCAN_EVT_E;
+
+/** Definition of tuner blind scan status*/
+/** CNcomment:TUNER盲扫状态*/
+typedef enum hiUNF_TUNER_BLINDSCAN_STATUS_E
+{
+    HI_UNF_TUNER_BLINDSCAN_STATUS_IDLE,         /**<Idel*/              /**<CNcomment:空闲*/
+    HI_UNF_TUNER_BLINDSCAN_STATUS_SCANNING,     /**<Scanning*/          /**<CNcomment:扫描中*/
+    HI_UNF_TUNER_BLINDSCAN_STATUS_FINISH,       /**<Finish*/            /**<CNcomment:成功完成*/
+    HI_UNF_TUNER_BLINDSCAN_STATUS_QUIT,         /**<User quit*/         /**<CNcomment:用户退出*/
+    HI_UNF_TUNER_BLINDSCAN_STATUS_FAIL,         /**<Scan fail*/         /**<CNcomment:扫描失败*/
+    HI_UNF_TUNER_BLINDSCAN_STATUS_BUTT          /**<Invalid value*/     /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_BLINDSCAN_STATUS_E;
+
+typedef enum hiUNF_TUNER_UNICABLE_SCAN_STATUS_E
+{
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_IDLE,         /**<Idel*/              /**<CNcomment:空闲*/
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_SCANNING,     /**<Scanning*/          /**<CNcomment:扫描中*/
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_FINISH,       /**<Finish*/            /**<CNcomment:成功完成*/
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_QUIT,         /**<User quit*/         /**<CNcomment:用户退出*/
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_FAIL,         /**<Scan fail*/         /**<CNcomment:扫描失败*/
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_BUTT          /**<Invalid value*/     /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_UNICABLE_SCAN_STATUS_E;
+
+/** Structure of satellite TP*/
+/** CNcomment:TUNER扫出TP信息*/
+typedef struct  hiUNF_TUNER_SAT_TPINFO_S
+{
+    HI_U32                          u32Freq;            /**<Downlink frequency, in kHz*/    /**<CNcomment:下行频率，单位：kHz*/
+    HI_U32                          u32SymbolRate;      /**<Symbol rate, in bit/s*/         /**<CNcomment:符号率，单位bps */
+    HI_UNF_TUNER_FE_POLARIZATION_E  enPolar;            /**<Polarization type*/             /**<CNcomment:极化方式*/
+    HI_U8                           cbs_reliablity;     /**<TP reliability*/                /**<CNcomment:TP的可靠度*/
+} HI_UNF_TUNER_SAT_TPINFO_S;
+
+/** Structure of terrestrial tp information*/
+/** CNcomment:地面机频点信息*/
+typedef struct hiUNF_TUNER_TER_CHANNEL_ATTR_S
+{
+    HI_U32 u32Frequency;        /**<frequency of TP,unit KHz*/                /**<CNcomment:频点的频率，单位是KHz*/
+    HI_U32 u32BandWidth;        /**<BandWidth of TP,unit KHz*/                /**<CNcomment:频点的带宽，单位是KHz*/
+    HI_U8  u8DVBTMode;          /**<signal type.0--DVB-T2,1--DVB-T*/          /**<CNcomment:信号类型.0--DVB-T2,1--DVB-T*/
+    HI_U8  u8PlpIndex;          /**<plp index*/                               /**<CNcomment:物理层管道索引号*/
+    HI_U8  u8PlpId;             /**<plp id*/                                  /**<CNcomment:物理层管道ID*/
+    HI_U8  u8CommId;            /**<common plp id*/                           /**<CNcomment:共享物理层管道ID*/
+    HI_U8  u8Combination;       /**<plp combination flag*/                    /**<CNcomment:数据物理层管道和共享物理层管道是否组合标志*/
+    HI_UNF_TUNER_TER_MODE_E     enChannelMode;  /**<channel attribute*/             /**<CNcomment:通道属性*/
+    HI_UNF_TUNER_TS_PRIORITY_E  enTSPri;        /**<TS priority, only in DVB-T*/    /**<CNcomment:TS优先级模式，仅用于DVB-T*/
+} HI_UNF_TUNER_TER_CHANNEL_ATTR_S;
+
+/** Notify structure of tuner blind scan */
+/** CNcomment:TUNER盲扫通知信息*/
+typedef union hiUNF_TUNER_BLINDSCAN_NOTIFY_U
+{
+    HI_UNF_TUNER_BLINDSCAN_STATUS_E* penStatus;             /**<Scanning status*/            /**<CNcomment:盲扫状态*/
+    HI_U16*                          pu16ProgressPercent;   /**<Scanning progress*/          /**<CNcomment:盲扫进度*/
+    HI_UNF_TUNER_SAT_TPINFO_S* pstResult;                   /**<Scanning result*/            /**<CNcomment:盲扫结果*/
+} HI_UNF_TUNER_BLINDSCAN_NOTIFY_U;
+
+/** Parameter of the satellite tuner blind scan */
+/** CNcomment:卫星TUNER盲扫参数*/
+typedef struct hiUNF_TUNER_SAT_BLINDSCAN_PARA_S
+{
+    /**<LNB Polarization type, only take effect in manual blind scan mode*/
+    /**<CNcomment:LNB极化方式，自动扫描模式设置无效*/
+    HI_UNF_TUNER_FE_POLARIZATION_E enPolar;
+
+    /**<LNB 22K signal status, for Ku band LNB which has dual LO, 22K ON will select high LO and 22K off select low LO,
+        only take effect in manual blind scan mode*/
+    /**<CNcomment:LNB 22K状态，对于Ku波段双本振LNB，ON选择高本振，OFF选择低本振，自动扫描模式设置无效*/
+    HI_UNF_TUNER_FE_LNB_22K_E      enLNB22K;
+
+    /**<Blind scan start IF, in kHz, only take effect in manual blind scan mode */
+    /**<CNcomment:盲扫起始频率(中频)，单位：kHz，自动扫描模式设置无效*/
+    HI_U32                         u32StartFreq;
+
+    /**<Blind scan stop IF, in kHz, only take effect in manual blind scan mode */
+    /**<CNcomment:盲扫结束频率(中频)，单位：kHz，自动扫描模式设置无效*/
+    HI_U32                         u32StopFreq;
+
+    /**<The execution of the blind scan may change the 13/18V or 22K status.
+        If you use any DiSEqC device which need send command when 13/18V or 22K status change,
+        you should registe a callback here. Otherwise, you can set NULL here.*/
+    /**<CNcomment:盲扫过程可能会切换极化方式和22K，如果你用了某些DiSEqC设备需要设置13/18V和22K的，
+        请注册这个回调，如果没有用，请可传NULL */
+    HI_VOID (*pfnDISEQCSet)(HI_U32 u32TunerId, HI_UNF_TUNER_FE_POLARIZATION_E enPolar,
+                            HI_UNF_TUNER_FE_LNB_22K_E enLNB22K);
+
+    /**<Callback when scan status change, scan progress change or find new channel.*/
+    /**<CNcomment:扫描状态或进度百分比发生变化时、发现新的频点时回调*/
+    HI_VOID (*pfnEVTNotify)(HI_U32 u32TunerId, HI_UNF_TUNER_BLINDSCAN_EVT_E enEVT, HI_UNF_TUNER_BLINDSCAN_NOTIFY_U * punNotify);
+} HI_UNF_TUNER_SAT_BLINDSCAN_PARA_S;
+
+typedef enum hiUNF_TUNER_UNICABLE_SCAN_USER_BAND_EVT_E
+{
+    HI_UNF_TUNER_UNICABLE_SCAN_EVT_STATUS,          /**<New status*/        /**<CNcomment:状态变化*/
+    HI_UNF_TUNER_UNICABLE_SCAN_EVT_PROGRESS,        /**<New Porgress */     /**<CNcomment:进度变化*/
+    HI_UNF_TUNER_UNICABLE_SCAN_EVT_BUTT             /**<Invalid value*/     /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_UNICABLE_SCAN_USER_BAND_EVT_E;
+
+typedef union hiUNF_TUNER_UNICABLE_SCAN_USER_BAND_NOTIFY_S
+{
+    HI_UNF_TUNER_UNICABLE_SCAN_STATUS_E* penStatus;         /**<Scanning status*/   /**<CNcomment:盲扫状态*/
+    HI_U16*                          pu16ProgressPercent;   /**<Scanning progress*/ /**<CNcomment:盲扫进度*/
+} HI_UNF_TUNER_UNICABLE_SCAN_USER_BAND_NOTIFY_S;
+
+/** Structure of terrestrial scan*/
+/** CNcomment:配置TUNER扫描DVB-T/T2信号*/
+typedef struct hiUNF_TUNER_UNICABLE_SCAN_PARA_S
+{
+    HI_VOID (*pfnEVTNotify)(HI_U32 u32TunerId, HI_UNF_TUNER_UNICABLE_SCAN_USER_BAND_EVT_E enEVT, HI_UNF_TUNER_UNICABLE_SCAN_USER_BAND_NOTIFY_S *pNotify);
+} HI_UNF_TUNER_UNICABLE_SCAN_PARA_S;
+
+/** Parameter of the tuner blind scan */
+/** CNcomment:TUNER盲扫参数*/
+typedef struct hiUNF_TUNER_BLINDSCAN_PARA_S
+{
+    HI_UNF_TUNER_BLINDSCAN_MODE_E enMode;            /**<Scanning mode*/            /**<CNcomment:盲扫模式*/
+    union
+    {
+        HI_UNF_TUNER_SAT_BLINDSCAN_PARA_S stSat;    /**<Scanning parameter*/        /**<CNcomment:盲扫参数*/
+    } unScanPara;
+} HI_UNF_TUNER_BLINDSCAN_PARA_S;
+
+/** PLP information */
+/** CNcomment:物理层管道信息*/
+typedef struct hiUNF_TUNER_TER_PLP_INFO_S
+{
+    HI_U8                       u8PlpId;            /**<PLP id*/                /**<CNcomment:物理层管道ID*/
+    HI_U8                       u8PlpGrpId;         /**<PLP group id*/          /**<CNcomment:物理层管道组ID*/
+    HI_UNF_TUNER_T2_PLP_TYPE_E  enPlpType;          /**<PLP type*/              /**<CNcomment:物理层管道类型*/
+} HI_UNF_TUNER_TER_PLP_INFO_S;
+
+/** DiSEqC Level*/
+/** CNcomment:DiSEqC设备版本*/
+typedef enum hiUNF_TUNER_DISEQC_LEVEL_E
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_1_X,      /**<1.x, one way*/                  /**<CNcomment:1.x，单向 */
+    HI_UNF_TUNER_DISEQC_LEVEL_2_X,      /**<2.x, two way, support reply*/   /**<CNcomment:2.x，双向，支持Reply*/
+    HI_UNF_TUNER_DISEQC_LEVEL_BUTT      /**<Invalid value*/                 /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_DISEQC_LEVEL_E;
+
+/** Receive status of DiSEqC reply massage*/
+/** CNcomment:DiSEqC消息接收状态*/
+typedef enum hiUNF_TUNER_DISEQC_RECV_STATUS_E
+{
+    HI_UNF_TUNER_DISEQC_RECV_OK,        /**<Receive successfully*/          /**<CNcomment:接收成功*/
+    HI_UNF_TUNER_DISEQC_RECV_UNSUPPORT, /**<Device don't support reply*/    /**<CNcomment:设备不支持回传*/
+    HI_UNF_TUNER_DISEQC_RECV_TIMEOUT,   /**<Receive timeout*/               /**<CNcomment:接收超时*/
+    HI_UNF_TUNER_DISEQC_RECV_ERROR,     /**<Receive fail*/                  /**<CNcomment:接收出错*/
+    HI_UNF_TUNER_DISEQC_RECV_BUTT       /**<Invalid value*/                 /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_DISEQC_RECV_STATUS_E;
+
+/** Structure of the DiSEqC send massage */
+/** CNcomment:DiSEqC发送消息结构*/
+typedef struct hiUNF_TUNER_DISEQC_SENDMSG_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E     enLevel;        /**<Device level*/                         /**<CNcomment:器件版本*/
+    HI_UNF_TUNER_SWITCH_TONEBURST_E enToneBurst;    /**<Tone Burst */                          /**<CNcomment:tone信号状态*/
+    HI_U8                           au8Msg[HI_UNF_DISEQC_MSG_MAX_LENGTH]; /**<Message data*/   /**<CNcomment:消息字*/
+    HI_U8                           u8Length;       /**<Message length*/                       /**<CNcomment:信息长度*/
+    HI_U8                           u8RepeatTimes;  /**<Message repeat times*/                 /**<CNcomment:重传次数*/
+} HI_UNF_TUNER_DISEQC_SENDMSG_S;
+
+/** Structure of the DiSEqC reply massage */
+/** CNcomment:DiSEqC接收消息结构*/
+typedef struct hiUNF_TUNER_DISEQC_RECVMSG_S
+{
+    HI_UNF_TUNER_DISEQC_RECV_STATUS_E enStatus;     /**<Recieve status*/                                 /**<CNcomment:接收状态*/
+    HI_U8                             au8Msg[HI_UNF_DISEQC_MSG_MAX_LENGTH]; /**<Recieve message data*/   /**<CNcomment:接收数据缓存*/
+    HI_U8                             u8Length;     /**<Recieve message length*/                         /**<CNcomment:接收数据长度*/
+} HI_UNF_TUNER_DISEQC_RECVMSG_S;
+
+typedef struct hiUNF_TUNER_SCR_UB_S
+{
+    HI_U32          u32SCRNo;
+    HI_S32          s32CenterFreq;      /**<Unit MHz*/
+}HI_UNF_TUNER_SCR_UB_S;
+
+/** DiSEqC Switch port*/
+/** CNcomment:DiSEqC开关端口枚举*/
+typedef enum hiUNF_TUNER_DISEQC_SWITCH_PORT_E
+{
+    HI_UNF_TUNER_DISEQC_SWITCH_NONE = 0,         /**<none*/                                 /**<CNcomment:不接开关*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_1,           /**<port1*/                                /**<CNcomment:端口1*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_2,           /**<port2*/                                /**<CNcomment:端口2*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_3,           /**<port3*/                                /**<CNcomment:端口3*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_4,           /**<port4*/                                /**<CNcomment:端口4*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_5,           /**<port5*/                                /**<CNcomment:端口5*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_6,           /**<port6*/                                /**<CNcomment:端口6*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_7,           /**<port7*/                                /**<CNcomment:端口7*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_8,           /**<port8*/                                /**<CNcomment:端口8*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_9,           /**<port9*/                                /**<CNcomment:端口9*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_10,          /**<port10*/                               /**<CNcomment:端口10*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_11,          /**<port11*/                               /**<CNcomment:端口11*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_12,          /**<port12*/                               /**<CNcomment:端口12*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_13,          /**<port13*/                               /**<CNcomment:端口13*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_14,          /**<port14*/                               /**<CNcomment:端口14*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_15,          /**<port15*/                               /**<CNcomment:端口15*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_16,          /**<port16*/                               /**<CNcomment:端口16*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_BUTT         /**<Invalid value*/                        /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_DISEQC_SWITCH_PORT_E;
+
+/** Parameter for DiSEqC 1.0/2.0 switch
+   Some DiSEqC device need set polarization(13/18V) and 22K, you can set them here. */
+/** CNcomment:DiSEqC 1.0/2.0 开关参数
+   有些DiSEqC设备需要设置极化方式和22K的，如果用了这种设备，需要在这里设置 */
+typedef struct hiUNF_TUNER_DISEQC_SWITCH4PORT_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E       enLevel;  /**<DiSEqC device level*/           /**<CNcomment:器件版本*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_E enPort;   /**<DiSEqC switch port*/            /**<CNcomment:选通端口号*/
+    HI_UNF_TUNER_FE_POLARIZATION_E    enPolar;  /**<Polarization type */            /**<CNcomment:极化方式*/
+    HI_UNF_TUNER_FE_LNB_22K_E         enLNB22K; /**<22K status*/                    /**<CNcomment:22k状态*/
+} HI_UNF_TUNER_DISEQC_SWITCH4PORT_S;
+
+/** Parameter for DiSEqC 1.1/2.1 switch */
+/** CNcomment:DiSEqC 1.1/2.1 开关参数 */
+typedef struct hiUNF_TUNER_DISEQC_SWITCH16PORT_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E       enLevel;  /**<DiSEqC device level*/            /**<CNcomment:器件版本*/
+    HI_UNF_TUNER_DISEQC_SWITCH_PORT_E enPort;   /**<DiSEqC switch port*/             /**<CNcomment:选通端口号*/
+} HI_UNF_TUNER_DISEQC_SWITCH16PORT_S;
+
+/** DiSEqC motor limit setting*/
+/** CNcomment:DiSEqC马达极限设置*/
+typedef enum hiUNF_TUNER_DISEQC_LIMIT_E
+{
+    HI_UNF_TUNER_DISEQC_LIMIT_OFF,              /**<Disable Limits*/                /**<CNcomment:无限制*/
+    HI_UNF_TUNER_DISEQC_LIMIT_EAST,             /**<Set East Limit*/                /**<CNcomment:东向限制*/
+    HI_UNF_TUNER_DISEQC_LIMIT_WEST,             /**<Set West Limit*/                /**<CNcomment:西向限制*/
+    HI_UNF_TUNER_DISEQC_LIMIT_BUTT              /**<Invalid value*/                 /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_DISEQC_LIMIT_E;
+
+/** Difinition of DiSEqC motor move direction*/
+/** CNcomment:DiSEqC马达移动方向*/
+typedef enum hiUNF_TUNER_DISEQC_MOVE_DIR_E
+{
+    HI_UNF_TUNER_DISEQC_MOVE_DIR_EAST,          /**<Move east*/                     /**<CNcomment:向东移动*/
+    HI_UNF_TUNER_DISEQC_MOVE_DIR_WEST,          /**<Move west*/                     /**<CNcomment:向西移动*/
+    HI_UNF_TUNER_DISEQC_MOVE_DIR_BUTT           /**<Invalid value*/                 /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_DISEQC_MOVE_DIR_E;
+
+/** Difinition of DiSEqC motor move type*/
+/** CNcomment:DiSEqC马达移动方式*/
+typedef enum hiUNF_TUNER_DISEQC_MOVE_TYPE_E
+{
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_SLOW,         /**<1 step one time, default*/      /**<CNcomment:每次转动1 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_SLOW1,        /**<2 step one time*/               /**<CNcomment:每次转动2 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_SLOW2,        /**<3 step one time*/               /**<CNcomment:每次转动3 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_SLOW3,        /**<4 step one time*/               /**<CNcomment:每次转动4 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_SLOW4,        /**<5 step one time*/               /**<CNcomment:每次转动5 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_FAST,         /**<6 step one time*/               /**<CNcomment:每次转动6 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_FAST1,        /**<7 step one time*/               /**<CNcomment:每次转动7 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_FAST2,        /**<8 step one time*/               /**<CNcomment:每次转动8 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_FAST3,        /**<9 step one time*/               /**<CNcomment:每次转动9 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_STEP_FAST4,        /**<10 step one time*/               /**<CNcomment:每次转动10 step*/
+    HI_UNF_TUNER_DISEQC_MOVE_CONTINUE,          /**<Continuous moving*/             /**<CNcomment:连续移动*/
+    HI_UNF_TUNER_DISEQC_MOVE_TYPE_BUTT          /**<Invalid value*/                 /**<CNcomment:非法边界值*/
+} HI_UNF_TUNER_DISEQC_MOVE_TYPE_E;
+
+/** Parameter for DiSEqC motor store position*/
+/** CNcomment:天线存储位置参数*/
+typedef struct hiUNF_TUNER_DISEQC_POSITION_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E enLevel;        /**<DiSEqC device level*/               /**<CNcomment:器件版本*/
+    HI_U32                      u32Pos;         /**<Index of position, 0-255*/          /**<CNcomment:位置序号*/
+} HI_UNF_TUNER_DISEQC_POSITION_S;
+
+/** Parameter for DiSEqC motor limit setting*/
+/** CNcomment:天线Limit设置参数*/
+typedef struct hiUNF_TUNER_DISEQC_LIMIT_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E enLevel;        /**<DiSEqC device level*/               /**<CNcomment:器件版本*/
+    HI_UNF_TUNER_DISEQC_LIMIT_E enLimit;        /**<Limit setting*/                     /**<CNcomment:限制设定*/
+} HI_UNF_TUNER_DISEQC_LIMIT_S;
+
+/** Parameter for DiSEqC motor moving*/
+/** CNcomment:DiSEqC马达移动参数*/
+typedef struct hiUNF_TUNER_DISEQC_MOVE_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E     enLevel;    /**<DiSEqC device level*/           /**<CNcomment:器件版本*/
+    HI_UNF_TUNER_DISEQC_MOVE_DIR_E  enDir;      /**<Moving direction*/              /**<CNcomment:移动方向*/
+    HI_UNF_TUNER_DISEQC_MOVE_TYPE_E enType;     /**<Moving type*/                   /**<CNcomment:移动类型(慢速，快速，连续)*/
+} HI_UNF_TUNER_DISEQC_MOVE_S;
+
+/** Parameter for DiSEqC motor running*/
+/** CNcomment:DiSEqC马达转动参数*/
+typedef struct hiUNF_TUNER_DISEQC_RUN_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E     enLevel;    /**<DiSEqC device level*/           /**<CNcomment:器件版本*/
+    HI_UNF_TUNER_DISEQC_MOVE_DIR_E  enDir;      /**<Moving direction*/              /**<CNcomment:转动方向*/
+    HI_U32                          u32RunningSteps;        /**<0 mean running continus;1~128 mean running steps every time.*/
+                                                            /**<CNcomment:0表示持续转动；1~128之间表示每次转动step数，*/
+} HI_UNF_TUNER_DISEQC_RUN_S;
+
+/** Parameter for DiSEqC motor recalculate*/
+/** CNcomment:DiSEqC天线重计算参数*/
+typedef struct hiUNF_TUNER_DISEQC_RECALCULATE_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E enLevel;        /**<DiSEqC device level*/           /**<CNcomment:器件版本*/
+    HI_U8                       u8Para1;        /**<Parameter 1*/                   /**<CNcomment:参数1*/
+    HI_U8                       u8Para2;        /**<Parameter 2*/                   /**<CNcomment:参数2*/
+    HI_U8                       u8Para3;        /**<Parameter 3*/                   /**<CNcomment:参数3*/
+    HI_U8                       u8Reserve;      /**<Reserve*/                       /**<CNcomment:保留参数*/
+} HI_UNF_TUNER_DISEQC_RECALCULATE_S;
+
+/** Parameter for USALS*/
+/** CNcomment:USALS 参数*/
+typedef struct hiUNF_TUNER_DISEQC_USALS_PARA_S
+{
+    HI_U16 u16LocalLongitude;   /**<local longitude, is 10*longitude, in param, E:0-1800, W:1800-3600(3600-longtitude)*/
+                                /**<CNcomment:本地经度，单位0.1度，东经取值范围0-1800，西经取值范围1800-3600，值为3600-经度值*/
+    HI_U16 u16LocalLatitude;    /**<local latitude, is 10*latitude, in param N:0-900, S:900-1800(1800-latitude)*/
+                                /**<CNcomment:本地纬度，单位0.1度，北纬取值范围0-900，南纬取值范围900-1800，值为1800-纬度值*/
+    HI_U16 u16SatLongitude;     /**<sat longitude, is 10*longitude, in param, E:0-1800, W:1800-3600(3600-longtitude)*/
+                                /**<CNcomment:卫星经度，单位0.1度，东经取值范围0-1800，西经取值范围1800-3600，值为3600-经度值*/
+    HI_U16 u16Angular;          /**<calculate result, out param*/
+                                /**<CNcomment:计算结果，输出参数*/
+} HI_UNF_TUNER_DISEQC_USALS_PARA_S;
+
+/** Parameter for USALS goto angular*/
+/** CNcomment:USALS角度参数*/
+typedef struct hiUNF_TUNER_DISEQC_USALS_ANGULAR_S
+{
+    HI_UNF_TUNER_DISEQC_LEVEL_E enLevel;        /**<DiSEqC device level*/                                       /**<CNcomment:器件版本*/
+    HI_U16                      u16Angular;     /**<Angular, calculated by HI_UNF_TUNER_DISEQC_CalcAngular()*/  /**<CNcomment:角度值，可通过函数HI_UNF_TUNER_DISEQC_CalcAngular计算得到*/
+} HI_UNF_TUNER_DISEQC_USALS_ANGULAR_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      FRONTEND */
+/** @{ */  /** <!-- [FRONTEND] */
+/*---TUNER---*/
+/**
+\brief Initializes the tuner.
+CNcomment:\brief 初始化TUNER设备。CNend
+
+\attention \n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:支持重复初始化TUNER设备，此时直接返回成功。CNend
+\param N/A                                    CNcomment:无 CNend
+\retval ::HI_SUCCESS Success                  CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API系统调用失败 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Init(HI_VOID);
+
+
+/**
+\brief Deinitializes the tuner.
+CNcomment:\brief 去初始化TUNER设备。CNend
+
+\attention \n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:支持重复去初始化TUNER设备，此时直接返回成功。CNend
+\param  N/A                    CNcomment:无 CNend
+\retval ::HI_SUCCESS Success   CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API系统调用失败 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DeInit(HI_VOID);
+
+/**
+\brief  Obtains the default attributes of the tuner.
+CNcomment:\brief  获取TUNER的默认属性。CNend
+\attention \n
+This API is available only after the tuner is initialized.
+CNcomment:此接口在TUNER设备初始化后才能使用。CNend
+\param[in] u32tunerId   tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2。CNend
+\param[out] pstTunerAttr The default attributes of the tuner are returned. CNcomment:返回当前TUNER的默认属性。CNend
+\retval ::HI_SUCCESS Success.                                      CNcomment: 成功 CNend
+\retval ::HI_FAILURE Calling this API fails.                                               CNcomment: API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_INIT  The Frontend module is not initialized. CNcomment: 模块没有初始化CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入PORT 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入PORT 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetDeftAttr(HI_U32  u32tunerId , HI_UNF_TUNER_ATTR_S *pstTunerAttr );
+
+
+/**
+\brief Sets the current attributes of the tuner.
+CNcomment:\brief 设置TUNER当前属性。CNend
+\attention \n
+N/A
+\param[in] u32tunerId   tuner port ID. The port ID can be 0-2.      CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] pstTunerAttr tuner attributes                            CNcomment:TUNER的属性。CNend
+\retval ::HI_SUCCESS Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling this API fails.                       CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_FAILED_SELECTI2CCHANNEL The input I2C channel is invalid. CNcomment:输入I2C 通道非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetAttr(HI_U32  u32tunerId , const HI_UNF_TUNER_ATTR_S *pstTunerAttr );
+
+
+/**
+\brief While using satellite channel, sets the current attributes of the tuner.
+CNcomment:\brief 设置卫星TUNER附加属性。CNend
+\attention \n
+N/A
+\param[in] u32tunerId   tuner port ID. The port ID can be 0-2.      CNcomment:卫星TUNER端口号，取值为0-2 CNend
+\param[in] pstSatTunerAttr tuner attributes                         CNcomment:卫星TUNER的附加属性。CNend
+\retval ::HI_SUCCESS Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling this API fails.                       CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_FAILED_SETSATATTR Tuner TUNER_SETDEMODATTR_CMD error. CNcomment:设置属性失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetSatAttr(HI_U32   u32tunerId , const HI_UNF_TUNER_SAT_ATTR_S *pstSatTunerAttr);
+
+/**
+\brief While using terrestrial channel, sets the current attributes of the tuner.
+CNcomment:\brief 设置地面TUNER附加属性。CNend
+\attention \n
+N/A
+\param[in] u32tunerId   tuner port ID. The port ID can be 0-2.      CNcomment:地面TUNER端口号，取值为0-2 CNend
+\param[in] pstTerTunerAttr tuner attributes                         CNcomment:地面TUNER的附加属性。CNend
+\retval ::HI_SUCCESS Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling this API fails.                       CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_FAILED_SETTERATTR Tuner TUNER_SETDEMODATTR_CMD error. CNcomment:设置属性失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetTerAttr(HI_U32   u32tunerId , const HI_UNF_TUNER_TER_ATTR_S *pstTerTunerAttr);
+
+/**
+\brief While using cable channel, sets the current attributes of the tuner.
+CNcomment:\brief 设置有线TUNER附加属性。CNend
+\attention \n
+N/A
+\param[in] u32tunerId   tuner port ID. The port ID can be 0-2.      CNcomment:地面TUNER端口号，取值为0-2 CNend
+\param[in] pstTerTunerAttr tuner attributes                         CNcomment:地面TUNER的附加属性。CNend
+\retval ::HI_SUCCESS Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling this API fails.                       CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_FAILED_SETTERATTR Tuner TUNER_SETDEMODATTR_CMD error. CNcomment:设置属性失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetCabAttr(HI_U32   u32tunerId , const HI_UNF_TUNER_CAB_ATTR_S *pstTerTunerAttr);
+
+/**
+\brief Obtains the attributes of the tuner.
+CNcomment:\brief 获取TUNER的属性。CNend
+\attention \n
+N/A
+This API is available only after the tuner is initialized.
+CNcomment:此接口在TUNER设备初始化后才能使用。CNend
+
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.                CNcomment:TUNER端口号，取值为0-2 CNend
+\param[out] pstTunerAttr   The current attributes of the tuner are returned. CNcomment:返回当前TUNER的属性。CNend
+\retval ::HI_SUCCESS Success                                                 CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling this API fails.                                CNcomment: API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_INIT  The TUNER module is not initialized. CNcomment: 模块没有初始化CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetAttr(HI_U32  u32tunerId , HI_UNF_TUNER_ATTR_S *pstTunerAttr );
+
+
+/**
+\brief Starts the tuner.
+CNcomment:\brief 打开TUNER设备。CNend
+
+\attention \n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:支持重复打开TUNER设备。此时，直接返回成功。CNend
+
+\param[in] u32tunerId   tuner port ID. The port ID can be 0-2.      CNcomment:TUNER端口号，取值为0-2 CNend
+\retval ::HI_SUCCESS Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_INIT  The TUNER module is not initialized. CNcomment: 模块没有初始化CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_FAILED_INIT  Opening The TUNER module  fails. CNcomment:打开设备失败CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Open (HI_U32    u32tunerId);
+
+
+/**
+\brief Stops the tuner.
+CNcomment:\brief 关闭TUNER设备。CNend
+
+\attention \n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:支持重复关闭TUNER设备。此时，直接返回成功。CNend
+
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.     CNcomment:TUNER端口号，取值为0-2 CNend
+\retval ::HI_SUCCESS Success                                      CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling this API fails.                     CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_INIT  The TUNER module is not initialized. CNcomment: 模块没有初始化CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Close(HI_U32    u32tunerId);
+
+
+/**
+\brief Locks the frequency of the tuner.
+CNcomment:\brief TUNER锁频。CNend
+\attention \n
+N/A
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] pstConnectPara   Information about the frequency of the tuner  CNcomment:TUNER的频点信息。CNend
+\param[in] u32TimeOut  Wait timeout (in ms) when the frequency of the tuner \n
+is locked. The value 0 indicates no wait, and any other value indicates the \n
+maximum wait period.
+                                                                          CNcomment:TUNER的锁定等待超时时间，0为不等待，其他为最长等待时间，单位ms。CNend
+\retval ::HI_SUCCESS Success                                              CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling this API fails.                             CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_FAILED_CONNECT The signal is locked unsuccessfully . CNcomment:锁定频点失败CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Connect(HI_U32  u32tunerId , const HI_UNF_TUNER_CONNECT_PARA_S  *pstConnectPara,HI_U32 u32TimeOut);
+
+
+/**
+\brief  set TS out.CNcomment:设置TS输出 CNend
+\attention \n
+\Please call this API to set TS out. \n
+\There are 12 signals in ts interface, ts_dat[0..7], ts_sync, ts_vld, ts_err, ts_clk.\n
+\There're 12 pins in HI3136 or HI3130v200 chip, and each pin can be set to output ts_dat[0..7], ts_sync,\n
+\ts_vld or ts_err, but ts_clk is binded to one pin, cannot be setted.\n
+CNcomment:ts接口共有12根信号线，分别是ts_dat[0..7], ts_sync, ts_vld, ts_err, ts_clk，HI3136/HI3130V200 芯片上有12个ts管脚，每个管脚可以\n
+配置成除ts_clk之外的任意一个管脚，ts_clk是固定的，不支持配置。其中pstTSOUT->enTSOutput[0..7]，对应芯片TS_OUT0..TS_OUT7管脚;\n
+pstTSOUT->enTSOutput[8..10]，对应芯片TS_SYNC,TS_VALID,TS_ERR管脚。CNend
+
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] pstTSOUT   pointer of ts pin.                                  CNcomment:指针类型，ts管脚定义，请参见::HI_UNF_TUNER_TSOUT_SET_S CNend
+\retval ::HI_SUCCESS                                                      CNcomment: success.成功 CNend
+\retval ::HI_FAILURE  Calling this API fails.                             CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_FAILED_SETTSOUT Setting tsout fails. CNcomment:设置ts out 失败 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_TUNER_SetTSOUT(HI_U32 u32TunerId, HI_UNF_TUNER_TSOUT_SET_S *pstTSOUT);
+
+/**
+\brief Obtains the frequency locking status and parameters of the tuner.
+CNcomment:\brief 获取TUNER锁频状态和锁频参数。CNend
+\attention \n
+N/A
+\param[in] u32tunerId tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] u32TimeOut frequency locking timeout, unit: ms, frequency locking time is related to strength of signal CNcomment:锁频的超时时间，单位是毫秒，锁频时间和信号强度有关系。CNend
+               if you want to get the state of locking, the u32TimeOut should be set 100ms at least;
+               if the u32TimeOut is 0, just config register without locking state, return HI_SUCCESS
+               CNcomment: 如果想得到锁定状态，锁频超时最小设置为100ms；
+                          如果超时时间为0，只配置寄存器，不判定锁定状态，返回HI_SUCCESS。CNend
+\param[out] pstTunerStatus: The current frequency locking status and parameters of the tuner are returned. Note: This parameter is valid only when HI_SUCCESS is returned.  CNcomment: 返回当前TUNER的锁频状态和锁频参数。 注意：此参数只在函数返回成功的情况下才有意义。CNend
+\retval ::HI_SUCCESS Success                    CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling this API fails.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetStatus(HI_U32    u32tunerId , HI_UNF_TUNER_STATUS_S  *pstTunerStatus);
+
+
+/**
+\brief Obtains the current bit error rate (BER) of the tuner. The BER is expressed by using the scientific notation.
+CNcomment:\brief 获取当前TUNER 的误码率，用科学计数法表示。CNend
+\attention \n
+N/A
+\param[in] u32tunerId tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2 CNend
+\param[out] pu32BER  Pointer to the current BER of the tuner The error bit rate consists of three elements. Their definitions are as follows:
+                      Their definitions are as follows:
+                    pu32BER[0]: integral part of the base number of the BER
+                    pu32BER[1]: decimal part of the base number of the BER x 1000
+                    pu32BER[2]: absolute value of the exponential of the BER
+                    For example, if the BER is 2.156E-7, the values of the three elements are
+                    2, 156, and 7 respectively.
+                    The three elements are valid only when HI_SUCCESS is returned.
+                    Otherwise, the application layer sets a large value as required, for example, 0.5 (the values of the three elements are 5, 0, and 1 respectively).
+                         0.5 (the values of the three elements are 5, 0, and 1 respectively).
+CNcomment:\param[out] pu32BER  指向当前TUNER 误码率的指针。该指针指向一个包含三个元素的数组，三个元素含义如下:
+                              pu32BER[0]:误码率底数的整数部分
+                              pu32BER[1]:误码率底数的小数部分乘以1000
+                              pu32BER[2]:误码率指数部分取绝对值
+                              例如:误码率为2.156E-7，那么三个元素的取值分别为
+                              2、156和7
+                              这三个元素只在函数返回成功的情况下才有意义，
+                              否则应用层可根据实际情况自行设置一个较大值(比如0.5，即三个元素分别为5、0、1)。CNend
+\retval ::HI_SUCCESS Success                  CNcomment:成功 CNend
+\retval ::HI_FAILURE Calling this API fails.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment:信号未锁定 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetBER(HI_U32   u32tunerId , HI_U32 *pu32BER);
+
+
+/**
+\brief Obtains the current signal-to-noise ratio (SNR) of the tuner.
+CNcomment:\brief 获取当前TUNER 的信噪比。CNend
+\attention \n
+N/A
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[out] pu32SNR  Pointer to the current SNR of the tuner,SNR unit:dB,not reserves fractional part.
+                    This parameter is valid only when HI_SUCCESS is returned.
+                   Otherwise, the application layer sets the parameter to a small value.
+CNcomment:\param[out] pu32SNR  指向当前TUNER信噪比的指针，信噪比取整单位为dB。
+                              此参数只在函数返回成功的情况下才有意义，
+                              否则，应用层可将此值设置为最小值。CNend
+\retval ::HI_SUCCESS Success                   CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling this API fails.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment:信号未锁定 CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSTATUS Getting status fails. CNcomment:获取信道锁定状态失败 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSNR(HI_U32   u32tunerId , HI_U32 *pu32SNR );
+
+/**
+\brief Obtains the current precise signal-to-noise ratio (SNR) of the tuner.
+CNcomment:\brief 获取当前TUNER 的精确信噪比。CNend
+\attention \n
+N/A
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[out] pdSNR  Pointer to the current SNR of the tuner,SNR unit:dB,and reserves fractional part.
+                    This parameter is valid only when HI_SUCCESS is returned.
+                   Otherwise, the application layer sets the parameter to a small value.
+CNcomment:\param[out] pdSNR  指向当前TUNER信噪比的指针，信噪比单位为dB且保留小数部分。
+                              此参数只在函数返回成功的情况下才有意义，
+                              否则，应用层可将此值设置为最小值。CNend
+\retval ::HI_SUCCESS Success                   CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling this API fails.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment:信号未锁定 CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSTATUS Getting status fails. CNcomment:获取信道锁定状态失败 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetPreciseSNR(HI_U32   u32tunerId , HI_DOUBLE *pdSNR );
+
+
+/**
+\brief Obtains the current signal strength of the tuner.
+CNcomment:\brief 获取当前TUNER的信号强度。CNend
+\attention \n
+N/A
+\param[in] u32tunerId  tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[out] pu32SignalStrength  Pointer to the current signal strength of the tuner
+                            For cable signal, the value of *pu32SignalStrength ranges from 20~120.
+                            For satellite signal, the value is 0~100, unit in percent.
+                            For terrestrial signal, the value is 0~100, unit in percent.
+                  This parameter is valid only when HI_SUCCESS is returned.
+                  Otherwise, the application layer sets the parameter to a small value.
+CNcomment:\param[out] pu32SignalStrength  指向当前TUNER信号强度的指针。
+                            对于Cable信号，*pu32SignalStrength的取值范围为20~120
+                            对于Satellite信号，*pu32SignalStrength的取值范围为0~100，单位为百分比
+                            对于Terrestrial信号，*pu32SignalStrength的取值范围为0~100，单位为百分比
+                            此参数只在函数返回成功的情况下才有意义，
+                            否则，应用层可将此值设置为最小值。CNend
+\retval ::HI_SUCCESS Success                  CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling this API fails. CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment:信号未锁定 CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSTATUS Getting status fails. CNcomment:获取信道锁定状态失败 CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSIGNALSTRENGTH Calling this CMD fails. CNcomment:ioctl系统调用失败 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSignalStrength(HI_U32   u32tunerId , HI_U32 *pu32SignalStrength );
+
+/**
+\brief Obtains the current signal quality of the tuner, returns a percentage value.
+CNcomment:\brief 获取当前TUNER的信号质量，返回百分比( 此接口不支持DVB_C 和J83B制式)。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[out] pu32SignalQuality   Output pointer.                       CNcomment:指向信号质量的指针。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment:信号未锁定 CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSTATUS Getting status fails. CNcomment:获取信道锁定状态失败 CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSIGNALQUALITY Calling this CMD fails. CNcomment:ioctl系统调用失败 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSignalQuality(HI_U32 u32TunerId, HI_U32 *pu32SignalQuality);
+
+/**
+\brief Obtains the actual frequency and symbol rate of the current tuner for cable,terrestrial and satellite
+signal, for terrestrial signal, symbol rate means nothing, ignore it.
+CNcomment:\brief 获取当前TUNER的实际频率和符号率。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[out] pu32Freq   Pointer to the current frequency of the tuner. CNcomment:指向当前TUNER频点的指针。CNend
+\param[out] pu32Symb   Points to the current symbol rate.             CNcomment:指向当前符号率 CNend
+\retval ::HI_SUCCESS Success                                          CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling this API fails.                         CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment:信号未锁定 CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSTATUS Getting status fails. CNcomment:获取信道锁定状态失败 CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSIGNALSTRENGTH  Calling this CMD fails. CNcomment:ioctl系统调用失败 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetRealFreqSymb( HI_U32 u32TunerId, HI_U32 *pu32Freq, HI_U32 *pu32Symb );
+
+/**
+\brief Obtains current signal information of the TUNER, used in satellite and terrestrial, not necessary for cable.
+CNcomment:\brief 获取当前TUNER的信号信息。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[out] pstSignalInfo Pointer to a signal info structure.         CNcomment:指向信号信息结构体的指针。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_NOT_CONNECT The signal is droped. CNcomment:信号未锁定 CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSTATUS Getting status fails. CNcomment:获取信道锁定状态失败 CNend
+\retval ::HI_ERR_TUNER_FAILED_GETSIGNALINFO  Calling this CMD fails. CNcomment:ioctl系统调用失败 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSignalInfo(HI_U32 u32TunerId, HI_UNF_TUNER_SIGNALINFO_S *pstSignalInfo);
+
+/**
+\brief Sets the LNB parameter.
+CNcomment:\brief 设置LNB参数。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] pstLNB      Pointer to a LNB parameter structure.          CNcomment:指向LNB参数结构体的指针。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetLNBConfig(HI_U32 u32TunerId, HI_UNF_TUNER_FE_LNB_CONFIG_S *pstLNB);
+
+/**
+\brief Sets the LNB power.
+CNcomment:\brief 设置LNB供电。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] enLNBPower  The enumeration of the LNB power type.         CNcomment:LNB供电方式枚举值。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetLNBPower(HI_U32 u32TunerId, HI_UNF_TUNER_FE_LNB_POWER_E enLNBPower);
+
+/**
+\brief Gets PLP number, only used in DVB-T2.
+CNcomment:\brief 获取物理层管道数量。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[out] pu8PLPNum  The PLP number.                                CNcomment:物理层管道数量。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_FAILED_GETPLPNUM  Calling this CMD fails. CNcomment:ioctl系统调用失败 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetPLPNum(HI_U32 u32TunerId, HI_U8 *pu8PLPNum);
+
+
+
+
+/**
+\brief Sets PLP ID, only used in DVB-T2.
+CNcomment:\brief 设置物理层管道参数。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] pstPLPPara  The PLP parameters.                                       CNcomment:物理层管道参数。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_FAILED_SETPLPID  Calling this CMD fails. CNcomment:ioctl系统调用失败 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetPLPPara(HI_U32 u32TunerId, HI_UNF_TUNER_TER_PLP_PARA_S *pstPLPPara);
+
+/**
+\brief Get PLP information, only used in DVB-T2.
+CNcomment:\brief 获取物理层管道信息。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] u32PLPIndex  PLP index.                                    CNcomment:物理层管道索引号。CNend
+\param[out] pstPLPInfo  The PLP information.                          CNcomment:物理层管道信息。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_FAILED_SETPLPID  Calling this CMD fails. CNcomment:ioctl系统调用失败 CNend
+
+\see \n
+N/A
+*/
+
+HI_S32 HI_UNF_TUNER_GetPLPInfo(HI_U32 u32TunerId, HI_U32 u32PLPIndex, HI_UNF_TUNER_TER_PLP_INFO_S *pstPLPInfo);
+
+/**
+\brief Set antenna power.
+CNcomment:\brief 设置天线电源。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] enPower  The antenna power status.                         CNcomment:天线电源状态。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened.      CNcomment: 模块没有打开 CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid.  CNcomment:输入 参数非法 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetAntennaPower(HI_U32 u32TunerId, HI_UNF_TUNER_TER_ANTENNA_POWER_E enPower);
+
+
+/**
+\brief Starts blind scan.
+CNcomment:\brief 开始盲扫。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] pstPara     The pointer to the blind scan parameter.       CNcomment:指向盲扫参数的指针。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_FAILED_BLINDSCAN Blind scan busy. CNcomment:盲扫正在应用 CNend
+
+\see Please refer to definition of HI_UNF_TUNER_BLINDSCAN_PARA_S.
+N/A
+*/
+HI_S32 HI_UNF_TUNER_BlindScanStart(HI_U32 u32TunerId, const HI_UNF_TUNER_BLINDSCAN_PARA_S *pstPara);
+
+/**
+\brief Stops blind scan.
+CNcomment:\brief 停止盲扫。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_BlindScanStop(HI_U32 u32TunerId);
+
+/**
+\brief TUNER standby.
+CNcomment:\brief TUNER待机(  此接口不支持DVB_C 和J83B制式，此两种制式待机请参见pmoc 待机接口)  CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_FAILED_STANDBY  Calling this CMD fails. CNcomment:ioctl系统调用失败 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Standby(HI_U32 u32TunerId);
+
+/**
+\brief Wakes up TUNER.
+CNcomment:\brief TUNER唤醒(  此接口不支持DVB_C 和J83B制式，此两种制式唤醒请参见pmoc 唤醒唤醒接口) CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_FAILED_WAKEUP  Calling this CMD fails. CNcomment:ioctl系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_WakeUp( HI_U32 u32TunerId);
+/*ZHTQ ADD*/
+HI_S32 TUNER_DISEQC_SendMessage(HI_U32 u32TunerId,
+                                           const HI_UNF_TUNER_DISEQC_SENDMSG_S * pstSendMsg);
+
+HI_S32 TUNER_DISEQC_RecvMessage(HI_U32 u32TunerId,
+                                           HI_UNF_TUNER_DISEQC_RECVMSG_S * pstRecvMsg);
+
+/**
+\brief Sends and receives DiSEqC message, only the devices supporting DiSEqC 2.x support receive message.
+CNcomment:\brief 发送接收DiSEqC消息，仅支持DiSEqC 2.x的设备支持接收消息。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号, 取值范围0-2 CNend
+\param[in] pstSendMsg  The pointer to a sending message structure.    CNcomment:指向发送消息结构体的指针。CNend
+\param[out] pstRecvMsg The pointer to a receiving message structure.If your device is DiSEqC 1.x, you can pass NULL here.
+CNcomment:\param[out] pstRecvMsg 指向接收消息结构体的指针。如果是DiSEqC 1.x设备，这里可以传NULL。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_FAILED_DISEQC Send DiSEqC message fail. CNcomment:发送消息失败 CNend
+\retval ::HI_ERR_TUNER_FAILED_DISEQC Recv DiSEqC message fail. CNcomment:接收消息失败 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_SendRecvMessage(HI_U32 u32TunerId,
+                                           const HI_UNF_TUNER_DISEQC_SENDMSG_S * pstSendMsg,
+                                           HI_UNF_TUNER_DISEQC_RECVMSG_S * pstRecvMsg);
+
+/**
+\brief Sets 0/12V switch. Don't support now.
+CNcomment:\brief 设置0/12V开关状态，暂不支持。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] enPort      The enumeration of the switch port.            CNcomment:开关枚举值。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Switch012V(HI_U32 u32TunerId, HI_UNF_TUNER_SWITCH_0_12V_E enPort);
+
+/**
+\brief Sets 22KHz switch.
+CNcomment:\brief 设置22KHz开关状态。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] enPort      The enumeration of the switch port.            CNcomment:开关枚举值。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_Switch22K(HI_U32 u32TunerId, HI_UNF_TUNER_SWITCH_22K_E enPort);
+
+/**
+\brief Sets tone burst switch.
+CNcomment:\brief 设置Tone burst开关状态。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] enStatus    The enumeration of the switch port.            CNcomment:开关枚举值。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_FAILED_DISEQC  Calling this CMD fails. CNcomment:ioctl系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SwitchToneBurst(HI_U32 u32TunerId, HI_UNF_TUNER_SWITCH_TONEBURST_E enStatus);
+
+//#ifdef DISEQC_SUPPORT
+/**
+\brief Sets DiSEqC 1.0/2.0 switch, at most 4 port.
+CNcomment:\brief 设置DiSEqC 1.0/2.0开关，至多4口。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] pstPara     The pointer to a switch parameter structure.   CNcomment:指向开关参数的指针。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\see Please refer to definition of HI_UNF_TUNER_DISEQC_SWITCH4PORT_S.
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Switch4Port(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_SWITCH4PORT_S* pstPara);
+
+/**
+\brief Sets DiSEqC 1.1/2.1 switch, supports 8in1, 16in1 switches.
+CNcomment:\brief 设置DiSEqC 1.1/2.1开关，支持8口，16口开关。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] pstPara     The pointer to a switch parameter structure.   CNcomment:指向开关参数的指针。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Switch16Port(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_SWITCH16PORT_S* pstPara);
+
+/**
+\brief Lets the DiSEqC motor store current position.
+CNcomment:\brief DiSEqC马达存储当前位置。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] pstPara     The pointer to a position parameter structure. CNcomment:指向位置参数的指针。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_StorePos(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_POSITION_S *pstPara);
+
+/**
+\brief Lets the DiSEqC motor move to stored position.
+CNcomment:\brief DiSEqC马达转动至存储位置。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] pstPara     The pointer to a position parameter structure. CNcomment:指向位置参数的指针。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_GotoPos(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_POSITION_S *pstPara);
+
+/**
+\brief Enables or disables the DiSEqC motor's limit setting.
+CNcomment:\brief 打开、关闭DiSEqC马达权限设置。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] pstPara     The pointer to a limit parameter structure.    CNcomment:指向limit参数的指针。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_SetLimit(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_LIMIT_S* pstPara);
+
+/**
+\brief Drives DiSEqC motor.
+CNcomment:\brief 驱动DiSEqC马达移动，注意HI_UNF_TUNER_DISEQC_Move接口会逐渐被HI_UNF_TUNER_DISEQC_RunStep替代，现阶段不方便切的，可以
+继续使用HI_UNF_TUNER_DISEQC_Move接口，当有HI_UNF_TUNER_DISEQC_RunStep接口时，尽量使用该接口。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] pstPara     The pointer to a movement parameter structure. CNcomment:指向移动参数的指针。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Move(HI_U32 u32TunerId,  HI_UNF_TUNER_DISEQC_MOVE_S* pstPara);
+
+/**
+\brief Drives DiSEqC motor.
+CNcomment:\brief 驱动DiSEqC马达转动。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] pstPara     The pointer to a movement parameter structure. CNcomment:指向移动参数的指针。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_RunStep(HI_U32 u32TunerId,  HI_UNF_TUNER_DISEQC_RUN_S* pstPara);
+
+/**
+\brief Halts DiSEqC motor.
+CNcomment:\brief 停止DiSEqC马达移动。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] enLevel     The command level of the DiSEqC motor.         CNcomment:马达支持的命令等级。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Stop(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_LEVEL_E enLevel);
+
+/**
+\brief Lets the DiSEqC motor recalculate its stored positions.
+CNcomment:\brief 重新计算马达存储位置。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] pstPara     The pointer to a recaulculate parameter structure.
+                                                                      CNcomment:指向重计算参数的指针。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Recalculate(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_RECALCULATE_S* pstPara);
+
+/**
+\brief Calculates the angular, basing on site-longitude, site-latitude and satellite-longitude.
+CNcomment:\brief USALS根据当地经纬度、卫星经度计算卫星角度。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in/out] pstPara The pointer to a USALS parameter structure.    CNcomment:指向USALS计算参数的指针。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_CalcAngular(HI_U32 u32TunerId, HI_UNF_TUNER_DISEQC_USALS_PARA_S* pstPara);
+
+/**
+\brief Gotos the indicated angular.
+CNcomment:\brief USALS设备转至某角度。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] pstPara     The pointer to a USALS angular structure.      CNcomment:指向USALS角度参数的指针。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_GotoAngular(HI_U32 u32TunerId, const HI_UNF_TUNER_DISEQC_USALS_ANGULAR_S* pstPara);
+
+/**
+\brief Resets DiSEqC device.
+CNcomment:\brief 复位DiSEqC设备。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] enLevel     The command level of the DiSEqC device.        CNcomment:设备支持的命令等级。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Reset(HI_U32 u32TunerId, HI_UNF_TUNER_DISEQC_LEVEL_E enLevel);
+
+/**
+\brief DiSEqC device standby.
+CNcomment:\brief DiSEqC设备待机。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] enLevel     The command level of the DiSEqC device.        CNcomment:设备支持的命令等级。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_Standby(HI_U32 u32TunerId, HI_UNF_TUNER_DISEQC_LEVEL_E enLevel);
+
+/**
+\brief Wakes up DiSEqC device.
+CNcomment:\brief 唤醒DiSEqC设备。CNend
+\attention \n
+N/A
+\param[in] u32TunerId  Tuner port ID. The port ID can be 0-2.         CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in] enLevel     The command level of the DiSEqC device.        CNcomment:设备支持的命令等级。CNend
+\retval ::HI_SUCCESS   Success                                        CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                        CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_DISEQC_WakeUp(HI_U32 u32TunerId, HI_UNF_TUNER_DISEQC_LEVEL_E enLevel);
+
+/**
+\brief Acquire data to display constellation.
+CNcomment:\brief 获取星座图数据。CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in]  enDataLen     The sample data length, can be 512, 1024 or 2048.  CNcomment:采集的数据长度, 支持512，1024和2048 3种。CNend
+\param[out] pstData       The buffer to store data.                          CNcomment:数据存储区。CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_FAILED_SAMPLEDATA Tuner sample data fail. CNcomment:获取数据失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetConstellationData(HI_U32 u32TunerId, HI_UNF_TUNER_SAMPLE_DATALEN_E enDataLen, HI_UNF_TUNER_SAMPLE_DATA_S *pstData);
+
+/**
+\brief Acquire data to display spectrum.
+CNcomment:\brief 获取频谱图数据。CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in]  enDataLen     The sample data length, can be 512, 1024 or 2048.  CNcomment:采集的数据长度, 支持512，1024和2048 3种。CNend
+\param[out] pu32Data      The buffer to store data.                          CNcomment:数据存储区。CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_FAILED_SAMPLEDATA Tuner sample data fail. CNcomment:获取数据失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSpectrumData(HI_U32 u32TunerId, HI_UNF_TUNER_SAMPLE_DATALEN_E enDataLen, HI_U32 *pu32Data);
+
+/**
+\brief Get the upper limit time according to the connect parameter.
+CNcomment:\brief 根据锁频参数获取最大锁频时间。CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in]  pstConnectPara     The pointer to store the connect parameter.   CNcomment:锁频参数指针。CNend
+\param[out] pu32TimeOutMs      The upper limit time.                         CNcomment:最大锁台时间。CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_TUNER_NOT_OPEN  The TUNER module is not opened. CNcomment: 模块没有打开CNend
+\retval ::HI_ERR_TUNER_INVALID_PORT  The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_POINT The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\retval ::HI_ERR_TUNER_INVALID_PARA The input parameter is invalid. CNcomment:输入 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetDefaultTimeout(HI_U32  u32tunerId, const HI_UNF_TUNER_CONNECT_PARA_S  *pstConnectPara, HI_U32 *pu32TimeOutMs);
+
+/**
+\brief Set isi id,means selecting the chose vcm stream to receive.
+CNcomment:\brief 当前端是VCM信号时，存在多套流，通过设置流ID，接收指定VCM流。CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in]  u8SCRNO     user band number,u8SCRNO can be SaTCR1-SaTCR8.       CNcomment:unicable设备用户频段号。CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UnicPowerOff(HI_U32 u32TunerId,HI_U8 u8SCRNO);
+
+/**
+\brief Each SaTCR generates a tone at the center frequency of its associated band-pass filter.
+CNcomment: 设置unicable在所有用户频段中心频率处产生一个tone 信号。CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2 CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UnicSCRxOn(HI_U32 u32TunerId);
+
+/**
+\brief Allows to check the application number.
+CNcomment: 检查unicable的产品型号。CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in]  u8SCRNO     user band number,u8SCRNO can be SaTCR1-SaTCR8.       CNcomment:unicable设备用户频段号。CNend
+\param[in]  u8AppNo     application number.   CNcomment:unicable产品型号。CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UnicConfig(HI_U32 u32TunerId,HI_U8 u8SCRNO,HI_U8 u8AppNo);
+
+/**
+\brief Allows to check LNB local oscillator frequencies.
+CNcomment: 检查unicable LNB的本振频率。CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in]  u8SCRNO     user band number,u8SCRNO can be SaTCR1-SaTCR8.       CNcomment:unicable设备用户频段号。CNend
+\param[in]  u8LoFreqNo     local oscillator number.   CNcomment:本振频率号。CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UnicLOFREQ(HI_U32 u32TunerId,HI_U8 u8SCRNO,HI_U8 u8LoFreqNo);
+
+/**
+\brief Set isi id,means selecting the chose vcm stream to receive.
+CNcomment:\brief 当前端是VCM信号时，存在多套流，通过设置流ID，接收指定VCM流。CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2 CNend
+\param[out] u8IsiID       isi id,vcm stream id transmitted by server.        CNcomment:流的ID号。CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetSatIsiID(HI_U32 u32TunerId, HI_U8 u8IsiID);
+
+/**
+\brief Get total vcm streams number.
+CNcomment:\brief 当前端是VCM信号时，获取总共有多少套流。CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in]  *pu32TotalStream      total streams number.                      CNcomment:总共的流数目。CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSatTotalStream(HI_U32 u32TunerId, HI_U8 *pu8TotalStream);
+
+/**
+\brief Get isi id,by setting stream number,will get isi id.
+CNcomment:\brief 当前端是VCM信号时，通过设置流序号，能够获取到流的ID号。CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in]  u8Stream      stream number,can be 0-n.                          CNcomment:流序号。CNend
+\param[out] u8IsiID       isi id,vcm stream id transmitted by server.        CNcomment:流的ID号。CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetSatIsiID(HI_U32 u32TunerId, HI_U8 u8StreamIndex, HI_U8 *pu8IsiID);
+
+/**
+\brief scan 950~2150 frequency range,and find out the user bands.
+CNcomment: 扫描950~2150MHz频率范围，并找出用户频段。CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2 CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UNICABLE_ScanUserBands(HI_U32 u32TunerId, HI_UNF_TUNER_UNICABLE_SCAN_PARA_S stScanPara);
+
+/**
+\brief exit from user band scanning .
+CNcomment: 中止用户频点扫描。CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2 CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UNICABLE_ExitScanUserBands(HI_U32 u32TunerId);
+
+/**
+\brief get user band number after finishing scan .
+CNcomment: 搜索结束后获取找到的用户频段总数。CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2 CNend
+\param[out] pu32UbNum    Total number of user band after finishing scan.     CNcomment:搜索结束后找到的用户频段总个数。CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UNICABLE_GetUserBandsNum(HI_U32 u32TunerId, HI_U32 *pu32UbNum);
+
+/**
+\brief Copy scanned results,get user bands information.
+CNcomment: 拷贝扫描结果，获取扫描到的所有用户频段信息。CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2 CNend
+\param[out] pstUbInfo     user bands information struct array,used to save user band number/user band frequency.       CNcomment:用户频段信息结构体数组，用于存储用户频段号，用户频率信息。CNend
+\param[in]  u32UbInfoNum  the number of user bands information structs.      CNcomment:用户频段信息结构体个数。CNend
+\param[out]  pu32Num     the number of user bands actual obtained.           CNcomment:实际获取到的用户频段个数。CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_UNICABLE_GetUserBandsInfo(HI_U32 u32TunerId, HI_UNF_TUNER_SCR_UB_S *pstUbInfo, HI_U32 u32UbInfoNum, HI_U32 *pu32Num);
+
+/**
+\brief config the scrambing code sequces on physical layer.
+CNcomment: 设置物理层扰码初始相位。CNend
+\attention \n
+N/A
+\param[in]  u32TunerId           Tuner port ID. The port ID can be 0-2.      CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in]  u32ScrambleValue     Initial scrambling code. Range 0-262141,
+                                when value is not 0, signal is special       CNcomment:初始化扰码，取值为0-262141，非0时为特殊信号 CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_SetScramble(HI_U32 u32TunerId, HI_U32 u32ScrambleValue);
+
+/**
+\brief Acquire data to display spectrum.
+CNcomment:\brief 获取全频段频谱的数据。CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.                                                                          CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in]  u32freqStartInHz     The sample data start freqency (Hz), For examle: 435000000 Hz, 698000000 Hz (1000HZ~1300000000HZ).     CNcomment:采集的数据开始频点( 赫兹)，例如: 435000000 Hz,698000000 Hz(范围: 1000HZ~1300000000HZ)。CNend
+\param[in]  u32freqStepInHz     The sample data step(Hz), For examle: 10000 Hz, 20000 Hz (greater than 10000Hz).                CNcomment:采集的数据步长( 赫兹)，例如: 10000 Hz,20000 Hz (范围: 10000Hz 以上)。CNend
+\param[in]  u32numOfFreqSteps     The sample data number, For examle: 1000, 10000.                                          CNcomment:采集的数据个数，例如: 1000,10000。CNend
+\param[out] ps16powerData      The buffer to store data.                                                                                      CNcomment:数据存储区。CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_GetTunerPowerSpectrumData(HI_U32 u32TunerId, HI_U32 u32freqStartInHz,HI_U32 u32freqStepInHz,HI_U32 u32numOfFreqSteps,HI_S16 *ps16powerData);
+
+/**
+\brief config which ISDBT layer is select to receive.
+CNcomment: 对ISDBT信号，可选择性的配置层信息，比如A/B/C层中的哪一层信号需要接收。CNend
+\attention \n
+N/A
+\param[in]  u32TunerId    Tuner port ID. The port ID can be 0-2.             CNcomment:TUNER端口号，取值为0-2 CNend
+\param[in]  pstMonLayersConfig    the layers configuration.                              CNcomment:层配置信息 CNend
+\retval ::HI_SUCCESS   Success                                               CNcomment:成功 CNend
+\retval ::HI_FAILURE   Calling this API fails.                               CNcomment:API系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_TUNER_MonitorISDBTLayer(HI_U32 u32TunerId, HI_UNF_TUNER_MONITOR_LAYERS_CONFIG_S *pstMonLayersConfig);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_ECS_TYPE_H__ */
+
diff -uNr a/include/hi_unf_gpio.h b/include/hi_unf_gpio.h
--- a/include/hi_unf_gpio.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_gpio.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,269 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+******************************************************************************
+ File Name     : hi_unf_gpio.h
+Version       : Initial draft
+Author        : HiSilicon multimedia software group
+Created Date   : 2008-06-05
+Last Modified by:
+Description   : Application programming interfaces (APIs) of the external chip software (ECS)
+Function List :
+Change History:
+******************************************************************************/
+#ifndef __HI_UNF_GPIO_H__
+#define __HI_UNF_GPIO_H__
+
+#include "hi_common.h"
+#include "hi_error_mpi.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      GPIO */
+/** @{*/  /** <!-- [GPIO] */
+
+#define HI_UNF_GPIO_Open  HI_UNF_GPIO_Init
+#define HI_UNF_GPIO_Close HI_UNF_GPIO_DeInit
+
+/**type of GPIO interrupt*/
+/** CNcomment:GPIO 中断类型*/
+typedef enum hiUNF_GPIO_INTTYPE_E
+{
+    HI_UNF_GPIO_INTTYPE_UP, /**<spring by the up edge*/                 /**< CNcomment:上升沿触发*/
+    HI_UNF_GPIO_INTTYPE_DOWN, /**<spring by the down edge*/               /**< CNcomment:下降沿触发*/
+    HI_UNF_GPIO_INTTYPE_UPDOWN, /**<spring by both the up and down edge*/   /**< CNcomment:双沿触发*/
+    HI_UNF_GPIO_INTTYPE_HIGH, /**<spring by the high level*/              /**< CNcomment:高电平触发*/
+    HI_UNF_GPIO_INTTYPE_LOW, /**<spring by the low level*/               /**< CNcomment:低电平触发*/
+    HI_UNF_GPIO_INTTYPE_BUTT, /**<Invalid value*/                        /**< CNcomment:非法边界值*/
+} HI_UNF_GPIO_INTTYPE_E;
+
+/**GPIO output type*/
+/** CNcomment:GPIO 输出类型*/
+typedef enum hiUNF_GPIO_OUTPUTTYPE_E
+{
+	HI_UNF_GPIO_OUTPUTTYPE_CMOS,
+	HI_UNF_GPIO_OUTPUTTYPE_OD,
+	HI_UNF_GPIO_OUTPUTTYPE_BUTT,		
+}HI_UNF_GPIO_OUTPUTTYPE_E;
+
+/** @}*/  /** <!-- ==== Structure Definition End ====*/
+
+
+
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      GPIO*/
+/** @{*/  /** <!-- [GPIO] */
+
+/**
+ \brief Starts the general-purpose input/output (GPIO) device.
+CNcomment:\brief 打开GPIO（General Purpose Input/Output）设备。CNend
+
+ \attention \n
+This API can be called repeatedly.
+CNcomment:重复打开会成功。CNend
+
+ \param  N/A       CNcomment:无。CNend
+ \retval 0 Success. CNcomment:成功。CNend
+ \retval ::HI_FAILURE			Initialize GPIO failed.                 	CNcomment:打开GPIO失败。CNend
+ \retval ::HI_ERR_GPIO_OPEN_ERR  Initialize GPIO failed.                 	CNcomment:打开GPIO失败。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_Init(HI_VOID);
+
+/**
+ \brief Stops the GPIO device.
+CNcomment:\brief 关闭GPIO设备。CNend
+
+ \attention \n
+This API can be called repeatedly.
+CNcomment:重复关闭会成功。CNend
+ \param  N/A  CNcomment:无。CNend
+ \retval 0 Success. CNcomment:成功。CNend
+ \retval ::HI_ERR_GPIO_CLOSE_ERR  Deinitialize GPIO failed.                 	CNcomment:打开GPIO失败。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_DeInit(HI_VOID);
+
+/**
+ \brief Reads data from a GPIO pin.
+CNcomment:\brief 从GPIO单个引脚读取数据。CNend
+
+ \attention The pin number is defined as follows: Pin number = GPIO group ID x 8 + GPIO pin ID in the group\n
+For example, GPIO1_2 indicates pin 2 in group 1, and the pin number is 10 (1 x 8 + 2).\n
+Both pin group ID and pin number are numbered from 0. Each HD chip provides GPIO pins number reference to HD chip hardware manual.\n
+CNcomment:\attention 管脚号计算规则: 管脚号 = GPIO组号*8 + GPIO管脚在组内的遍号。\n
+比如GPIO1_2,代表第1组第2脚，那么管脚号=1*8+2=10。\n
+GPIO的组号和管脚号的编号都从0开始。高清芯片提供的gpio管脚数请参考相关的芯片硬件手册\n CNend
+
+ \param[in] u32GpioNo  Pin number, ranging from 0 to 103, ranging is different in otherness chip type     CNcomment:管脚号，取值范围为0～103，不同的芯片类型范围不一样。CNend
+ \param[out] pbHighVolt   Pointer to the input level of a pin.  CNcomment:指针类型，返回管脚输入或者输出电平。CNend
+ \retval 0 Success. CNcomment:成功。CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA	 Parameters Invalid.                 		CNcomment:非法参数。CNend
+ \retval ::HI_ERR_GPIO_NULL_PTR  Pointer Parameters is NULL.                 	CNcomment:指针参数为空指针。CNend
+ \retval ::HI_ERR_GPIO_NOT_INIT  GPIO module is not initialiazed.              	CNcomment:GPIO模块没有初始化。CNend
+ \retval ::HI_ERR_GPIO_INVALID_OPT  Invalid Operation.              			CNcomment:非法操作。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_ReadBit(HI_U32 u32GpioNo, HI_BOOL  *pbHighVolt);
+
+/**
+ \brief Writes data to a GPIO pin.
+CNcomment:\brief 向GPIO单个引脚输出数据。CNend
+ \attention \n
+N/A
+ \param[in] u32GpioNo  Pin number, ranging from 0 to 103, ranging is different in otherness chip type     CNcomment:管脚号，取值范围为0～103，不同的芯片类型范围不一样。CNend
+ \param[in] bHighVolt  Output level of a pin              CNcomment:管脚输出电平。CNend
+                      0: low level                       CNcomment:0: 低电平 CNend
+                      1: high level                      CNcomment:1：高电平 CNend
+                     Others: high level                  CNcomment:其他：高电平。CNend
+ \retval 0 Success. CNcomment:成功。CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA	 Parameters Invalid.                 		CNcomment:非法参数。CNend
+ \retval ::HI_ERR_GPIO_NOT_INIT  GPIO module is not initialiazed.              	CNcomment:GPIO模块没有初始化。CNend
+ \retval ::HI_ERR_GPIO_INVALID_OPT  Invalid Operation.              			CNcomment:非法操作。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_WriteBit(HI_U32 u32GpioNo, HI_BOOL bHighVolt );
+
+/**
+ \brief Sets the direction (input or output) of a GPIO pin.
+CNcomment:\brief 设置GPIO单个引脚输入输出方向。CNend
+
+ \attention \n
+When setting the operating mode of a GPIO pin, ensure that it works in GPIO mode only.\n
+This is because the GPIO pin may be multiplexed.\n
+CNcomment:设置对应管脚的工作方式时，必须保证该管脚仅工作在GPIO模式下，GPIO管脚有可能被复用。CNend
+
+ \param[in] u32GpioNo  Pin number, ranging from 0 to 103, ranging is different in otherness chip type     CNcomment:管脚号，取值范围为0～103，不同的芯片类型范围不一样。CNend
+ \param[in] bInput  Boolean variable that indicates the direction of a pin  CNcomment:布尔变量，标识管脚方向。CNend
+                   HI_TRUE: input pin  HI_TRUE.                           CNcomment:该管脚用于输入。CNend
+                   HI_FALSE: output pin HI_FALSE.                         CNcomment:该管脚用于输出。CNend
+ \retval 0 Success. CNcomment:成功。CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA	 Parameters Invalid.                 		CNcomment:非法参数。CNend
+ \retval ::HI_ERR_GPIO_NOT_INIT  GPIO module is not initialiazed.              	CNcomment:GPIO模块没有初始化。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_SetDirBit(HI_U32 u32GpioNo, HI_BOOL bInput);
+
+/**
+ \brief Obtains the direction (input or output) of a GPIO pin.
+CNcomment:\brief 获取GPIO单个引脚输入输出方向。CNend
+
+ \attention \n
+N/A
+ \param[in] u32GpioNo  Pin number, ranging from 0 to 103, ranging is different in otherness chip type.     CNcomment:管脚号，取值范围为0～103，不同的芯片类型范围不一样。CNend
+ \param[out] pbInput   Pointer to the boolean variable that indicates the direction of a pin.  CNcomment:指针类型，指向布尔型变量，用来返回管脚方向。CNend
+ \retval 0 Success. CNcomment:成功。CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA	 Parameters Invalid.                 		CNcomment:非法参数。CNend
+ \retval ::HI_ERR_GPIO_NULL_PTR  Pointer Parameters is NULL.                 	CNcomment:指针参数为空指针。CNend
+ \retval ::HI_ERR_GPIO_NOT_INIT  GPIO module is not initialiazed.              	CNcomment:GPIO模块没有初始化。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_GetDirBit(HI_U32 u32GpioNo, HI_BOOL    *pbInput);
+
+/**
+ \brief Starts the cipher device.
+CNcomment:\brief 设置GPIO单个引脚的中断类型。CNend
+
+ \attention \n
+N/A
+ \param[in] u32GpioNo  Pin number, ranging from 0 to 103, ranging is different in otherness chip type     CNcomment:管脚号，取值范围为0～103，不同的芯片类型范围不一样。CNend
+ \param[in] enIntType    interrupt type                                CNcomment:中断类型。CNend
+ \retval 0 Success. CNcomment:成功。CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA	 Parameters Invalid.                 		CNcomment:非法参数。CNend
+ \retval ::HI_ERR_GPIO_INTTYPE_NOT_SUPPORT  interupt type is not support.       CNcomment:不支持的中断类型。CNend
+ \retval ::HI_ERR_GPIO_NOT_INIT  GPIO module is not initialiazed.              	CNcomment:GPIO模块没有初始化。CNend
+ \retval ::HI_ERR_GPIO_FAILED_SETINT  set interupt type failed.              	CNcomment:设置中断类型失败。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_SetIntType(HI_U32 u32GpioNo, HI_UNF_GPIO_INTTYPE_E enIntType);
+
+/**
+ \brief set GPIO single pin interrupt enable
+CNcomment:\brief 设置GPIO单个引脚的中断使能。CNend
+ \attention \n
+interrupte type HI_UNF_GPIO_INTTYPE_LOW and HI_UNF_GPIO_INTTYPE_HIGH is not support
+CNcomment:不支持HI_UNF_GPIO_INTTYPE_LOW 和 HI_UNF_GPIO_INTTYPE_HIGH中断类型。CNend
+ \param[in] u32GpioNo  Pin number, ranging from 0 to 103, ranging is different in otherness chip type     CNcomment:管脚号，取值范围为0～103，不同的芯片类型范围不一样。CNend
+ \param[in] bEnable  HI_TRUE: interrupt enable, HI_FALSE: interrupt disable CNcomment:HI_TRUE: 中断使能 ,HI_FALSE: 中断禁止。CNend
+ \retval 0 Success. CNcomment:成功。CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA	 Parameters Invalid.                 		CNcomment:非法参数。CNend
+ \retval ::HI_ERR_GPIO_NOT_INIT  GPIO module is not initialiazed.              	CNcomment:GPIO模块没有初始化。CNend
+ \retval ::HI_ERR_GPIO_FAILED_SETENABLE  enable interupt failed.              	CNcomment:使能中断失败。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_SetIntEnable(HI_U32 u32GpioNo, HI_BOOL bEnable);
+
+/**
+ \brief query GPIO interrupt, report it if there is interrupter happen.\n
+CNcomment:\brief 查询GPIO中断，只要有GPIO中断就会上报上来。CNend
+ \attention \n
+N/A
+ \param[out] p32GpioNo    get interrupt pin number.        CNcomment:获取中断的管脚号。CNend
+ \param[in] u32TimeoutMs  get interrupt timeout.           CNcomment:获取中断超时时间。CNend
+ \retval 0 Success. CNcomment:成功。CNend
+ \retval ::HI_ERR_GPIO_NULL_PTR  Pointer Parameters is NULL.                 	CNcomment:指针参数为空指针。CNend
+ \retval ::HI_ERR_GPIO_NOT_INIT  GPIO module is not initialiazed.              	CNcomment:GPIO模块没有初始化。CNend
+ \retval ::HI_ERR_GPIO_FAILED_GETINT  Query interupt failed.              	CNcomment:查询中断失败。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_QueryInt(HI_U32 *p32GpioNo, HI_U32 u32TimeoutMs);
+
+/**
+ \brief Obtains the output type (od or cmos) of a GPIO pin.
+CNcomment:\brief 设置GPIO单个引脚的输出类型。CNend
+
+ \attention \n
+N/A
+ \param[in] u32GpioNo  Pin number, ranging from 0 to 103, ranging is different in otherness chip type.     CNcomment:管脚号，取值范围为0～103，不同的芯片类型范围不一样。CNend
+ \param[in] enOutputType   Pointer to the enumerate variable that indicates the direction of a pin.  CNcomment:指针类型，指向枚举型变量，用来返回管脚输出类型。CNend
+ \retval 0 Success. CNcomment:成功。CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA	 Parameters Invalid.                 		CNcomment:非法参数。CNend
+ \retval ::HI_ERR_GPIO_NOT_INIT  GPIO module is not initialiazed.              	CNcomment:GPIO模块没有初始化。CNend
+ \retval ::HI_ERR_GPIO_FAILED_SETOUTPUTTYPE Get output type failed.				CNcomment:设置输出类型失败。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_SetOutputType(HI_U32 u32GpioNo, HI_UNF_GPIO_OUTPUTTYPE_E  enOutputType);
+
+/**
+ \brief Obtains the output type (od or cmos) of a GPIO pin.
+CNcomment:\brief 获取GPIO单个引脚的输出类型。CNend
+
+ \attention \n
+N/A
+ \param[in] u32GpioNo  Pin number, ranging from 0 to 103, ranging is different in otherness chip type.     CNcomment:管脚号，取值范围为0～103，不同的芯片类型范围不一样。CNend
+ \param[out] penOutputType   Pointer to the enumerate variable that indicates the output type of a pin.  CNcomment:指针类型，指向枚举型变量，用来返回管脚输出类型。CNend
+ \retval 0 Success. CNcomment:成功。CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA	 Parameters Invalid.                 		CNcomment:非法参数。CNend
+ \retval ::HI_ERR_GPIO_NOT_INIT  GPIO module is not initialiazed.              	CNcomment:GPIO模块没有初始化。CNend
+ \retval ::HI_ERR_GPIO_FAILED_GETOUTPUTTYPE Get output type failed.				CNcomment:获取输出类型失败。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_GPIO_GetOutputType(HI_U32 u32GpioNo, HI_UNF_GPIO_OUTPUTTYPE_E  *penOutputType);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_GPIO_H__ */
diff -uNr a/include/hi_unf_hdcp.h b/include/hi_unf_hdcp.h
--- a/include/hi_unf_hdcp.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_hdcp.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,77 @@
+#ifndef __HI_UNF_HDCP_H__
+#define __HI_UNF_HDCP_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HDCP */
+/** @{ */  /** <!-- [HDCP] */
+
+typedef struct hiUNF_DECRYPT_HDCP_S
+{
+	HI_U8 u8KSV[5];                         /**< HDCP KSV:40bits, Orignal data */
+	HI_U8 u8PrivateKey[280];                /**< HDCP Device Private key:40*56bits, Orignal data */
+}HI_UNF_HDCP_DECRYPT_S;
+
+/** Encrypted HDCP key */
+/** CNcomment:加密的HDCP key */
+typedef struct hiUNF_ENCRYPT_HDCP_S
+{
+	HI_U8 u8EncryptKey[384];
+}HI_UNF_HDCP_ENCRYPT_S;
+
+typedef struct hiUNF_HDCPKEY_HDCP_S
+{
+    HI_BOOL bIsUseHdcpRootKey;            /**< This parameter is used to select the key(key in otp or a fixed key by hisilicon). */   /**< CNcomment: 是否使用OTP/EFUSE中烧写的HdcpRootKey加密HDCP key. CNend*/
+    HI_U8  u8ToolAesKey[16];                 /**< The AES Key used by tool to encrypt the original hdcp key. */   /**< CNcomment: HDCP工具加密原始HDCP Key时使用的AES密钥，该接口将先使用这个密钥解密再使用硬件密钥加密. CNend*/
+    HI_U8  u8ToolAesIV[16];                 /**< The AES IV used by tool to encrypt the original hdcp key. */   /**< CNcomment: HDCP工具加密原始HDCP Key时使用的AES初始向量，该接口将先使用这个密钥解密再使用硬件密钥加密. CNend*/
+    HI_BOOL EncryptionFlag;               /**< HI_TRUE:Encryption, HI_FALSE: Unencryption */    /**< CNcomment: HI_TRUE: 输入的是加密后的原始HDCP Key, HI_FALSE:输入的是明文原始HDCP Key. CNend*/
+    union
+    {
+        HI_UNF_HDCP_DECRYPT_S DecryptData;
+        HI_UNF_HDCP_ENCRYPT_S EncryptData;
+    }key;									/**< Key = DecryptData,if EncryptionFlag == HI_FALSE.if EncryptionFlag == HI_TRUE,key = Encrpytiondata */
+    HI_U32 Reserved;                        /**< Reserved for future use */
+}HI_UNF_HDCP_HDCPKEY_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HDCP */
+/** @{ */  /** <!-- [HDCP] */
+
+
+/**
+\brief Encrypt HDCP key. HDCP key is encrypted using hdcp root key in otp when bIsUseOTPRootKey equals 'HI_TRUE' or using key defined by hisilicon when bIsUseOTPRootKey equals 'HI_FALSE'.
+\n Additional descryption:Only the 'HDMIIP_HDCPKey' is encrypted. The HDCP key format shows belows:
+\n        head                HDMIIP_HDCPKey               CRC32_0 CRC32_1
+\n		|-------|-----------------------------------------|------|------|
+\n
+\brief CNcomment: 加密客户设置的HDCP key。通过 bIsUseOTPRootKey 选择是否使用OTP内部的RootKey加密数据还是使用海思固定的key加密数据。 CNend
+\attention \n The encrypted data(u8OutEncryptKey) include two CRC32 values.CRC32_1 is used to verify the integration of the whole data, and CRC32_0 is used to debug.  CNcomment: 加密的数据u8OutEncryptKey包含2次CRC校验值，CRC32_1 用于数据完整性判断，CRC32_0用于调试使用。 CNend
+\param[in] :pstHdcpKey.This parameter is used to define hdcp key in encrypted mode or clear mode.  CNcomment: 该参数为HDCP key的参数定义,包含加密/非加密的方式. CNend
+\param[out]:pu8OutEncryptKey. Output the encrypted hdcp key.   CNcomment: 输出的加密后的HDCP KEY参数。 CNend
+\param[in] :u32OutEncryptKeyBufLength. The buffer length of pu8OutEncryptKey.  CNcomment: pu8OutEncryptKey指向的缓冲区大小. CNend
+\param[out]:pu32OutEncryptKeyLength. The length of data that write to pu8OutEncryptKey.   CNcomment: 写到缓冲区pu8OutEncryptKey中的数据长度。 CNend
+\retval HI_SUCCESS  Call this API succussful.  	CNcomment:API系统调用成功。 CNend
+\retval HI_FAILURE  Call this API fails.  		CNcomment:API系统调用失败。 CNend
+*/
+HI_S32  HI_UNF_HDCP_EncryptHDCPKey(HI_UNF_HDCP_HDCPKEY_S *pstHdcpKey,
+                                   HI_U8 *pu8OutEncryptKey,
+                                   HI_U32 u32OutEncryptKeyBufLength,
+                                   HI_U32 *pu32OutEncryptKeyLength);
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_HDCP_H__ */
diff -uNr a/include/hi_unf_hdmi.h b/include/hi_unf_hdmi.h
--- a/include/hi_unf_hdmi.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_hdmi.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,1326 @@
+
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_hdmi.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009-12-10
+  Description   :
+  History       :
+  1.Date        : 2009-12-10
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+
+#ifndef __HI_UNF_HDMI_H__
+#define __HI_UNF_HDMI_H__
+
+/* add include here */
+#include "hi_unf_common.h"
+#include "hi_unf_sound.h"
+#include "hi_unf_edid.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HDMI */
+/** @{ */  /** <!-- [HDMI] */
+
+/**the max infoframe length*//**CNcomment:最大信息帧长度 */
+#define HI_UNF_HDMI_MAX_INFOFRAME_LEN   0X20
+
+/**HDMI default value*//**CNcomment:HDMI 缺省值 */
+#define HI_UNF_HDMI_DEFAULT_SETTING     0x00
+
+/**HDMI interface ID *//**CNcomment:HDMI接口ID  */
+typedef enum hiUNF_HDMI_ID_E
+{
+    HI_UNF_HDMI_ID_0         = 0,          /**<HDMI interface 0*/ /**<CNcomment:HDMI接口0 */
+    HI_UNF_HDMI_ID_BUTT
+} HI_UNF_HDMI_ID_E;
+
+/**HDMI event type*//**CNcomment: HDMI事件类型 */
+typedef enum hiUNF_HDMI_EVENT_TYPE_E
+{
+    HI_UNF_HDMI_EVENT_HOTPLUG = 0x10,       /**<HDMI HotPlug event type*//**<CNcomment:<HDMI热插拔事件 */
+    HI_UNF_HDMI_EVENT_NO_PLUG,              /**<HDMI unplug event type*//**<CNcomment:HDMI Cable没有连接 事件 */
+    HI_UNF_HDMI_EVENT_EDID_FAIL,            /**<HDMI read edid fail event type*//**<CNcomment:HDMI EDID读取失败事件 */
+    HI_UNF_HDMI_EVENT_HDCP_FAIL,            /**<HDCP authentication fail event type *//**<CNcomment:HDCP验证失败事件 */
+    HI_UNF_HDMI_EVENT_HDCP_SUCCESS,         /**<HDCP authentication succeed event type*//**<CNcomment:HDCP验证成功 */
+    HI_UNF_HDMI_EVENT_RSEN_CONNECT,         /**<TMDS link is connected*//**<CNcomment:TMDS链接成功 */
+    HI_UNF_HDMI_EVENT_RSEN_DISCONNECT,      /**<TMDS link is disconnected*//**<CNcomment:TMDS未链接 */
+    HI_UNF_HDMI_EVENT_HDCP_USERSETTING,     /**<HDMI Reset *//**<CNcomment:HDCP 复位*/
+    HI_UNF_HDMI_EVENT_BUTT
+}HI_UNF_HDMI_EVENT_TYPE_E;
+
+/*Video color space mode*//**CNcomment:视频颜色空间类型*/
+typedef enum hiUNF_HDMI_VIDEO_MODE
+{
+    HI_UNF_HDMI_VIDEO_MODE_RGB444,          /**<RGB444 output mode*//**<CNcomment:RGB444输出模式 */
+    HI_UNF_HDMI_VIDEO_MODE_YCBCR422,        /**<YCBCR422 output mode*//**<CNcomment:YCBCR422输出模式 */
+    HI_UNF_HDMI_VIDEO_MODE_YCBCR444,        /**<YCBCR444 output mode*//**<CNcomment:YCBCR444输出模式 */
+    HI_UNF_HDMI_VIDEO_MODE_YCBCR420,        /**<YCBCR420 output mode*//**<CNcomment:YCBCR420输出模式 */
+    HI_UNF_HDMI_VIDEO_MODE_BUTT
+}HI_UNF_HDMI_VIDEO_MODE_E;
+
+/*HDMI Output Aspect Ratio*//**CNcomment:HDMI输出宽高比*/
+typedef enum hiUNF_HDMI_ASPECT_RATIO_E
+{
+    HI_UNF_HDMI_ASPECT_RATIO_NO_DATA,        /**<Aspect Ratio unknown *//**<CNcomment:未知宽高比 */
+    HI_UNF_HDMI_ASPECT_RATIO_4TO3,           /**<Aspect Ratio 4:3  *//**<CNcomment:宽高比4:3*/
+    HI_UNF_HDMI_ASPECT_RATIO_16TO9,          /**<Aspect Ratio 16:9 *//**<CNcomment:宽高比16:9 */
+    HI_UNF_HDMI_ASPECT_RATIO_64TO27,
+    HI_UNF_HDMI_ASPECT_RATIO_256TO135,
+    HI_UNF_HDMI_ASPECT_RATIO_FUTURE,
+    HI_UNF_HDMI_ASPECT_RATIO_BUTT
+}HI_UNF_HDMI_ASPECT_RATIO_E;
+
+
+/**HDMI Deep color mode*//**CNcomment: HDMI 深色模式 */
+typedef enum hiUNF_HDMI_DEEP_COLOR_E
+{
+    HI_UNF_HDMI_DEEP_COLOR_24BIT = 0x00,    /**<HDMI Deep color 24bit mode*//**<CNcomment:HDMI 24bit 深色模式  */
+    HI_UNF_HDMI_DEEP_COLOR_30BIT,           /**<HDMI Deep color 30bit mode*//**<CNcomment:HDMI 30bit 深色模式  */
+    HI_UNF_HDMI_DEEP_COLOR_36BIT,           /**<HDMI Deep color 36bit mode*//**<CNcomment:HDMI 36bit 深色模式  */
+    HI_UNF_HDMI_DEEP_COLOR_OFF   = 0xff,
+    HI_UNF_HDMI_DEEP_COLOR_BUTT
+}HI_UNF_HDMI_DEEP_COLOR_E;
+
+/**HDMI AVI infoframe BarInfo enum*//**CNcomment: HDMI AVI信息帧 BarInfo 枚举 */
+typedef enum hiUNF_HDMI_BARINFO_E
+{
+   HDMI_BAR_INFO_NOT_VALID,                 /**<Bar Data not valid *//**<CNcomment:无效Bar数据  */
+   HDMI_BAR_INFO_V,                         /**<Vertical bar data valid *//**<CNcomment:垂直Bar数据有效  */
+   HDMI_BAR_INFO_H,                         /**<Horizental bar data valid *//**<CNcomment:水平bar数据有效  */
+   HDMI_BAR_INFO_VH                         /**<Horizental and Vertical bar data valid *//**<CNcomment:水平垂直Bar数据同时有效 */
+}HI_UNF_HDMI_BARINFO_E;
+
+/**HDMI AVI infofram ScanInfo enum*//**CNcomment: HDMI AVI信息帧 ScanInfo 枚举 */
+typedef enum hiUNF_HDMI_SCANINFO_E
+{
+    HDMI_SCAN_INFO_NO_DATA      = 0,        /**< No Scan information*//**<CNcomment:无扫描信息  */
+    HDMI_SCAN_INFO_OVERSCANNED  = 1,        /**< Scan information, Overscanned (for television) *//**<CNcomment:扫描信息:全画面扫描  */
+    HDMI_SCAN_INFO_UNDERSCANNED = 2,        /**< Scan information, Underscanned (for computer) *//**<CNcomment:扫描信息: 非全画面扫描  */
+    HDMI_SCAN_INFO_FUTURE
+}HI_UNF_HDMI_SCANINFO_E;
+
+/**HDMI AVI InfoFrame picture scale enum*//**CNcomment: HDMI AVI信息帧 Picture scale 枚举 */
+typedef enum hiUNF_HDMI_PICTURE_SCALING_E
+{
+    HDMI_PICTURE_NON_UNIFORM_SCALING,       /**< No Known, non-uniform picture scaling  *//**<CNcomment:统一图像坐标  */
+    HDMI_PICTURE_SCALING_H,                 /**< Picture has been scaled horizentally *//**<CNcomment:图像水平坐标化  */
+    HDMI_PICTURE_SCALING_V,                 /**< Picture has been scaled Vertically *//**<CNcomment:图像垂直坐标化  */
+    HDMI_PICTURE_SCALING_HV                 /**< Picture has been scaled Horizentally and Vertically   *//**<CNcomment:图像水平垂直坐标化  */
+} HI_UNF_HDMI_PICTURE_SCALING_E;
+
+/**HDMI AVI InfoFrame colorimetry enum*//**CNcomment: HDMI AVI信息帧 色度空间 枚举 */
+typedef enum hiUNF_HDMI_COLORSPACE_E
+{
+    HDMI_COLORIMETRY_NO_DATA,               /**<Colorimetry No Data option*//**<CNcomment:Colorimetry No Data选项 */
+    HDMI_COLORIMETRY_ITU601,                /**<Colorimetry ITU601 option*//**<CNcomment:Colorimetry ITU601色度空间选项 */
+    HDMI_COLORIMETRY_ITU709,                /**<Colorimetry ITU709 option*//**<CNcomment:Colorimetry ITU709色度空间选项 */
+    HDMI_COLORIMETRY_EXTENDED,              /**<Colorimetry extended option*//**<CNcomment:Colorimetry 扩展选项 */
+    HDMI_COLORIMETRY_XVYCC_601,             /**<Colorimetry xvYCC601 extened option*//**<CNcomment:Colorimetry xvYCC601扩展选项 */
+    HDMI_COLORIMETRY_XVYCC_709,             /**<Colorimetry xvYCC709 extened option*//**<CNcomment:Colorimetry xvYCC709扩展选项 */
+    HDMI_COLORIMETRY_S_YCC_601,             /**<Colorimetry S YCC 601 extened option*//**<CNcomment:Colorimetry S YCC 601扩展选项 */
+    HDMI_COLORIMETRY_ADOBE_YCC_601,         /**<Colorimetry ADOBE YCC 601 extened option*//**<CNcomment:Colorimetry ADOBE YCC 601扩展选项 */
+    HDMI_COLORIMETRY_ADOBE_RGB,             /**<Colorimetry ADOBE RGB extened option*//**<CNcomment:Colorimetry ADOBE RGB扩展选项 */
+    HDMI_COLORIMETRY_2020_CONST_LUMINOUS,    /**<Colorimetry ITU2020 extened option*//**<CNcomment:Colorimetry ITU2020扩展选项:BT2020cYCC */
+    HDMI_COLORIMETRY_2020_NON_CONST_LUMINOUS,/**<Colorimetry ITU2020 extened option*//**<CNcomment:Colorimetry ITU2020扩展选项:BT2020RGB或BT2020YCC*/
+} HI_UNF_HDMI_COLORSPACE_E;
+
+/**HDMI AVI InfoFrame RGB range enum*//**CNcomment: HDMI AVI信息帧 RGB色度范围 枚举 */
+typedef enum hiUNF_HDMI_RGB_QUAN_RAGE_E
+{
+    HDMI_RGB_QUANTIZATION_DEFAULT_RANGE,    /**< Defaulr range, it depends on the video format *//**<CNcomment:默认色度范围，依赖于视频制式 */
+    HDMI_RGB_QUANTIZATION_LIMITED_RANGE,    /**< Limited quantization range of 220 levels when receiving a CE video format*//**<CNcomment:受限色度范围16-234 */
+    HDMI_RGB_QUANTIZATION_FULL_RANGE        /**< Full quantization range of 256 levels when receiving an IT video format*//**<CNcomment:全色度范围 0-255 */
+} HI_UNF_HDMI_RGB_QUAN_RAGE_E;
+
+/**HDMI AVI InfoFrame YCC quantization range enum *//**CNcomment:HDMI AVI信息帧 YCC色度范围 枚举 */
+typedef enum hiUNF_HDMI_YCC_QUAN_RAGE_E
+{
+    HDMI_YCC_QUANTIZATION_LIMITED_RANGE,    /**< Limited quantization range of 220 levels when receiving a CE video format*//**<CNcomment:受限色度范围16-234 */
+    HDMI_YCC_QUANTIZATION_FULL_RANGE        /**< Full quantization range of 256 levels when receiving an IT video format*//**<CNcomment:全色度范围 0-255 */
+}HI_UNF_HDMI_YCC_QUAN_RAGE_E;
+
+/**HDMI AVI InfoFrame AVI video content type enum*//**CNcomment:HDMI AVI信息帧 AVI视频内容的类型 枚举 */
+typedef enum hiUNF_HDMI_CONTENT_TYPE_E
+{
+    HDMI_CONTNET_GRAPHIC,                   /**< Graphics type*//**<CNcomment:图像 */
+    HDMI_CONTNET_PHOTO,                     /**< Photo type*//**<CNcomment:照片 */
+    HDMI_CONTNET_CINEMA,                    /**< Cinema type*//**<CNcomment:电影院 */
+    HDMI_CONTNET_GAME                       /**< Game type*//**<CNcomment:游戏 */
+}HI_UNF_HDMI_CONTENT_TYPE_E;
+
+/**HDMI Priority judgments strategy enum*//**CNcomment:HDMI 优先判断策略 枚举*/
+typedef enum hiUNF_HDMI_DEFAULT_ACTION_E
+{
+    HI_UNF_HDMI_DEFAULT_ACTION_NULL,   /**<Default action null*//**<CNcomment:无默认优先策略 */
+    HI_UNF_HDMI_DEFAULT_ACTION_HDMI,   /**<Default action HDMI*//**<CNcomment:优先判断HDMI */
+    HI_UNF_HDMI_DEFAULT_ACTION_DVI,    /**<Default action DVI*//**<CNcomment:优先判断DVI */
+    HI_UNF_HDMI_DEFAULT_ACTION_BUTT
+}HI_UNF_HDMI_DEFAULT_ACTION_E;
+
+
+/**The hotplug callback function interface */
+/**CNcomment: 接口热插拔回调函数 */
+typedef void (*HI_UNF_HDMI_CALLBACK)(HI_UNF_HDMI_EVENT_TYPE_E event, HI_VOID *pPrivateData);
+
+/**HDMI Callback Struct*/
+/**CNcomment: HDMI回调结构 */
+typedef struct hiUNF_HDMI_CALLBACK_FUNC_S
+{
+    HI_UNF_HDMI_CALLBACK pfnHdmiEventCallback;  /**<callback function pointer*//**<CNcomment:回调函数指针*/
+    HI_VOID             *pPrivateData;         /**<callback funtion param*//**<CNcomment:回调函数参数*/
+ }HI_UNF_HDMI_CALLBACK_FUNC_S;
+
+/**HDMI Open Param*/
+/**CNcomment: HDMI打开参数 */
+typedef struct hiUNF_HDMI_OPEN_PARA_S
+{
+    HI_UNF_HDMI_DEFAULT_ACTION_E enDefaultMode;/**<HDMI Priority judgments strategy enum*//**<CNcomment:HDMI 优先判断策略 枚举*/
+}HI_UNF_HDMI_OPEN_PARA_S;
+
+/**Current HDCP version enum*/
+/**CNcomment:当前HDCP版本 枚举*/
+typedef enum hiUNF_HDMI_HDCP_VERSION_E
+{
+    HI_UNF_HDMI_HDCP_VERSION_NONE,      /**<HDCP version, none HDCP*//**<CNcomment:无HDCP */
+    HI_UNF_HDMI_HDCP_VERSION_HDCP14,    /**<HDCP version, HDCP1.4*//**<CNcomment:HDCP1.4 */
+    HI_UNF_HDMI_HDCP_VERSION_HDCP22,    /**<HDCP version, HDCP2.2*//**<CNcomment:HDCP2.2 */
+    HI_UNF_HDMI_HDCP_VERSION_BUTT
+}HI_UNF_HDMI_HDCP_VERSION_E;
+
+/**HDMI status*/
+/**CNcomment: HDMI状态 */
+typedef struct hiUNF_HDMI_STATUS_S
+{
+    HI_BOOL                 bConnected;             /**<The Device is connected or disconnected *//**<CNcomment:设备是否连接 */
+    HI_BOOL                 bSinkPowerOn;           /**<The sink is PowerOn or not*//**<CNcomment:Sink设备是否上电 */
+    HI_BOOL                 bAuthed;                /**<HDCP Authentication *//**<CNcomment:HDCP 是否握手完成 */
+    HI_U8                   u8Bksv[5];              /**<Bksv of sink 40bits*//**<CNcomment:接收端的Bksv */
+    HI_UNF_HDMI_HDCP_VERSION_E enHDCPVersion;       /**<Current HDCP version*//**<CNcomment:当前HDCP版本 */
+}HI_UNF_HDMI_STATUS_S;
+
+/**Current HDCP mode enum*/
+/**CNcomment:HDCP模式 枚举*/
+typedef enum hiUNF_HDMI_HDCP_MODE_E
+{
+    HI_UNF_HDMI_HDCP_MODE_AUTO,         /**< HDCP auto mode,priority is 2.2 then 1.4 to set HDCP according to sink's HDCP-capability *//**<CNcomment:HDCP自动模式，HDMI驱动根据Sink端能力自动选择HDCP认证版本，2.2优先于1.4 */
+    HI_UNF_HDMI_HDCP_MODE_1_4,          /**< forec to HDCP1.4 disregard sink's HDCP-capability.It may be fail due to sink not support. *//**<CNcomment:强制设置HDCP1.4版本，不参考sink能力。未参考sink能力而强制使能可能导致认证失败。 */
+    HI_UNF_HDMI_HDCP_MODE_2_2,          /**< forec to HDCP2.2 disregard sink's HDCP-capability.It may be fail due to sink not support. *//**<CNcomment:强制设置HDCP2.2版本，不参考sink能力。未参考sink能力而强制使能可能导致认证失败。 */
+    HI_UNF_HDMI_HDCP_BUTT
+}HI_UNF_HDMI_HDCP_MODE_E;
+
+/**the config parameter of HDMI interface*/
+/**CNcomment:HDMI 接口参数配置 */
+typedef struct hiUNF_HDMI_ATTR_S
+{
+    HI_BOOL                 bEnableHdmi;         /**<force to HDMI or DVI,the value must set before HI_UNF_HDMI_Start or behind HI_UNF_HDMI_Stop*//**<CNcomment:是否强制HDMI,否则为DVI.该值必须在 HI_UNF_HDMI_Start之前或者HI_UNF_HDMI_Stop之后设置  */
+
+    HI_BOOL                 bEnableVideo;        /**<parameter must set HI_TRUE,or the HDMI diver will force to set HI_TRUE*//**<CNcomment:必须是HI_TRUE, 如果是HI_FALSE:HDMI驱动会强制设置为HI_TRUE */
+
+    HI_UNF_HDMI_VIDEO_MODE_E enVidOutMode;       /**<HDMI output vedio mode VIDEO_MODE_YCBCR,VIDEO_MODE_YCBCR444,VIDEO_MODE_YCBCR422,VIDEO_MODE_RGB444 *//**<CNcomment:HDMI输出视频模式，VIDEO_MODE_YCBCR444，VIDEO_MODE_YCBCR422，VIDEO_MODE_RGB444 */
+    HI_UNF_HDMI_DEEP_COLOR_E enDeepColorMode;    /**<Deep Color output mode,defualt: HI_UNF_HDMI_DEEP_COLOR_24BIT *//**<CNcomment:DeepColor输出模式, 默认为HI_UNF_HDMI_DEEP_COLOR_24BIT */
+    HI_BOOL                 bxvYCCMode;          /**<the xvYCC output mode,default:HI_FALSE*//**<CNcomment:< xvYCC输出模式，默认为HI_FALSE */
+
+    HI_BOOL                 bEnableAudio;        /**<Enable flag of Audio*//**CNcomment:是否Enable音频 */
+
+    HI_BOOL                 bEnableAviInfoFrame; /**<Enable flag of AVI InfoFrame,suggestion:enable *//**<CNcomment:是否使能 AVI InfoFrame，建议使能 */
+    HI_BOOL                 bEnableAudInfoFrame; /**<Enable flag of Audio InfoFrame,suggestion:enable*//**<CNcomment:是否使能 AUDIO InfoFrame，建议使能 */
+    HI_BOOL                 bEnableSpdInfoFrame; /**<Enable flag of SPD info frame,suggestion:disable*//**<CNcomment:是否使能 SPD InfoFrame， 建议关闭 */
+    HI_BOOL                 bEnableMpegInfoFrame;/**<Enable flag of MPEG info frame,suggestion:disable*//**<CNcomment:是否使能 MPEG InfoFrame， 建议关闭 */
+
+    HI_BOOL                 bHDCPEnable;         /**<0:HDCP disable mode,1:eable HDCP mode.see HI_UNF_HDMI_HdcpEanble*//**<CNcomment:< 0:HDCP不激活，1:HDCP模式打开。见HI_UNF_HDMI_HdcpEanble */
+
+    HI_BOOL                 bEnableVidModeAdapt; /**<Enable flag of vedio mode & DVI adapting case of user setting incorrect,default:HI_TRUE.When user have no any adapting strategy,suggestion HI_TRUE*//**<CNcomment:当用户设置的输出颜色空间与DVI 错误时是否使能 自动校正，不使能则用户设置错误时直接返回失败，默认使能 。建议当用户有自适应策略时关闭，否则使能*/
+    HI_BOOL                 bEnableDeepClrAdapt; /**<Enable flag of deep color mode adapting case of user setting incorrect,default: HI_FALSE.When user have no any adapting strategy,suggestion HI_TRUE*//**<CNcomment:当用户设置的输出色深(位宽)错误时是否使能 自动校正，不使能则用户设置错误时直接返回失败，默认使能。建议当用户有自适应策略时关闭，否则使能*/
+    HI_BOOL                 bAuthMode;           /**<Enable flag of authentication, suggestion:disable *//**<CNcomment:是否使能认证模式，建议默认不是能 */
+    HI_UNF_HDMI_HDCP_MODE_E enHDCPMode;          /**<HDCP mode:HI_UNF_HDMI_HDCP_MODE_AUTO, HI_UNF_HDMI_HDCP_MODE_1_4,HI_UNF_HDMI_HDCP_MODE_2_2,see HI_UNF_HDMI_HdcpEanble*//**<CNcomment:< HDCP等级，HI_UNF_HDMI_HDCP_MODE_AUTO(根据能力自动选择)，HI_UNF_HDMI_HDCP_MODE_1_4,HI_UNF_HDMI_HDCP_MODE_2_2. 见HI_UNF_HDMI_HdcpEanble */
+}HI_UNF_HDMI_ATTR_S;
+
+/**HDMI infoFrame type definition*/
+/**CNcomment: HDMI 信息帧类型定义 */
+typedef enum tagHI_UNF_HDMI_INFOFRAME_TYPE_E
+{
+    HI_INFOFRAME_TYPE_AVI,          /**<HDMI AVI InfoFrame type defintion*//**<CNcomment:HDMI AVI InfoFrame 类型定义 */
+    HI_INFOFRAME_TYPE_SPD,          /**<HDMI SPD InfoFrame type defintion*//**<CNcomment:HDMI SPD InfoFrame 类型定义 */
+    HI_INFOFRAME_TYPE_AUDIO,        /**<HDMI AUDIO InfoFrame type defintion*//**<CNcomment:HDMI AUDIO InfoFrame 类型定义 */
+    HI_INFOFRAME_TYPE_MPEG,         /**<HDMI MPEG InfoFrame type defintion*//**<CNcomment:HDMI MPEG InfoFrame 类型定义 */
+    HI_INFOFRAME_TYPE_VENDORSPEC,   /**<HDMI Specific InfoFrame type defintion*//**<CNcomment:HDMI Vendor Specific InfoFrame 类型定义 */
+    HI_INFOFRAME_TYPE_BUTT
+}HI_UNF_HDMI_INFOFRAME_TYPE_E;
+
+/**HDMI AVI InfoFrame parameter struct,please reference EIA-CEA-861-D*/
+/**CNcomment: HDMI AVI 信息帧参数结构, 请参考EIA-CEA-861-D */
+typedef struct hiUNF_HDMI_AVI_INFOFRAME_VER2_S
+{
+    HI_UNF_ENC_FMT_E               enTimingMode;            /**<AVI video timing format*//**<CNcomment:AVI视频timing格式 */
+    HI_UNF_HDMI_VIDEO_MODE_E       enOutputType;            /**<AVI video output color space*//**<CNcomment:AVI视频输出颜色格式 */
+    HI_BOOL                        bActive_Infor_Present;   /**<AVI video Active_Infor_Present flag*//**<CNcomment:AVI视频Active_Infor_Present标志位 */
+    HI_UNF_HDMI_BARINFO_E          enBarInfo;               /**<AVI video BarInfo type*//**<CNcomment:AVI视频BarInfo类型 */
+    HI_UNF_HDMI_SCANINFO_E         enScanInfo;              /**<AVI video ScanInfo type*//**<CNcomment:AVI视频ScanInfo类型 */
+    HI_UNF_HDMI_COLORSPACE_E       enColorimetry;           /**<AVI video Colorimetry type*//**<CNcomment:AVI视频Colorimetry类型 */
+    HI_UNF_HDMI_ASPECT_RATIO_E     enAspectRatio;           /**<AVI video AspectRatio type*//**<CNcomment:AVI视频宽高比格式 */
+    HI_UNF_HDMI_ASPECT_RATIO_E     enActiveAspectRatio;     /**<AVI video Active AspectRatio type*//**<CNcomment:AVI视频有效宽高比格式 */
+    HI_UNF_HDMI_PICTURE_SCALING_E  enPictureScaling;        /**<AVI video picture scaling type*//**<CNcomment:AVI视频scaling格式 */
+    HI_UNF_HDMI_RGB_QUAN_RAGE_E    enRGBQuantization;       /**<AVI video RGB Quantization*//**<CNcomment:AVI视频RGB色度范围 */
+    HI_BOOL                        bIsITContent;            /**<AVI video ITContent flag*//**<CNcomment:AVI视频ITcontent */
+    HI_U32                         u32PixelRepetition;      /**<AVI video Pixel Repetition flag*//**<CNcomment:AVI视频像素重传标志位 */
+
+    HI_UNF_HDMI_CONTENT_TYPE_E     enContentType;           /**<AVI video content type*//**<CNcomment:AVI视频内容的类型 */
+    HI_UNF_HDMI_YCC_QUAN_RAGE_E    enYCCQuantization;       /**<AVI video YCC Quantization*//**CNcomment:*< AVI视频YCC色度范围 */
+
+    HI_U32                         u32LineNEndofTopBar;     /**<AVI video EndofTopBar coordinate,defualt:0 *//**<CNcomment:AVI视频EndofTopBar坐标，缺省为0 */
+    HI_U32                         u32LineNStartofBotBar;   /**<AVI video StartofBotBar coordinate,defualt:0*//**<CNcomment:AVI视频StartofBotBar坐标，缺省为0 */
+    HI_U32                         u32PixelNEndofLeftBar;   /**<AVI video EndofLeft coordinate,defualt:0*//**<CNcomment:AVI视频EndofLeft坐标，缺省为0 */
+    HI_U32                         u32PixelNStartofRightBar;/**<AVI video StartofRightBar coordinate,defualt:0*//**<CNcomment:AVI视频StartofRightBar坐标，缺省为0 */
+}HI_UNF_HDMI_AVI_INFOFRAME_VER2_S;
+
+/**HDMI AUDIO InfoFrame parameter struct ,please reference EIA-CEA-861-D*/
+/**CNcomment: HDMI 音频信息帧参数结构, 请参考EIA-CEA-861-D */
+typedef struct hiUNF_HDMI_AUD_INFOFRAME_VER1_S
+{
+    HI_U32                            u32ChannelCount;          /**<audio frequency channel count*//**<CNcomment:音频 声道数 */
+    HI_UNF_EDID_AUDIO_FORMAT_CODE_E   enCodingType;             /**<audio frequency coding type,default 0;Refer to Stream Header*//**<CNcomment:音频 编码类型，缺省为0：Refer to Stream Header */
+    HI_U32                            u32SampleSize;            /**<audio frequency sample size,default 0,Refer to Stream Header*//**<CNcomment:音频 采样大小，缺省为0：Refer to Stream Header */
+    HI_U32                            u32SamplingFrequency;     /**<audio frequency sampling frequency ,default 0,Refer to Stream Header*//**<CNcomment:音频 采样频率，缺省为0：Refer to Stream Header */
+    HI_U32                            u32ChannelAlloc;          /**<audio frequency channel allocable ,default 0,Refer to Stream Header*//**<CNcomment:音频 声道分配，缺省为0：Refer to Stream Header */
+    HI_U32                            u32LevelShift;            /**<audio frequency Levelshift ,default 0,Refer to Stream Header*//**<CNcomment:音频 Levelshift，缺省为0：Refer to Stream Header */
+    HI_BOOL                           u32DownmixInhibit;        /**<audio frequency DownmixInhibit ,default 0,Refer to Stream Header*//**<CNcomment:音频 DownmixInhibit，缺省为0：Refer to Stream Header */
+}HI_UNF_HDMI_AUD_INFOFRAME_VER1_S;
+
+/**HDMI SPD InfoFrame parameter struct,please reference EIA-CEA-861-D*/
+/**CNcomment: HDMI SPD信息帧参数结构 , 请参考EIA-CEA-861-D */
+typedef struct hiUNF_HDMI_SPD_INFOFRAME_S
+{
+    HI_U8                          u8VendorName[8];          /**<vendor name*//**<CNcomment:卖方名称 */
+    HI_U8                          u8ProductDescription[16]; /**<product Description*//**<CNcomment:产品描述符 */
+    HI_U8                          u8SrcDevInfo;             /**<Source Device Information  *//**<CNcomment:源设备信息 */
+}HI_UNF_HDMI_SPD_INFOFRAME_S;
+
+/**HDMI Source HDMI MPEG InfoFrame parameter struct,please reference EIA-CEA-861-D*/
+/**CNcomment: HDMI MPEG信息帧参数结构 , 请参考EIA-CEA-861-D */
+typedef struct hiUNF_HDMI_MPEGSOURCE_INFOFRAME_S
+{
+    HI_U32                         u32MPEGBitRate;           /**<MPEG bit Rate*//**<CNcomment:MPEG位率 */
+    HI_BOOL                        bIsFieldRepeated;         /**<FieldRepeater flag*//**<CNcomment:FieldRepeater标志位 */
+}HI_UNF_HDMI_MPEGSOURCE_INFOFRAME_S;
+
+/**HDMI Vendor Specific InfoFrame parameter struct,please reference EIA-CEA-861-D*/
+/**CNcomment: HDMI VSIF信息帧 参数结构 , 请参考EIA-CEA-861-D */
+typedef struct hiUNF_HDMI_VENDORSPEC_INFOFRAME_S
+{
+    HI_U32                         u32RegistrationId;       /**<Registration Id*//**<CNcomment:注册ID号 */
+}HI_UNF_HDMI_VENDORSPEC_INFOFRAME_S;
+
+/**HDMI InfoFrame unit struct*/
+/**CNcomment: HDMI 信息帧联合定义体 */
+typedef union hiUNF_HDMI_INFOFRAME_UNIT_U
+{
+    HI_UNF_HDMI_AVI_INFOFRAME_VER2_S   stAVIInfoFrame;      /**<AVI FrameInfo*//**<CNcomment:AVI信息帧 */
+    HI_UNF_HDMI_AUD_INFOFRAME_VER1_S   stAUDInfoFrame;      /**<Audio FrameInfo*//**<CNcomment:AUD信息帧 */
+    HI_UNF_HDMI_SPD_INFOFRAME_S        stSPDInfoFrame;      /**<SPD FrameInfo*//**<CNcomment:SPD信息帧 */
+    HI_UNF_HDMI_MPEGSOURCE_INFOFRAME_S stMPEGSourceInfoFrame;/**<MPEGSource FrameInfo*//**<CNcomment:MPEGSource信息帧 */
+    HI_UNF_HDMI_VENDORSPEC_INFOFRAME_S stVendorSpecInfoFrame;/**<VS FrameInfo*//**<CNcomment:VS信息帧 */
+}HI_UNF_HMDI_INFORFRAME_UNIT_U;
+
+/**HDMI InfoFrame struct */
+/**CNcomment: HDMI 信息帧数据结构 */
+typedef struct hiUNF_HDMI_INFOFRAME_S
+{
+    HI_UNF_HDMI_INFOFRAME_TYPE_E    enInfoFrameType;  /**<InfoFrame type*//**CNcomment:<InfoFrame类型 */
+    HI_UNF_HMDI_INFORFRAME_UNIT_U   unInforUnit;      /**<InfoFrame unit data*//**CNcomment:<InfoFrame数据 */
+}HI_UNF_HDMI_INFOFRAME_S;
+
+
+/* CEC */
+/** CEC interrelated Opcode:Please refer to CEC 15 Message Descriptions */
+/** CNcomment: CEC 相关的操作码 */
+
+/* General Protocol messages */
+
+/**"Feature Abort" Used as a response to indicate that the device does not support the requested message type, or that it cannot execute it at the present time. */
+/**CNcomment:"Feature Abort"消息表明设备不支持该信息的回复，或当前没法处理*/
+#define CEC_OPCODE_FEATURE_ABORT                  0X00
+/**"Abort" Message This message is reserved for testing purposes.*/
+/**CNcomment:"Abort"消息是专为测试保留的*/
+#define CEC_OPCODE_ABORT_MESSAGE                  0XFF
+
+/* One Touch Play Feature*/
+
+/**"Active Source" Used by a new source to indicate that it has started to transmit a stream OR used in response to a "Request Active Source"*/
+/**CNcomment:"Active Source"消息说明源端设备正在发送一条码流或者回复"Request Active Source"消息*/
+#define CEC_OPCODE_ACTIVE_SOURCE                  0X82
+/**"Image View On" Sent by a source device to the TV whenever it enters the active state (alternatively it may send "Text View On").*/
+/**CNcomment:当源端设备进入激活状态时，会给TV发送一次"Image View On"消息*/
+#define CEC_OPCODE_IMAGE_VIEW_ON                  0X04
+/**"Text View On" As "Image View On", but should also remove any text, menus and PIP windows from the TV's display.*/
+/**CNcomment:"Text View On" 和"Image View On"指令相似，但同时会从TV画面上关闭文字，菜单和画中画窗口*/
+#define CEC_OPCODE_TEXT_VIEW_ON                   0X0D
+
+/* Routing Control Feature*/
+
+/**"Inactive Source" Used by the currently active source to inform the TV that it has no video to be presented to the user, or is going into standby as the result of a local user command on the device. */
+/**CNcomment: "Inactive Source"消息表明当前无码流播放或者因用户操作，设备要进入待机状态*/
+#define CEC_OPCODE_INACTIVE_SOURCE                0X9D
+/**"Request Active Source" Used by a new device to discover the status of the system.*/
+/**CNcomment: "Request Active Source"消息用于通知系统添加了一个新设备*/
+#define CEC_OPCODE_REQUEST_ACTIVE_SOURCE          0X85
+/**"Routing Change" Sent by a CEC Switch when it is manually switched to inform all other devices on the network that the active route below the switch has changed. */
+/**CNcomment: 当CEC转接器检测到子设备列表发生变化时，会通知所有活动子设备 "Routing Change"消息*/
+#define CEC_OPCODE_ROUTING_CHANGE                 0X80
+/**"Routing Information" Sent by a CEC Switch to indicate the active route below the switch.*/
+/**CNcomment: CEC转接器发送"Routing Information"消息来检测子网络下活动子设备*/
+#define CEC_OPCODE_ROUTING_INFORMATION            0X81
+/**"Set Stream Path" Used by the TV to request a streaming path from the specified physical address.*/
+/**CNcomment: TV从一个特定的设备上获取码流路径 */
+#define CEC_OPCODE_SET_STREAM_PATH                0X86
+
+/* Standby Feature*/
+
+/**"Standby" Switches one or all devices into standby mode. Can be used as a broadcast message or be addressed to a specific device.See section CEC 13.3 for important notes on the use of this message */
+/**CNcomment: "Standby"消息能使一个或多个设备进入待机状态。可用广播或者给特定的设备单独发送*/
+#define CEC_OPCODE_STANDBY                        0X36
+
+/* One Touch Record Feature*/
+
+/**"Record Off" Requests a device to stop a recording. */
+/**CNcomment: "Record Off"能使一个设备停止录像*/
+#define CEC_OPCODE_RECORD_OFF                     0X0B
+/**"Record On" Attempt to record the specified source. */
+/**CNcomment: "Record On"消息用于尝试让一个特定的源录像*/
+#define CEC_OPCODE_RECORD_ON                      0X09
+/**"Record Status" Used by a Recording Device to inform the initiator of the message "Record On" about its status. */
+/**CNcomment: 可录像设备发送"Record Status"消息和状态给发起"Record On"消息的的设备*/
+#define CEC_OPCODE_RECORD_STATUS                  0X0A
+/**"Record TV Screen" Request by the Recording Device to record the presently displayed source. */
+/**CNcomment: "Record TV Screen"消息用于请求录像设备记录当前显示的资源*/
+#define CEC_OPCODE_RECORD_TV_SCREEN               0X0F
+
+/* Timer Programming Feature*/
+
+/**"Clear Analogue Timer" Used to clear an Analogue timer block of a device. */
+/**CNcomment: 清空模拟定时器设备*/
+#define CEC_OPCODE_CLEAR_ANALOGUE_TIMER           0X33
+/**"Clear Digital Timer" Used to clear a Digital timer block of a device. */
+/**CNcomment: 清空数字定时器设备*/
+#define CEC_OPCODE_CLEAR_DIGITAL_TIMER            0X99
+/**"Clear External Timer" Used to clear an External timer block of a device. */
+/**CNcomment: 清空外部定时器设备*/
+#define CEC_OPCODE_CLEAR_EXTERNAL_TIMER           0XA1
+/**"Set Analogue Timer" Used to set a single timer block on an Analogue Recording Device. */
+/**CNcomment: 在模拟定时器设备上设置定时器*/
+#define CEC_OPCODE_SET_ANALOGUE_TIMER             0X34
+/**"Set Digital Timer" Used to set a single timer block on a Digital Recording Device. */
+/**CNcomment: 在数字定时器设备上设置定时器*/
+#define CEC_OPCODE_SET_DIGITAL_TIMER              0X97
+/**"Set External Timer" Used to set a single timer block to record from an external device. */
+/**CNcomment: 在外部定时器设备上设置定时器*/
+#define CEC_OPCODE_SET_EXTERNAL_TIMER             0XA2
+/**"Set Timer Program Title" Used to set the name of a program associated with a timer block. Sent directly after sending a "Set Analogue Timer" or "Set Digital Timer" message. The name is then associated with that timer block. */
+/**CNcomment: 当发送完"Set Analogue Timer" 或"Set Digital Timer"消息后发送一个名称用于程序和定时器模块关联 */
+#define CEC_OPCODE_SET_TIMER_PROGRAM_TITLE        0X67
+/**"Timer Cleared Status" Used to give the status of a "Clear Analogue Timer", "Clear Digital Timer" or "Clear External Timer" message. */
+/**CNcomment: "Timer Cleared Status"消息用于发送"Clear Analogue Timer"，"Clear Digital Timer"，"Clear External Timer"之后的状态*/
+#define CEC_OPCODE_TIMER_CLEARED_STATUS           0X43
+/**"Timer Status" Used to send timer status to the initiator of a "Set Timer" message. */
+/**CNcomment: "Timer Status"消息用于给Set Timer"消息的发起者发送定时器状态*/
+#define CEC_OPCODE_TIMER_STATUS                   0X35
+
+/* System Information Feature*/
+
+/**"CEC Version" Used to indicate the supported CEC version, in response to a "Get CEC Version" */
+/**CNcomment: "CEC Version"消息用于发送设备上的CEC版本信息来回复"Get CEC Version"消息*/
+#define CEC_OPCODE_CEC_VERSION                    0X9E
+/**"Get CEC Version" Used by a device to enquire which version of CEC the target supports */
+/**CNcomment: "Get CEC Version"用于一个设备获取从设备的CEC版本信息*/
+#define CEC_OPCODE_GET_CEC_VERSION                0X9F
+/**"Give Physical Address" A request to a device to return its physical address. */
+/**CNcomment: 向一个设备请求获取该设备的物理地址*/
+#define CEC_OPCODE_GIVE_PHYSICAL_ADDRESS          0X83
+/**"Report Physical Address" Used to inform all other devices of the mapping between physical and logical address of the initiator.*/
+/**CNcomment: 向同一网络下其他所有设备发送物理地址和逻辑地址*/
+#define CEC_OPCODE_REPORT_PHYSICAL_ADDRESS        0X84
+/**"Get Menu Language" Sent by a device capable of character generation (for OSD and Menus) to a TV in order to discover the currently selected Menu language.Also used by a TV during installation to discover the currently set menu language of other devices.*/
+/**CNcomment: "Get Menu Language"用于获取Tv端能力集，用于替换当前的菜单语言类型；也可用于TV设备启动时，设置其它设备的菜单语言*/
+#define CEC_OPCODE_GET_MENU_LANGUAGE              0X91
+/**"Set Menu Language" Used by a TV or another device to indicate the menu language. */
+/**CNcomment: "Set Menu Language"用于Tv或其他设备，设置菜单语言*/
+#define CEC_OPCODE_SET_MENU_LANGUAGE              0X32
+
+/*  Deck Control Feature*/
+
+/**"Deck Control" Used to control a device's media functions. */
+/**CNcomment: "Deck control"消息用于控制一个设备的多媒体功能*/
+#define CEC_OPCODE_DECK_CONTROL                   0X42
+/**"Deck Status" Used to provide a deck's status to the initiator of the "Give Deck Status" message. */
+/**CNcomment: "Deck Status "消息用于回复"Give Deck Status"消息的发起者Deck的状态*/
+#define CEC_OPCODE_DECK_STATUS                    0X1B
+/**"Give Deck Status" Used to request the status of a device, regardless of whether or not it is the current active source. */
+/**CNcomment: "Give Deck Status"消息请求获取目标设备的状态，而不管目标设备目前是不是激活的*/
+#define CEC_OPCODE_GIVE_DECK_STATUS               0X1A
+/**"Play" Used to control the playback behaviour of a source device. */
+/**CNcomment: "Play"消息用于控制源设备播放*/
+#define CEC_OPCODE_PLAY                           0X41
+
+/* Tuner Control Feature*/
+
+/**"Give Tuner Device Status" Used to request the status of a tuner device. */
+/**CNcomment: "Give Tuner Device Status"用于获取电视调谐器的状态*/
+#define CEC_OPCODE_GIVE_TUNER_DEVICE_STATUS       0X08
+/**"Select Analogue Service" Directly selects an Analogue TV service */
+/**CNcomment: "Select Analogue Service"消息用于直接选择一个模拟电视的服务项*/
+#define CEC_OPCODE_SELECT_ANALOGUE_SERVICE        0X92
+/**"Select Digital Service" Directly selects a Digital TV, Radio or Data Broadcast Service */
+/**CNcomment: "Select Digital Service"消息用于直接选择一个数字电视的服务项*/
+#define CEC_OPCODE_SELECT_DIGITAL_SERVICE         0X93
+/**"Tuner Device Status" Use by a tuner device to provide its status to the initiator of the "Give Tuner Device Status" message. */
+/**CNcomment: "Tuner Device Status"消息用于电视调谐器给" Give Tuner Device Status"消息的发起端回复*/
+#define CEC_OPCODE_TUNER_DEVICE_STATUS            0X07
+/**"Tuner Step Decrement" Used to tune to next lowest service in a tuner's service list. Can be used for PIP. */
+/**CNcomment: "Tuner Step Decrement"消息用于把次低的服务项放入调谐器的服务列表，能用于画中画*/
+#define CEC_OPCODE_TUNER_STEP_DECREMENT           0X06
+/**"Tuner Step Increment" Used to tune to next highest service in a tuner's service list. Can be used for PIP. */
+/**CNcomment: "Tuner Step Decrement"消息用于把次高的服务项放入调谐器的服务列表，能用于画中画*/
+#define CEC_OPCODE_TUNER_STEP_INCREMENT           0X05
+
+/* Vendor Specific Command*/
+
+/**"Device Vendor ID" Reports the vendor ID of this device. */
+/**CNcomment: "Device Vendor ID"消息用于报告此设备的供应商ID*/
+#define CEC_OPCODE_DEVICE_VENDOR_ID               0X87
+/**"Give Device Vendor ID" Requests the Vendor ID from a device. */
+/**CNcomment: "Give Device Vendor ID"消息用于请求此设备的供应商ID*/
+#define CEC_OPCODE_GIVE_DEVICE_VENDOR_ID          0X8C
+/**"Vendor Command" Allows vendor specific commands to be sent between two devices. */
+/**CNcomment: "Vendor Command"用于两个设备之间互相发送供应商定制消息*/
+#define CEC_OPCODE_VENDOR_COMMAND                 0X89
+/**"Vendor Command With ID" Allows vendor specific commands to be sent between two devices or broadcast. */
+/**CNcomment: "Vendor Command With ID"用于两个设备之间或广播形式发送供应商定制消息*/
+#define CEC_OPCODE_VENDOR_COMMAND_WITH_ID         0XA0
+/**"Vendor Remote Button Down" Indicates that a remote control button has been depressed. */
+/**CNcomment: "Vendor Remote Button Down"消息表示，遥控器有按键按下来*/
+#define CEC_OPCODE_VENDOR_REMOTE_BUTTON_DOWN      0X8A
+/**"Vendor Remote Button Up" Indicates that a remote control button (the last button pressed indicated by the Vendor Remote Button Down message) has been released. */
+/**CNcomment: "Vendor Remote Button Up"消息表示 "Vendor Remote Button Down"消息最后一次表示过的按键被释放了*/
+#define CEC_OPCODE_VENDOR_REMOTE_BUTTON_UP        0X8B
+
+/* OSD Display Feature*/
+
+/**"Set OSD String" Used to send a text message to output on a TV. */
+/**CNcomment: "Set OSD String"消息可以发送一段文字消息让它显示在电视机上*/
+#define CEC_OPCODE_SET_OSD_STRING                 0X64
+/**"Give OSD Name" Used to request the preferred OSD name of a device for use in menus associated with that device. */
+/**CNcomment:请求首选的关联设备菜单显示的名字 */
+#define CEC_OPCODE_GIVE_OSD_NAME                  0X46
+/**"Set OSD Name" Used to set the preferred OSD name of a device for use in menus associated with that device. */
+/**CNcomment:设置首选关联设备菜单显示的名字 */
+#define CEC_OPCODE_SET_OSD_NAME                   0X47
+
+/* Device Menu Control Feature*/
+
+/**"Menu Request" A request from the TV for a device to show/remove a menu or to query if a device is currently showing a menu. */
+/**CNcomment: "Menu Request"消息用于电视请求一个设备显示/关闭菜单或询问该设备当前有没有菜单显示*/
+#define CEC_OPCODE_MENU_REQUEST                   0X8D
+/**"Menu Status" Used to indicate to the TV that the device is showing/has removed a menu and requests the remote control keys to be passed though. */
+/**CNcomment: "Menu Status"消息用于回复电视端当前正显示/移除了菜单，并透传遥控器指令*/
+#define CEC_OPCODE_MENU_STATUS                    0X8E
+/**"User Control Pressed" Used to indicate that the user pressed a remote control button or switched from one remote control button to another. */
+/**CNcomment: "User Control Pressed"表示用户按了一个遥控器按键或从某一个按键换到另一个按键.也可以用于用户间接发起的指令*/
+#define CEC_OPCODE_USER_CONTROL_PRESSED           0X44
+/**"User Control Released" Indicates that user released a remote control button (the last one indicated by the "User Control Pressed" message) */
+/**CNcomment: "User Control Released"表示用户释放了"User Control Released"消息指定的遥控器按键.也可以用于用户间接发起的指令*/
+#define CEC_OPCODE_USER_CONTROL_RELEASED          0X45
+
+/* Power Status Feature*/
+
+/**"Give Device Power Status" Used to determine the current power status of a target device */
+/**CNcomment: "Give Device Power Status"消息用于获取目标设备当前的电源状态*/
+#define CEC_OPCODE_GIVE_DEVICE_POWER_STATUS       0X8F
+/**"Report Power Status" Used to inform a requesting device of the current power status */
+/**CNcomment: "Report Power Status"消息用于发送当前的电源状态回复请求设备*/
+#define CEC_OPCODE_REPORT_POWER_STATUS            0X90
+
+/* System Audio Control Feature*/
+
+/**"Give Audio Status" Requests an amplifier to send its volume and mute status */
+/**CNcomment: "Give Audio Status"消息请求获取扩音器的音量和静音状态*/
+#define CEC_OPCODE_GIVE_AUDIO_STATUS              0X71
+/**"Give System Audio Mode Status" Requests the status of the System Audio Mode */
+/**CNcomment: "Give System Audio Mode Status"消息请求系统音频的状态*/
+#define CEC_OPCODE_GIVE_SYSTEM_AUDIO_MODE_STATUS  0x7D
+/**"Report Audio Status" Reports an amplifier's volume and mute status */
+/**CNcomment: "Report Audio Status"消息用于发送扩音器的音量和静音状态*/
+#define CEC_OPCODE_REPORT_AUDIO_STATUS            0X7A
+/**"Set System Audio Mode" Turns the System Audio Mode On or Off. */
+/**CNcomment: "Set System Audio Mode"消息用于打开/关闭系统音频功能*/
+#define CEC_OPCODE_SET_SYSTEM_AUDIO_MODE          0X72
+/**"System Audio Mode Request" A device implementing System Audio Control and which has volume control RC buttons (eg TV or STB) requests to use System Audio Mode to the amplifier */
+/**CNcomment: 使用音量控制按钮(stb或者tv)需要扬声器进入 System Audio Mode*/
+#define CEC_OPCODE_SYSTEM_AUDIO_MODE_REQUEST      0X70
+/**"System Audio Mode Status" Reports the current status of the System Audio Mode */
+/**CNcomment: "System Audio Mode Status"消息用于发送系统音频当前的状态*/
+#define CEC_OPCODE_SYSTEM_AUDIO_MODE_STATUS       0X7E
+
+/* Audio Rate Control Feature*/
+
+/**"Set Audio Rate" Used to control audio rate from Source Device. */
+/**CNcomment: "Set Audio Rate"消息用于控制源端设备的音频采样率*/
+#define CEC_OPCODE_SET_AUDIO_RATE                 0X9A
+
+/**POLL message have no opcode, So, we just use this value */
+/**CNcomment: "POLL"消息没有操作码，我们仅仅只是使用该值*/
+#define CEC_OPCODE_POLLING_MESSAGE                0XFE
+
+/**HDMI CEC logical address,please reference  HDMI specification 1.4a*/
+/**CNcomment: HDMI CEC逻辑地址，请参考HDMI 1.4a协议 */
+typedef enum hiUNF_CEC_LOGICALADD_S
+{
+    HI_UNF_CEC_LOGICALADD_TV               = 0X00, /**<TV*//**CNcomment:<电视 */
+    HI_UNF_CEC_LOGICALADD_RECORDDEV_1      = 0X01, /**<Record device 1*//**CNcomment:<录像机 1 */
+    HI_UNF_CEC_LOGICALADD_RECORDDEV_2      = 0X02, /**<Record device 2*//**CNcomment:<录像机 2 */
+    HI_UNF_CEC_LOGICALADD_TUNER_1          = 0X03, /**<Tuner 1*//**CNcomment:<高频头 1*/
+    HI_UNF_CEC_LOGICALADD_PLAYDEV_1        = 0X04, /**<play device 1*//**CNcomment:<播放设备 1 */
+    HI_UNF_CEC_LOGICALADD_AUDIOSYSTEM      = 0X05, /**<audio system*//**CNcomment:<音频系统 */
+    HI_UNF_CEC_LOGICALADD_TUNER_2          = 0X06, /**<tuner 2*//**CNcomment:<高频头 2 */
+    HI_UNF_CEC_LOGICALADD_TUNER_3          = 0X07, /**<tuner 3*//**CNcomment:<高频头 3 */
+    HI_UNF_CEC_LOGICALADD_PLAYDEV_2        = 0X08, /**<play device 2*//**CNcomment:<播放设备 2 */
+    HI_UNF_CEC_LOGICALADD_RECORDDEV_3      = 0X09, /**<Record device 3*//**CNcomment:<录像机 3 */
+    HI_UNF_CEC_LOGICALADD_TUNER_4          = 0X0A, /**<tuner 4*//**CNcomment:<高频头 4 */
+    HI_UNF_CEC_LOGICALADD_PLAYDEV_3        = 0X0B, /**<play device 3*//**CNcomment:<播放设备 3 */
+    HI_UNF_CEC_LOGICALADD_RESERVED_1       = 0X0C, /**<reserved 1*//**CNcomment:<保留项 1 */
+    HI_UNF_CEC_LOGICALADD_RESERVED_2       = 0X0D, /**<reserved 2*//**CNcomment:<保留项 2 */
+    HI_UNF_CEC_LOGICALADD_SPECIALUSE       = 0X0E, /**<special use*//**CNcomment:<特殊用途 */
+    HI_UNF_CEC_LOGICALADD_BROADCAST        = 0X0F, /**<broadcast*//**CNcomment:<广播 */
+    HI_UNF_CEC_LOGICALADD_BUTT
+}HI_UNF_CEC_LOGICALADD_S;
+
+/**HDMI CEC command type,please reference  HDMI specification 1.4a*/
+/**CNcomment: HDMI CEC命令类型，请参考HDMI 1.4a协议 */
+typedef enum hiUNF_CEC_CMDTYPE_E
+{
+    HI_UNF_CEC_STRUCTCOMMAND,                    /**<CEC struct command*//**<CNcomment:CEC 结构命令 */
+    HI_UNF_CEC_RAWCOMMAND,                       /**<CEC raw command*//**<CNcomment:CEC 原始命令 */
+    HI_UNF_CEC_BUTT
+}HI_UNF_CEC_CMDTYPE_E;
+
+/**HDMI CEC Raw Data struct,please reference  HDMI specification 1.4a*/
+/**CNcomment: HDMI CEC原始数据结构体，请参考HDMI 1.4a协议 */
+typedef struct hiUNF_CEC_RAWDATA_S
+{
+    HI_U8                              u8Length;  /**<CEC raw data lengh*//**<CNcomment:cec 有效参数个数 */
+    HI_U8                              u8Data[15];     /**<CEC raw data*//**<CNcomment:CEC 参数结构体 */
+}HI_UNF_CEC_RAWDATA_S;
+
+/**HDMI CEC user Interface Command Opcode,please reference  HDMI specification 1.4a*/
+/**CNcomment: HDMI CEC 用户接口操作指令，请参考HDMI 1.4a协议 */
+typedef enum hiUNF_CEC_UICMD_E
+{
+    HI_UNF_CEC_UICMD_SELECT                      = 0x00,
+    HI_UNF_CEC_UICMD_UP                          = 0x01,
+    HI_UNF_CEC_UICMD_DOWN                        = 0x02,
+    HI_UNF_CEC_UICMD_LEFT                        = 0x03,
+    HI_UNF_CEC_UICMD_RIGHT                       = 0x04,
+    HI_UNF_CEC_UICMD_RIGHT_UP                    = 0x05,
+    HI_UNF_CEC_UICMD_RIGHT_DOWN                  = 0x06,
+    HI_UNF_CEC_UICMD_LEFT_UP                     = 0x07,
+    HI_UNF_CEC_UICMD_LEFT_DOWN                   = 0x08,
+    HI_UNF_CEC_UICMD_ROOT_MENU                   = 0x09,
+    HI_UNF_CEC_UICMD_SETUP_MENU                  = 0x0A,
+    HI_UNF_CEC_UICMD_CONTENTS_MENU               = 0x0B,
+    HI_UNF_CEC_UICMD_FAVORITE_MENU               = 0x0C,
+    HI_UNF_CEC_UICMD_EXIT                        = 0x0D,
+    HI_UNF_CEC_UICMD_NUM_0                       = 0x20,
+    HI_UNF_CEC_UICMD_NUM_1                       = 0x21,
+    HI_UNF_CEC_UICMD_NUM_2                       = 0x22,
+    HI_UNF_CEC_UICMD_NUM_3                       = 0x23,
+    HI_UNF_CEC_UICMD_NUM_4                       = 0x24,
+    HI_UNF_CEC_UICMD_NUM_5                       = 0x25,
+    HI_UNF_CEC_UICMD_NUM_6                       = 0x26,
+    HI_UNF_CEC_UICMD_NUM_7                       = 0x27,
+    HI_UNF_CEC_UICMD_NUM_8                       = 0x28,
+    HI_UNF_CEC_UICMD_NUM_9                       = 0x29,
+    HI_UNF_CEC_UICMD_DOT                         = 0x2A,
+    HI_UNF_CEC_UICMD_ENTER                       = 0x2B,
+    HI_UNF_CEC_UICMD_CLEAR                       = 0x2C,
+    HI_UNF_CEC_UICMD_NEXT_FAVORITE               = 0x2F,
+    HI_UNF_CEC_UICMD_CHANNEL_UP                  = 0x30,
+    HI_UNF_CEC_UICMD_CHANNEL_DOWN                = 0x31,
+    HI_UNF_CEC_UICMD_PREVIOUS_CHANNEL            = 0x32,
+    HI_UNF_CEC_UICMD_SOUND_SELECT                = 0x33,
+    HI_UNF_CEC_UICMD_INPUT_SELECT                = 0x34,
+    HI_UNF_CEC_UICMD_DISPLAY_INFORMATION         = 0x35,
+    HI_UNF_CEC_UICMD_HELP                        = 0x36,
+    HI_UNF_CEC_UICMD_PAGE_UP                     = 0x37,
+    HI_UNF_CEC_UICMD_PAGE_DOWN                   = 0x38,
+    HI_UNF_CEC_UICMD_POWER                       = 0x40,
+    HI_UNF_CEC_UICMD_VOLUME_UP                   = 0x41,
+    HI_UNF_CEC_UICMD_VOLUME_DOWN                 = 0x42,
+    HI_UNF_CEC_UICMD_MUTE                        = 0x43,
+    HI_UNF_CEC_UICMD_PLAY                        = 0x44,
+    HI_UNF_CEC_UICMD_STOP                        = 0x45,
+    HI_UNF_CEC_UICMD_PAUSE                       = 0x46,
+    HI_UNF_CEC_UICMD_RECORD                      = 0x47,
+    HI_UNF_CEC_UICMD_REWIND                      = 0x48,
+    HI_UNF_CEC_UICMD_FAST_FORWARD                = 0x49,
+    HI_UNF_CEC_UICMD_EJECT                       = 0x4A,
+    HI_UNF_CEC_UICMD_FORWARD                     = 0x4B,
+    HI_UNF_CEC_UICMD_BACKWARD                    = 0x4C,
+    HI_UNF_CEC_UICMD_STOP_RECORD                 = 0x4D,
+    HI_UNF_CEC_UICMD_PAUSE_RECORD                = 0x4E,
+    HI_UNF_CEC_UICMD_ANGLE                       = 0x50,
+    HI_UNF_CEC_UICMD_SUBPICTURE                  = 0x51,
+    HI_UNF_CEC_UICMD_VIDEO_ON_DEMAND             = 0x52,
+    HI_UNF_CEC_UICMD_ELECTRONIC_PROGRAM_GUIDE    = 0x53,
+    HI_UNF_CEC_UICMD_TIMER_PROGRAMMING           = 0x54,
+    HI_UNF_CEC_UICMD_INITIAL_CONFIGURATION       = 0x55,
+    HI_UNF_CEC_UICMD_PLAY_FUNCTION               = 0x60,
+    HI_UNF_CEC_UICMD_PAUSE_PLAY_FUNCTION         = 0x61,
+    HI_UNF_CEC_UICMD_RECORD_FUNCTION             = 0x62,
+    HI_UNF_CEC_UICMD_PAUSE_RECORD_FUNCTION       = 0x63,
+    HI_UNF_CEC_UICMD_STOP_FUNCTION               = 0x64,
+    HI_UNF_CEC_UICMD_MUTE_FUNCTION               = 0x65,
+    HI_UNF_CEC_UICMD_RESTORE_VOLUME_FUNCTION     = 0x66,
+    HI_UNF_CEC_UICMD_TUNE_FUNCTION               = 0x67,
+    HI_UNF_CEC_UICMD_SELECT_MEDIA_FUNCTION       = 0x68,
+    HI_UNF_CEC_UICMD_SELECT_AV_INPUT_FUNCTION    = 0x69,
+    HI_UNF_CEC_UICMD_SELECT_AUDIO_INPUT_FUNCTION = 0x6A,
+    HI_UNF_CEC_UICMD_POWER_TOGGLE_FUNCTION       = 0x6B,
+    HI_UNF_CEC_UICMD_POWER_OFF_FUNCTION          = 0x6C,
+    HI_UNF_CEC_UICMD_POWER_ON_FUNCTION           = 0x6D,
+    HI_UNF_CEC_UICMD_F1_BLUE                     = 0x71,
+    HI_UNF_CEC_UICMD_F2_RED                      = 0x72,
+    HI_UNF_CEC_UICMD_F3_GREEN                    = 0x73,
+    HI_UNF_CEC_UICMD_F4_YELLOW                   = 0x74,
+    HI_UNF_CEC_UICMD_F5                          = 0x75,
+    HI_UNF_CEC_UICMD_DATA                        = 0x76
+}HI_UNF_CEC_UICMD_E;
+
+/**HDMI CEC operand command,please reference  HDMI specification 1.4a*/
+/**CNcomment: HDMI CEC 操作指令，请参考HDMI 1.4a协议 */
+/**member stUIOpcode:
+\ member stUIOpcode not support when "CEC OPERAND FORCE RAWDATA" set Y on make menuconfig options
+\ or just support when u8Opcode is <User Control Pressed>
+\ CNcomment:
+\ 当make menuconfig参数选择了CEC OPERAND FORCE RAWDATA时, 成员stUIOpcode不可用;
+\ 当没有选择此宏时，u8Opcode为<User Control Pressed>时只能使用成员stUIOpcode
+*/
+typedef union hiUNF_CEC_Operand_t
+{
+    HI_UNF_CEC_RAWDATA_S               stRawData;   /**<CEC raw date*//**<CNcomment:CEC 原始命令 */
+    HI_UNF_CEC_UICMD_E                 stUIOpcode;  /**<CEC user interface command*//**<CNcomment:CEC用户自定义操作 */
+}HI_UNF_CEC_Operand_t;
+
+/**HDMI CEC struct command*/
+/**CNcomment: HDMI CEC 命令结构 */
+typedef struct hiUNF_HDMI_CEC_CMD_S
+{
+    HI_UNF_CEC_LOGICALADD_S  enSrcAdd;     /**<logical address of source *//**<CNcomment:源端设备地址 */
+    HI_UNF_CEC_LOGICALADD_S  enDstAdd;     /**<logical address of destination*//**<CNcomment:目标设备地址 */
+    HI_U8                    u8Opcode;     /**<opration code*//**<CNcomment:操作码*/
+    HI_UNF_CEC_Operand_t     unOperand;    /**<operand*//**<CNcomment:操作数*/
+}HI_UNF_HDMI_CEC_CMD_S;
+
+/**HDMI CEC status struct*/
+/**CNcomment: HDMI CEC 状态结构 */
+typedef struct hiUNF_HDMI_CEC_STATUS_S
+{
+    HI_BOOL bEnable;                                 /**<the flag of CEC work,HI_TRUE:CEC work enable,HI_FALSE:CEC no work ,other parameter no effect*/ /**<CNcomment:CEC 正常工作标记位，如果为HI_TRUE,CEC可以正常工作，如果为HI_FASLE,CEC的其他参数无效，并且不能工作 */
+    HI_U8   u8PhysicalAddr[4];                       /**<CEC physics address*/ /**<CNcomment:CEC 物理地址 */
+    HI_U8   u8LogicalAddr;                           /**<CEC logic address,defualt 0x03*//**<CNcomment:CEC 逻辑地址，默认为：0x03. */
+    HI_U8   u8Network[HI_UNF_CEC_LOGICALADD_BUTT];   /**<CEC network struct ,1:the device can response CEC command*/ /**<CNcomment:CEC 构建的网路结构，为1表示该设备能够响应CEC命令 */
+}HI_UNF_HDMI_CEC_STATUS_S;
+
+/**HDMI CEC Regcallback param struct */
+/**CNcomment: HDMI CEC 回调函数参数结构 */
+typedef HI_VOID (*HI_UNF_HDMI_CECCALLBACK)(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CEC_CMD_S *pstCECCmd, HI_VOID *pData);
+
+
+/**HDMI Callback Struct*/
+/**CNcomment: HDMI回调结构 */
+typedef struct hiUNF_HDMI_CECCALLBACK_FUNC_S
+{
+    HI_UNF_HDMI_CECCALLBACK pfnCECCallBack;       /**<callback function pointer*//**<CNcomment:回调函数指针*/
+    HI_VOID                *pPrivateData;         /**<callback funtion param*//**<CNcomment:回调函数参数*/
+ }HI_UNF_HDMI_CECCALLBACK_EXT_S;
+
+
+
+/**HDMI HDCP key struct*/
+/**CNcomment: HDMI HDCP 密钥结构 */
+typedef struct hiUNF_HDMI_LOAD_KEY_S
+{
+    HI_U8 *pu8InputEncryptedKey;            /**<Encrypted key pointer *//**<CNcomment:加密的密钥数组头地址 */
+    HI_U32 u32KeyLength;                    /**<Encrypted key length*//**<CNcomment:加密的密钥长度 */
+}HI_UNF_HDMI_LOAD_KEY_S;
+
+/**HDMI HDCP SRM(system renewability messages) struct*/
+/**CNcomment: HDMI HDCP SRM(失效列表)结构 */
+typedef struct hiUNF_HDMI_SRM_S
+{
+    HI_U8 *pu8SrmData;              /**<SRM raw data *//**<CNcomment:SRM 原始数据数组头地址 */
+    HI_U32 u32SrmLen;               /**<Length of SRM *//**<CNcomment:原始数据长度，单位为字节 */
+} HI_UNF_HDMI_SRM_S;
+
+
+/**< HDCP-capability struct *//**<CNcomment:HDCP 能力结构体 */
+typedef struct{
+    HI_BOOL        bHdcp14Support;  /**<sink support HDCP1.4 *//**<CNcomment:sink支持HDCP1.4 */
+    HI_BOOL        bHdcp22Support;  /**<sink support HDCP2.2 *//**<CNcomment:sink支持HDCP2.2 */
+}HI_UNF_HDMI_HDCP_CAP_S;
+
+/**HDMI HDCP eanble parameter*/
+/**CNcomment: HDMI HDCP 使能参数 */
+typedef struct hiUNF_HDMI_HDCP_PARAM_S{
+    HI_BOOL                 bHdcpEnable;    /**<set HI_TRUE to enable HDCP,set HI_FALSE to disable HDCP. *//**<CNcomment:设置HI_TRUE使能HDCP;设置HI_FALSE关闭关闭HDCP*/
+    HI_UNF_HDMI_HDCP_MODE_E enHdcpMode;     /**<HDCP mode of authentication,suggest that according to HDCP-capability. *//**<CNcomment:HDCP认证模式，建议获取sink能力之后根据能力设置*/
+
+}HI_UNF_HDMI_HDCP_PARAM_S;
+
+/**HDMI HDCP error code*/
+/**CNcomment: HDMI HDCP错误码*/
+typedef enum hiUNF_HDMI_HDCP_ERR_E
+{
+    HI_UNF_HDMI_HDCP_ERR_UNDO = 0x00,           /**< undo hdcp. *//**<CNcomment:未进行HDCP认证*/
+    HI_UNF_HDMI_HDCP_ERR_NONE,                  /**< no error. *//**<CNcomment:没有发生HDCP认证错误*/
+    HI_UNF_HDMI_HDCP_ERR_UNHPD,                 /**< eanble HDCP when HPD is low. *//**<CNcomment:HPD为低时使能认证*/
+    HI_UNF_HDMI_HDCP_ERR_NO_TIMMING,            /**< no timming.Enable HDCP before HDMI start. *//**<CNcomment:无时序，在HDMI无视频输出时使能使能HDCP(HDMI 未启动)*/
+    HI_UNF_HDMI_HDCP_ERR_LOADKEY_FAIL,          /**< no loadkey.Only for HDCP1.4 *//**<CNcomment:未加载HDCP1.4 key*/
+    HI_UNF_HDMI_HDCP_ERR_ON_REVOCATION_LIST,    /**< recieve ID/BKSV list on revocation list.*//**<CNcomment:接收设备(包含下游设备)在DCP失效列表黑名单中*/
+    HI_UNF_HDMI_HDCP_ERR_RECEIVER_FAIL,         /**< receiver respond error.*//**<CNcomment:接收设备响应错误信息*/
+    HI_UNF_HDMI_HDCP_ERR_MAXDEV_EXCEEDED,       /**< more than 127 downstream devices,  or the capacity of the KSV Fifo, are attached.*//**<CNcomment:拓扑中设备数量超过最大值127，或者存在设备KSV Fifo不足情况*/
+    HI_UNF_HDMI_HDCP_ERR_MAXCASCADE_EXCEEDED,   /**< more than seven levels of video repeater have been cascaded together*//**<CNcomment:拓扑中超过7级设备层数*/
+    HI_UNF_HDMI_HDCP_ERR_REPEATER_FAIL,         /**< repeater respond error.*//**<CNcomment:repeater设备响应错误信息*/
+
+}HI_UNF_HDMI_HDCP_ERR_E;
+
+/**HDMI HDCP status */
+/**CNcomment: HDMI HDCP状态*/
+typedef struct hiUNF_HDCP_STATUS_S{
+    HI_UNF_HDMI_HDCP_VERSION_E      enHdcpVersion;  /**< HDCP current version.*//**<CNcomment:HDCP当前版本*/
+    HI_BOOL                         bHdcpEnable;    /**< HDCP enable status.*//**<CNcomment:HDCP使能状态*/
+    HI_UNF_HDMI_HDCP_ERR_E          enHdcpErrCode;  /**< HDCP error code.*//**<CNcomment:HDCP 错误码*/
+}HI_UNF_HDCP_STATUS_S;
+
+
+/**HDMI Delay struct*/
+/**CNcomment: HDMI 延时结构 */
+typedef struct hiUNF_HDMI_DELAY_S
+{
+    HI_U32  u32MuteDelay;           /**<delay for avmute *//**<CNcomment:avmute的延时 */
+    HI_U32  u32FmtDelay;            /**<delay for setformat *//**<CNcomment:设置制式的延时 */
+    HI_BOOL bForceFmtDelay;         /**<force setformat delay mode *//**<CNcomment:切换制式强制延时模式 */
+    HI_BOOL bForceMuteDelay;        /**<force avmute delay mode *//**<CNcomment:mute强制延时模式 */
+}HI_UNF_HDMI_DELAY_S;
+
+/**HDMI Resume start flag*/
+/**CNcomment: 系统唤醒时HDMI驱动是否主动打开输出 */
+typedef enum hiUNF_HDMI_RESUME_START_E
+{
+    HI_UNF_HDMI_RESUME_AND_START = 0,   /**<HDMI starts when the system is resumed*//**<CNcomment:系统Resume时HDMI驱动主动start*/
+    HI_UNF_HDMI_RESUME_NOT_START        /**<HDMI not start when the system is resumed*//**<CNcomment:系统Resume时HDMI驱动不主动start*/
+} HI_UNF_HDMI_RESUME_START_E;
+
+/**HDMI advanced attribute struct*/
+/**CNcomment: HDMI高级属性结构 */
+typedef struct hiUNF_HDMI_ADVANCED_ATTR_S
+{
+    HI_UNF_HDMI_RESUME_START_E enResumeStart;
+}HI_UNF_HDMI_ADVANCED_ATTR_S;
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HDMI */
+/** @{ */  /** <!-- [HDMI] */
+
+/**
+\brief the whole initialization of the hdmi. CNcomment:HDMI接口驱动软件初始化 CNend
+\attention  this func should be called before vo_init and after disp_init. CNcomment:必须在DISP驱动Setup之后和VO驱动Setup之前打开 CNend
+\param CNcomment:无 CNend
+\retval HI_SUCCESS  success. CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_Init(HI_VOID);
+
+
+/**
+\brief deinit the hdmi. CNcomment:HDMI接口去初始化 CNend
+\attention  this must be called after vo exited and before disp  exited . CNcomment:必须在VO驱动Exit之后和DISP驱动Exit之前打开 CNend
+\param CNcomment:无 CNend
+\retval HI_SUCCESS      success.CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_DeInit(HI_VOID);
+
+
+/**
+\brief create hdmi device. CNcomment:创建HDMI设备 CNend
+\attention \n
+\param[in] enHdmi  hdmi device id. CNcomment:要打开的HDMI设备 CNend
+\param[in] pstOpenPara  When get GetSinkCapability failed,defalut set sink device to DVI/HDMI mode.CNcomment:未获取到对端能力集时，默认把对端当成(DVI/HDMI)设备 CNend
+\retval HI_SUCCESS     success.  CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_Open(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_OPEN_PARA_S *pstOpenPara);
+
+/**
+\brief close the handler created by  HI_UNF_HDMI_Open. CNcomment:销毁由HI_UNF_HDMI_Open创建的句柄 CNend
+\attention \n
+\param[in] enHdmi  hdmi device id. CNcomment:HDMI设备ID CNend
+\retval HI_SUCCESS     success.  CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_Close(HI_UNF_HDMI_ID_E enHdmi);
+
+/**
+\brief get current hdmi status. CNcomment:获取hdmi当前的状态 CNend
+\attention \n
+\param[in] enHdmi  hdmi device id. CNcomment:HDMI设备ID CNend
+\param[out] pHdmiStatus hdmi cuttent status. CNcomment:HDMI当前状态 CNend
+\retval HI_SUCCESS     success.  CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_GetStatus(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_STATUS_S *pHdmiStatus);
+
+/**
+\brief to get the capability of sink connect to stbbox. CNcomment:查询获取HDMI Sink设备的能力集 CNend
+\attention \n
+\param[in] enHdmi   hdmi device id.CNcomment:HDMI设备ID CNend
+\param[out] pCapability  the capability of the sink .CNcomment:SINK能力集 CNend
+\retval HI_SUCCESS       success.  CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi. CNcomment:请参考MPI错误码 CNend
+\see ::HI_UNF_EDID_BASE_INFO_S\n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_GetSinkCapability(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_EDID_BASE_INFO_S *pCapability);
+
+/**
+\brief set the attr of given hdmi interface. CNcomment:设置HDMI接口属性。 CNend
+\attention the setting will take effect after HI_UNF_HDMI_Start is called.Suggest that HI_UNF_HDMI_Stop before change enDeepColorMode to reduce noisy.
+\param[in] enHdmi      hdmi device id.CNcomment:HDMI设备ID CNend
+\param[in] pstAttr     the attr of given hdmi interface.CNcomment:HDMI接口属性 CNend
+\retval HI_SUCCESS     success.  CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see ::HI_UNF_HDMI_ATTR_S\n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_SetAttr(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_ATTR_S *pstAttr);
+
+
+/**
+\brief get the current attr of the give hdmi interface. CNcomment:查询HDMI接口当前属性 CNend
+\attention \n
+\param[in] enHdmi hdmi device id.CNcomment: HDMI设备ID CNend
+\param[out] pstAttr     the attr of given hdmi interface. CNcomment:HDMI接口属性 CNend
+\retval HI_SUCCESS      success. CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see HI_UNF_HDMI_ATTR_S\n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_GetAttr(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_ATTR_S *pstAttr);
+
+
+/**
+\brief get the cec working status. CNcomment:获取CEC状态 CNend
+\attention  user can get the cec working status through this func. CNcomment:客户可以通过该接口获取CEC工作状态\n CNend
+\param[in] enHdmi       hdmi device id.CNcomment:HDMI设备ID CNend
+\param[in] pStatus     get cec working status. CNcomment:CEC 状态 CNend
+\retval HI_SUCCESS     success. CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see ::HI_UNF_HDMI_CEC_CMD_S\n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_CECStatus(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CEC_STATUS_S  *pStatus);
+
+
+/**
+\brief send the cec data. CNcomment:发送CEC 命令 CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMI设备ID CNend
+\param[in] pCECCmd      the cec cmd data.CNcomment:Cec Command 内容 CNend
+\retval HI_SUCCESS     success. CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see ::HI_UNF_HDMI_CEC_CMD_S\n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_SetCECCommand(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CEC_CMD_S  *pCECCmd);
+
+
+/**
+\brief get the cec data received. CNcomment:接收的CEC 命令 CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMI设备ID CNend
+\param[in] pCECCmd    the cec cmd data. CNcomment:Cec Command 内容 CNend
+\param[in] timeout    timeout for getting cec cmd, unit: 10ms;
+\retval HI_SUCCESS      success. CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see ::HI_UNF_HDMI_CEC_CMD_S\n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_GetCECCommand(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CEC_CMD_S  *pCECCmd, HI_U32 timeout);
+
+/**
+\brief register CEC callback function. CNcomment:注册获取CEC回调函数 CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMI设备ID CNend
+\param[in] pCECCallback    the cec callback handle. CNcomment:回调函数句柄 CNend
+\retval HI_SUCCESS      success. CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see ::HI_UNF_HDMI_CECCALLBACK,HI_UNF_HDMI_RegCECCallBackFuncExt\n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_RegCECCallBackFunc(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CECCALLBACK pCECCallback);
+
+/**
+\brief unregister CEC callback function. CNcomment:反注册获取CEC回调函数 CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMI设备ID CNend
+\param[in] pCECCallback  the cec callback handle. CNcomment:回调函数句柄 CNend
+\retval HI_SUCCESS      success. CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\NOTE:: You should un-register when finished using the CEC_CALLBACK function before HI_UNF_HDMI_DeInit.Associate with HI_UNF_HDMI_RegCECCallBackFunc.CNcomment:退出前请注销回调函数 CNend
+\see ::HI_UNF_HDMI_CECCALLBACK,HI_UNF_HDMI_UnRegCECCallBackFuncExt\n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_UnRegCECCallBackFunc(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CECCALLBACK pCECCallback);
+
+
+/**
+\brief register CEC callback function, only use with HI_UNF_HDMI_RegCECCallbackFuncExt. CNcomment:注册获取CEC回调函数，仅与 HI_UNF_HDMI_UnRegCECCallBackFunc配套使用 CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMI设备ID CNend
+\param[in] pstCallBackFunc    the cec callback handle. CNcomment:回调函数句柄 CNend
+\retval HI_SUCCESS      success. CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\NOTE:: You can use the interface deliver a private data pointer.But HI_UNF_HDMI_RegCECCallBackFunc can't support.You can select one of them.CNcomment:本接口支持传入私有数据指针，但 HI_UNF_HDMI_RegCECCallBackFunc不支持,请根据需要选择其中之一使用即可。 CNend
+\see ::HI_UNF_HDMI_CECCALLBACK_EXT_S\n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_RegCECCallBackFuncExt(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CECCALLBACK_EXT_S *pstCallBackExt);
+
+/**
+\brief unregister CEC callback function. CNcomment:反注册获取CEC回调函数 CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMI设备ID CNend
+\param[in] pstCallBackFunc  the cec callback handle. CNcomment:回调函数句柄 CNend
+\retval HI_SUCCESS      success. CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\NOTE:: You should un-register when finished using the CEC_CALLBACK function before HI_UNF_HDMI_DeInit.Associate with HI_UNF_HDMI_RegCECCallBackFuncExt.CNcomment:退出前请注销回调函数 CNend
+\see ::HI_UNF_HDMI_CECCALLBACK_EXT_S\n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_UnRegCECCallBackFuncExt(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CECCALLBACK_EXT_S *pstCallBackExt);
+
+
+/**
+\brief enable the cec func. CNcomment:CEC 使能打开 CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMI设备ID CNend
+\retval HI_SUCCESS     success. CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_CEC_Enable(HI_UNF_HDMI_ID_E enHdmi);
+
+/**
+\brief disable the cec func. CNcomment:CEC 使能关闭 CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMI设备ID CNend
+\retval HI_SUCCESS      success. CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_CEC_Disable(HI_UNF_HDMI_ID_E enHdmi);
+
+/**
+\brief  set and send infoframe. CNcomment:设置并发送InfoFrame CNend
+\attention \n
+\param[in] enHdmi       hdmi device id.CNcomment:HDMI设备ID CNend
+\param[in] pstInfoFrame the inforframe content.CNcomment:InfoFrame内容 CNend
+\retval HI_SUCCESS      success. CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_SetInfoFrame(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_INFOFRAME_S *pstInfoFrame);
+
+/**
+\brief get the infoframe infor. CNcomment:获取正在发送的InfoFrame的信息 CNend
+\attention \n
+\param[in] enHdmi       hdmi device id. CNcomment:HDMI设备ID CNend
+\param[in] enInfoFrameType the info frame type such as avi or audio or gcp etc. CNcomment:InfoFrame类型 CNend
+\param[out] pstInfoFrame   the inforframe content.CNcomment:InfoFrame内容 CNend
+\retval HI_SUCCESS      success.CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_GetInfoFrame(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_INFOFRAME_TYPE_E enInfoFrameType, HI_UNF_HDMI_INFOFRAME_S *pstInfoFrame);
+
+
+
+/**
+\brief  start the hdmi works. CNcomment:HDMI开始 CNend
+\attention \n
+this should be called after HI_UNF_HDMI_SetAttr.
+CNcomment:启动HDMI接口。一般在HI_UNF_HDMI_SetAttr之后调用 CNend
+\param[in] enHdmi   hdmi device id.CNcomment:HDMI设备ID CNend
+\retval HI_SUCCESS     success. CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_Start(HI_UNF_HDMI_ID_E enHdmi);
+
+/**
+\brief stop  the hdmi. CNcomment:hdmi停止 CNend
+\attention \n
+this func should be called  when hdmi plug out.
+CNcomment:当HDMI线被拔除后，HDMI回调函数应该调用该函数。 CNend
+\param[in] enHdmi  hdmi device id. CNcomment:HDMI设备ID CNend
+\retval HI_SUCCESS     success. CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_Stop(HI_UNF_HDMI_ID_E enHdmi);
+
+/**
+\brief set the deep color mode. CNcomment:设置HDMI DeepColor模式 CNend
+\attention \n
+\param[in] enHdmi   hdmi device id. CNcomment:HDMI设备ID CNend
+\param[in] enDeepColor deep color mode,please refer to the HI_UNF_HDMI_DEEP_COLOR_E definiton.CNcomment:DeepColor模式，请参考::HI_UNF_HDMI_DEEP_COLOR_E  CNend
+\retval HI_SUCCESS     success. CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_SetDeepColor(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_DEEP_COLOR_E enDeepColor);
+
+/**
+\brief switch the xvycc on or off. CNcomment:设置HDMI xvYCC 模式 CNend
+\attention \n
+\param[in] enHdmi   hdmi device id.CNcomment:HDMI设备ID CNend
+\param[in] bEnalbe   whether to enable xvycc mode or not .CNcomment:是否使能xvYCC模式 CNend
+\retval HI_SUCCESS    success.  CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_SetxvYCCMode(HI_UNF_HDMI_ID_E enHdmi, HI_BOOL bEnalbe);
+
+/**
+\brief switch the mute of av  on or off. CNcomment:设置HDMI AV mute 模式 CNend
+\attention \n
+\param[in] enHdmi   hdmi device id.CNcomment:HDMI设备ID CNend
+\param[in] bAvMute   whether to mute the av.CNcomment:是否mute AV CNend
+\retval HI_SUCCESS     success. CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_SetAVMute(HI_UNF_HDMI_ID_E enHdmi, HI_BOOL bAvMute);
+
+/**
+\brief get the edid information forcelly. CNcomment:强制获取EDID原始数据,该接口为特定平台需要获取原始EDID的接口 CNend
+\attention \n
+\param[in] enHdmi   hdmi device id.CNcomment:HDMI设备ID CNend
+\param[out] *u8Edid  the buffer allocated externally, buffer size must be 512. CNcomment:获取原始EDID数据buffer。EDID版本不同，读出来的数据不同，取上限buffer 大小为512,用户需自己分配好; CNend
+\param[in] u32EdidBufSize  size of the Edid buffer. CNcomment:EDID数据buffer大小 CNend
+\param[out] *u32EdidLength  the data lenth of  original edid. CNcomment:获取原始EDID数据长度 CNend
+\retval HI_SUCCESS   success.   CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_Force_GetEDID(HI_UNF_HDMI_ID_E enHdmi, HI_U8 *u8Edid, HI_U32 u32EdidBufSize, HI_U32 *u32EdidLength);
+
+
+/**
+\brief register callback function. CNcomment:注册回调函数 CNend
+\attention \n
+this func should be called before HI_UNF_HDMI_Open and after HI_UNF_HDMI_Init
+because HI_UNF_HDMI_Open will trigger hotplug event.
+And this function can only register one function
+If call this func two times,then the 2nd callback function will cover 1st one.
+CNcomment:建议在HI_UNF_HDMI_Init之后和HI_UNF_HDMI_Open之前调用 \n
+因为Open时如果连着接收端设备上会触发一次hotplug消息 \n
+该函数只能注册一个回调函数，第二次注册的回调函数会覆盖前面的回调函数 CNend
+\param CNcomment:无 CNend
+\param[in] enHdmi   hdmi device id.CNcomment:HDMI设备ID CNend
+\param[in] *HI_UNF_HDMI_CALLBACK_FUNC_S  callback function CNcomment:回调函数 CNend
+\retval HI_SUCCESS   success.   CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_RegCallbackFunc(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CALLBACK_FUNC_S *pstCallbackFunc);
+
+
+/**
+\brief unregister CallbackFunc. CNcomment:注销回调函数 CNend
+\attention \n
+this func should be called before HI_UNF_HDMI_DeInit and after HI_UNF_HDMI_Close
+CNcomment:建议在HI_UNF_HDMI_Close之后和HI_UNF_HDMI_DeInit之前调用 CNend
+\param[in] enHdmi   hdmi device id.CNcomment:HDMI设备ID CNend
+\param[in] *HI_UNF_HDMI_CALLBACK_FUNC_S  callback function CNcomment:回调函数 CNend
+\retval HI_SUCCESS   success.   CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_UnRegCallbackFunc(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_CALLBACK_FUNC_S *pstCallbackFunc);
+
+/**
+\brief Load HDCP key. CNcomment:导入hdcpkey CNend
+\attention \n
+\param[in] enHdmi   hdmi device id.CNcomment:HDMI设备ID CNend
+\param[in] *pstLoadKey  key struct length and point CNcomment:key 的结构 长度和指针 CNend
+\retval HI_SUCCESS   success.   CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_LoadHDCPKey(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_LOAD_KEY_S *pstLoadKey);
+
+/**
+\brief Set SRM, it is called by user, it can be call more time,only remain the last one when set success.Ncomment:导入SRM数据 CNend
+\param[in]  enHdmi  hdmi channel id. CNcomment:HDMI设备ID CNend
+\param[in]  pstSrm SRM raw dataCNcomment:SRM结构 指针 CNend
+\retval HI_SUCCESS   success/HI_FAILURE fail.  CNcomment:成功/失败 CNend
+*/
+HI_S32 HI_UNF_HDMI_SetSrm(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_SRM_S *pstSrm);
+
+/**
+\brief to get the HDCP-capability of sink connect to stbbox. CNcomment:获取HDMI Sink设备的HDCP能力 CNend
+\attention in HI_UNF_HDMI_GetSinkCapability,HI_UNF_EDID_BASE_INFO_S's stHDCPSupport is triggered by HotPlug,some Sink get HDCP-capability fail when HotPlug.Base on these,it is suggested that use HI_UNF_HDMI_GetHdcpCapability force to get HDCP-capability from sink.When retval is HI_FAILURE,it is suggested that use HI_UNF_HDMI_GetHdcpCapability to get more times until retval is HI_SUCCESS.
+\CNcomment:注意，HI_UNF_EDID_BASE_INFO_S的stHDCPSupport只在HotPlug到来时获取sink能力，部分电视可能未准备好而获取失败。强烈建议使用HI_UNF_HDMI_GetHdcpCapability获取sink的HDCP能力。若返回值为HI_FAILURE,建议获取多次，直到返回值HI_SUCCESS。 CNend
+\param[in] enHdmi   hdmi device id.CNcomment:HDMI设备ID CNend
+\param[out] pstHdcpCap  the HDCP capability of the sink .CNcomment:SINK的HDCP能力 CNend
+\retval HI_SUCCESS   success/HI_FAILURE fail.  CNcomment:成功/失败 CNend
+*/
+HI_S32 HI_UNF_HDMI_GetHdcpCapability(HI_UNF_HDMI_ID_E enHdmi,HI_UNF_HDMI_HDCP_CAP_S *pstHdcpCap);
+
+/**
+\brief to enable HDCP authentication dynamically after HI_UNF_HDMI_Start. CNcomment:动态使能HDCP认证 CNend
+\attention the interface must call after HI_UNF_HDMI_Start.And ,it is suggested that select enHdcpMode according to sink's HDCP-capability.
+\CNcomment:注意，该接口必须在HI_UNF_HDMI_Start之后调用。建议根据sink的HDCP能力选择对应模式。 CNend
+\param[in] enHdmi   hdmi device id.CNcomment:HDMI设备ID CNend
+\param[in] pstParm  hdcp parameter when enable.CNcomment:HDCP使能参数 CNend
+\retval HI_SUCCESS   success/HI_FAILURE fail.  CNcomment:成功/失败 CNend
+*/
+HI_S32 HI_UNF_HDMI_HdcpEnable(HI_UNF_HDMI_ID_E enHdmi,HI_UNF_HDMI_HDCP_PARAM_S *pstParm);
+
+/**
+\brief to get HDCP status. CNcomment:获取HDCP认证状态 CNend
+\attention suggest the interface call after getting HDCP event.CNcomment:建议在获取HDCP事件后调用 CNend
+\param[in] enHdmi   hdmi device id.CNcomment:HDMI设备ID CNend
+\param[in] pstStatus  hdcp status.CNcomment:HDCP认证状态 CNend
+\retval HI_SUCCESS   success/HI_FAILURE fail.  CNcomment:成功/失败 CNend
+*/
+HI_S32 HI_UNF_HDMI_GetHdcpStatus(HI_UNF_HDMI_ID_E enHdmi,HI_UNF_HDCP_STATUS_S *pstStatus);
+
+
+/**
+\brief get the edid information forcelly. CNcomment:从EEPROM获取EDID数据 CNend
+\attention \n
+Difference with two interface for get EDID
+HI_UNF_HDMI_Force_GetEDID : Reread EDID from Sink,and write it to EEPROM
+HI_UNF_HDMI_ReadEDID : read edid from EEPROM,not Real-time read from Sink
+CNcomment:两个获取EDID的接口差别
+HI_UNF_HDMI_Force_GetEDID 是重新从接收端读取Edid，并写到EEPROM
+HI_UNF_HDMI_ReadEDID 是从EEPROM读取Edid，而不是实时的接收端EDID CNend
+\param[out] *u8Edid  the buffer allocated externally, buffer size must be 512. CNcomment:获取原始EDID数据buffer。EDID版本不同，读出来的数据不同，取上限buffer 大小为512,用户需自己分配好; CNend
+\param[in] u32EdidBufSize  size of the Edid buffer. CNcomment:EDID数据buffer大小 CNend
+\param[out] *u32EdidLength  the data lenth of  original edid. CNcomment:获取原始EDID数据长度 CNend
+\retval HI_SUCCESS   success.   CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_ReadEDID(HI_U8 *u8Edid, HI_U32 u32EdidBufSize, HI_U32 *u32EdidLength);
+
+/**
+\brief Get HDMI runtime delay. CNcomment:获取hdmi运行时延时 CNend
+\attention \n
+CNend
+\param[in] *pstDelay  delay struct delay time and mode CNcomment:延时结构体 延时的时长和模式 CNend
+\retval HI_SUCCESS   success.   CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_GetDelay(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_DELAY_S *pstDelay);
+
+/**
+\brief Set HDMI runtime delay. CNcomment:设置hdmi运行时延时 CNend
+\attention \n
+if not use this interface, then use hdmi inner delay
+CNcomment:默认情况下调用该接口前会使用内部延时,调用后根据delay模式使用延时 CNend
+\param[in] *pstDelay  delay struct delay time and mode CNcomment:延时结构体 延时的时长和模式 CNend
+\retval HI_SUCCESS   success.   CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_SetDelay(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_DELAY_S *pstDelay);
+
+/**
+\brief set the advanced attr of given hdmi interface. CNcomment:设置HDMI接口的高级属性。 CNend
+\attention when the pstAdvancedAttr->enResumeStart is set to HI_UNF_HDMI_RESUME_NOT_START, resuming the system needs to call HI_UNF_HDMI_Start().
+\param[in] enHdmi      hdmi device id.CNcomment:HDMI设备ID CNend
+\param[in] pstAdvancedAttr     the attr of given hdmi interface.CNcomment:HDMI接口高级属性 CNend
+\retval HI_SUCCESS     success.  CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see ::HI_UNF_HDMI_ADVANCED_ATTR_S\n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_SetAdvancedAttr(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_ADVANCED_ATTR_S *pstAdvancedAttr);
+
+/**
+\brief get the current advanced attr of the give hdmi interface. CNcomment:查询HDMI接口当前的高级属性 CNend
+\attention \n
+\param[in] enHdmi hdmi device id.CNcomment: HDMI设备ID CNend
+\param[out] pstAdvancedAttr     the attr of given hdmi interface. CNcomment:HDMI接口高级属性 CNend
+\retval HI_SUCCESS      success. CNcomment:成功 CNend
+\retval please refer to the err code definitino of mpi.CNcomment:请参考MPI错误码 CNend
+\see HI_UNF_HDMI_ADVANCED_ATTR_S\n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_HDMI_GetAdvancedAttr(HI_UNF_HDMI_ID_E enHdmi, HI_UNF_HDMI_ADVANCED_ATTR_S *pstAdvancedAttr);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+
+#endif /* __HI_UNF_HDMI_H__ */
+
diff -uNr a/include/hi_unf_i2c.h b/include/hi_unf_i2c.h
--- a/include/hi_unf_i2c.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_i2c.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,248 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+******************************************************************************
+ File Name     : hi_unf_i2c.h
+Version       : Initial draft
+Author        : HiSilicon multimedia software group
+Created Date   : 2008-06-05
+Last Modified by:
+Description   : Application programming interfaces (APIs) of the external chip software (ECS)
+Function List :
+Change History:
+******************************************************************************/
+#ifndef __HI_UNF_I2C_H__
+#define __HI_UNF_I2C_H__
+
+#include "hi_common.h"
+#include "hi_error_mpi.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      I2C */
+/** @{*/  /** <!-[I2C]*/
+
+#define HI_UNF_I2C_Open  HI_UNF_I2C_Init
+#define HI_UNF_I2C_Close HI_UNF_I2C_DeInit
+
+/**Maximum I2C channel ID*/ /**CNcomment:最大I2C通道号*/
+#define HI_I2C_MAX_NUM_USER (15)
+
+/**Rate type of the I2C module*/
+/**CNcomment:I2C的速率类型 */
+typedef enum hiUNF_I2C_RATE_E
+{
+    HI_UNF_I2C_RATE_10K = 0, /**<Standard rate: 10 kbit/s*/         /**<CNcomment:标准速率：10kbit/s*/
+    HI_UNF_I2C_RATE_50K, /**<Standard rate: 50 kbit/s*/   /**<CNcomment:标准速率：50kbit/s*/
+    HI_UNF_I2C_RATE_100K, /**<Standard rate: 100 kbit/s*/  /**<CNcomment:标准速率：100kbit/s*/
+    HI_UNF_I2C_RATE_200K, /**<Standard rate: 200 kbit/s*/  /**<CNcomment:标准速率：200kbit/s*/
+    HI_UNF_I2C_RATE_300K, /**<Standard rate: 300 kbit/s*/  /**<CNcomment:标准速率：300kbit/s*/
+    HI_UNF_I2C_RATE_400K, /**<Fast rate: 400 kbit/s*/      /**<CNcomment:快速速率：400kbit/s*/
+
+    HI_UNF_I2C_RATE_BUTT
+} HI_UNF_I2C_RATE_E;
+
+/** @}*/  /** <!-- ==== Structure Definition End ====*/
+
+
+
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      I2C*/
+/** @{*/  /** <!-- -I2C=*/
+
+/**
+ \brief Init the I2C device.
+CNcomment:\brief 初始化I2C（the Inter-Integrated Circuit）设备。CNend
+
+ \param N/A                                                               CNcomment:无。CNend
+ \retval 0 Success                                                        CNcomment:成功。CNend
+ \retval ::HI_ERR_I2C_OPEN_ERR  Open I2c Error				  CNcomment:I2C无效参数。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_Init (HI_VOID);
+
+/**
+ \brief  DeInit the I2C device.
+CNcomment:\brief 去初始化I2C设备。CNend
+
+ \attention \n
+This API is called after I2C operations are completed.\n
+CNcomment:在I2C操作结束后调用此接口\n CNend
+
+ \param N/A                                                        CNcomment:无。CNend
+ \retval 0 Success                                                 CNcomment: 成功。CNend
+ \retval ::HI_ERR_I2C_CLOSE_ERR  Close I2c Error.	 	   CNcomment:I2C设备未初始化。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_DeInit(HI_VOID);
+
+/**
+ \brief  Get the number of I2C module.
+CNcomment:\brief 去初始化I2C设备。CNend
+
+ \attention \n
+Call this API to get the number of I2C module befor read/write data.\n
+CNcomment:在使用I2C读写数据之前调用此接口获取芯片的I2C模块数目\n CNend
+
+ \param N/A                                                        CNcomment:无。CNend
+ \retval 0 Success                                                 CNcomment: 成功。CNend
+ \retval ::	 
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_GetCapability(HI_U32 *pu32I2cNum);
+
+/**
+The I2C device is not initialized.
+CNcomment:\brief 创建一路GpioI2c。CNend
+
+ \attention \n
+If the specified GPIO pins are used, this API fails to be called.\n
+CNcomment:如果Gpio已被占用会失败\n CNend
+
+ \param[out] u32I2cNum  ID of the obtained I2C bus                            CNcomment:得到I2C总线号。CNend
+ \param[in] u32SCLGpioNo  SCL Pin number, ranging from 0 to 103, ranging is different in otherness chip type     CNcomment:管脚号，取值范围为0～103，不同的芯片类型范围不一样。CNend
+ \param[in] u32SDAGpioNo  SDA Pin number, ranging from 0 to 103, ranging is different in otherness chip type     CNcomment:管脚号，取值范围为0～103，不同的芯片类型范围不一样。CNend
+ \retval 0 Success                                                           CNcomment:成功。CNend
+ \retval ::HI_FAILURE	Create gpioi2c failed								CNcomment:失败。CNend
+ \retval ::HI_ERR_I2C_NULL_PTR 		The pointer parameter is NULL			CNcomment:指针参数为空。CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA  The parameter is invalid.               CNcomment:参数非法。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_CreateGpioI2c(HI_U32 *pu32I2cNum, HI_U32 u32SCLGpioNo, HI_U32 u32SDAGpioNo);
+
+/**
+ \brief Destroys a inter-integrated circuit (I2C) channel that simulates the general-purpose input/output (GPIO) function.
+CNcomment:\brief 销毁一路GpioI2c。CNend
+
+ \attention \n
+If the I2C channel is not used, a code indicating success is returned.\n
+CNcomment:如果该GpioI2c未使用，直接返回成功\n CNend
+
+ \param[in] u32I2cNum ID of the I2C bus to be destroyed        CNcomment:要销毁的I2C总线号。CNend
+ \retval 0  Success                                            CNcomment:成功。CNend
+ \retval ::HI_FAILURE	Destroy gpioi2c failed				  CNcomment:失败。CNend
+ \retval ::HI_ERR_GPIO_INVALID_PARA  The parameter is invalid. CNcomment:参数非法。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_DestroyGpioI2c(HI_U32 u32I2cNum);
+
+/**
+ \brief Reads data by using the I2C bus.
+CNcomment:\brief 通过I2C读数据。CNend
+
+ \attention \n
+N/A
+ \param[in] u32I2cNum  I2C bus of the device to be read           CNcomment:所读取设备使用的I2C总线。CNend
+ \param[in] u8DevAddress  Address of a device on the I2C bus      CNcomment:设备在I2C总线上的地址。CNend
+ \param[in] u32RegAddr  On-chip offset address of a device        CNcomment:设备的片内偏移地址。CNend
+ \param[in] u32RegAddrCount  Length of an on-chip offset address. CNcomment:片内偏移地址的长度单位。CNend
+                      1: 8-bit sub address                       CNcomment:1：表示8bit子地址；CNend
+                      2: 16-bit sub address                      CNcomment:2：表示16bit子地址；CNend
+                      3: 24-bit sub address                      CNcomment:3：表示24bit子地址；CNend
+                      4: 32-bit sub address                      CNcomment:4：表示32bit子地址。CNend
+
+ \param[out] pu8Buf   Buffer for storing the data to be read                            CNcomment:读Buffer，存放读取数据。CNend
+ \param[in] u32Length  Length of the data to be read                                    CNcomment:要读取的数据长度。CNend
+ \retval 0 Success                                                                      CNcomment:成功。CNend
+ \retval ::HI_FAILURE	Read data failed					  	CNcomment:失败。CNend
+ \retval ::HI_ERR_I2C_NOT_INIT  The I2C device is not initialized.                      CNcomment:I2C设备未初始化。CNend
+ \retval ::HI_ERR_I2C_NULL_PTR  The I2C pointer is invalid.                        	   CNcomment:I2C无效指针。CNend
+ \retval ::HI_ERR_I2C_INVALID_PARA  The I2C parameter is invalid.                       CNcomment:I2C无效参数。CNend
+ \retval ::HI_ERR_I2C_FAILED_READ  Data fails to be read by using the I2C bus.          CNcomment:I2C读数据失败。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_Read(HI_U32 u32I2cNum, HI_U8 u8DevAddress, HI_U32 u32RegAddr,
+                       HI_U32 u32RegAddrCount, HI_U8 *pu8Buf, HI_U32 u32Length);
+
+/**
+ \brief Writes data by using the I2C bus. That is, you can call this API to write data to the device mounted on the I2C bus through the I2C channel.
+CNcomment:\brief 通过I2C写数据。通过I2C通道，向I2C总线上挂接的设备进行写操作。CNend
+
+ \attention \n
+N/A
+ \param[in] u32I2cNum  I2C bus of the device to be written         CNcomment:待写设备使用的I2C总线。CNend
+ \param[in] u8DevAddress  Address of a device on the I2C bus       CNcomment:设备在I2C总线上的地址。CNend
+ \param[in] u32RegAddr  On-chip offset address of a device         CNcomment:设备的片内偏移地址。CNend
+ \param[in] u32RegAddrCount Length of an on-chip offset address.   CNcomment:片内偏移地址的长度单位。CNend
+                    1: 8-bit sub address                          CNcomment:1：表示8bit子地址；CNend
+                    2: 16-bit sub address                         CNcomment:2：表示16bit子地址；CNend
+                    3: 24-bit sub address                         CNcomment:3：表示24bit子地址；CNend
+                    4: 32-bit sub address                         CNcomment:4：表示32bit子地址。CNend
+
+ \param[in]  pu8Buf   Buffer for storing the data to be written                         CNcomment:写Buffer，存放待写入数据。CNend
+ \param[in] u32Length  Length of the data to be written                                 CNcomment:要写入的数据的长度。CNend
+ \retval 0  Success                                                                     CNcomment:成功。CNend
+ \retval ::HI_FAILURE	Write data failed					  	CNcomment:失败。CNend
+ \retval ::HI_ERR_I2C_NOT_INIT  The I2C device is not initialized.                      CNcomment:I2C设备未初始化。CNend
+ \retval ::HI_ERR_I2C_NULL_PTR  The I2C pointer is invalid.                        	   CNcomment:I2C无效指针。CNend
+ \retval ::HI_ERR_I2C_INVALID_PARA  The I2C parameter is invalid.                       CNcomment:I2C无效参数。CNend
+ \retval ::HI_ERR_I2C_FAILED_WRITE  Data fails to be written by using the I2C bus.      CNcomment:I2C写数据失败。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_Write(HI_U32 u32I2cNum, HI_U8 u8DevAddress, HI_U32 u32RegAddr,
+                        HI_U32 u32RegAddrCount, HI_U8 * pu8Buf, HI_U32 u32Length);
+
+/**
+ \brief Sets the transfer rate of the I2C bus.
+CNcomment:\brief 设置I2C的传输速率。CNend
+
+ \attention \n
+Call this API Only be effect in standard i2c, gpio simulate i2c is noneffective.\n 
+If you do not call this API to set the transfer rate, the rate 100 kbit/s is used by default.\n
+CNcomment:此接口仅对标准的i2c通道有效，对gpio 模拟 i2c 无效。\nCNend
+CNcomment:如果不调用此接口，系统采用400Kbit/s作为缺省速率。\n CNend
+
+ \param[in] u32I2cNum  D of channel corresponding to the device to be written on the I2C bus                         CNcomment:所写设备在I2C总线上的通道号。CNend
+ \param[in] enI2cRate  I2C clock rate. For details about the definition, see the description of ::HI_UNF_I2C_RATE_E. CNcomment:I2C时钟速率。含义请参考::HI_UNF_I2C_RATE_E。CNend
+ \retval 0  Success                                                                                                  CNcomment:成功。CNend
+ \retval ::HI_FAILURE	Set rate failed									   	     CNcomment:失败。CNend
+ \retval ::HI_ERR_I2C_NOT_INIT  The I2C device is not initialized.                                                   CNcomment:I2C设备未初始化。CNend
+ \retval ::HI_ERR_I2C_INVALID_PARA  The I2C parameter is invalid.                                                    CNcomment:I2C无效参数。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_SetRate(HI_U32 u32I2cNum, HI_UNF_I2C_RATE_E enI2cRate);
+
+/**
+ \brief Sets the transfer rate of the I2C bus.
+CNcomment:\brief 设置I2C的传输速率。CNend
+
+ \attention \n
+Call this API Only be effect in standard i2c, gpio simulate i2c is noneffective.\n 
+If you do not call this API to set the transfer rate, the rate 100 kbit/s is used by default.\n
+CNcomment:此接口仅对标准的i2c通道有效，对gpio 模拟 i2c 无效。\n
+如果不调用此接口，系统采用400Kbit/s作为缺省速率。\n CNend
+
+ \param[in] u32I2cNum  D of channel corresponding to the device to be written on the I2C bus                         CNcomment:所写设备在I2C总线上的通道号。CNend
+ \param[in] u32I2cRate  I2C clock rate.  CNcomment:I2C时钟速率。CNend
+ \retval 0  Success                                                                                                  CNcomment:成功。CNend
+ \retval ::HI_FAILURE	Set rate failed									   	     CNcomment:失败。CNend
+ \retval ::HI_ERR_I2C_NOT_INIT  The I2C device is not initialized.                                                   CNcomment:I2C设备未初始化。CNend
+ \retval ::HI_ERR_I2C_INVALID_PARA  The I2C parameter is invalid.                                                    CNcomment:I2C无效参数。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_I2C_SetRateEx(HI_U32 u32I2cNum, HI_U32 u32I2cRate);
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_ECS_TYPE_H__ */
diff -uNr a/include/hi_unf_ir.h b/include/hi_unf_ir.h
--- a/include/hi_unf_ir.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_ir.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,408 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+ ******************************************************************************
+File Name     : hi_unf_ir.h
+Version       : Initial draft
+Author        : HiSilicon multimedia software group
+Created Date  : 2012-08-24
+Last Modified by:
+Description   : Application programming interfaces (APIs) of IR
+Function List :
+Change History:
+ ******************************************************************************/
+
+#ifndef __HI_UNF_IR_H__
+#define __HI_UNF_IR_H__
+
+#include "hi_common.h"
+#include "hi_error_mpi.h"
+//#include "hi_unf_keyled.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      IR */
+/** @{ */  /** <!-- [IR] */
+
+/**status of key*/
+/**CNcomment:按键状态*/
+typedef enum  hiUNF_KEY_STATUS_E
+{
+    HI_UNF_KEY_STATUS_DOWN = 0 ,   /**<Pressed*/   /**<CNcomment:按下按键 */
+    HI_UNF_KEY_STATUS_HOLD ,       /**<Hold*/      /**<CNcomment:按住不动 */
+    HI_UNF_KEY_STATUS_UP ,         /**<Released*/  /**<CNcomment:抬起按键 */
+
+    HI_UNF_KEY_STATUS_BUTT
+}HI_UNF_KEY_STATUS_E ;
+
+/**Code type supported by the infrared (IR) module*/
+/**CNcomment:IR支持的码型*/
+typedef enum hiUNF_IR_CODE_E
+{
+    HI_UNF_IR_CODE_NEC_SIMPLE = 0,  /**<NEC with simple repeat code*/   /**<CNcomment:NEC with simple repeat code码型*/
+    HI_UNF_IR_CODE_TC9012,          /**<TC9012 code*/                   /**<CNcomment:TC9012码型*/
+    HI_UNF_IR_CODE_NEC_FULL,        /**<NEC with full repeat code*/     /**<CNcomment:NEC with full repeat code码型*/
+    HI_UNF_IR_CODE_SONY_12BIT,      /**<SONY 12-bit code */             /**<CNcomment:SONY 12BIT码型*/
+    HI_UNF_IR_CODE_RAW,               /**<Raw code*/	                    /**<CNcomment:raw 码型*/
+    HI_UNF_IR_CODE_BUTT
+}HI_UNF_IR_CODE_E;
+
+/**List of IR code type. For details about HI_UNF_IR_STD, see HI_UNF_IR_CODE_E.*/
+/**CNcomment:IR码型列表,HI_UNF_IR_STD部分请参照HI_UNF_IR_CODE_E */
+typedef enum hiUNF_IR_PROTOCOL_E
+{
+    HI_UNF_IR_NEC,               /**<For NEC protocol*/                          /**<CNcomment:NEC码型*/
+    HI_UNF_IR_RC6A = 10,         /**<For RC6A protocol*/                         /**<CNcomment:RC6A码型*/
+    HI_UNF_IR_RC5,               /**<For RC5 protocol*/                          /**<CNcomment:RC5码型*/
+    HI_UNF_IR_LOW_LATENCY_PROTOCOL,
+    HI_UNF_IR_RC6_MODE0,         /**<For RC6 mode 0*/                            /**<CNcomment:RC6 mode0码型*/
+    HI_UNF_IR_RCMM,              /**<For RCMM 24/32 protocol*/                   /**<CNcomment:RCMM 24/32码型*/
+    HI_UNF_IR_RUWIDO,            /**<For Ruwido protocol*/                       /**<CNcomment:Ruwido码型*/
+    HI_UNF_IR_RCRF8,             /**<For RCRF8 protocol*/                        /**<CNcomment:RCRF8码型*/
+    HI_UNF_IR_MULTIPLE,          /**<For multiple protocol support*/             /**<CNcomment:Multiple码型*/    
+    HI_UNF_IR_RMAP,              /**<For RMAP protocol with Mancester coding*/   /**<CNcomment:RMAP 曼彻斯特码型*/
+    HI_UNF_IR_RSTEP,             /**<For RSTEP protocol*/                        /**<CNcomment:RSTEP码型*/
+    HI_UNF_IR_RMAP_DOUBLEBIT,    /**<For RMAP protocol with Double bit coding*/  /**<CNcomment:RMAP 双bit码型*/
+    HI_UNF_IR_LOW_LATENCY_PRO_PROTOCOL,
+    HI_UNF_IR_XMP,               /**<For XMP protocol*/                          /**<CNcomment:XMP码型*/
+    HI_UNF_IR_USER_DEFINED,      /**<For user protocol*/                         /**<CNcomment:用户自定义码型*/    
+    HI_UNF_IR_PROTOCOL_BUTT 
+} HI_UNF_IR_PROTOCOL_E;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      IR */
+/** @{ */  /** <!-- [IR] */
+/*---IR---*/
+
+/**
+\brief Starts the IR device.
+CNcomment:\brief 打开IR设备。CNend
+
+\attention \n
+This API can be called repeatedly. Key IDs can be received only after you can start the IR device, and then call HI_UNF_IR_Enable. \n
+CNcomment:重复调用会返回成功，打开设备后必须再调用HI_UNF_IR_Enable才能正常接收键值。CNend
+
+\param N/A                                                                   CNcomment:无 CNend
+\retval HI_SUCCESS Success                                                   CNcomment:成功 CNend
+\retval ::HI_ERR_IR_OPEN_ERR   The IR device fails to open                   CNcomment:IR设备打开失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_Init(HI_VOID);
+
+#define HI_UNF_IR_Open() HI_UNF_IR_Init()
+
+/**
+\brief Stops the IR device.
+CNcomment:\brief 关闭IR设备。CNend
+
+\attention \n
+This API can be called repeatedly. \n
+CNcomment:重复调用关闭会返回成功。CNend
+
+\param  N/A                                                                  CNcomment:无 CNend
+\retval HI_SUCCESS Success                                                   CNcomment:成功 CNend
+\retval ::HI_ERR_IR_CLOSE_ERR  The IR device fails to close.                 CNcomment:IR设备关闭失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_DeInit(HI_VOID);
+
+#define HI_UNF_IR_Close() HI_UNF_IR_DeInit()
+
+/**
+\brief Enables the IR device.
+CNcomment:\brief 使能IR设备。CNend
+\attention \n
+N/A
+\param[in] bEnable  IR enable. HI_TRUE: enabled; HI_FALSE: disabled           CNcomment:IR 使能开关, HI_TRUE 使能, HI_FALSE 禁用。CNend
+\retval HI_SUCCESS Success                                                    CNcomment:成功 CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.               CNcomment:IR设备未初始化 CNend
+\retval ::HI_ERR_IR_INVALID_PARA  The parameter is invalid.                   CNcomment:参数非法 CNend
+\retval ::HI_ERR_IR_ENABLE_FAILED It fails to enable IR device.               CNcomment:使能设备失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_Enable ( HI_BOOL bEnable);
+
+/**
+\brief Obtains the protocol type of a remote control.
+CNcomment:\brief 获取遥控器的协议类型 。CNend
+
+\attention \n
+This interface is only supported in IR_STD mode. And it must be used after function "HI_UNF_IR_GetValueWithProtocol".\n
+CNcomment:此接口只在IR_STD模式下支持。需要在HI_UNF_IR_GetValueWithProtocol函数后调用。 CNend
+
+\param[out]  penProtocol  protocol type pointer,reference HI_UNF_IR_PROTOCOL_E for detail   CNcomment:协议类型指针  具体含义请参考::HI_UNF_IR_PROTOCOL_E CNend
+\retval HI_SUCCESS Success                                                            CNcomment:成功 CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.                       CNcomment:IR设备未初始化 CNend
+\retval ::HI_ERR_IR_NULL_PTR  The pointer is invalid.                                 CNcomment: 指针为空 CNend
+\see \n
+N/A
+*/
+
+HI_S32 HI_UNF_IR_GetProtocol(HI_UNF_IR_PROTOCOL_E *penProtocol);
+
+/**
+\brief obtain name of remote control protocol
+CNcomment:\brief 获取遥控器的协议名称 。CNend
+
+\attention \n
+when IR_TYPE=IR_LIRC is effective, this interface is not supported now.
+CNcomment:当IR_TYPE=IR_LIRC时有效，此接口暂不支持 CNend
+
+\param[out]  pProtocolName  used to save first address of the protocol name buffer    CNcomment:用于存储协议名称的缓冲区首地址 CNend
+\param[in]   s32BufLen      used to save length of the protocol name buffer           CNcomment:用于存储协议名称的缓冲区长度 CNend
+\retval ::HI_ERR_IR_UNSUPPORT   It is not supported.                                  CNcomment:操作不支持 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_GetProtocolName(HI_CHAR *pProtocolName, HI_S32 s32BufLen);
+
+/**
+\brief Obtains the key values and key status of the remote control.
+CNcomment:\brief 获取遥控器的按键值和按键状态 。CNend
+
+\attention \n
+
+\param[out]  penPressStatus  Key status. For details about the definition, see the description of ::HI_UNF_KEY_STATUS_E.  CNcomment:按键状态。具体含义请参考::HI_UNF_KEY_STATUS_E CNend
+\param[out]  pu64KeyId  Key value                                                     CNcomment:按键值 CNend
+\param[out]  pszProtocolName  used to save first address of the protocol name buffer    CNcomment:用于存储协议名称的缓冲区首地址 CNend
+\param[in]   s32NameSize      used to save length of the protocol name buffer           CNcomment:用于存储协议名称的缓冲区长度 CNend
+\param[in] u32TimeoutMs  Timeout (in ms). 0: not blocked; 0xFFFFFFFF: infinite block  CNcomment:超时值, 单位是毫秒, 0 - 不阻塞, 0xFFFFFFFF-永久阻塞 CNend
+\retval HI_SUCCESS Success                                                            CNcomment:成功 CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.                       CNcomment:IR设备未初始化 CNend
+\retval ::HI_ERR_IR_NULL_PTR  The pointer is invalid.                                 CNcomment: 指针为空 CNend
+\retval ::HI_ERR_IR_INVALID_PARA  The parameter is invalid.                           CNcomment:参数非法 CNend
+\retval ::HI_ERR_IR_SET_BLOCKTIME_FAILED  The IR device fails to set block time.      CNcomment:设置阻塞时间失败 CNend
+\retval ::HI_ERR_IR_READ_FAILED  The IR device fails to read key.                     CNcomment:读取键值和状态失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_GetValueWithProtocol(HI_UNF_KEY_STATUS_E *penPressStatus, HI_U64 *pu64KeyId,
+                                      HI_CHAR *pszProtocolName, HI_S32 s32NameSize, HI_U32 u32TimeoutMs);
+
+#define HI_UNF_IR_GetValue(penPressStatus, pu64KeyId, u32TimeoutMs) HI_UNF_IR_GetValueWithProtocol(penPressStatus, \
+                                                                                                   pu64KeyId, NULL, 0, \
+                                                                                                   u32TimeoutMs)
+
+
+/**
+\brief Set key fetch or symbol fetch from ir driver.
+CNcomment:\brief 设定从红外驱动获取的是键值还是裸电平 。CNend
+
+\attention \n
+when IR_TYPE=IR_S2 is effective.
+CNcomment:当IR_TYPE=IR_S2时有效。CNend
+
+\param[in] mode 0 means key mode. 1 means symbol mode                                 CNcomment:0获取键值，1获取裸电平 CNend
+\retval HI_SUCCESS Success                                                            CNcomment:成功 CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.                       CNcomment:IR设备未初始化 CNend
+\retval ::HI_ERR_IR_INVALID_PARA  The parameter is invalid.                           CNcomment:参数非法 CNend
+\retval ::HI_ERR_IR_SET_FETCHMETHOD_FAILED  The IR device fails to set fetch method.  CNcomment:设置获取方式失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_SetFetchMode(HI_S32 s32Mode);
+
+/**
+\brief Obtains the raw symbols from ir driver.
+CNcomment:\brief 获取遥控器的裸电平 。CNend
+
+\attention \n
+when IR_TYPE=IR_S2 is effective.
+CNcomment:当IR_TYPE=IR_S2时有效。CNend
+
+\param[out]  pu64lower  lower pluse value                                             CNcomment:裸电平对的低位 CNend
+\param[out]  pu64upper  upper space value                                             CNcomment:裸电平对的高位 CNend
+\param[in] s32TimeoutMs read timeout .                                                CNcomment:读超时时间。CNend
+
+\retval HI_SUCCESS Success                                                            CNcomment:成功 CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized. 					  CNcomment:IR设备未初始化 CNend
+\retval ::HI_ERR_IR_NULL_PTR  The pointer is invalid.								  CNcomment: 指针为空 CNend
+\retval ::HI_ERR_IR_SET_BLOCKTIME_FAILED  The IR device fails to set block time.      CNcomment:设置阻塞时间失败 CNend
+\retval ::HI_ERR_IR_READ_FAILED  The IR device fails to read key.					  CNcomment:读取键值和状态失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_GetSymbol(HI_U64 *pu64First, HI_U64* pu64Second, HI_U32 u32TimeoutMs);
+
+/**
+\brief Enables or disables the function of reporting the released status of a key.
+CNcomment:\brief 设置是否上报按键弹起状态。CNend
+
+\attention \n
+The function is enabled by default.
+CNcomment:如不设置，默认为打开。CNend
+
+\param[in] bEnable      Key released enable.  CNcomment:按键弹起有效。CNend
+                        0: disabled           CNcomment:0：关闭；CNend
+                        1: enabled            CNcomment: 1：使能。CNend
+\retval HI_SUCCESS  Success                                             CNcomment:成功 CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.         CNcomment:IR设备未初始化 CNend
+\retval ::HI_ERR_IR_INVALID_PARA  The parameter is invalid.             CNcomment:参数非法 CNend
+\retval ::HI_ERR_IR_SET_KEYUP_FAILED  It fails to enable released key.  CNcomment:设置上报按键弹起状态失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_EnableKeyUp(HI_BOOL bEnable);
+
+/**
+\brief Enables or disables the function of reporting the same key value. If keys are pressed and held down, data is continuously transmitted to the receive buffer. Therefore, you can enable or disable this function for applications as required.
+CNcomment:\brief 设置是否上报重复按键。一直按键时，数据会源源不断的送入到接收缓冲区，因此应用程序可以根据需要来设置是否上报重复按键。CNend
+
+\attention \n
+The function is enabled by default.\n
+This API must work with HI_UNF_IR_RepKeyTimeoutVal. The API HI_UNF_IR_RepKeyTimeoutVal is used to set the interval of reporting the same key value.\n
+If the function of reporting the same key value is enabled, the keys are pressed and held down, and the interval is set to 300 ms, data is reported once every 300 ms.
+If the function is disabled, data is reported only once regardless of how long the keys are held down.
+CNcomment:如不设置，默认为打开\n 
+此接口需要和HI_UNF_IR_RepKeyTimeoutVal函数结合使用，由HI_UNF_IR_RepKeyTimeoutVal设置上报重复按键的间隔\n 
+如果使能了重复按键上报，当按键一直处于按下状态，间隔设为300毫秒，则每300毫秒会上报一次数据\n 
+如果禁止了重复按键上报，则不论按下多长时间，只上报一次数据。CNend
+\param[in] bEnable     Repeat key report enable.    CNcomment:按键产生重复按键功能。CNend
+                       0: disabled                  CNcomment:0：关闭；CNend
+                       1: enabled                   CNcomment:1：使能。CNend
+\retval HI_SUCCESS Success                                                     CNcomment:成功 CNend
+\retval ::HI_ERR_IR_NOT_INIT   The IR device is not initialized.               CNcomment:IR设备未初始化 CNend
+\retval ::HI_ERR_IR_INVALID_PARA   The parameter is invalid.                   CNcomment:参数非法 CNend
+\retval ::HI_ERR_IR_SET_REPEAT_FAILED   It fails to enable repeat key.         CNcomment:设置上报重复键失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_EnableRepKey(HI_BOOL bEnable);
+
+/**
+\brief Sets the interval (in ms) of reporting the same key value.
+CNcomment:\brief 设置上报重复按键的时间间隔，单位为ms 。CNend
+
+\attention \n
+This API is unavailable if the function of reporting the same key value is disabled by calling HI_UNF_IR_IsRepKey.
+CNcomment:当HI_UNF_IR_IsRepKey配置为不上报重复按键时，此接口设置无效。CNend
+
+\param[in] u32TimeoutMs   Interval of reporting the same key value. The interval ranges from 0 ms to 65,536 ms.\n
+						  The value 0 will be set to 108, and the value bigger than 65536 will be set to 65536 \n
+                          CNcomment:上报重复按键的时间间隔，设置范围：0ms～65536ms 。\n
+						  等于0的参数会被强制设置成108，大于65536的参数会被强制设置成65536。CNend
+\retval HI_SUCCESS Success CNcomment:                                          CNcomment:成功 CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.                CNcomment:IR设备未初始化 CNend
+\retval ::HI_ERR_IR_SET_REPKEYTIMEOUT_FAILED  It fails to set repeat key timeout.  CNcomment:设置上报重复按键间隔失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_SetRepKeyTimeoutAttr(HI_U32 u32TimeoutMs);
+
+/**
+\brief Sets the code type of the remote control.
+CNcomment:\brief 设置遥控器码型。CNend
+
+\attention \n
+when IR_TYPE=IR_STD is effective.
+CNcomment:当IR_TYPE=IR_STD时有效。CNend
+
+
+\param[in] enIRCode Four standard code types of the remote control are supported by default.  CNcomment:默认支持4种标准遥控器码型：CNend
+                     HI_UNF_IR_CODE_NEC_SIMPLE:Nec With Simple code type. CNcomment:Nec Simple 码型。 CNend
+                     HI_UNF_IR_CODE_TC9012:TC9012 code type.              CNcomment:TC9012 码型。     CNend
+                     HI_UNF_IR_CODE_NEC_FULL:Nec With Full code type.     CNcomment:Nec Full 码型。   CNend
+                     HI_UNF_IR_CODE_SONY_12BIT:Sony 12 Bit code type.     CNcomment:Sony 12 bit 码型。CNend
+\retval HI_SUCCESS Success                                                 CNcomment:成功 CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.            CNcomment:IR设备未初始化 CNend
+\retval ::HI_ERR_IR_INVALID_PARA   The parameter is invalid.               CNcomment:参数非法 CNend
+\retval ::HI_ERR_IR_SETFORMAT_FAILED It fails to set IR code type.         CNcomment:设置IR类型失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_SetCodeType(HI_UNF_IR_CODE_E enIRCode);
+
+/**
+\brief  Resets the IR device.
+CNcomment:\brief  复位IR设备。CNend
+
+\attention \n
+This API is used to delete the key values in the buffer.
+CNcomment:只是把buffer中的键值清掉。CNend
+
+\param N/A         CNcomment:无 CNend
+\retval HI_SUCCESS Success                                                      CNcomment:成功 CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.                 CNcomment:IR设备未初始化 CNend
+\retval ::HI_ERR_IR_RESET_FAILED  The IR device fails to reset.                 CNcomment:IR设备复位失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_Reset(HI_VOID);
+
+/**
+\brief enable an infrared code.
+CNcomment:\brief  激活某类红外遥控器协议。CNend
+
+\attention \n
+when IR_TYPE=IR_S2 is effective.
+CNcomment:当IR_TYPE=IR_S2时有效。CNend
+
+\param N/A         CNcomment:无 CNend
+\retval HI_SUCCESS Success                                                      CNcomment:成功 CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.                 CNcomment:IR设备未初始化 CNend
+\retval ::HI_ERR_IR_NULL_PTR  The pointer is invalid.							CNcomment: 指针为空 CNend
+\retval ::HI_ERR_IR_INVALID_PARA   The parameter is invalid.                    CNcomment:参数非法 CNend
+\retval ::HI_ERR_IR_ENABLE_PROT_FAILED  It fails to enable an infrared code.    CNcomment:激活遥控协议失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_EnableProtocol(const HI_CHAR* pszProtocolName);
+
+/**
+\brief disable an infrared code.
+CNcomment:\brief  禁用某类红外遥控器协议。CNend
+
+\attention \n
+when IR_TYPE=IR_S2 is effective.
+CNcomment:当IR_TYPE=IR_S2时有效。CNend
+
+\param N/A         CNcomment:无 CNend
+\retval HI_SUCCESS Success                                                      CNcomment:成功 CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.                 CNcomment:IR设备未初始化 CNend
+\retval ::HI_ERR_IR_NULL_PTR  The pointer is invalid.							CNcomment: 指针为空 CNend
+\retval ::HI_ERR_IR_INVALID_PARA   The parameter is invalid.                    CNcomment:参数非法 CNend
+\retval ::HI_ERR_IR_DISABLE_PROT_FAILED   It fails to disalbe an infrared code. CNcomment:禁用遥控协议失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_DisableProtocol(const HI_CHAR* pszProtocolName);
+
+/**
+\brief get the enable or disable status of  an infrared code.
+CNcomment:\brief  获取某类红外遥控器协议激活状态。CNend
+
+\attention \n
+when IR_TYPE=IR_S2 is effective.
+CNcomment:当IR_TYPE=IR_S2时有效。CNend
+
+\param N/A         CNcomment:无 CNend
+\retval HI_SUCCESS Success                                                      CNcomment:成功 CNend
+\retval HI_FAILURE Failure                                                      CNcomment:失败 CNend
+\retval ::HI_ERR_IR_NOT_INIT  The IR device is not initialized.                 CNcomment:IR设备未初始化 CNend
+\retval ::HI_ERR_IR_NULL_PTR  The pointer is invalid.							CNcomment: 指针为空 CNend
+\retval ::HI_ERR_IR_INVALID_PARA   The parameter is invalid.                    CNcomment:参数非法 CNend
+\retval ::HI_ERR_IR_GET_PROTENABLE_FAILED It fails to get status of an infrared code.  CNcomment:获取遥控协议状态失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_IR_GetProtocolEnabled(const HI_CHAR* pszProtocolName, HI_BOOL *pbEnabled);
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* End of #ifndef __HI_UNF_IR_H__ */
diff -uNr a/include/hi_unf_keyled.h b/include/hi_unf_keyled.h
--- a/include/hi_unf_keyled.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_keyled.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,476 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+ ******************************************************************************
+File Name     : hi_unf_keyled.h
+Version       : Initial draft
+Author        : HiSilicon multimedia software group
+Created Date  : 2012-08-24
+Last Modified by:
+Description   : Application programming interfaces (APIs) of the KEYLED
+Function List :
+Change History:
+ ******************************************************************************/
+
+#ifndef __HI_UNF_KEYLED_H__
+#define __HI_UNF_KEYLED_H__
+
+#include "hi_common.h"
+#include "hi_error_mpi.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      KEYLED */
+/** @{ */  /** <!-- [KEYLED] */
+/**keyled type*/
+/**CNcomment:KEYLED类型 */
+typedef enum  hiUNF_KEYLED_TYPE_E
+{
+    HI_UNF_KEYLED_TYPE_74HC164 = 0x0, /**<KEYLED type:74HC164*/                   /**<CNcomment:KEYLED型号: 74HC164 */
+    HI_UNF_KEYLED_TYPE_PT6961,    /**<KEYLED type: PT6961*/                       /**<CNcomment:KEYLED型号：PT6961 */
+    HI_UNF_KEYLED_TYPE_CT1642,    /**<KEYLED type: CT1642*/                       /**<CNcomment:KEYLED型号：CT1642 */
+    HI_UNF_KEYLED_TYPE_PT6964,	  /**<KEYLED type: PT6964*/                       /**<CNcomment:KEYLED型号：PT6964 */
+    HI_UNF_KEYLED_TYPE_FD650,     /**<KEYLED type: FD650*/                        /**<CNcomment:KEYLED型号：FD650 */
+    HI_UNF_KEYLED_TYPE_GPIOKEY,   /**<KEYLED type :GPIOKEY*/   					 /**<CNcomment:GPIO按键面板*/
+    HI_UNF_KEYLED_TYPE_BUTT       
+}HI_UNF_KEYLED_TYPE_E;
+
+/**Blink frequency level of the LED*/
+/**CNcomment:LED闪烁频率级别*/
+typedef enum hiUNF_KEYLED_LEVEL_E
+{
+    HI_UNF_KEYLED_LEVEL_1 = 0x01,   /**<Level 1, slowest*/  /**<CNcomment:级别1,闪烁频率最慢*/
+    HI_UNF_KEYLED_LEVEL_2,          /**<Level 2*/           /**<CNcomment:级别2 */
+    HI_UNF_KEYLED_LEVEL_3,          /**<Level 3*/           /**<CNcomment:级别3 */
+    HI_UNF_KEYLED_LEVEL_4,          /**<Level 4*/           /**<CNcomment:级别4 */
+    HI_UNF_KEYLED_LEVEL_5,          /**<Level 5, fastest*/  /**<CNcomment:级别5 , 闪烁频率最快*/
+
+    HI_UNF_KEYLED_LEVEL_BUTT
+}HI_UNF_KEYLED_LEVEL_E;
+
+/**Blink sequence of LEDs*/
+/**CNcomment:闪烁的LED序号*/
+typedef enum hiUNF_KEYLED_LIGHT_E
+{
+    HI_UNF_KEYLED_LIGHT_1 = 0x01,   /**<The first LED blinks.*/   /**<CNcomment:第1个LED闪烁*/
+    HI_UNF_KEYLED_LIGHT_2,          /**<The second LED blinks.*/  /**<CNcomment:第2个LED闪烁*/
+    HI_UNF_KEYLED_LIGHT_3,          /**<The third LED blinks.*/   /**<CNcomment:第3个LED闪烁*/
+    HI_UNF_KEYLED_LIGHT_4,          /**<The fourth LED blinks.*/  /**<CNcomment:第4个LED闪烁*/
+    HI_UNF_KEYLED_LIGHT_ALL,        /**<All LEDs blink.*/        /**<CNcomment:所有LED均闪烁*/
+    HI_UNF_KEYLED_LIGHT_NONE,       /**<All LEDs do not blink.*/  /**<CNcomment:所有LED均不闪烁*/
+
+    HI_UNF_KEYLED_LIGHT_BUTT
+}HI_UNF_KEYLED_LIGHT_E;
+
+/**Display time of each LED*/
+/**CNcomment:LED显示时间*/
+typedef struct hiUNF_KEYLED_Time_S
+{
+    HI_U32 u32Hour;           /**<Hour*/   /**<CNcomment:时*/
+    HI_U32 u32Minute;         /**<Minute*/ /**<CNcomment:分*/
+}HI_UNF_KEYLED_TIME_S, *HI_UNF_KEYLED_TIME_S_PTR;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      KEYLED */
+/** @{ */  /** <!-- [KEYLED] */
+/**---- keyled ----*/
+
+/**
+\brief Initializes the KEYLED module.
+CNcomment:\brief 初始化KEYLED模块。CNend
+
+\attention \n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:重复调用本接口，会返回成功。CNend
+
+\param N/A                                             CNcomment:无 CNend
+\retval ::HI_SUCCESS Success                           CNcomment:成功 CNend
+\retval ::HI_FAILURE  The KEYLED device fails to open. CNcomment:KEYLED设备打开失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_KEYLED_Init(HI_VOID);
+
+
+/**
+\brief Deinitializes the KEYLED module.
+CNcomment:\brief 去初始化KEYLED模块。CNend
+
+\attention \n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:重复调用本接口，会返回成功。CNend
+
+\param N/A                                             CNcomment:无 CNend
+\retval ::HI_SUCCESS Success                           CNcomment:成功 CNend
+\retval ::HI_FAILURE  The KEYLED device fails to close. CNcomment:KEYLED设备关闭失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_KEYLED_DeInit(HI_VOID);
+
+/**
+\brief Selects the type of the KEYLED.
+CNcomment:\brief 选择KEYLED器件类型。CNend
+
+\attention \n
+It is recommended to call this API once after the KEYLED module is initialized.
+CNcomment:建议初始化后只选择一次，不要重复调用。CNend
+
+\param[in] enKeyLedType   KEYLED type                                           CNcomment:keyled类型。 CNend
+\retval ::HI_SUCCESS   Success                                                  CNcomment:成功 CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED device is not initialized.         CNcomment:KEYLED设备未初始化 CNend
+\retval ::HI_ERR_KEYLED_INVALID_PARA  The parameter is invalid.                 CNcomment:参数非法 CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                                     CNcomment: Ioctrl调用失败 CNend
+
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_KEYLED_SelectType(HI_UNF_KEYLED_TYPE_E enKeyLedType);
+
+/**
+\brief Enables the key function.
+CNcomment:\brief 打开按键功能。CNend
+\attention \n
+The KEYLED module starts to receive key values after the key function is enabled.\n
+The error code HI_SUCCESS is returned if this API is called repeatedly.\n
+CNcomment:打开后开始接收按键\n
+重复调用本接口，会返回成功。CNend
+\param N/A                                                                      CNcomment:无 CNend
+\retval ::HI_SUCCESS Success                                                    CNcomment:成功 CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED device is not initialized.         CNcomment:KEYLED设备未初始化 CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                                     CNcomment: Ioctrl调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_KEY_Open(HI_VOID);
+
+/**
+\brief Disables the key function.
+CNcomment:\brief 关闭按键功能。CNend
+
+\attention \n
+The KEYLED module stops receiving key IDs after the key function is disabled.\n
+This API is valid when it is called for the first time. If this API is called repeatedly, the error code HI_SUCCESS is returned.\n
+CNcomment:关闭后停止接收按键\n
+本接口第一次调用起作用,重复调用返回成功。CNend
+
+\param N/A                                                                      CNcomment:无 CNend
+\retval ::HI_SUCCESS Success                                                    CNcomment:成功 CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED device is not initialized.         CNcomment:KEYLED设备未初始化 CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                                     CNcomment: Ioctrl调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_KEY_Close(HI_VOID);
+
+/**
+\brief Clears the key values that are not received.
+CNcomment:\brief 清空当前没有接收的按键。CNend
+
+\attention \n
+This API is used to clear the buffer for storing the key values. In this way, the initial state is returned.
+CNcomment:清空按键buffer，回到初始状态。CNend
+\param N/A Success                                                              CNcomment:无 CNend
+\retval ::HI_SUCCESS Success                                                    CNcomment:成功 CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED device is not initialized.         CNcomment:KEYLED设备未初始化 CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                                     CNcomment: Ioctrl调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_KEY_Reset(HI_VOID);
+
+
+/**
+\brief Obtains a key value.
+CNcomment:\brief 获取一个按键值。CNend
+
+\attention \n
+This API is used to obtain the key value that is received first in the buffer. After this API is called, the key value and key status are returned.\n
+The key status contains pressed, hold and released.\n
+This API needs to work with ::HI_UNF_KEY_SetBlockTime.\n
+If there are no key values, the API waits until timeout occurs. In this case, the error code ::HI_ERR_KEYLED_TIMEOUT is returned.\n
+If the timeout is set to 0 in non-block mode, the error code ::HI_ERR_KEYLED_NO_NEW_KEY is returned when there are no key values.\n
+If the timeout is set to 0xFFFFFFFF, it indicates infinite wait.\n
+CNcomment:获取buffer中最早到达的按键值，返回按键值的数值和状态\n
+状态包含按下，长按和弹起\n
+接口配合::HI_UNF_KEY_SetBlockTime接口一起使用\n
+没有按键时，进行等待，超时后退出并返回超时错误码\n
+超时值为0时为非阻塞接口，没有按键直接返回没有按键错误码\n
+超时值设置为0xffffffff，一直等待。CNend
+\param[out] pu32PressStatus Key status: pressed(0x0), hold(0x1) or released(0x2) CNcomment:按键状态是按下，长按还是弹起。CNend
+\param[out] pu32KeyId  Key value                                                 CNcomment:按键值。CNend
+\retval ::HI_SUCCESS  Success                                                    CNcomment:成功 CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED module is not initialized.          CNcomment:模块没有初始化 CNend
+\retval ::HI_ERR_KEYLED_NULL_PTR  The pointer is null.                           CNcomment:指针参数为空 CNend
+\retval ::HI_ERR_KEYLED_NO_NEW_KEY  There are no key values.                     CNcomment:没有按键 CNend
+\retval ::HI_ERR_KEYLED_TIMEOUT  Waiting for key values times out.               CNcomment:等待按键超时 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_KEY_GetValue(HI_U32 * pu32PressStatus, HI_U32 * pu32KeyId);
+
+/**
+\brief Sets the timeout of reading key IDs.
+CNcomment:\brief 设置按键读取的超时时间。CNend
+
+\attention \n
+If the timeout is set to 0, the API is not blocked. If there is no key ID, the error code HI_ERR_KEYLED_NO_NEW_KEY is returned.\n
+If the timeout is set to 0xFFFFFFFF, it indicates infinite wait.\n
+The default time is 500 ms.\n
+CNcomment:超时值为0时不阻塞，没有按键直接返回没有按键错误码\n
+超时值设置为0xffffffff，一直等待。\n 
+默认的超时判断时间为500ms。CNend
+\param[in] u32BlockTimeMs   Timeout, in ms                               CNcomment:超时时间，单位ms。CNend
+\retval ::HI_SUCCESS Success                                             CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                              CNcomment: Ioctrl调用失败 CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED module is not initialized.  CNcomment:模块没有初始化 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_KEY_SetBlockTime(HI_U32 u32BlockTimeMs);
+
+
+/**
+\brief Set the time of pressing a key repeatedly.
+CNcomment:\brief 设置重复按键的时间。CNend
+
+\attention \n
+If a key is pressed for a period of time, it considers that the key is pressed repeatedly.\n
+The time ranges from 108 ms to 65536 ms. If the time is not within the range, the time is automatically restricted to this range.\n
+The default time is 200 ms.\n
+CNcomment:当某个键处于按下状态，超过设置的时间值判断为重复按键\n
+重复按键的设置范围在108ms到65536ms之间，超过这个范围会自动约束到上限或下限上\n
+默认的重复按键判断时间为200ms。CNend
+
+\param[in] u32RepTimeMs  Time of pressing a key repeatedly, in ms       CNcomment:判断为重复按键的时间，单位ms。CNend
+\retval ::HI_SUCCESS Success                                            CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                              CNcomment: Ioctrl调用失败 CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED module is not initialized. CNcomment:模块没有初始化 CNend
+\see \n 
+N/A
+*/
+HI_S32 HI_UNF_KEY_RepKeyTimeoutVal(HI_U32 u32RepTimeMs);
+
+/**
+\brief Enables or disables the function of reporting the same key ID.
+CNcomment:\brief 设置是否使能重复按键。CNend
+
+\attention \n
+The ID of a pressed key is reported consecutively only after the report function is enabled.\n
+CNcomment:只有使能后，一直按住某个键，才能连续上报键值。CNend
+
+\param[in] u32IsRepKey Repeat key report enable. 1: enabled; 0: disabled   CNcomment:是否使能重复按键，1 使能，0 不使能。CNend
+\retval ::HI_SUCCESS Success                                               CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                                CNcomment: Ioctrl调用失败 CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED module is not initialized.    CNcomment:模块没有初始化 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_KEY_IsRepKey(HI_U32 u32IsRepKey);
+
+/**
+\brief Enables or disables the function of reporting the released status of a key.
+CNcomment:\brief 设置是否上报按键弹起。CNend
+
+\attention \n
+The released statuses of keys are reported only after the report function is enabled. Otherwise, only the pressed statuses are reported.\n
+CNcomment:使能后才会上报按键弹起事件，不然只上报按下事件。CNend
+
+\param[in] u32IsKeyUp Repeat key report enable. 1: enabled; 0: disabled  CNcomment:是否使能重复按键，1 使能，0 不使能。CNend
+\retval ::HI_SUCCESS Success                                             CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                              CNcomment: Ioctrl调用失败 CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED module is not initialized.  CNcomment:模块没有初始化 CNend
+\see \n 
+N/A
+*/
+HI_S32 HI_UNF_KEY_IsKeyUp(HI_U32 u32IsKeyUp);
+
+/**
+\brief Enables the display function of LEDs.
+CNcomment:\brief 打开数码管显示功能。CNend
+
+\attention \n
+The LEDs work only after the display function is enabled.\n
+The error code HI_SUCCESS is returned if this API is called repeatedly.\n
+CNcomment:打开后才会有数码管的显示\n
+重复调用本接口，会返回成功。CNend
+
+\param N/A                                     CNcomment:无 CNend
+\retval ::HI_SUCCESS Success                   CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.    CNcomment: Ioctrl调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_LED_Open(HI_VOID);
+
+/**
+\brief Disables the display function of LEDs.
+CNcomment:\brief 关闭数码管显示功能。CNend
+
+\attention \n
+The LEDs do not work after the display function is disabled.\n
+This API is valid when it is called for the first time. If this API is called repeatedly, the error code HI_SUCCESS is returned.\n
+CNcomment:关闭后停止数码管显示\n
+本接口第一次调用起作用,重复调用返回成功。CNend
+ 
+\param N/A                                    CNcomment:无 CNend
+\retval ::HI_SUCCESS Success                  CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.   CNcomment: Ioctrl调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_LED_Close(HI_VOID);
+
+
+/**
+\brief Displays characters based on the type of the input code.
+CNcomment:\brief 根据传入的码型值进行显示。CNend
+
+\attention \n
+Each LED displays a character that corresponds to the value of one byte.\n
+During displaying, the values of the four characters to be displayed need to be combined to form a 32-bit unsigned int data segment. The data serves as the parameter value of this API.\n
+The four LEDs from left to right display bit[7:0], bit[15:8], bit[23:16], and bit[31:24] of the data respectively.\n
+For example, if you want to display "0123" on LEDs, you need to combine the display values corresponding to these characters to form the following unsigned int variable:\n
+  Unsigned int parameter = 0x03 + (0x9F <<8) + (0x25<<16) + (0x0D <<24);\n
+Where, 0x03, 0x9F, 0x25, and 0x0D are the display values of 0, 1, 2, and 3 respectively.\n
+The following shows the mapping between the segments of a 7-segment LED and data bits:\n
+       --7--       \n
+      |     |      \n
+     2|     |6     \n
+      |--1--       \n
+      |     |      \n
+     3|     |5     \n
+       --4-- .0    \n
+The common display characters and values of the LEDs on HiSilicon demo board are as follows in the case of co-anode (the display characters and values need to be reversed in the case of co-cathode):
+  Digitals 0-9: 0x03, 0x9F, 0x25, 0x0D, 0x99, 0x49, 0x41, 0x1F, 0x01, 0x09\n
+  Upper-case letters A-Z (the characters that cannot be displayed are expressed as 0xFF):\n
+     0xFF, 0xFF, 0x63, 0xFF, 0x61, 0x71, 0xFF, 0x91, 0xFF, 0xFF, 0xFF, 0xE3, 0xFF,\n
+     0xFF, 0x03, 0x31, 0xFF, 0xFF, 0x49, 0xFF, 0x83, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n
+  Lower-case letters a-z (the characters that cannot be displayed are expressed as 0xFF):\n
+    0xFF, 0xC1, 0xE5, 0x85, 0x21, 0xFF, 0x09, 0xD1, 0xDF, 0xFF, 0xFF, 0x9F, 0xFF,\n
+    0xD5, 0xC5, 0x31, 0x19, 0xFF, 0x49, 0xFF, 0xC7, 0xE1, 0xFF, 0xFF, 0xFF, 0xFF
+CNcomment:	每个数码管要显示的字符对应一个字节的显示值。\n
+显示时需要将4 个待显示字符对应的显示值组合成一个unsiged int（32bit）数据作为此接口的参数值。\n
+从左到右的4 个LED 依次显示数据的bit[7:0]、bit[15:8]、bit[23:16]、bit[31:24]。\n
+例如：在LED 上显示“0123”，则需要将这些字符对应的显示值组合成一个Unsigned int 的变量：\n
+   Unsigned int parameter = 0x03 + (0x9F <<8) + (0x25<<16) + (0x0D <<24)；\n
+其中：0x03、0x9F、0x25、0x0D 分别是‘0’、‘1’、‘2’、‘3’的显示值。\n
+七段数码管段数与数据的bit对应关系如下:\n
+       --7--       \n
+      |     |      \n
+     2|     |6     \n
+      |--1--       \n
+      |     |      \n
+     3|     |5     \n
+       --4-- .0    \n
+海思DEMO板数码管常用显示字符及其对应的显示值如下(针对共阳极，共阴极要取反)：\n
+  . 字符0-9：0x03, 0x9F, 0x25, 0x0D, 0x99, 0x49, 0x41, 0x1F, 0x01, 0x09\n
+  . 大写字母A-Z（不能显示的用0xFF 表示）：\n
+     0xFF, 0xFF, 0x63, 0xFF, 0x61, 0x71, 0xFF, 0x91, 0xFF, 0xFF, 0xFF, 0xE3, 0xFF,\n
+     0xFF, 0x03, 0x31, 0xFF, 0xFF, 0x49, 0xFF, 0x83, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n
+  . 小写字母a-z（不能显示的用0xFF 表示）：\n
+     0xFF, 0xC1, 0xE5, 0x85, 0x21, 0xFF, 0x09, 0xD1, 0xDF, 0xFF, 0xFF, 0x9F, 0xFF,\n
+     0xD5, 0xC5, 0x31, 0x19, 0xFF, 0x49, 0xE1, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF CNend
+\param[in] u32CodeValue 4-digit value to be displayed                   CNcomment:需要显示的4位数值。CNend
+\retval ::HI_SUCCESS Success                                            CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                             CNcomment: Ioctrl调用失败 CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED module is not initialized. CNcomment:模块没有初始化 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_LED_Display(HI_U32 u32CodeValue);
+
+
+/**
+\brief Displays the time on LEDs.
+CNcomment:\brief 在数码管上显示时间。CNend
+
+\attention \n
+The values of hour and minute need to be converted into corresponding decimal values. For example, if you want to display 22:45, you need to set hour to 22 and set minute to 45.\n
+After the start time is set, the time is displayed on LEDs. At the same time, the colon (:) in the time blinks at the frequency of 1 Hz.\n
+Because the time is displayed in 24-hour format, the maximum value of hour is 23, and the maximum value of minute is 59.\n
+CNcomment:小时、分钟只需配置成相应的十进制值就行了。比如显示22：45，则hour=22，minute=45。\n
+传入时间数据结构，然后在数码管上显示，显示时间的同时冒号会以1HZ的频率闪烁\n
+时间的范围注意按24小时制，最大支持小时为23，分为59。CNend
+
+\param[in] stLedTime Time                                                CNcomment:时间。CNend
+\retval ::HI_SUCCESS  Success                                            CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                              CNcomment: Ioctrl调用失败 CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED module is not initialized.  CNcomment:模块没有初始化 CNend
+\retval ::HI_ERR_KEYLED_INVALID_PARA  The input parameter is invalid.    CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_LED_DisplayTime(HI_UNF_KEYLED_TIME_S stLedTime);
+
+/**
+\brief Sets the ID of the blinked LED.
+CNcomment:\brief 设置要闪烁的LED 序号。CNend
+
+\attention \n
+The IDs of the LEDs on the board are 1, 2, 3, and 4 from left to right. If you want 4 LEDs to blink together, set 5.\n
+CNcomment:单板上的数码管的序号从左到右依次为：1、2、3、4。设置4个数码管一起闪烁:5；CNend
+
+\param[in] enPin  Pin ID                                                 CNcomment:要显示的序号。CNend
+\retval ::HI_SUCCESS Success                                             CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                              CNcomment: Ioctrl调用失败 CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED module is not initialized.  CNcomment:模块没有初始化 CNend
+\retval ::HI_ERR_KEYLED_INVALID_PARA  The input parameter is invalid.    CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_LED_SetFlashPin(HI_UNF_KEYLED_LIGHT_E enPin);
+
+/**
+\brief Sets the blink level of an LED.
+CNcomment:\brief 设置LED 闪烁级别。CNend
+
+\attention \n
+The higher the level, the faster an LED blinks.
+CNcomment:级别越高闪烁速度越快。CNend
+
+\param[in] enLevel  Blink level from 1 to 5.                             CNcomment:闪烁级别，设置范围:1 到 5 CNend
+\retval ::HI_SUCCESS Success                                             CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                              CNcomment: Ioctrl调用失败 CNend
+\retval ::HI_ERR_KEYLED_NOT_INIT  The KEYLED module is not initialized.  CNcomment:模块没有初始化 CNend
+\retval ::HI_ERR_KEYLED_INVALID_PARA The input parameter is invalid.     CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_LED_SetFlashFreq(HI_UNF_KEYLED_LEVEL_E enLevel);
+
+/**
+\brief  whether enable the lockfreq led.
+CNcomment:\brief 设置锁频LED。CNend
+
+\attention \n
+At present,only FD650 KEYLED support this.
+CNcomment:目前只有FD650面板支持该设置CNend
+
+\param[in] setLock  If lock ,set to HI_TRUE. Otherwise,set to HI_FALSE.                            CNcomment:LOCKLED设置，锁定时设置为HI_TRUE，否则，设置为HI_FALSE.CNend
+\retval ::HI_SUCCESS Success                                             CNcomment:成功 CNend
+\retval ::HI_FAILURE  Calling Ioctrl fails.                              CNcomment: Ioctrl调用失败 CNend
+\retval ::HI_ERR_KEYLED_INVALID_PARA The input parameter is invalid.     CNcomment:输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_LED_SetLockPin(HI_BOOL setLock);
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* End of #ifndef __HI_UNF_KEYLED_H__ */
+
+
diff -uNr a/include/hi_unf_klad.h b/include/hi_unf_klad.h
--- a/include/hi_unf_klad.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_klad.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,270 @@
+/******************************************************************************
+
+Copyright (C), 2016, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_unf_klad.h
+Version       : Initial draft
+Author        : Hisilicon hisecurity team
+Created       : 2016-12-08
+Last Modified :
+Description   : Key ladder basic API declaration
+Function List :
+History       :
+******************************************************************************/
+#ifndef __HI_UNF_KLAD_H__
+#define __HI_UNF_KLAD_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      KLAD */
+/** @{ */  /** <!-- [KLAD] */
+
+#define HI_UNF_KLAD_MAX_KEY_LEN     (16)
+
+/*
+Level: 1
+Algorithm: TDES/AES
+Target Engine: Multicipher - fixed; encrypted register - NA
+*/
+#define HI_UNF_KLAD_TYPE_BLPK       (0x0000)
+
+/*
+Level: 1
+Algorithm: TDES
+Target Engine: Multicipher - fixed; encrypted register - NA
+*/
+#define HI_UNF_KLAD_TYPE_SWPK       (0x0001)
+
+/*
+Level: 0
+Algorithm: NA
+Target Engine: Multicipher - fixed
+*/
+#define HI_UNF_KLAD_TYPE_STBROOTKEY (0x0002)
+
+/*
+Level: 0
+Algorithm: NA
+Target Engine: Demux - CSA2/CSA3/AES/DES/NOVEL/SM4/TDES; Payload cipher - AES; Multicipher - fixed
+*/
+#define HI_UNF_KLAD_TYPE_CLEARCW    (0x0003)
+
+/*
+Level: 1
+Algorithm: TDES
+Target Engine: Multicipher - fixed; encrypted register - NA
+*/
+#define HI_UNF_KLAD_TYPE_STBM_R2R   (0x0004)
+
+
+/**Target engine of key ladder*/
+typedef enum
+{
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_CSA2             = 0x0000,   /**<Demux PAYLOAD CSA2 */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_CSA3             = 0x0010,   /**<Demux PAYLOAD CSA3 */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_AES_CBC_IDSA     = 0x0020,   /**<Demux PAYLOAD AES  IPTV Mode */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_AES_ECB          = 0x0021,   /**<Demux PAYLOAD AES  ECB Mode */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_AES_CBC_CI       = 0x0022,   /**<Demux PAYLOAD AES  CIPLUS */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_AES_CLRSTART_ECB = 0x0024,   /**<Demux PAYLOAD AES  CLRSTART ECB */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_AES_CLRSTART_CBC = 0x0025,   /**<Demux PAYLOAD AES  CLRSTART CBC */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_AES_CTR          = 0x0026,   /**<Demux PAYLOAD AES  CTR */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_DES_IPTV         = 0x0030,   /**<Demux PAYLOAD DES  CIPLUS */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_DES_CIPLUS       = 0x0032,   /**<Demux PAYLOAD DES  CIPLUS */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_DES_CBC          = 0x0033,   /**<Demux PAYLOAD DES  CBC */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_AES_NOVEL        = 0x0040,   /**<Demux PAYLOAD AES  NOVEL */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_SMS4_NOVEL       = 0x0041,   /**<Demux PAYLOAD SMS4 NOVEL */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_SMS4_IPTV        = 0x0050,   /**<Demux PAYLOAD SMS4 IPTV */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_SMS4_ECB         = 0x0051,   /**<Demux PAYLOAD SMS4 ECB */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_SMS4_CBC         = 0x0053,   /**<Demux PAYLOAD SMS4 CBC */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_AES_CBC          = 0x0063,   /**<Demux PAYLOAD AES  CBC */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_TDES_IPTV        = 0x0070,   /**<Demux PAYLOAD TDES IPTV */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_TDES_ECB         = 0x0071,   /**<Demux PAYLOAD TDES ECB */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_TDES_CBC         = 0x0073,   /**<Demux PAYLOAD TDES CBC */
+    HI_UNF_KLAD_TARGET_ENGINE_PAYLOAD_ASA              = 0x0091,   /**<Demux PAYLOAD ASA */
+    HI_UNF_KLAD_TARGET_ENGINE_RAW_AES_CBC              = 0x4020,   /**<Cipher AES CBC */
+    HI_UNF_KLAD_TARGET_ENGINE_RAW_AES_ECB              = 0x4021,   /**<Cipher AES ECB */
+    HI_UNF_KLAD_TARGET_ENGINE_RAW_AES_CBC_PIFF         = 0x4022,   /**<Cipher AES CBC PIFF */
+    HI_UNF_KLAD_TARGET_ENGINE_RAW_AES_CBC_APPLE        = 0x4023,   /**<Cipher AES CBC APPLE */
+    HI_UNF_KLAD_TARGET_ENGINE_RAW_AES_CTR              = 0x4024,   /**<Cipher AES CTR */
+    HI_UNF_KLAD_TARGET_ENGINE_RAW_AES_GCM              = 0x4028,   /**<Cipher AES GCM */
+    HI_UNF_KLAD_TARGET_ENGINE_RAW_TDES_CBC             = 0x4040,   /**<Cipher AES CBC */
+    HI_UNF_KLAD_TARGET_ENGINE_RAW_TDES_ECB             = 0x4041,   /**<Cipher AES ECB */
+    HI_UNF_KLAD_TARGET_ENGINE_FIXED,                               /**<Can't config by software */
+    HI_UNF_KLAD_TARGET_ENGINE_BUTT
+} HI_UNF_KLAD_TARGET_ENGINE_E;
+
+/**Encryption algorithm of key ladder*/
+typedef enum
+{
+    HI_UNF_KLAD_ALG_TYPE_TDES = 0,      /**<Encryption algorithm : TDES*/
+    HI_UNF_KLAD_ALG_TYPE_AES,           /**<Encryption algorithm : AES*/
+    HI_UNF_KLAD_ALG_TYPE_BUTT
+} HI_UNF_KLAD_ALG_TYPE_E;
+
+/**Level of key ladder*/
+typedef enum
+{
+    HI_UNF_KLAD_LEVEL1 = 0,
+    HI_UNF_KLAD_LEVEL2,
+    HI_UNF_KLAD_LEVEL3,
+    HI_UNF_KLAD_LEVEL4,
+    HI_UNF_KLAD_LEVEL5,
+    HI_UNF_KLAD_LEVEL6,
+    HI_UNF_KLAD_LEVEL_BUTT
+} HI_UNF_KLAD_LEVEL_E;
+
+/**Session key*/
+typedef struct
+{
+    HI_UNF_KLAD_LEVEL_E enLevel;
+    HI_U8 au8Key[HI_UNF_KLAD_MAX_KEY_LEN];
+} HI_UNF_KLAD_SESSION_KEY_S;
+
+/**Content key*/
+typedef struct
+{
+    HI_BOOL bOdd;
+    HI_U8 au8Key[HI_UNF_KLAD_MAX_KEY_LEN];
+} HI_UNF_KLAD_CONTENT_KEY_S;
+
+typedef struct
+{
+    HI_U8 au8ClearKey[HI_UNF_KLAD_MAX_KEY_LEN];
+    HI_U8 au8EncKey[HI_UNF_KLAD_MAX_KEY_LEN];
+} HI_UNF_KLAD_ENC_KEY_S;
+
+/**Attributes of key ladder*/
+typedef struct
+{
+    HI_U32 u32KladType;
+    HI_UNF_KLAD_ALG_TYPE_E enAlg;
+    HI_UNF_KLAD_TARGET_ENGINE_E enEngine;
+} HI_UNF_KLAD_ATTR_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      KLAD */
+/** @{ */  /** <!--[KLAD]*/
+
+/**
+\brief Init the key ladder device
+\param  None
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_Init(HI_VOID);
+
+/**
+\brief Deinit the key ladder device
+\param  None
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_DeInit(HI_VOID);
+
+/**
+\brief Create a handle of key ladder
+\param[in] u32Type  key ladder type, ref: HI_UNF_KLAD_TYPE_
+\param[out] phKlad  Handle of key ladder
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_Create(HI_HANDLE* phKlad);
+
+/**
+\brief Destroy key ladder handle
+\param[in] hKlad    Handle of key ladder
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_Destroy(HI_HANDLE hKlad);
+
+/**
+\brief Attach key ladder to the taget, include mcipher, plcipher, demux
+\param[in] hKlad    Handle of key ladder
+\param[in] hTarget  Handle of target
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_Attach(HI_HANDLE hKlad, HI_HANDLE hTarget);
+
+/**
+\brief Detach a key ladder from a target
+\param[in] hKlad    Handle of key ladder
+\param[in] hTarget  Handle of target
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_Detach(HI_HANDLE hKlad, HI_HANDLE hTarget);
+
+/**
+\brief Set the attributes of a key ladder
+\param[in] hKlad    Handle of key ladder
+\param[in] pstAttr  Pointer to the attributes of a key ladder
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_SetAttr(HI_HANDLE hKlad, HI_UNF_KLAD_ATTR_S* pstAttr);
+
+/**
+\brief Get the attributes of a key ladder
+\param[in] hKlad    Handle of key ladder
+\param[out] pstAttr Pointer to the attributes of a key ladder
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_GetAttr(HI_HANDLE hKlad, HI_UNF_KLAD_ATTR_S* pstAttr);
+
+/**
+\brief Set session key of a keyladder
+\param[in] hKlad    Handle of key ladder
+\param[in] pstKey   Pointer to the session key
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_SetSessionKey(HI_HANDLE hKlad, HI_UNF_KLAD_SESSION_KEY_S* pstKey);
+
+/**
+\brief Set content key of a keyladder
+\param[in] hKlad    Handle of key ladder
+\param[in] pstKey   Pointer to the content key
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_SetContentKey(HI_HANDLE hKlad, HI_UNF_KLAD_CONTENT_KEY_S* pstKey);
+
+/**
+\brief Generate an encrypted key
+\param[in] hKlad    Handle of key ladder
+\param[in] pstKey   Pointer to the encrypted key
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_GenerateEncKey(HI_HANDLE hKlad, HI_UNF_KLAD_ENC_KEY_S* pstKey);
+
+/**
+\brief Send STB rootkey to cipher
+\param[in] hKlad    Handle of key ladder
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_SendSTBRootkeyToCipher(HI_HANDLE hKlad);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_KLAD_H__ */
+
diff -uNr a/include/hi_unf_klad_common_ca.h b/include/hi_unf_klad_common_ca.h
--- a/include/hi_unf_klad_common_ca.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_klad_common_ca.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,82 @@
+/******************************************************************************
+
+Copyright (C), 2016, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_unf_klad_common_ca.h
+Version       : Initial draft
+Author        : Hisilicon hisecurity team
+Created       : 2016-12-08
+Last Modified :
+Description   : Key ladder API declaration for common ca
+Function List :
+History       :
+******************************************************************************/
+#ifndef __HI_UNF_KLAD_COMMON_CA_H__
+#define __HI_UNF_KLAD_COMMON_CA_H__
+
+#include "hi_type.h"
+#include "hi_unf_klad.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      COMMON_CA */
+/** @{ */  /** <!-- [COMMON_CA] */
+
+/*
+Level: 2/3 depends on OTP
+Algorithm: TDES/AES
+Target Engine: Demux - CSA2
+*/
+#define HI_UNF_KLAD_COMMON_CA_TYPE_CSA2   0x3f00
+
+/*
+Level: 2/3 depends on OTP
+Algorithm: TDES/AES
+Target Engine: Demux - CSA3
+*/
+#define HI_UNF_KLAD_COMMON_CA_TYPE_CSA3   0x3f01
+
+/*
+Level: 2/3/4/5 depends on OTP
+Algorithm: TDES/AES
+Target Engine: Demux - AES/NOVEL/SM4; Payload cipher - AES; Multicipher - fixed
+*/
+#define HI_UNF_KLAD_COMMON_CA_TYPE_SP     0x3f02
+
+/*
+Level: 2/3 depends on OTP
+Algorithm: TDES/AES
+Target Engine: Demux - AES/NOVEL/SM4/TDES; Payload cipher - AES; Multicipher - fixed
+*/
+#define HI_UNF_KLAD_COMMON_CA_TYPE_R2R    0x3f03
+
+/*
+Level: 2/3/4/5 depends on OTP
+Algorithm: TDES/AES
+Target Engine: Demux - CSA2/CSA3/AES/NOVEL/SM4/TDES; Payload cipher - AES; Multicipher - fixed
+*/
+#define HI_UNF_KLAD_COMMON_CA_TYPE_MISC   0x3f04
+
+
+/************************************************/
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      COM_CA */
+/** @{ */  /** <!-- [COM_CA] */
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_KLAD_COMMON_CA_H__ */
+
diff -uNr a/include/hi_unf_klad_dcas.h b/include/hi_unf_klad_dcas.h
--- a/include/hi_unf_klad_dcas.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_klad_dcas.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,81 @@
+/******************************************************************************
+
+Copyright (C), 2017, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_unf_klad_dcas.h
+Version       : Initial draft
+Author        : Hisilicon hisecurity team
+Created       : 2017-03-21
+Last Modified :
+Description   : Key ladder API declaration for DCAS
+Function List :
+History       :
+******************************************************************************/
+#ifndef __HI_UNF_KLAD_DCAS_H__
+#define __HI_UNF_KLAD_DCAS_H__
+
+#include "hi_type.h"
+#include "hi_unf_klad.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup       */
+/** @{ */  /** <!-- [DCAS] */
+
+
+/*
+Level: 1
+Algorithm: AES
+Target Engine: NA
+*/
+#define HI_UNF_KLAD_DCAS_TYPE_RKD    0x0c00
+
+/*
+Level: 3
+Algorithm: TDES/AES
+Target Engine: Demux - CSA2/CSA3/AES/NOVEL/SM4/TDES; Payload cipher - AES; Multicipher - fixed
+*/
+#define HI_UNF_KLAD_DCAS_TYPE_K30    0x0c01
+
+
+/**da nonce*/
+typedef struct hiUNF_KLAD_DCAS_DA_NONCE_S
+{
+    HI_U8 au8Nonce[HI_UNF_KLAD_MAX_KEY_LEN];
+    HI_U8 au8DaNonce[HI_UNF_KLAD_MAX_KEY_LEN];
+} HI_UNF_KLAD_DCAS_DA_NONCE_S;
+
+
+/************************************************/
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      DCAS */
+/** @{ */  /** <!-- [DCAS] */
+
+
+/**
+\brief Generate K30 DA nonce
+\param[in] hKlad    Handle of key ladder
+\param[in/out] pstDaNonce    pointer to the DA nonce
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_KLAD_DCAS_K30GenDaNonce(HI_HANDLE hKlad, HI_UNF_KLAD_DCAS_DA_NONCE_S *pstDaNonce);
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_KLAD_DCAS_H__ */
+
+
diff -uNr a/include/hi_unf_mailbox.h b/include/hi_unf_mailbox.h
--- a/include/hi_unf_mailbox.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_mailbox.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,151 @@
+/******************************************************************************
+
+  Copyright (C), 2016, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_mailbox.h
+  Version       : Initial Draft
+  Author        : Hisilicon hisecurity team
+  Created       : 2016-11-4
+  Description   :
+  History       :
+  1.Date        :
+  Author        : sdk
+  Modification  :
+
+*******************************************************************************/
+#ifndef __HI_UNF_MAILBOX_H__
+#define __HI_UNF_MAILBOX_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+
+/** Mailbox ID */
+#define MID_SCPU_COMMON          (0x01)
+#define MID_TCPU_COMMON          (0x40)
+#define MID_ACPU_COMMON          (0x60)
+
+typedef struct
+{
+    HI_VOID *pMessage;
+    HI_U32 u32MessageLen;
+    HI_VOID *pOutBuffer;
+    HI_U32 *pu32OutBufferLen;
+} HI_UNF_MAILBOX_BUFFER_S;
+
+/******************************* API declaration *****************************/
+
+/**
+\brief Initializes the mailbox module. CNcomment:初始化Mailbox模块 CNend
+\attention \n
+Before calling other functions in this file, you must call this application programming interface (API).
+\param N/A
+\retval ::HI_SUCCESS  Success.       CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Failure.       CNcomment:API系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_MAILBOX_Init(HI_VOID);
+
+/**
+\brief Deinitializes the mailbox module. CNcomment:去初始化Mailbox设备 CNend
+\attention \n
+N/A
+\param N/A                           CNcomment:无。 CNend
+\retval ::HI_SUCCESS  Success.       CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Failure.       CNcomment:API系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_MAILBOX_DeInit(HI_VOID);
+
+/**
+\brief Open mailbox device.                      CNcomment:打开 mailbox 设备，返回 maibox 句柄。 CNend
+\attention \n
+N/A
+\param[out] pHandle: Create handle/A             CNcomment:无。 CNend
+\param[in]  u32Id:  mailbox ID, now it is fixed to MID_ACPU_COMMON/A  CNcomment:无。 CNend
+
+\retval ::HI_SUCCESS  Call this API successful.  CNcomment:系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API failure.     CNcomment:分配句柄失败。 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_MAILBOX_Open(HI_HANDLE* pHandle, HI_U32 u32Id);
+
+/**
+\brief Destory mailbox instance.                 CNcomment:关闭 mailbox 设备实例。 CNend
+\attention \n
+N/A
+\param [in] handle: mailbox instance handle/A    CNcomment:无。 CNend
+\retval ::HI_SUCCESS  Call this API successful.  CNcomment:系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API failure.     CNcomment:释放句柄失败。 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_MAILBOX_Close(HI_HANDLE handle);
+
+/**
+\brief  send data by mailbox.                    CNcomment:通过 mailbox 发送数据。 CNend
+\attention \n
+N/A
+\param [in] handle: mailbox instance handle/A
+\param [in] u32ReceiverId: mailbox ID of data receiver/A
+\param [in/out] pstBuffer: intput and output buffer/A
+\param [in] u32Flags: mailbox mode. 0 means block mode, 1 means timeout mode/A
+\param [in] u32Param: mailbox max wait time, it is valid when mailbox mode is set to 1/A
+\retval ::HI_SUCCESS  Call this API successful.
+\retval ::HI_FAILURE  Call this API failure.
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_MAILBOX_Send
+(
+    HI_HANDLE handle,
+    HI_U32 u32ReceiverId,
+    HI_UNF_MAILBOX_BUFFER_S *pstBuffer,
+    HI_U32 u32Flags,
+    HI_U32 u32Param
+);
+
+/**
+\brief  start transaction.                    CNcomment:开启事务处理 CNend
+\attention \n
+N/A
+\param [in] handle: mailbox instance handle/A
+\retval ::HI_SUCCESS  Call this API successful.
+\retval ::HI_FAILURE  Call this API failure.
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_MAILBOX_BeginTransaction(HI_HANDLE handle);
+
+/**
+\brief  end transaction.                    CNcomment:结束事务处理 CNend
+\attention \n
+N/A
+\param [in] handle: mailbox instance handle/A
+\retval ::HI_SUCCESS  Call this API successful.
+\retval ::HI_FAILURE  Call this API failure.
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_MAILBOX_EndTransaction(HI_HANDLE handle);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif
+
+#endif /** __HI_UNF_MAILBOX_H__*/
+
diff -uNr a/include/hi_unf_mce.h b/include/hi_unf_mce.h
--- a/include/hi_unf_mce.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_mce.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,253 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_mce.h
+  Version       : Initial Draft
+  Author        : HiSilicon multimedia software group
+  Created       : 2011-xx-xx
+  Description   : hi_unf_mce.h header file
+  History       :
+  1.Date        : 2011/xx/xx
+    Author      :
+    Modification: This file is created.
+
+******************************************************************************/
+/**
+ * \file
+ * \brief Describes the logo and play contents and related configuration information.
+ */
+#ifndef __HI_UNF_MCE_H__
+#define __HI_UNF_MCE_H__
+
+#include "hi_unf_common.h"
+#include "hi_unf_disp.h"
+#include "hi_unf_vo.h"
+#include "hi_unf_avplay.h"
+#include "hi_unf_frontend.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif  /* End of #ifdef __cplusplus */
+
+/********************************Struct Definition********************************/
+/** \addtogroup      MCE */
+/** @{ */  /** <!-- [MCE] */
+
+
+/** Defines the logo parameter*/
+/** CNcomment:开机Logo参数*/
+typedef struct hiUNF_MCE_LOGO_PARAM_S
+{
+    HI_BOOL     bLogoEnable;    /**<Whether logo is enable*//**<CNcomment: Logo是否使能*/
+    HI_U32      u32LogoLen;     /**<Length of logo data*//**<CNcomment: Logo数据的长度*/
+}HI_UNF_MCE_LOGO_PARAM_S;
+
+
+/*fastplay supports the decoding mode of ADEC*//**<CNcomment:fastplay 支持的ADEC解码格式 */
+typedef enum hiUNF_MCE_ADEC_TYPE_E
+{
+    HI_UNF_MCE_ADEC_TYPE_MP2 = 0,       /**<MP2 format*//**<CNcomment:MP2 制式 */
+    HI_UNF_MCE_ADEC_TYPE_MP3 = 1,       /**<MP3 format*//**<CNcomment:MP3 制式 */
+    HI_UNF_MCE_ADEC_TYPE_BUTT           /**<Invalid format*//**<CNcomment:无效 制式 */
+}HI_UNF_MCE_ADEC_TYPE_E;
+
+/**fastplay supports the decoding mode of VDEC*//**<CNcomment:fastplay 支持的VDEC解码格式 */
+typedef enum hiUNF_MCE_VDEC_TYPE_E
+{
+    HI_UNF_MCE_VDEC_TYPE_MPEG2 = 0,     /**<MPEG2 format*//**<CNcomment:MPEG2  制式 */
+    HI_UNF_MCE_VDEC_TYPE_MPEG4 = 1,     /**<MPEG4 format*//**<CNcomment:MPEG4  制式 */
+    HI_UNF_MCE_VDEC_TYPE_H264  = 2,     /**<H264 format*//**<CNcomment:H264  制式 */
+    HI_UNF_MCE_VDEC_TYPE_AVS   = 3,     /**<AVS format*//**<CNcomment:AVS   制式 */
+    HI_UNF_MCE_VDEC_TYPE_HEVC  = 4,     /**<HEVC format*//**<CNcomment:H265  制式 */
+    HI_UNF_MCE_VDEC_TYPE_BUTT           /**<Invalid format*//**<CNcomment:无效 制式 */
+}HI_UNF_MCE_VDEC_TYPE_E;
+
+
+/**Parameters for digital video broadcasting (DVB) play configuration*//**<CNcomment:DVB配置信息  */
+typedef struct hiUNF_MCE_DVB_PARAM_S
+{
+    HI_U32                      u32PcrPid;      /**<Program clock reference (PCR) packet ID (PID)*//**<CNcomment:pcr pid*/
+    HI_U32                      u32VideoPid;    /**<Video PID*//**<CNcomment:视频 pid*/
+    HI_U32                      u32AudioPid;    /**<Audio PID*//**<CNcomment:音频 pid*/
+    HI_UNF_MCE_VDEC_TYPE_E      enVideoType;    /**<Video type*//**<CNcomment:视频 类型*/
+    HI_UNF_MCE_ADEC_TYPE_E      enAudioType;    /**<Audio type*//**<CNcomment:音频 类型*/
+    HI_U32                      u32Volume;      /**<volume of output*//**<CNcomment:音量 */
+    HI_UNF_TRACK_MODE_E         enTrackMode;    /**<Track mode. Only HI_UNF_TRACK_MODE_STEREO is supported.*//**<CNcomment:仅支持立体声 */
+    HI_UNF_VO_DEV_MODE_E        enDevMode;      /**<Working mode of the VO device*//**<CNcomment:dev 的 vo 模式  */
+    HI_UNF_TUNER_CONNECT_PARA_S stConnectPara;  /**<Tuner connect parameter*//**<CNcomment:Tuner锁频参数.*/
+    HI_UNF_TUNER_FE_LNB_CONFIG_S    stLnbCfg;   /**<LNB config*//**<CNcomment:LNB 配置 */
+    HI_UNF_TUNER_FE_LNB_POWER_E            enLNBPower;/**<LNB Power*//**<CNcomment:LNB供电控制 */
+    HI_UNF_TUNER_DISEQC_SWITCH16PORT_S     st16Port;/**<Switch16 parameter*//**<CNcomment:Switch16开关参数 */
+    HI_UNF_TUNER_DISEQC_SWITCH4PORT_S      st4Port;/**<Switch4 parameter*//**<CNcomment:Switch4开关参数 */
+    HI_UNF_TUNER_SWITCH_22K_E              enSwitch22K; /**<22K switch parameter*//**<CNcomment:22K开关参数 */
+}HI_UNF_MCE_DVB_PARAM_S;
+
+/**Play parameter configuration of transport stream (TS) files*//**<CNcomment:TS文件配置信息 */
+typedef struct hiUNF_MCE_TSFILE_PARAM_S
+{
+    HI_U32                      u32ContentLen;  /**File length*//**<CNcomment:文件长度  */
+    HI_U32                      u32PcrPid;      /**<pcr pid*//**<CNcomment:pcr pid  */
+    HI_U32                      u32VideoPid;    /**<Video PID*//**<CNcomment:视频 pid. */
+    HI_U32                      u32AudioPid;    /**<Audio PID*//**<CNcomment:音频 pid. */
+    HI_UNF_MCE_VDEC_TYPE_E      enVideoType;    /**<Video type*//**<CNcomment:视频 类型 */
+    HI_UNF_MCE_ADEC_TYPE_E      enAudioType;    /**<Audio type*//**<CNcomment:音频 类型 */
+    HI_U32                      u32Volume;      /**<volume of output *//**<CNcomment:音量 */
+    HI_UNF_TRACK_MODE_E         enTrackMode;    /**<Track mode. Only HI_UNF_TRACK_MODE_STEREO is supported.*//**<CNcomment:仅支持立体声 */
+    HI_UNF_VO_DEV_MODE_E        enDevMode;      /**<mode of vo device  *//**<CNcomment:vo设备的模式  */
+}HI_UNF_MCE_TSFILE_PARAM_S;
+
+#define ANI_MAX_PIC_SUPPORT (30)
+typedef struct hiUNF_MCE_ANI_PARAM_S
+{
+    HI_U32  u32ContentLen;  /**File length*//**<CNcomment:文件长度  */
+    HI_U32  u32PicCount;
+    HI_U32  au32PicTime[ANI_MAX_PIC_SUPPORT];
+}HI_UNF_MCE_ANI_PARAM_S;
+
+/**Play type*//**<CNcomment:播放类型*/
+typedef enum hiUNF_MCE_PLAY_TYPE_E
+{
+    HI_UNF_MCE_TYPE_PLAY_DVB     = 0,   /**<DVB type*/ /**<CNcomment:DVB 类型 */
+    HI_UNF_MCE_TYPE_PLAY_TSFILE  = 1,   /**<TS file type*/ /**<CNcomment:ts 文件类型 */
+    HI_UNF_MCE_TYPE_PLAY_ANI     = 2,   /**<ES file type*/ /**<CNcomment:es 文件类型 */
+    HI_UNF_MCE_TYPE_PLAY_BUTT
+}HI_UNF_MCE_PLAY_TYPE_E;
+
+
+/**Play configuration*//**<CNcomment:播放配置信息 */
+typedef struct hiUNF_MCE_PLAY_PARAM_S
+{
+    HI_UNF_MCE_PLAY_TYPE_E          enPlayType;     /**<Play type*//**<CNcomment:播放类型*/
+    HI_BOOL                         bPlayEnable;    /**<Whether play is enable*//**<CNcomment: 瞬播是否使能*/
+
+    union
+    {
+        HI_UNF_MCE_DVB_PARAM_S     stDvbParam;      /**<dvb parameter*//**<CNcomment:dvb参数*/
+        HI_UNF_MCE_TSFILE_PARAM_S  stTsParam;       /**<ts parameter*//**<CNcomment:ts参数*/
+        HI_UNF_MCE_ANI_PARAM_S     stAniParam;      /**<es parameter*//**<CNcomment:es参数*/
+    }unParam;
+
+    HI_BOOL                         bContentValid;  /**<whether mce content is valid *//**<CNcomment:mce 数据是否有效*/
+}HI_UNF_MCE_PLAY_PARAM_S;
+
+/**Mode of Play Control*//**CNcomment:播放控制模式 */
+typedef enum hiUNF_MCE_PLAYCTRL_MODE_E
+{
+    HI_UNF_MCE_PLAYCTRL_BY_TIME,    /**<play control by time*//**<CNcomment:通过时间控制*/
+    HI_UNF_MCE_PLAYCTRL_BY_COUNT,   /**<play control by count*//**<CNcomment:通过播放次数控制*/
+    HI_UNF_MCE_PLAYCTRL_BUTT
+}HI_UNF_MCE_PLAYCTRL_MODE_E;
+
+/**Defines the parameter of fastplay stop*//**CNcomment:瞬播停止参数 */
+typedef struct hiUNF_MCE_STOPPARM_S
+{
+    HI_UNF_AVPLAY_STOP_MODE_E   enStopMode;     /**<Mode of Stop,see ::HI_UNF_AVPLAY_STOP_MODE_E*//**<CNcomment:停止模式，参见::HI_UNF_AVPLAY_STOP_MODE_E*/
+    HI_UNF_MCE_PLAYCTRL_MODE_E  enCtrlMode;     /**<Mode of Play Control*//**<CNcomment:播放控制模式 */
+    HI_U32                      u32PlayTimeMs;    /**<Play time*//**<CNcomment:播放时间 */
+    HI_U32                      u32PlayCount;   /**<Play count*//**<CNcomment:播放次数 */
+} HI_UNF_MCE_STOPPARM_S;
+
+/**Defines the parameter of fastplay exit*//**CNcomment:瞬播退出参数 */
+typedef struct hiUNF_MCE_EXITPARAM_S
+{
+    HI_HANDLE   hNewWin;          /**<Handle of new window*//**<CNcomment:新窗口句柄 */
+}HI_UNF_MCE_EXITPARAM_S;
+
+/**Defines the parameter of fastplay init*//**CNcomment:瞬播初始化参数 */
+typedef struct hiUNF_MCE_INIT_PARAM_S
+{
+    HI_U32      u32Reserved;
+}HI_UNF_MCE_INIT_PARAM_S;
+
+
+/** @} */  /** <!-- ==== Struct Definition end ==== */
+
+/********************************API declaration********************************/
+/** \addtogroup      MCE */
+/** @{ */  /** <!-- [MCE]*/
+
+/**
+\brief init mce  CNcomment:MCE配置初始化接口 CNend
+\attention \n
+Initializes the media control engine (MCE) before call other MCE API.
+CNcomment:使用MCE接口前首先调用该接口 CNend
+\param[in]  pstInitParam  Pointer to MCE init parameter, reserved. CNcomment:指针类型，指向瞬播初始化参数，保留 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_MCE_DEV_NOT_EXIST      Device is not exist. CNcomment:设备不存在 CNend
+\retval :: HI_ERR_MCE_NOT_DEVICE      Not a device. CNcomment:非设备 CNend
+\retval :: HI_ERR_MCE_DEV_OPEN_ERR      Parameter is invalid. CNcomment:设备打开失败 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_MCE_Init(HI_UNF_MCE_INIT_PARAM_S *pstInitParam);
+
+/**
+\brief deinit mce  CNcomment:MCE配置去初始化接口 CNend
+\attention \n
+Destroys all MCE resources.  CNcomment:完成MCE配置工作最终调用该接口 CNend
+\see \n
+N/A
+*/
+HI_VOID HI_UNF_MCE_DeInit(HI_VOID);
+
+/**
+\brief deinit mce  CNcomment:清空开机画面接口 CNend
+\attention \n
+Destroys the logo.  CNcomment:清空开机画面 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_MCE_DEV_NOT_INIT      Device is not init. CNcomment:设备未初始化 CNend
+\retval :: HI_ERR_MCE_INVALID_OPT      The operation is invalid. CNcomment:无效操作 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_MCE_ClearLogo(HI_VOID);
+
+/**
+\brief  stop fastplay. CNcomment:停止fastplay CNend
+\attention \n
+If enCtrlMode is HI_UNF_MCE_PLAYCTRL_BY_TIME, u32PlayTime is valid; if enCtrlMode is HI_UNF_MCE_PLAYCTRL_BY_COUNT, u32PlayCount is valid
+CNcomment: enCtrlMode选为HI_UNF_MCE_PLAYCTRL_BY_TIME时，u32PlayTime生效, 选为HI_UNF_MCE_PLAYCTRL_BY_COUNT时，u32PlayCount生效 CNend
+\param[in]  pstStopParam  Pointer to fastplay  stop parameter. CNcomment:指针类型，指向瞬播停止参数 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_MCE_DEV_NOT_INIT      Device is not init. CNcomment:设备未初始化 CNend
+\retval :: HI_ERR_MCE_PTR_NULL      Pointer is null. CNcomment:空指针 CNend
+\retval :: HI_ERR_MCE_PARAM_INVALID      Parameter is invalid. CNcomment无效参数 CNend
+\retval :: HI_ERR_MCE_INVALID_OPT      The operation is invalid. CNcomment:无效操作 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_MCE_Stop(HI_UNF_MCE_STOPPARM_S *pstStopParam);
+
+
+/**
+\brief  Exit fastplay and destrory fastplay source CNcomment:退出fastplay,销毁fastplay资源 CNend
+\attention \n
+N/A
+\param[in]  pstExitParam  Pointer to fastplay  exit parameter. CNcomment:指针类型，指向瞬播退出参数 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_MCE_DEV_NOT_INIT      Device is not init. CNcomment:设备未初始化 CNend
+\retval :: HI_ERR_MCE_PARAM_INVALID      Parameter is invalid. CNcomment无效参数 CNend
+\retval :: HI_ERR_MCE_INVALID_OPT      The operation is invalid. CNcomment:无效操作 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_MCE_Exit(HI_UNF_MCE_EXITPARAM_S *pstExitParam);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif
+
+
+
diff -uNr a/include/hi_unf_otp.h b/include/hi_unf_otp.h
--- a/include/hi_unf_otp.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_otp.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,1121 @@
+/******************************************************************************
+
+  Copyright (C), 2016, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_otp.h
+  Version       : Initial Draft
+  Author        : Hisilicon otp software group
+  Created       : 2016/10/9
+  Description   :
+*******************************************************************************/
+/**
+ * \file
+ * \brief Describes the information about the otp module.
+          CNcomment:提供 OTP 模块的相关信息 CNend
+ */
+#ifndef __HI_UNF_OTP_H__
+#define __HI_UNF_OTP_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      OTP */
+/** @{ */  /** <!-- [OTP] */
+
+/** CA VendorID */
+typedef enum {
+    HI_UNF_OTP_VENDORID_COMMON     = 0x00,        /**<No-Advcance CA chipset, Marked with 0*/
+    HI_UNF_OTP_VENDORID_NAGRA      = 0x01,        /**<NAGRA  Chipse, Marked with R*/
+    HI_UNF_OTP_VENDORID_IRDETO     = 0x02,        /**<IRDETO Chipset, Marked with I*/
+    HI_UNF_OTP_VENDORID_CONAX      = 0x03,        /**<CONAX Chipset, Marked with C*/
+    HI_UNF_OTP_VENDORID_NDS        = 0x04,        /**<NDS Chipset*/
+    HI_UNF_OTP_VENDORID_SUMA       = 0x05,        /**<SUMA Chipset, Marked with S*/
+    HI_UNF_OTP_VENDORID_NOVEL      = 0x06,        /**<NOVEL Chipset, Marked with Y*/
+    HI_UNF_OTP_VENDORID_VERIMATRIX = 0x07,        /**<VERIMATRIX Chipset, Marked with M*/
+    HI_UNF_OTP_VENDORID_CTI        = 0x08,        /**<CTI Chipset, Marked with T*/
+    HI_UNF_OTP_VENDORID_SAFEVIEW   = 0x09,        /**<SAFEVIEW CA Chipset*/
+    HI_UNF_OTP_VENDORID_LATENSE    = 0x0a,        /**<LATENSE CA Chipset*/
+    HI_UNF_OTP_VENDORID_SH_TELECOM = 0x0b,        /**<SH_TELECOM CA Chipset*/
+    HI_UNF_OTP_VENDORID_DCAS       = 0x0c,        /**<DCAS CA Chipset*/
+    HI_UNF_OTP_VENDORID_VIACCESS   = 0x0d,        /**<VIACCESS CA Chipset*/
+    HI_UNF_OTP_VENDORID_BUTT
+} HI_UNF_OTP_VENDORID_E;
+
+/** FLASH device types*/
+typedef enum {
+    HI_UNF_OTP_FLASH_TYPE_SPI     = 0,    /**<SPI flash*/
+    HI_UNF_OTP_FLASH_TYPE_NAND,           /**<nand flash*/
+    HI_UNF_OTP_FLASH_TYPE_NOR,            /**<nor flash*/
+    HI_UNF_OTP_FLASH_TYPE_EMMC,           /**<eMMC*/
+    HI_UNF_OTP_FLASH_TYPE_SPI_NAND,       /**<spi_nand flash*/
+    HI_UNF_OTP_FLASH_TYPE_SD,             /**<FSD/TSD flash*/
+    HI_UNF_OTP_FLASH_TYPE_BUTT
+} HI_UNF_OTP_FLASH_TYPE_E;
+
+/** JTAG protect mode*/
+typedef enum {
+    HI_UNF_OTP_JTAG_MODE_OPEN     = 0,
+    HI_UNF_OTP_JTAG_MODE_PROTECT,
+    HI_UNF_OTP_JTAG_MODE_CLOSED,
+    HI_UNF_OTP_JTAG_MODE_BUTT
+} HI_UNF_OTP_JTAG_MODE_E;
+
+/** Rootkey type*/
+typedef enum {
+    HI_UNF_OTP_OEM_ROOTKEY        = 0,
+    HI_UNF_OTP_HDCP_ROOTKEY,
+    HI_UNF_OTP_STB_ROOTKEY,
+    HI_UNF_OTP_SW_ROOTKEY,
+    HI_UNF_OTP_STBTA_ROOTKEY,
+    HI_UNF_OTP_ROOTKEY_BUTT
+} HI_UNF_OTP_ROOTKEY_E;
+
+/** TA MSID(Trusted Application Market Segment ID) */
+typedef enum {
+    HI_UNF_OTP_TA_INDEX_1 = 0,
+    HI_UNF_OTP_TA_INDEX_2,
+    HI_UNF_OTP_TA_INDEX_3,
+    HI_UNF_OTP_TA_INDEX_4,
+    HI_UNF_OTP_TA_INDEX_5,
+    HI_UNF_OTP_TA_INDEX_6,
+    HI_UNF_OTP_TA_INDEX_BUTT
+} HI_UNF_OTP_TA_INDEX_E;
+
+#define OTP_FIELD_VALUE_MAX_LEN 1024
+#define OTP_FIELD_NAME_MAX_LEN 32
+typedef struct {
+    HI_BOOL bBurn;
+    HI_CHAR aszFieldName[OTP_FIELD_NAME_MAX_LEN]; //32
+    HI_U32 u32ValueLen;
+    HI_U8 au8Value[OTP_FIELD_VALUE_MAX_LEN]; //4
+    HI_BOOL bLock;
+} HI_UNF_OTP_BURN_PV_ITEM_S;
+
+/** UART type
+ChipSet: HI3796MV200/HI3716MV450
+UART0:For REE CPU, TEE CPU and LPMCU.
+UART1:Reserved.
+UART2:Reserved.
+UART3:Only for SMCU
+
+ChipSet: HI3716MV430
+UART0:For REE CPU,SMCU.
+UART1:Reserved.
+UART2:SECURE CPU.
+UART3:Reserved
+*/
+typedef enum {
+    HI_UNF_OTP_UART0 = 0,
+    HI_UNF_OTP_UART1,
+    HI_UNF_OTP_UART2,
+    HI_UNF_OTP_UART3,
+    HI_UNF_OTP_BUTT,
+} HI_UNF_OTP_UART_TYPE_E;
+/************************************************/
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+
+/******************************* API declaration *****************************/
+/** \addtogroup      OTP */
+/** @{ */  /** <!-- [OTP] */
+
+#define HI_UNF_OTP_Open(HI_VOID) HI_UNF_OTP_Init(HI_VOID)
+#define HI_UNF_OTP_Close(HI_VOID) HI_UNF_OTP_DeInit(HI_VOID)
+
+/**
+\brief Initializes the otp module. CNcomment:初始化OTP模块 CNend
+\attention \n
+Before calling other functions in this file, you must call this application programming interface (API).
+CNcomment 在调用OTP模块其他接口前，要求首先调用本接口 CNend
+\param N/A
+\retval ::HI_SUCCESS  Success.   CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Failure.       CNcomment:API系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_Init(HI_VOID);
+
+/**
+\brief Deinitializes the otp module. CNcomment:去初始化OTP设备 CNend
+\attention \n
+N/A
+\param N/A                                        CNcomment:无。 CNend
+\retval ::HI_SUCCESS  Success.   CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Failure.       CNcomment:API系统调用失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_DeInit(HI_VOID);
+
+
+/**
+\brief Set customer key, the customer key is used by the customer to encrypt some private data.
+\brief CNcomment:设置customer key，customer key由客户自己定义，且自定义用途。 CNend
+\attention \n
+N/A
+\param[in] pKey:  Customer key to be written to otp.                    CNcomment:Customer key的值，待写入OTP。 CNend
+\param[in] u32KeyLen:  The length of customer key, must be 16bytes.     CNcomment:Customer key的长度，必须为16字节。           CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API系统调用失败。 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_SetCustomerKey(HI_U8 *pKey, HI_U32 u32KeyLen);
+
+/**
+\brief Get customer key, the customer key is used by the customer to encrypt some private data.
+\brief CNcomment:获取customer key。 CNend
+\attention \n
+N/A
+\param[in] pKey:Buffer to store the customer key read from otp.     CNcomment:存储customer key的buffer。 CNend
+\param[in] u32KeyLen:The length of buffer, must be 16bytes.             CNcomment:customer key 的长度，必须为16字节。 CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API系统调用失败。 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetCustomerKey(HI_U8 *pKey, HI_U32 u32KeyLen);
+
+
+/**
+\brief Set stb private data, the stb private data is used by the customer to set some private data.
+\brief CNcomment:设置客户私有数据。 CNend
+\attention \n
+N/A
+\param[in] u32Offset:  The offset to set the private data, should be between 0 and 15.  CNcomment:设置stbprivData的偏移，必须为0~15之间。 CNend
+\param[in] u8Data:  The private data to be set.                         CNcomment:需要设置的值。 CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API系统调用失败。 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_SetStbPrivData(HI_U32 u32Offset, HI_U8 u8Data);
+
+/**
+\brief Get stb private data, the stb private data is used by the customer to set some private data.
+\brief CNcomment:获取客户私有数据。 CNend
+\attention \n
+N/A
+\param[in] u32Offset:  The offset to get the private data, should be between 0 and 15.  CNcomment:获取stbprivData的偏移，必须为0~15之间。 CNend
+\param[out] pu8Data:  The data read from otp.                           CNcomment:获取的值。 CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API系统调用失败。 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetStbPrivData(HI_U32 u32Offset, HI_U8 *pu8Data);
+
+/**
+\brief burn chipset to normal chipset CNcomment:将芯片烧写成普通芯片 CNend
+\attention \n
+N/A
+\retval ::HI_SUCCESS  Success.         CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Failure.         CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP未初始化 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_BurnToNormalChipset(HI_VOID);
+
+/**
+\brief Burn nomal chipset to secure chipset
+\brief CNcomment:将普通芯片烧写成安全芯片。 CNend
+\attention \n
+N/A
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API系统调用失败。 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_BurnToSecureChipset(HI_VOID);
+
+/**
+\brief Get idword lock status CNcomment:获取芯片内部IDWord锁定标志位状态 CNend
+\attention \n
+N/A
+\param[out] pbLockFlag:  Point to IDWord lock status. CNcomment:指针类型，锁状态信息 CNend
+\retval ::HI_SUCCESS  Success.         CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Failure.         CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP未初始化 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetIDWordLockFlag(HI_BOOL *pbLockFlag);
+/**
+\brief  Set hdcp root key to otp, 16bytes length.
+\brief CNcomment:向芯片内部写入hdcp root key，必须为16字节长。 CNend
+\attention \n
+N/A
+\param[in] pu8RootKey:  Set hdcp root key to otp.                   CNcomment设置hdcp root key到OTP。 CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API系统调用失败。 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_WriteHdcpRootKey(HI_U8 *pu8HdcpRootKey, HI_U32 u32Keylen);
+
+/**
+\brief  Get hdcp root key from otp, 16bytes length.
+\brief CNcomment:读取芯片内部设置的hdcp root key，必须为16字节长。 CNend
+\attention \n
+N/A
+\param[out] pu8RootKey:  Point to hdcp root key from otp.               CNcomment:从OTP中获取hdcp root key。 CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API系统调用失败。 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_ReadHdcpRootKey(HI_U8 *pu8HdcpRootKey, HI_U32 u32Keylen);
+
+/**
+\brief  Lock hdcp root key in otp.
+\brief CNcomment:锁定芯片内部设置的hdcp root key。锁定后，hdcp root key将不可被读取。 CNend
+\attention \n
+N/A
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API系统调用失败。 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_LockHdcpRootKey(HI_VOID);
+
+/**
+\brief  Get hdcp root Key lock flag.
+\brief CNcomment:读取芯片内部设置的hdcp root key的锁定标志位。 CNend
+\attention \n
+N/A
+\param[out] pbLockFlag:  Point to hdcp root key lock flag from otp.     CNcomment:指向获取到的标志位。 CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API系统调用失败。 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetHdcpRootKeyLockFlag(HI_BOOL *pbLock);
+
+/**
+\brief Set stb root key to otp.
+\brief CNcomment:向芯片内部设置stb root key。 CNend
+\attention \n
+N/A
+\param[in] u8StbRootKey:  Point to stb root key value.                  CNcomment:Stb root key的值。 CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API系统调用失败。 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_WriteStbRootKey(HI_U8 *pu8StbRootKey, HI_U32 u32Keylen);
+
+/**
+\brief Get stb root key from otp.
+\brief CNcomment:读取芯片内部设置的stb root key。 CNend
+\attention \n
+N/A
+\param[out] pu8RootKey:  Point to stb root key from otp.                CNcomment:只想获取到的Stb root key。 CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API系统调用失败。 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_ReadStbRootKey(HI_U8 *pu8StbRootKey, HI_U32 u32Keylen);
+
+/**
+\brief Lock stb root key in otp.
+\brief CNcomment:锁住芯片内部设置的stb root key。锁定后，stb root key将不可被读取。 CNend
+\attention \n
+N/A
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API系统调用失败。 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_LockStbRootKey(HI_VOID);
+
+/**
+\brief Get stb root Key lock flag
+\brief CNcomment:获取芯片内部stb root key的锁定标志位。 CNend
+\attention \n
+N/A
+\param[out] pbLockFlag:  Point to stb root key lock flag from otp.      CNcomment:指向获取到的标志位。 CNend
+\retval ::HI_SUCCESS  Call this API successful.                     CNcomment:API系统调用成功。 CNend
+\retval ::HI_FAILURE  Call this API fails.                          CNcomment:API系统调用失败。 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetStbRootKeyLockFlag(HI_BOOL *pbLockFlag);
+
+
+/**
+\brief Get CA Vendor ID. CNcomment:获取高安厂商标识 CNend
+\attention \n
+N/A
+\param[out] penVendorID:  CA VendorID. CNcomment:高安厂商标识 CNend
+\retval ::HI_SUCCESS  Success.         CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Failure.         CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP未初始化 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetVendorID(HI_UNF_OTP_VENDORID_E *penVendorID);
+
+/**
+\brief Get the serial number of the STB. CNcomment:获取机顶盒序列号 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pu8StbSn serial number of the STB. CNcomment:指针类型，机顶盒序列号 CNend
+\param[in/out] pu32Len point to the length of serial number of the STB, current is 4. CNcomment:指针类型，机顶盒序列号长度，当前是4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_GetStbSN(HI_U8 *pu8StbSN, HI_U32 *pu32Len);
+
+/**
+\brief Set the serial number of the STB. CNcomment:设置机顶盒序列号 CNend
+\attention \n
+The serial number of the STB is set before delivery. The serial number can be set once only and takes effects after the STB restarts.
+CNcomment:在机顶盒出厂时设置，仅支持设置一次，设置后重启生效 CNend
+\param[in] pu8StbSn point to serial number of the STB. CNcomment:指针类型，机顶盒序列号 CNend
+\param[in] u32Len The length of serial number of the STB, current is 4. CNcomment:指针类型，机顶盒序列号长度，当前是4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_OTP_SETPARAM_AGAIN The parameter has been set already. CNcomment:重复设置 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_SetStbSN(HI_U8 *pu8StbSN, HI_U32 u32Len);
+
+/**
+\brief set the type of flash memory for security startup. CNcomment:指定安全启动的Flash类型 CNend
+\attention N/A
+\param[in]  enFlashType Type of the flash memory for security startup. CNcomment: 启动的Flash类型 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_OTP_SETPARAM_AGAIN The parameter has been set already. CNcomment:重复设置 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_SetBootMode(HI_UNF_OTP_FLASH_TYPE_E enFlashType);
+
+
+/**
+\brief Disables the self-boot. CNcomment:关闭自举功能, boot下不能使用串口/网口升级 CNend
+\attention \n
+The setting is performed before delivery and can be performed once only.
+The self-boot function is enabled by default.
+CNcomment:在机顶盒出厂时选择是否设置，仅支持设置一次，默认使能SelfBoot功能 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_DisableSelfBoot(HI_VOID);
+
+/**
+\brief Get the self-boot status. CNcomment:获取自举状态 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pbDisable Pointer to the self-boot status, true means DISABLE. CNcomment:指针类型，自举状态，true表示禁用自举功能 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_GetSelfBootStat(HI_BOOL *pbDisable);
+
+
+/**
+\brief Force decrypt the BootLoader. CNcomment:设置必须对BootLoader进行解密 CNend
+\attention \n
+The setting is performed before delivery and can be performed once only.
+CNcomment:在机顶盒出厂时选择是否设置，仅支持设置一次
+默认根据Flash中的数据标识，决定BootLoader是否需要解密 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_EnableBootDecrypt(HI_VOID);
+
+
+/**
+\brief Get the BootLoader Decryption status. CNcomment:获取BootLoader解密状态 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pbEnable Point to bootLoader Decryption status. CNcomment:指针类型，Bootloader解密标志位 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_GetBootDecryptStat(HI_BOOL *pbEnable);
+
+
+/**
+\brief Enable the security startup. This API should be used after the API HI_UNF_OTP_SetBootMode.
+CNcomment:设置安全启动使能，该接口必须和HI_UNF_OTP_COMMON_SetBootMode配套使用 CNend
+\attention \n
+None CNcomment:无 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_EnableSCS(HI_VOID);
+
+
+/**
+\brief Get the security startup status function. CNcomment:获取安全启动使能标记 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pbEnable Point to bootLoader SCS status. CNcomment:指针类型，安全启动使能标志位 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_GetSCSStat(HI_BOOL *pbEnable);
+
+
+/**
+\brief Enable the Trust Zone. CNcomment:设置Trust Zone使能CNend
+\attention \n
+None CNcomment:无 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_EnableTrustZone(HI_VOID);
+
+
+/**
+\brief Get the Trust Zone status.
+CNcomment:获取TrustZone使能标记 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pbEnable Point to trust zone status. CNcomment:指针类型，安全区域使能标志位 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_GetTrustZoneStat(HI_BOOL *pbEnable);
+
+
+/**
+\brief Get the market segment identifier. CNcomment:获取市场区域码  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pu8MSID Point to MSID. CNcomment:指针类型，市场区域码 CNend
+\param[in/out] pu32Len Point to MSID length, current is 4. CNcomment:指针类型，市场区域码长度，当前长度是4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_SetMSId
+*/
+HI_S32 HI_UNF_OTP_GetMSID(HI_U8 *pu8MSID, HI_U32 *pu32Len);
+
+
+/**
+\brief Set the market segment identifier CNcomment:设置市场区域码  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] pu8MSID Point to MSID. CNcomment:指针类型，市场区域码 CNend
+\param[in/out] u32MSIdLen MSID length, current is 4. CNcomment:市场区域码长度，当前长度是4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_SetMSID(HI_U8 *pu8MSID, HI_U32 u32Len);
+
+
+/**
+\brief Get the secure os market segment identifier CNcomment:获取安全OS市场区域码  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pu8SOSMSID Point to SOS MSID. CNcomment:指针类型，安全OS市场区域码 CNend
+\param[in/out] pu32Len Point to SOS MSID length, current is 4. CNcomment:指针类型，安全OS市场区域码长度，当前长度是4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_SetMSId
+*/
+HI_S32 HI_UNF_OTP_GetSOSMSID(HI_U8 *pu8SOSMSID, HI_U32 *pu32Len);
+
+
+/**
+\brief Sets the sos market segment identifier CNcomment:设置安全OS市场区域码  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] pu8SOSMSID Point to SOSMSID. CNcomment:指针类型，安全OS市场区域码 CNend
+\param[in] u32Len MSID length, current is 4. CNcomment:指针类型，安全OS市场区域码长度，当前长度是4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_SetSOSMSID(HI_U8 *pu8SOSMSID, HI_U32 u32Len);
+
+/**
+\brief Sets the LongData segment identifier CNcomment:设置LongData  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] u32Offset CNcomment: 地址偏移16字节对齐 CNend
+\param[in] pu8Value CNcomment: otp数据数组  CNend
+\param[in] u32Length CNcomment: otp数据数组长度,不用16字节对齐  CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_SetLongData(HI_CHAR *pFuseName, HI_U32 u32Offset, HI_U8 *pu8Value, HI_U32 u32Length);
+
+/**
+\brief Sets the LongData segment identifier CNcomment:设置LongData  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] u32Offset CNcomment: 地址偏移16字节对齐 CNend
+\param[out] pu8Value CNcomment: 接受otp数据数组  CNend
+\param[in] u32Length CNcomment: otp数据数组长度,不用16字节对齐  CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_GetLongData(HI_CHAR *pFuseName, HI_U32 u32Offset, HI_U8 *pu8Value, HI_U32 u32Length);
+
+/**
+\brief Sets the LongData segment identifier CNcomment:设置LongData的锁  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] u32Offset CNcomment: 地址偏移,16字节对齐 CNend
+\param[in] u32Length CNcomment: otp数据数组长度,16字节对齐  CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_SetLongDataLock(HI_CHAR *pFuseName, HI_U32 u32Offset, HI_U32 u32Length);
+
+/**
+\brief Sets the LongData segment identifier CNcomment:获得LongData的锁 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] u32Offset CNcomment: 地址偏移,16字节对齐 CNend
+\param[in] u32Length CNcomment: otp数据数组长度,16字节对齐  CNend
+\param[out] pu32Lock CNcomment: 返回0全没锁,返回1全锁,返回2部分被锁  CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_GetLongDataLock(HI_CHAR *pFuseName, HI_U32 u32Offset, HI_U32 u32Length,  HI_U32 *pu32Lock);
+
+/**
+\brief disable wake up from ddr. CNcomment:关闭原地唤醒模式 CNend
+\attention \n
+None CNcomment:无 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_DisableDDRWakeup(HI_VOID);
+
+
+/**
+\brief Get wake up from ddr status. CNcomment:获取原地唤醒状态 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pbDisable Point to DDR WakeUp status. CNcomment:指针类型，原地唤醒使能状态 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_GetDDRWakeupStat(HI_BOOL *pbDisable);
+
+/**
+\brief Lock the whole OTP area. CNcomment:锁定整个OTP区域 CNend
+\attention \n
+None CNcomment:无 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_LockGlobalOTP(HI_VOID);
+
+
+
+/**
+\brief Get global otp lock status function. CNcomment:获取OTP锁状态 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out]  pbEnable Point to global OTP lock status. CNcomment:指针类型，OTP锁定状态 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_GetGlobalOTPLockStat(HI_BOOL *pbEnable);
+
+
+/**
+\brief Enable runtime-check. CNcomment:设置运行时校验功能使能 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in]  None
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_EnableRuntimeCheck(HI_VOID);
+
+
+/**
+\brief Get runtime-check status CNcomment:获取运行时校验状态使能标记  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pbEnable Point to runtime Check status. CNcomment:指针类型，运行时校验使能状态 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_GetRuntimeCheckStat(HI_BOOL *pbEnable);
+
+/**
+\brief Disable DDR wakeup check. CNcomment:关闭待机唤醒校验。CNend
+\attention \n
+None CNcomment:无 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_DisableDDRWakeupCheck(HI_VOID);
+
+
+/**
+\brief Get ddr wakeup check status. CNcomment:获取待机唤醒校验使能标记  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pbEnable Point to DDR Wakeup Check status. CNcomment:指针类型，待机唤醒校验使能状态 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_GetDDRWakeupCheckStat(HI_BOOL *pbEnable);
+
+
+/**
+\brief Enable ddr scramble. CNcomment:设置内存加扰功能 CNend
+\attention \n
+None CNcomment:无 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_EnableDDRScramble(HI_VOID);
+
+
+/**
+\brief Get ddr scramble status CNcomment:获取内存加扰使能标记  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pbEnable Pointer to DDR Scramble Stat. CNcomment:指向内存加扰使能标记值的指针 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_GetDDRScrambleStat(HI_BOOL *pbEnable);
+
+
+/**
+\brief Get the mode of the JTAG. CNcomment:获取JTAG调试接口模式 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] penJtagMode Point to the mode of the JTAG. CNcomment:指针类型，JTAG调试接口模式 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_OTP_GetJtagMode(HI_UNF_OTP_JTAG_MODE_E *penJtagMode);
+
+
+/**
+\brief Set the mode of the JTAG. CNcomment:设置JTAG调试接口模式 CNend
+\attention \n
+If the mode of the JTAG interface is set to closed or password-protected, it cannot be opened.
+If the JTAG interface is open, it can be closed or password-protected.
+If the JATG interface is password-protected, it can be closed.
+After being closed, the JATG interface cannot be set to open or password-protected mode.
+CNcomment:不支持设置为打开状态。\n
+打开的时候可以关闭或设置为密钥保护状态。\n
+处于密钥保护状态时可以关闭。\n
+关闭之后不能打开和设置为密钥保护状态 CNend
+\param[in] enJtagMode Mode of the JTAG. CNcomment:JTAG调试接口模式 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_OTP_SetJtagMode(HI_UNF_OTP_JTAG_MODE_E enJtagMode);
+
+
+/**
+\brief Get the mode of the TEE JTAG. CNcomment:获取 TEE JTAG调试接口模式 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] penJtagMode Point to the mode of the JTAG. CNcomment:指针类型，JTAG调试接口模式 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_OTP_GetTEEJtagMode(HI_UNF_OTP_JTAG_MODE_E *penJtagMode);
+
+
+/**
+\brief Set the mode of the TEE JTAG. CNcomment:设置 TEE JTAG调试接口模式 CNend
+\attention \n
+If the mode of the JTAG interface is set to closed or password-protected, it cannot be opened.
+If the JTAG interface is open, it can be closed or password-protected.
+If the JATG interface is password-protected, it can be closed.
+After being closed, the JATG interface cannot be set to open or password-protected mode.
+CNcomment:不支持设置为打开状态。\n
+打开的时候可以关闭或设置为密钥保护状态。\n
+处于密钥保护状态时可以关闭。\n
+关闭之后不能打开和设置为密钥保护状态 CNend
+\param[in] enJtagMode Mode of the JTAG. CNcomment:JTAG调试接口模式 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_JTAG_MODE_E
+*/
+HI_S32 HI_UNF_OTP_SetTEEJtagMode(HI_UNF_OTP_JTAG_MODE_E enJtagMode);
+
+
+/**
+\brief Get the boot version identifier CNcomment:获取boot版本号  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pu8VersionID Point to version ID. CNcomment:指针类型，boot版本号 CNend
+\param[in/out] pu32VersionIdLen Point to the length of version ID, current is 4. CNcomment:指针类型，boot版本号长度，当前为4 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+::HI_UNF_ADVCA_SetMSId
+*/
+HI_S32 HI_UNF_OTP_GetBootVersionID(HI_U8 *pu8VersionID, HI_U32 *pu32Len);
+
+
+/**
+\brief Sets the boot version identifier CNcomment:设置boot版本号  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] pu8VersionID Point to version ID. CNcomment:指针类型，boot版本号 CNend
+\param[in] u32Len The length of version ID, current is 4. CNcomment:指针类型，boot版本号长度，当前为4 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_SetBootVersionID(HI_U8 *pu8VersionID, HI_U32 u32Len);
+
+
+/**
+\brief Set root key to otp. CNcomment:向芯片内部设置根密钥 CNend
+\attention \n
+N/A
+\param[in] enRootkeyType:   Type of rootkey.        CNcomment:根密钥类型 CNend
+\param[in] pu8Rootkey: Point to root key value.     CNcomment:指针类型，根密钥 CNend
+\param[in] u32Len: The length of root key.          CNcomment:根密钥长度 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_SetRootKey(HI_UNF_OTP_ROOTKEY_E enRootkeyType, HI_U8 *pu8Rootkey, HI_U32 u32Len);
+
+
+/**
+\brief Get root key lock status.                    CNcomment:获取OTP锁状态信息 CNend
+\attention \n
+N/A
+\param[in] enRootkeyType: Type of rootkey.          CNcomment:根密钥类型 CNend
+\param[out] pbLock: Point to root key lock status.  CNcomment:指针类型，跟密钥是否被锁 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetRootKeyLockStat(HI_UNF_OTP_ROOTKEY_E enRootkeyType, HI_BOOL *pbLock);
+
+/**
+\brief Set RSA key to otp. CNcomment:向芯片内部设置RSA密钥 CNend
+\attention \n
+N/A
+\param[in] pu8Key: Point to RSA key value.         CNcomment:指针类型，RSA密钥 CNend
+\param[in] u32KeyLen: The length of RSA key.       CNcomment:RSA密钥长度 CNend
+\retval ::HI_SUCCESS Success                                            CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called                        CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized  CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid   CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_SetRSAKey(HI_U8 *pu8Key, HI_U32 u32KeyLen);
+
+/**
+\brief Get rsa lock status. CNcomment:获取RSA lock状态 CNend
+\attention \n
+N/A
+\param[out] pbLock: Rsa lock status.   CNcomment:指针类型，RSA lock状态 CNend
+\retval ::HI_SUCCESS  Success.         CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Failure.         CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP未初始化 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_GetRSALockStat(HI_BOOL *pbLock);
+
+
+/**
+\brief Burn product PV to otp. CNcomment:向芯片内部OTP固定配置 CNend
+\attention \n
+N/A
+\param[in] pstPV: Point to the name of the config table.   CNcomment:指针类型，配置数据表地址 CNend
+\param[in] u32Num: The nember of config table.         CNcomment:配置数据条目数 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_BurnProductPV(HI_UNF_OTP_BURN_PV_ITEM_S *pstPV, HI_U32 u32Num);
+
+/**
+\brief Verify product PV. CNcomment:调试校验PV数据的正确性 CNend
+\attention \n
+N/A
+\param[in] pstPV: Point to the name of the config table.   CNcomment:指针类型，配置数据表地址 CNend
+\param[in] u32Num: The nember of config table.         CNcomment:配置数据条目数 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_VerifyProductPV(HI_UNF_OTP_BURN_PV_ITEM_S *pstPV, HI_U32 u32Num);
+
+/**
+\brief Set TEE enable lock flag. CNcomment:设置TEE使能锁定标记位 CNend
+\attention \n
+None CNcomment:无 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_SetTEECtrlLock(HI_VOID);
+
+/**
+\brief Get TEE enable lock flag. CNcomment: 获取TEE使能锁定标记位 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pbTEEEnL: Point to TEE lock status. CNcomment:指针类型，TEE锁的状态 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_GetTEECtrlLock(HI_BOOL *pbTEEEnL);
+
+/**
+\brief Set the ASC(ACPU Start Code) market segment ID. CNcomment: 设置ASC(ACPU Start Code)市场区域码 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] pu8ASCMSID: Point to ASC market segment ID. CNcomment:指针类型，ASC市场区域码 CNend
+\param[in] u32Len: ASC market segment ID length, current is 4. CNcomment:ASC 市场区域码长度，当前长度是4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_SetASCMSID (HI_U8 *pu8ASCMSID, HI_U32 u32Len);
+
+/**
+\brief Get the ASC(ACPU Start Code) market segment ID. CNcomment:获取ASC(ACPU Start Code)市场区域码 CNend
+\attention \n
+None CNcomment:无 CNend
+\param[out] pu8ASCMSID: Point to ASC market segment identifier. CNcomment:指针类型，ASC市场区域码 CNend
+\param[in] pu32Len: ASC market segment ID length, current is 4. CNcomment:指针类型，ASC市场区域码长度，当前长度是4 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_GetASCMSID(HI_U8 *pu8ASCMSID, HI_U32 *pu32Len);
+
+/**
+\brief Sets TA ID and TA market segment ID. CNcomment:设置TA ID和TA市场区域码  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] enIndex: TA ID and TA market segment ID index. CNcomment:TA ID和TA市场区域码的索引  CNend
+\param[in] u32TAID: TA ID. CNcomment:TA ID CNend
+\param[in] u32MSID: TA market Segment ID. CNcomment:TA市场区域码 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_SetTAIDAndMSID(const HI_UNF_OTP_TA_INDEX_E enIndex, HI_U32 u32TAID, HI_U32 u32MSID);
+
+/**
+\brief Get TA ID and TA market segment ID. CNcomment:获取TA ID和TA市场区域码  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] enIndex: TA ID and TA market segment ID index. CNcomment:TA ID和TA市场区域码的索引  CNend
+\param[out] pu32TAID: TA ID. CNcomment:指针类型，TA ID CNend
+\param[out] pu32MSID: TA market segment ID. CNcomment:指针类型，TA市场区域码 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_GetTAIDAndMSID(const HI_UNF_OTP_TA_INDEX_E enIndex, HI_U32 *pu32TAID, HI_U32 *pu32MSID);
+
+/**
+\brief Disable UART(Universal Asynchronous Receiver/Transmitter) output. CNcomment:关闭UART输出  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] enUartType: UART type. CNcomment:UART类型  CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_OTP_NOT_SUPPORT Not support for this chipset. CNcomment:此芯片不支持 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_DisableUART(HI_UNF_OTP_UART_TYPE_E enUartType);
+/**
+\brief Get UART(Universal Asynchronous Receiver/Transmitter) status. CNcomment:获取UART状态  CNend
+\attention \n
+None CNcomment:无 CNend
+\param[in] enUartType: UART type. CNcomment:UART类型  CNend
+\param[out] pbDisable Pointer to UART Stat. CNcomment:指向UART去使能标记值的指针 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_OTP_NOT_SUPPORT Not support for this chipset. CNcomment:此芯片不支持 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_GetUARTStat(HI_UNF_OTP_UART_TYPE_E enUartType, HI_BOOL *pbDisable);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_OTP_H__ */
diff -uNr a/include/hi_unf_otp_common_ca.h b/include/hi_unf_otp_common_ca.h
--- a/include/hi_unf_otp_common_ca.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_otp_common_ca.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,267 @@
+/******************************************************************************
+
+  Copyright (C), 2017, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_otp_common_ca.h
+  Version       : Initial Draft
+  Author        : Hisilicon otp software group
+  Created       : 2017/1/14
+  Description   :
+*******************************************************************************/
+#ifndef __HI_UNF_OTP_COMMON_CA_H__
+#define __HI_UNF_OTP_COMMON_CA_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      OTP_COMMON_CA */
+/** @{ */  /** <!-- [OTP_COMMON_CA] */
+
+/** advanced CA session serect key class*/
+typedef enum {
+    HI_UNF_OTP_COMMON_CA_KLAD_LEV1 = 0,   /**<session serect key level 1*/
+    HI_UNF_OTP_COMMON_CA_KLAD_LEV2,       /**<session serect key level 2*/
+    HI_UNF_OTP_COMMON_CA_KLAD_LEV3,       /**<session serect key level 3*/
+    HI_UNF_OTP_COMMON_CA_KLAD_LEV4,       /**<session serect key level 4*/
+    HI_UNF_OTP_COMMON_CA_KLAD_LEV5,       /**<session serect key level 5*/
+    HI_UNF_OTP_COMMON_CA_KLAD_LEV_BUTT
+} HI_UNF_OTP_COMMON_CA_KLAD_LEV_E;
+
+
+/** advanced CA session serect key class*/
+typedef enum {
+    HI_UNF_OTP_COMMON_CA_KLAD_TARGET_DEMUX_CIPHER = 0,
+    HI_UNF_OTP_COMMON_CA_KLAD_TARGET_DEMUX,
+    HI_UNF_OTP_COMMON_CA_KLAD_TARGET_CIPHER,
+    HI_UNF_OTP_COMMON_CA_KLAD_TARGET_NULL,
+    HI_UNF_OTP_COMMON_CA_KLAD_TARGET_BUTT
+} HI_UNF_OTP_COMMON_CA_KLAD_TARGET_E;
+
+
+typedef enum {
+    HI_UNF_OTP_COMMON_CA_KLAD_CSA2 = 0,
+    HI_UNF_OTP_COMMON_CA_KLAD_CSA3,
+    HI_UNF_OTP_COMMON_CA_KLAD_SP,
+    HI_UNF_OTP_COMMON_CA_KLAD_MISC,
+    HI_UNF_OTP_COMMON_CA_KLAD_R2R,
+    HI_UNF_OTP_COMMON_CA_KLAD_LP,
+    HI_UNF_OTP_COMMON_CA_KLAD_BUTT
+} HI_UNF_OTP_COMMON_CA_KLAD_TYPE_E;
+
+/** Rootkey type*/
+typedef enum {
+    HI_UNF_OTP_COMMON_CA_CSA2 = 0,
+    HI_UNF_OTP_COMMON_CA_CSA3,
+    HI_UNF_OTP_COMMON_CA_SP,
+    HI_UNF_OTP_COMMON_CA_MISC,
+    HI_UNF_OTP_COMMON_CA_R2R,
+    HI_UNF_OTP_COMMON_CA_LP,
+    HI_UNF_OTP_COMMON_CA_BOOT,
+    HI_UNF_OTP_COMMON_CA_BUTT
+} HI_UNF_OTP_COMMON_CA_ROOTKEY_E;
+
+
+/************************************************/
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      OTP_COMMON_CA */
+/** @{ */  /** <!-- [OTP_COMMON_CA] */
+
+
+/**
+\brief Set the chipID. CNcomment:设置芯片ID CNend
+\attention \n
+\param[in] pu8ChipID point to chip id. CNcomment:指针类型，芯片ID CNend
+\param[in] u32Len The length of ChipID, current is 8. CNcomment:芯片ID长度，8 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_OTP_SETPARAM_AGAIN The parameter has been set already. CNcomment:重复设置 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_SetChipID(HI_U8 *pu8ChipID, HI_U32 u32Len);
+
+
+/**
+\brief Get the chipID. CNcomment:获取芯片ID CNend
+\attention \n
+\param[out] pu8ChipID point to chip id. CNcomment:指针类型，芯片ID CNend
+\param[in/out] pu32Len Point to the length of ChipID, current output length is 8. CNcomment:指针类型，芯片ID长度，当前输出8 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_OTP_SETPARAM_AGAIN The parameter has been set already. CNcomment:重复设置 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_GetChipID(HI_U8 *pu8ChipID, HI_U32 *pu32Len);
+
+
+/**
+\brief Set klad level. CNcomment:设置keylad级数 CNend
+\attention \n
+N/A
+\param[in] enType: klad type.   CNcomment:Klad类型 CNend
+\param[in] enLevel: klad level. CNcomment:Klad级数 CNend
+\retval ::HI_SUCCESS  Success.         CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Failure.         CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP未初始化 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_SetKladLevel(HI_UNF_OTP_COMMON_CA_KLAD_TYPE_E enType, HI_UNF_OTP_COMMON_CA_KLAD_LEV_E enLevel);
+
+
+/**
+\brief Get klad level. CNcomment:设置keylad级数 CNend
+\attention \n
+N/A
+\param[in] enType: klad type.       CNcomment:Klad类型 CNend
+\param[out] penLevel: klad level.   CNcomment:指针类型，Klad级数 CNend
+\retval ::HI_SUCCESS  Success.      CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Failure.      CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP未初始化 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_GetKladLevel(HI_UNF_OTP_COMMON_CA_KLAD_TYPE_E enType, HI_UNF_OTP_COMMON_CA_KLAD_LEV_E *penLevel);
+
+
+/**
+\brief Set klad target. CNcomment:设置keylad目标 CNend
+\attention \n
+N/A
+\param[in] enType: klad type.           CNcomment:Klad类型 CNend
+\param[in] enTarget: target type.       CNcomment:目标类型 CNend
+\retval ::HI_SUCCESS  Success.          CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Failure.          CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP未初始化 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_SetKladTarget(HI_UNF_OTP_COMMON_CA_KLAD_TYPE_E enType, HI_UNF_OTP_COMMON_CA_KLAD_TARGET_E enTarget);
+
+
+/**
+\brief Get klad target control. CNcomment:获取keylad目标 CNend
+\attention \n
+N/A
+\param[in] enType: klad type.           CNcomment:Klad类型 CNend
+\param[out] penTarget: target type.     CNcomment:指针类型，目标类型 CNend
+\retval ::HI_SUCCESS  Success.          CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Failure.          CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP未初始化 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_GetKladTarget(HI_UNF_OTP_COMMON_CA_KLAD_TYPE_E enType, HI_UNF_OTP_COMMON_CA_KLAD_TARGET_E *penTarget);
+
+/**
+\brief Disable keyladder. CNcomment:禁用keyladder CNend
+\attention \n
+N/A
+\param[in] enType: klad type.               CNcomment:Klad类型 CNend
+\retval ::HI_SUCCESS  Success.         CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Failure.         CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP未初始化 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_DisableKlad(HI_UNF_OTP_COMMON_CA_KLAD_TYPE_E enType);
+
+/**
+\brief Get klad disable status. CNcomment:获取klad使能状态 CNend
+\attention \n
+N/A
+\param[in] enType: klad type.               CNcomment:Klad类型 CNend
+\param[out] pbEnable:  Klad enable status.  CNcomment:指针类型，Klad使能状态 CNend
+\retval ::HI_SUCCESS  Success.         CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE  Failure.         CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized. CNcomment:OTP未初始化 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_GetKladStat(HI_UNF_OTP_COMMON_CA_KLAD_TYPE_E enType, HI_BOOL *pbEnable);
+
+
+/**
+\brief Set root key to otp. CNcomment:向芯片内部设置根密钥 CNend
+\attention \n
+N/A
+\param[in] enType: Type of keyladder rootkey.       CNcomment:根密钥类型 CNend
+\param[in] pu8Key: Point to root key value.         CNcomment:指针类型，根密钥 CNend
+\param[in] u32KeyLen: The length of root key.       CNcomment:根密钥长度 CNend
+\retval ::HI_SUCCESS Success                                            CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called                        CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized  CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid   CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_SetRootKey(HI_UNF_OTP_COMMON_CA_ROOTKEY_E enType, HI_U8 *pu8Key, HI_U32 u32KeyLen);
+
+/**
+\brief Get root key lock status.                    CNcomment:获取OTP锁状态信息 CNend
+\attention \n
+N/A
+\param[in] enRootkeyType: Type of rootkey.          CNcomment:根密钥类型 CNend
+\param[out] pbLock: Point to root key lock status.  CNcomment:指针类型，跟密钥是否被锁 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_GetRootKeyLockStat(HI_UNF_OTP_COMMON_CA_ROOTKEY_E enType, HI_BOOL *pbLock);
+
+/**
+\brief Set JTAG key to otp. CNcomment:向芯片内部设置JTAG密钥 CNend
+\attention \n
+N/A
+\param[in] pu8Key: Point to JTAG key value.         CNcomment:指针类型，JTAG密钥 CNend
+\param[in] u32KeyLen: The length of JRAG key.       CNcomment:JTAG密钥长度 CNend
+\retval ::HI_SUCCESS Success                                            CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called                        CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized  CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid   CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_SetJTAGKey(HI_U8 *pu8Key, HI_U32 u32KeyLen);
+
+/**
+\brief Get JTAG key lock status.                    CNcomment:获取JTAG key锁状态信息 CNend
+\attention \n
+N/A
+\param[out] pbLock: Point to JTAG key lock status.  CNcomment:指针类型，JTAG key是否被锁 CNend
+\retval ::HI_SUCCESS Success CNcomment:HI_SUCCESS 成功 CNend
+\retval ::HI_FAILURE This API fails to be called CNcomment:HI_FAILURE  API系统调用失败 CNend
+\retval ::HI_ERR_CA_NOT_INIT The advanced CA module is not initialized CNcomment:HI_ERR_CA_NOT_INIT  CA未初始化 CNend
+\retval ::HI_ERR_CA_INVALID_PARA The input parameter value is invalid CNcomment:HI_ERR_CA_INVALID_PARA  输入参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_OTP_COMMON_CA_GetJTAGKeyLockStat(HI_BOOL *pbLock);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_OTP_COMMON_CA_H__ */
diff -uNr a/include/hi_unf_otp_customize.h b/include/hi_unf_otp_customize.h
--- a/include/hi_unf_otp_customize.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_otp_customize.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,45 @@
+/******************************************************************************
+
+  Copyright (C), 2017, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_otp_verimatrix.h
+  Version       : Initial Draft
+  Author        : Hisilicon otp software group
+  Created       : 2017/1/14
+  Description   :
+*******************************************************************************/
+#ifndef __HI_UNF_OTP_CUSTOMIZE_H__
+#define __HI_UNF_OTP_CUSTOMIZE_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      OTP_CUSTOMIZE */
+/** @{ */  /** <!-- [OTP_CUSTOMIZE] */
+
+
+/************************************************/
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      OTP_CUSTOMIZE */
+/** @{ */  /** <!-- [OTP_CUSTOMIZE] */
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_OTP_CUSTOMIZE_H__ */
diff -uNr a/include/hi_unf_otp_dcas.h b/include/hi_unf_otp_dcas.h
--- a/include/hi_unf_otp_dcas.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_otp_dcas.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,61 @@
+/******************************************************************************
+
+  Copyright (C), 2017, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_otp_dcas.h
+  Version       : Initial Draft
+  Author        : Hisilicon otp software group
+  Created       : 2017/1/14
+  Description   :
+*******************************************************************************/
+#ifndef __HI_UNF_OTP_DCAS_H__
+#define __HI_UNF_OTP_DCAS_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      OTP_DCAS */
+/** @{ */  /** <!-- [OTP_DCAS] */
+
+
+/************************************************/
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      OTP_DCAS */
+/** @{ */  /** <!-- [OTP_DCAS] */
+
+
+/**
+\brief Get the chipID. CNcomment:获取芯片ID CNend
+\attention \n
+\param[out] pu8ChipID point to chip id. CNcomment:指针类型，芯片ID CNend
+\param[in/out] pu32Len Point to the length of ChipID, current output length is 8. CNcomment:指针类型，芯片ID长度，当前输出8 CNend
+\retval ::HI_SUCCESS Success.  CNcomment:API系统调用成功 CNend
+\retval ::HI_FAILURE Failure.  CNcomment:API系统调用失败 CNend
+\retval ::HI_ERR_OTP_NOT_INIT The otp module is not initialized.  CNcomment:OTP未初始化 CNend
+\retval ::HI_ERR_OTP_INVALID_PARA The input parameter is invalid. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_OTP_SETPARAM_AGAIN The parameter has been set already. CNcomment:重复设置 CNend
+\see \n
+None CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_OTP_DCAS_GetChipID(HI_U8 *pu8ChipID, HI_U32 *pu32Len);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_OTP_DCAS_H__ */
diff -uNr a/include/hi_unf_payloadcipher.h b/include/hi_unf_payloadcipher.h
--- a/include/hi_unf_payloadcipher.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_payloadcipher.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,239 @@
+/******************************************************************************
+Copyright (C), 2016, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name   :  hi_unf_payloadcipher.h
+Author        :  Hisilicon multimedia software group
+Created      :  2016/10/21
+Description :
+******************************************************************************/
+#ifndef __HI_UNF_PAYLOADCIPHER_H__
+#define __HI_UNF_PAYLOADCIPHER_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      PayloadCipher */
+/** @{ */  /** <!-- [PayloadCipher] */
+
+/** Max pidFilter Num */
+/**CNcomment:最大PID过滤数*/
+#define HI_UNF_PLCIPHER_PIDFILTER_NUM 16
+
+/** PLCipher algorithm */
+/** CNcomment:PLCipher加密算法*/
+typedef enum
+{
+    HI_UNF_PLCIPHER_ALG_AES_IPTV            = 0x20,  /**<AES IPTV*/
+    HI_UNF_PLCIPHER_ALG_AES_ECB             = 0x21,  /**<AES ECB*/
+    HI_UNF_PLCIPHER_ALG_AES_CBC             = 0x22,  /**<AES CBC*/
+    HI_UNF_PLCIPHER_ALG_AES_CISSA           = 0x23,  /**<AES CISSA*/
+    HI_UNF_PLCIPHER_ALG_BUTT                = 0x84
+}HI_UNF_PLCIPHER_ALG_E;
+
+/** PLCipher Key Type */
+/** CNcomment:PLCipher Key 类型*/
+typedef enum
+{
+    HI_UNF_PLCIPHER_KEY_EVEN       = 0,   /**< Even key type */ /**< CNcomment:偶KEY类型*/
+    HI_UNF_PLCIPHER_KEY_ODD        = 1,   /**< Odd key type */ /**< CNcomment:奇KEY类型*/
+    HI_UNF_PLCIPHER_KEY_BUTT,
+}HI_UNF_PLCIPHER_KEY_EVENODD_E;
+
+/** Structure of the plcipher control information */
+/** CNcomment:加密控制信息结构 */
+typedef struct
+{
+    HI_UNF_PLCIPHER_ALG_E enAlg;                   /**< Algorithm  type*/ /**< CNcomment:算法类型*/
+    HI_BOOL bPIDFilterEn;                          /**< Pid filter switch, default disable, plcipher will encrypt all pids in the ts when the switch is setted with HI_FALSE, and plcipher will just encrypt the assigned pids when the switch is setted with HI_TRUE*/
+                                                   /**< CNcomment:Pid 过滤使用开关，默认关闭，关闭时plcipher将对TS包的所有PID进行加密，而当开启时plcipher仅对指定的PID数据进行加密*/
+    HI_U32  u32PidNum;                             /**< valid when bPIDFilterEn is HI_TRUE, the pid number need to be filted.*/ /**< CNcomment:仅当bPIDFilterEn为HI_TRUE时有效，要过滤的PID个数*/
+    HI_U16  u16PID[HI_UNF_PLCIPHER_PIDFILTER_NUM]; /**< valid when bPIDFilterEn is HI_TRUE, the pid arrays need to be filted.*/ /**< CNcomment:仅当bPIDFilterEn为HI_TRUE时有效，要过滤的PID数组*/
+    HI_UNF_PLCIPHER_KEY_EVENODD_E enEvenOdd;       /**< Even Odd type, for keyladder encrypt even or odd key set */ /**< CNcomment:奇偶类型，针对于keyladder 加密场景时配置奇偶属性*/
+} HI_UNF_PLCIPHER_ATTR_S;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      PayloadCipher */
+/** @{ */  /** <!--[PayloadCipher]*/
+
+/**
+\brief Initializes the PLCIPHER module.CNcomment:初始化PLCIPHER模块。CNend
+\attention \n
+Before using PLCIPHERs, you must call this application programming interface (API).\n
+Before using the ts level encryption function, you need to initialize the PLCIPHER module.\n
+The error code HI_SUCCESS is returned if this API is called repeatedly.
+CNcomment:在进行PLCIPHER相关操作前应该首先调用本接口\n
+在使用TS级加密功能前请提前进行PLCIPHER模块的初始化\n
+重复调用本接口返回成功。CNend
+\param  N/A.CNcomment:无。CNend
+\retval ::HI_SUCCESS Success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\see \n
+N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_PLCIPHER_Init(HI_VOID);
+
+/**
+\brief Deinitializes the PLCIPHER module. CNcomment:去初始化PLCIPHER模块。CNend
+\attention \n
+After this API is called, the PLCIPHER module is stopped, and the PLCIPHER resources used by the process are released.\n
+This API is valid when it is called for the first time. If this API is called repeatedly, the error code HI_SUCCESS is returned.
+CNcomment:调用本接口停止使用PLCIPHER模块，并释放本进程所占用的PLCIPHER资源\n
+本接口第一次调用起作用，重复调用返回成功。CNend
+\param  N/A.CNcomment:无。CNend
+\retval ::HI_SUCCESS Success CNcomment:成功。CNend
+\retval ::HI_FAILURE Calling this API fails. CNcomment:API系统调用失败。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_PLCIPHER_DeInit(HI_VOID);
+
+/**
+\brief Creates a PLCIPHER channel for encryption.CNcomment:创建一路PLCIPHER通道。CNend
+\param[out] phPLCipher     Pointer to the handle of a PLCIPHER.CNcomment:指针类型，输出申请到的PLCIPHER Handle。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_PLCIPHER_NOT_INIT  The PLCIPHER module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_PLCIPHER_FAILED_GETHANDLE There is no more PLCIPHER channel left. CNcomment:没有空闲的PLCIPHER通道。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_PLCIPHER_Create(HI_HANDLE *phPLCipher);
+
+/**
+\brief Destroys an existing PLCIPHER channel.CNcomment:销毁一路PLCIPHER通道。CNend
+\param[in] hPLCipher  Handle of PLCIPHER channel to be destroyed.CNcomment:待销毁的PLCIPHER 通道句柄。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_PLCIPHER_NOT_INIT  The PLCIPHER module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_HANDLE The input PLCIPHER handle is invalid. CNcomment:输入PLCIPHER句柄非法。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_PLCIPHER_Destroy(HI_HANDLE hPLCipher);
+
+/**
+\brief Gets the attributes of a PLCIPHER channel.CNcomment:获取一路PLCIPHER通道的属性。CNend
+\param[in] hPLCipher  Handle of PLCIPHER channel.CNcomment:PLCIPHER 通道句柄。CNend
+\param[out] pstAttr  Pointer to the attributes of a PLCIPHER channel.CNcomment:PLCIPHER通道属性指针。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_PLCIPHER_NOT_INIT  The PLCIPHER module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_HANDLE The input PLCIPHER handle is invalid. CNcomment:输入PLCIPHER句柄非法。CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_PLCIPHER_GetAttr(HI_HANDLE hPLCipher, HI_UNF_PLCIPHER_ATTR_S *pstAttr);
+
+/**
+\brief Sets the attributes of a PLCIPHER channel.CNcomment:设置一路PLCIPHER通道的属性。CNend
+\attention \n
+plcipher will encrypt all pids in the ts when bPIDFilterEn is setted with HI_FALSE,\n
+and plcipher will just encrypt the assigned pids when bPIDFilterEn is setted with HI_TRUE.
+CNcomment:bPIDFilterEn 为HI_FALSE时plcipher将对TS包的所有PID进行加密，而当bPIDFilterEn 为HI_TRUE时plcipher仅对指定的PID数据进行加密。CNend
+\param[in] hPLCipher  Handle of PLCIPHER channel.CNcomment:PLCIPHER 通道句柄。CNend
+\param[in] pstAttr  Pointer to the attributes of a PLCIPHER channel.CNcomment:PLCIPHER通道属性指针。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_PLCIPHER_NOT_INIT  The PLCIPHER module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_HANDLE The input PLCIPHER handle is invalid. CNcomment:输入PLCIPHER句柄非法。CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PARA  The input attribute is invalid.CNcomment:输入属性结构成员非法。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_PLCIPHER_SetAttr(HI_HANDLE hPLCipher, HI_UNF_PLCIPHER_ATTR_S *pstAttr);
+
+/**
+\brief Sets the CW keys of a PLCIPHER channel. This API is used to configure the PLCIPHER channel.CNcomment:配置PLCIPHER通道的密钥，本接口用于配置PLCIPHER通道的密钥。CNend
+\param[in] hPLCipher  Handle of PLCIPHER channel.CNcomment:PLCIPHER 通道句柄。CNend
+\param[in] enKeyEvenOdd  Type of CW key odd or even.CNcomment:待设置密钥的奇偶类型。CNend
+\param[in] pu8Key  Pointer to odd or even CW key buffer to be set, always a 8 or 16 bytes array.CNcomment:指针类型，指向要设置的奇或偶密钥数据，一般8或16个字节的数组。CNend
+\param[in] u32KeyLen  The length of CW key data to be set, always 8 or 16.CNcomment:要设置的密钥数据的长度，一般8或16。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_PLCIPHER_NOT_INIT  The PLCIPHER module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_HANDLE The input PLCIPHER handle is invalid. CNcomment:输入PLCIPHER句柄非法。CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PARA  The input attribute is invalid.CNcomment:输入属性结构成员非法。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_PLCIPHER_SetKey(HI_HANDLE hPLCipher, HI_UNF_PLCIPHER_KEY_EVENODD_E enKeyEvenOdd, const HI_U8 *pu8Key, HI_U32 u32KeyLen);
+
+/**
+\brief Sets the IV vector of a PLCIPHER channel. This API is used to configure the PLCIPHER channel.CNcomment:配置PLCIPHER通道的IV向量，本接口用于配置PLCIPHER通道的IV向量。CNend
+\param[in] hPLCipher  Handle of PLCIPHER channel.CNcomment:PLCIPHER 通道句柄。CNend
+\param[in] enIVEvenOdd  Type of IV vector odd or even.CNcomment:待设置IV向量的奇偶类型。CNend
+\param[in] pu8IV  Pointer to odd or even IV vector buffer to be set, always a 8 or 16 bytes array.CNcomment:指针类型，指向要设置的奇或偶IV向量，一般8或16个字节的数组。CNend
+\param[in] u32IVLen  The length of IV vector to be set, always 8 or 16.CNcomment:要设置的IV向量数据的长度，一般8或16。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_PLCIPHER_NOT_INIT  The PLCIPHER module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_HANDLE The input PLCIPHER handle is invalid. CNcomment:输入PLCIPHER句柄非法。CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PARA  The input attribute is invalid.CNcomment:输入属性结构成员非法。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+
+HI_S32 HI_UNF_PLCIPHER_SetIV(HI_HANDLE hPLCipher, HI_UNF_PLCIPHER_KEY_EVENODD_E enIVEvenOdd, const HI_U8 *pu8IV, HI_U32 u32IVLen);
+
+/**
+\brief Encrypt TS package data in a PLCIPHER channel.CNcomment:使用PLCIPHER通道对TS包数据进行TS级加密。CNend
+\attention \n
+PLCIPHER support pSrcBuf and pDestBuf are the same address, in other word, PLCIPHER support encryption at the same adress.
+CNcomment:PLCIPHER支持pSrcBuf和pDestBuf的值相同，换句话说PLCIPHER支持就地加密。CNend
+\param[in] hPLCipher  Handle of PLCIPHER channel.CNcomment:PLCIPHER 通道句柄。CNend
+\param[in] pSrcBuf  The physical address(must be 16 bytes align) of TS package data to be encrypted.CNcomment:VOID指针类型，待加密TS包数据的起始物理地址，必须16字节对齐。CNend
+\param[in] pDestBuf  The physical address(must be 16 bytes align) of the encryted TS package data.CNcomment:VOID指针类型，加密完成后TS包数据数据的物理地址，必须16字节对齐。CNend
+\param[in] u32Length  The length of TS package data to be encrypted.CNcomment:待加密TS包数据的长度。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_PLCIPHER_NOT_INIT  The PLCIPHER module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_HANDLE The input PLCIPHER handle is invalid. CNcomment:输入PLCIPHER句柄非法。CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PARA  The input attribute is invalid.CNcomment:输入属性结构成员非法。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_PLCIPHER_Encrypt(HI_HANDLE hPLCipher, HI_VOID* pSrcBuf, HI_VOID* pDestBuf, HI_U32 u32Length);
+
+/**
+\brief Decrypt TS package data in a PLCIPHER channel.CNcomment:使用PLCIPHER通道对TS包数据进行TS级解密。CNend
+\attention \n
+PLCIPHER support pSrcBuf and pDestBuf are the same address, in other word, PLCIPHER support decryption at the same adress.
+CNcomment:PLCIPHER支持pSrcBuf和pDestBuf的值相同，换句话说PLCIPHER支持就地解密。CNend
+\param[in] hPLCipher  Handle of PLCIPHER channel.CNcomment:PLCIPHER 通道句柄。CNend
+\param[in] pSrcBuf  The physical address(must be 16 bytes align) of TS package data to be decrypted.CNcomment:VOID指针类型，待解密TS包数据的起始物理地址，必须16字节对齐。CNend
+\param[in] pDestBuf  The physical address(must be 16 bytes align) of the decryted TS package data.CNcomment:VOID指针类型，解密完成后TS包数据数据的物理地址，必须16字节对齐。CNend
+\param[in] u32Length  The length of TS package data to be decrypted.CNcomment:待解密TS包数据的长度。CNend
+\retval ::HI_SUCCESS Success.CNcomment:成功。CNend
+\retval ::HI_FAILURE  Calling this API fails.CNcomment:API系统调用失败。CNend
+\retval ::HI_ERR_PLCIPHER_NOT_INIT  The PLCIPHER module is not initialized.CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_HANDLE The input PLCIPHER handle is invalid. CNcomment:输入PLCIPHER句柄非法。CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_ERR_PLCIPHER_INVALID_PARA  The input attribute is invalid.CNcomment:输入属性结构成员非法。CNend
+\see \n
+ N/A.CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_PLCIPHER_Decrypt(HI_HANDLE hPLCipher, HI_VOID* pSrcBuf, HI_VOID* pDestBuf, HI_U32 u32Length);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_PAYLOADCIPHER_H__ */
diff -uNr a/include/hi_unf_pdm.h b/include/hi_unf_pdm.h
--- a/include/hi_unf_pdm.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_pdm.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,443 @@
+/******************************************************************************
+
+  Copyright (C), 2011-2014, HiSilicon Technologies Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_pdm.h
+  Version       : Initial Draft
+  Author        : HiSilicon multimedia software group
+  Created       : 2011-xx-xx
+  Description   : hi_unf_pdm.h header file
+  History       :
+  1.Date        : 2011/xx/xx
+    Author      :
+    Modification: This file is created.
+
+******************************************************************************/
+
+#ifndef __HI_UNF_PDM_H__
+#define __HI_UNF_PDM_H__
+
+#include "hi_unf_common.h"
+#include "hi_unf_mce.h"
+#include "hi_go_surface.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif  /* End of #ifdef __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      PDM */
+/** @{ */  /** <!-- [PDM] */
+
+/**Defines the base config parameter*/
+/** CNcomment:基本配置参数结构体*/
+typedef struct hiUNF_PDM_DISP_PARAM_S
+{
+    HI_UNF_DISP_E               enSrcDisp;          /**<source display*//**<CNcomment: 同源display枚举*/
+    HI_UNF_ENC_FMT_E            enFormat;           /**<Format*//**<CNcomment: 制式*/
+    HI_U32                      u32Brightness;      /**<Brightness*//**<CNcomment: 亮度*/
+    HI_U32                      u32Contrast;        /**<Contrast*//**<CNcomment: 对比度*/
+    HI_U32                      u32Saturation;      /**<Saturation*//**<CNcomment: 饱和度*/
+    HI_U32                      u32HuePlus;         /**<HuePlus*//**<CNcomment: 色度*/
+    HI_BOOL                     bGammaEnable;       /**<Is Gamma enable*//**<CNcomment: 是否使能gamma*/
+    HI_UNF_DISP_BG_COLOR_S      stBgColor;          /**<Background Color*//**<CNcomment: 背景色*/
+    HI_UNF_DISP_INTF_S          stIntf[HI_UNF_DISP_INTF_TYPE_BUTT];     /**<configuration of display interface*//**<CNcomment: 显示接口配置*/
+    HI_UNF_DISP_TIMING_S        stDispTiming;       /**<Display timeing*//**<CNcomment: 显示时序*/
+
+    HIGO_PF_E                   enPixelFormat;      /**<Pixel format*//**<CNcomment: 像素格式*/
+    HI_UNF_DISP_OFFSET_S        stDispOffset;       /**<Display margin info*//**<CNcomment: 显示空白区域*/
+    HI_U32                      u32VirtScreenWidth; /**<Virtual screen width*//**<CNcomment: 虚拟屏幕宽*/
+    HI_U32                      u32VirtScreenHeight;    /**<Virtual screen height*//**<CNcomment: 虚拟屏幕高*/
+
+    HI_UNF_DISP_ASPECT_RATIO_S  stAspectRatio;      /**<The device aspect ratio*//**<CNcomment: 设备宽高比*/
+    HI_UNF_HDMI_VIDEO_MODE_E    enVidOutMode;       /**<HDMI output vedio mode*//**<CNcomment:HDMI输出视频模式*/
+    HI_UNF_HDMI_DEEP_COLOR_E    enDeepColorMode;    /**<Deep Color output mode*//**<CNcomment:DeepColor输出模式*/
+}HI_UNF_PDM_DISP_PARAM_S;
+
+typedef struct hiUNF_PDM_SOUND_PARAM_S
+{
+    HI_U32                    u32PortNum;  /**<Outport number attached sound*/ /**<CNcomment:绑定到Sound设备的输出端口数*/
+    HI_UNF_SND_OUTPORT_S stOutport[HI_UNF_SND_OUTPUTPORT_MAX];  /**<Outports attached sound*/ /**<CNcomment:绑定到Sound设备的输出端口*/
+    HI_U32               au32Volume[HI_UNF_SND_OUTPUTPORT_MAX];
+}HI_UNF_PDM_SOUND_PARAM_S;
+
+typedef struct hiUNF_PDM_PMOC_PARAM_S
+{
+    HI_U32      u32Flag;  /**<Restore the standby mode, 1: enable; 0: disable>*/ /**<CNcomment:恢复关机前的待机状态，1:使能; 0:不使能*/
+}HI_UNF_PDM_PMOC_PARAM_S;
+
+typedef enum hiUNF_PDM_BASEPARAM_TYPE_E
+{
+    HI_UNF_PDM_BASEPARAM_DISP0 = 0,     /*HI_UNF_PDM_DISP_PARAM_S * */
+    HI_UNF_PDM_BASEPARAM_DISP1,         /*HI_UNF_PDM_DISP_PARAM_S * */
+    HI_UNF_PDM_BASEPARAM_SOUND0 = 10,
+    HI_UNF_PDM_BASEPARAM_SOUND1,
+    HI_UNF_PDM_BASEPARAM_SOUND2,
+    HI_UNF_PDM_BASEPARAM_HDMI = 20,
+    HI_UNF_PDM_BASEPARAM_PMOC = 30,
+
+    HI_UNF_PDM_BASEPARAM_BUTT = 0xFFFF,
+}HI_UNF_PDM_BASEPARAM_TYPE_E;
+
+typedef struct hiUNF_PDM_HDMI_PARAM_S
+{
+    HI_U8    *pu8EDID;
+    HI_U32   *pu32EDIDLen;
+}HI_UNF_PDM_HDMI_PARAM_S;
+
+/** @} */  /*! <!-- Structure Definition end */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      PDM */
+/** @{ */  /** <!-- [PDM] */
+/**
+\brief Obtains the basic configuration information.  CNcomment:获取BASE配置区信息 CNend
+\attention \n
+N/A
+\param[in]  pstBaseParam   Pointer to the basic parameters.  CNcomment:参数指针 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment:空指针 CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:获取Flash分区信息失败 CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:打开Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment:分配内存失败 CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:读取Flash分区失败 CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment:无效操作 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_GetBaseParam(HI_UNF_PDM_BASEPARAM_TYPE_E enType, HI_VOID *pData);
+
+
+/**
+\brief Modifies the basic configuration information.  CNcomment:更新BASE配置区信息 CNend
+\attention \n
+N/A
+\param[in]  pstBaseParam Pointer to the basic parameters.  CNcomment:参数指针 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment:空指针 CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:获取Flash分区信息失败 CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:打开Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment:分配内存失败 CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:读取Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MTD_WRITE      Write flash pation error. CNcomment:写Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MTD_ERASE      Erase flash pation error. CNcomment:擦除Flash分区失败 CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment:无效操作 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_UpdateBaseParam(HI_UNF_PDM_BASEPARAM_TYPE_E enType, HI_VOID *pData);
+
+/**
+\brief Obtains the basic configuration information from the flash memory.
+CNcomment:获取LOGO配置区信息 CNend
+\attention \n
+N/A
+\param[in]  pstLogoParam   Pointer to the logo parameter  CNcomment:参数指针 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment:空指针 CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:获取Flash分区信息失败 CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:打开Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment:分配内存失败 CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:读取Flash分区失败 CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment:无效操作 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_GetLogoParam(HI_UNF_MCE_LOGO_PARAM_S *pstLogoParam);
+
+/**
+\brief Modifies the configuration of the logo parameter.  CNcomment:更新LOGO配置区信息 CNend
+\attention \n
+Update logo parameter, you must invoke this function befor update data of logo
+\CNcomment:更新logo参数，在更新logo内容前必须先调用此函数 CNend
+\param[in]  pstLogoParam   Pointer to the logo parameter  CNcomment:参数指针 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment:空指针 CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:获取Flash分区信息失败 CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:打开Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment:分配内存失败 CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:读取Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MTD_WRITE      Write flash pation error. CNcomment:写Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MTD_ERASE      Erase flash pation error. CNcomment:擦除Flash分区失败 CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment:无效操作 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_UpdateLogoParam(HI_UNF_MCE_LOGO_PARAM_S *pstLogoParam);
+
+
+/**
+\brief Obtains the logo data from the flash memory. CNcomment:获取LOGO内容区信息 CNend
+\attention \n
+N/A
+\param[in]  pu8Content Pointer to the logo data that is written from the flash memory CNcomment:内容buf指针 CNend
+\param[in]  u32Size  Size of the logo data to be written  CNcomment:内容长度 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment:空指针 CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:获取Flash分区信息失败 CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:打开Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment:分配内存失败 CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:读取Flash分区失败 CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment:无效操作 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_GetLogoContent(HI_U8 *pu8Content, HI_U32 u32Size);
+
+
+/**
+\brief Modifies the logo data.  CNcomment:更新LOGO内容区信息 CNend
+\attention \n
+Update data in logo partition, You must invoke HI_UNF_PDM_UpdateLogoParam to update logo parameter before invoke this function
+\CNcomment:更新logo内容，在此函数之前必须先调用HI_UNF_PDM_UpdateLogoParam函数更新logo参数 CNend
+\param[in]  pu8Content   Pointer to the logo data that is read from the flash memory  CNcomment:内容buf指针 CNend
+\param[in]  u32Size   Size of the logo data to be read  CNcomment:内容长度 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment:空指针 CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:获取Flash分区信息失败 CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:打开Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment:分配内存失败 CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:读取Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MTD_WRITE      Write flash pation error. CNcomment:写Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MTD_ERASE      Erase flash pation error. CNcomment:擦除Flash分区失败 CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment:无效操作 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_UpdateLogoContent(HI_U8 *pu8Content, HI_U32 u32Size);
+
+/**
+\brief Obtains the playing configuration information.  CNcomment:获取PLAY配置区信息 CNend
+\attention \n
+N/A
+\param[in]  pstPlayParam   Playing configuration information  CNcomment:参数指针 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment:空指针 CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:获取Flash分区信息失败 CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:打开Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment:分配内存失败 CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:读取Flash分区失败 CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment:无效操作 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_GetPlayParam(HI_UNF_MCE_PLAY_PARAM_S *pstPlayParam);
+
+/**
+\brief   Modifies the playing configuration information.  CNcomment:更新PLAY配置区信息 CNend
+\attention \n
+Update play parameter, you must invoke this function befor update data of play
+\CNcomment:更新play参数，在更新play内容前必须先调用此函数 CNend
+\param[in]  pstPlayParam  Playing configuration information  CNcomment:参数指针 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment:空指针 CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:获取Flash分区信息失败 CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:打开Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment:分配内存失败 CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:读取Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MTD_WRITE      Write flash pation error. CNcomment:写Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MTD_ERASE      Erase flash pation error. CNcomment:擦除Flash分区失败 CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment:无效操作 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_UpdatePlayParam(HI_UNF_MCE_PLAY_PARAM_S *pstPlayParam);
+
+/**
+\brief Obtains the data being playing from the flash memory.  CNcomment:获取PLAY内容区信息 CNend
+\attention \n
+N/A
+\param[in]  pu8Content Pointer to the data that is read from the flash memory  CNcomment:内容buf指针 CNend
+\param[in]  u32Size  Size of the data being played that is read from the flash memory  CNcomment:内容长度 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment:空指针 CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:获取Flash分区信息失败 CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:打开Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment:分配内存失败 CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:读取Flash分区失败 CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment:无效操作 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_GetPlayContent(HI_U8 *pu8Content, HI_U32 u32Size);
+
+
+/**
+\brief Updates the playing data part. CNcomment:更新PLAY内容区信息 CNend
+\attention \n
+Update data in play partition, You must invoke HI_UNF_PDM_UpdatePlayParam to update plat parameter before invoke this function
+\CNcomment:更新play内容，在此函数之前必须先调用HI_UNF_PDM_UpdatePlayParam函数更新play参数 CNend
+\param[in]  pu8Content  Pointer to the data that is written to the flash memroy  CNcomment:内容buf指针 CNend
+\param[in]  u32Size  Size of the data being played  CNcomment:内容长度 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment:空指针 CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:获取Flash分区信息失败 CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:打开Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment:分配内存失败 CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:读取Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MTD_WRITE      Write flash pation error. CNcomment:写Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MTD_ERASE      Erase flash pation error. CNcomment:擦除Flash分区失败 CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment:无效操作 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_UpdatePlayContent(HI_U8 *pu8Content, HI_U32 u32Size);
+
+/**
+\brief Obtains the playing configuration information from backup partition.  CNcomment:从备份分区获取PLAY配置区信息 CNend
+\attention \n
+N/A
+\param[in]  pstPlayParam   Playing configuration information  CNcomment:参数指针 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment:空指针 CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:获取Flash分区信息失败 CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:打开Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment:分配内存失败 CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:读取Flash分区失败 CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment:无效操作 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_GetPlayBakParam(HI_UNF_MCE_PLAY_PARAM_S *pstPlayParam);
+
+/**
+\brief   Modifies the playing configuration information to backup partition.  CNcomment:更新PLAY配置区信息 CNend
+\attention \n
+Update play parameter, you must invoke this function befor update data of play
+\CNcomment:更新play参数，在更新play内容前必须先调用此函数 CNend
+\param[in]  pstPlayParam  Playing configuration information  CNcomment:参数指针 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment:空指针 CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:获取Flash分区信息失败 CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:打开Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment:分配内存失败 CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:读取Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MTD_WRITE      Write flash pation error. CNcomment:写Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MTD_ERASE      Erase flash pation error. CNcomment:擦除Flash分区失败 CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment:无效操作 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_UpdatePlayBakParam(HI_UNF_MCE_PLAY_PARAM_S *pstPlayParam);
+
+/**
+\brief Obtains the playing content from backup partition.  CNcomment:从备份分区获取PLAY内容区信息 CNend
+\attention \n
+N/A
+\param[in]  pu8Content Pointer to the data that is read from the flash memory  CNcomment:内容buf指针 CNend
+\param[in]  u32Size  Size of the data being played that is read from the flash memory  CNcomment:内容长度 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment:空指针 CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:获取Flash分区信息失败 CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:打开Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment:分配内存失败 CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:读取Flash分区失败 CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment:无效操作 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_GetPlayBakContent(HI_U8 *pu8Content, HI_U32 u32Size);
+
+
+/**
+\brief Updates the playing content to backup partition. CNcomment:更新PLAY内容到备份分区 CNend
+\attention \n
+Update data in play partition, You must invoke HI_UNF_PDM_UpdatePlayBakParam to update plat parameter before invoke this function
+\CNcomment:更新play内容，在此函数之前必须先调用HI_UNF_PDM_UpdatePlayBakParam函数更新play参数 CNend
+\param[in]  pu8Content  Pointer to the data that is written to the flash memroy  CNcomment:内容buf指针 CNend
+\param[in]  u32Size  Size of the data being played  CNcomment:内容长度 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment:空指针 CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error. CNcomment:获取Flash分区信息失败 CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:打开Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment:分配内存失败 CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:读取Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MTD_WRITE      Write flash pation error. CNcomment:写Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MTD_ERASE      Erase flash pation error. CNcomment:擦除Flash分区失败 CNend
+\retval :: HI_ERR_PDM_INVALID_OPT      The operation is invalid. CNcomment:无效操作 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_UpdatePlayBakContent(HI_U8 *pu8Content, HI_U32 u32Size);
+
+
+/**
+\brief Obtains the device cfg info.  CNcomment:获取设备相关的配置信息 CNend
+\attention \n
+N/A
+\param[in]  pstrCfgName Pointer to the cfg name,for exampe,
+"MAC" to get the MAC address,"SN" to get the SN number.
+Other configure items can be refered from the Readme file and BurnConfig.ini in HiproInfo tool directory.
+CNcomment:传入的配置项名,例如"MAC"为获取MAC地址,"SN"为获取SN号,
+其他配置项请参考HiproInfo 工具目录的Readme文件及配置文件 CNend
+\param[in]  pstrCfgValue Pointer to the cfg output buffer  CNcomment:输出
+buffer的地址，输出buffer用以保存读取到的值 CNend
+\param[in]  u32Size  Size of the output buffer  CNcomment:输出buffer长度 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment:空指针 CNend
+\retval :: HI_ERR_PDM_GET_MTDINFO_ERR      Get flash pation infomation error.
+CNcomment:获取Flash分区信息失败 CNend
+\retval :: HI_ERR_PDM_MTD_OPEN      Open flash pation error. CNcomment:打开
+Flash分区失败 CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment
+:分配内存失败 CNend
+\retval :: HI_ERR_PDM_MTD_READ      Read flash pation error. CNcomment:读取
+Flash分区失败 CNend
+\retval :: HI_ERR_PDM_GET_DEVINFO_ERR      Parse device info failed. CNcomment
+:解析device info配置失败  CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PDM_GetDeviceInfo(const HI_CHAR * pstrCfgName, HI_CHAR * pstrCfgValue, HI_U32 u32Size);
+
+/**
+\brief Get specific Reserve mem data. when the target buffer less than Reserve mem, this function
+can only get "u32Size" size data or the whole data will be obtained.CNcomment:获取指定保留内存区数据.
+在目的buffer小于保留内存区大小时，函数仅可获取到u32Size大小数据，否则将获取整个保留内存数据 CNend
+\attention \n
+\param[in]  pstrName  Pointer to the reserve memery name  CNcomment:指向保留内存区名字的字符串指针 CNend
+\param[in]  pBuf  Pointer to the out buffer used to get data  CNcomment:指向获取存储数据的输出buffer指针 CNend
+\param[in]  u32Size  The size of the pBuf  CNcomment: pBuf 大小 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment:空指针 CNend
+\retval :: HI_ERR_PDM_PARAM_INVALID para invalid. CNcomment:无效参数 CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment:分配内存失败 CNend
+\retval :: HI_ERR_PDM_INVALID_OPT   The operation is invalid. CNcomment:无效操作 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PDM_GetReserveMemData(const HI_CHAR *pstrName, HI_VOID *pBuf, HI_U32 u32Size);
+
+/**
+\brief Get specific Reserve mem addr .CNcomment:获取指定保留内存内存地址（虚拟地址留作以后拓展）. CNend
+\attention \n
+\param[in]   pstrName  Pointer to the reserve memery name  CNcomment:指向保留内存区名字的字符串指针 CNend
+\param[out]  pPhyAddr  Pointer to Phyaddr  CNcomment:指向保留内存的物理地址 CNend
+\param[out]  pVirAddr  Pointer to Viraddr  CNcomment: 指向保留内存的虚拟地址 CNend
+\param[out]  pBufLen   The size of reserve mem  CNcomment: 保留内存区大小 CNend
+\retval ::HI_SUCCESS       Success. CNcomment:成功 CNend
+\retval :: HI_ERR_PDM_PTR_NULL      Pointer is null. CNcomment:空指针 CNend
+\retval :: HI_ERR_PDM_PARAM_INVALID para invalid. CNcomment:无效参数 CNend
+\retval :: HI_ERR_PDM_MEM_ALLC      Alloc memory error. CNcomment:分配内存失败 CNend
+\retval :: HI_ERR_PDM_INVALID_OPT   The operation is invalid. CNcomment:无效操作 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_PDM_GetReserveMemAddr(const HI_CHAR *pstrName, HI_U64 *pPhyAddr,  HI_U8 *pVirAddr, HI_U32 *pBufLen);
+
+/** @} */  /*! <!-- API declaration end */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif
+
+
+
+
diff -uNr a/include/hi_unf_pmoc.h b/include/hi_unf_pmoc.h
--- a/include/hi_unf_pmoc.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_pmoc.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,479 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+ ******************************************************************************
+File Name     : hi_unf_pmoc.h
+Version       : Initial draft
+Author        : HiSilicon multimedia software group
+Created Date  : 2012-08-24
+Last Modified by:
+Description   : Application programming interfaces (APIs) of the PMOC
+Function List :
+Change History:
+ ******************************************************************************/
+
+#ifndef __HI_UNF_PMOC_H__
+#define __HI_UNF_PMOC_H__
+
+#include "hi_common.h"
+#include "hi_error_mpi.h"
+
+#include "hi_unf_keyled.h"
+
+#include "hi_unf_ir.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      PMOC */
+/** @{ */  /** <!-- [PMOC] */
+
+/**ARM mode*/
+/**CNcomment:ARM所处的模式*/
+typedef enum hiUNF_PMOC_MODE_E
+{
+    HI_UNF_PMOC_MODE_NORMAL = 0,    /**<Normal*/     /**<CNcomment:普通模式 */
+    HI_UNF_PMOC_MODE_SLOW,          /**<Not support*/ /**<CNcomment: 不支持 */
+    HI_UNF_PMOC_MODE_DOZE,          /**<Not support*/ /**<CNcomment: 不支持 */
+    HI_UNF_PMOC_MODE_SLEEP,         /**<Sleep*/      /**<CNcomment:睡眠模式 */
+
+    HI_UNF_PMOC_MODE_BUTT
+}HI_UNF_PMOC_MODE_E;
+
+
+/**standby woken type*/
+/**CNcomment:待机被唤醒的类型 */
+typedef enum hiUNF_PMOC_ACTUAL_WKUP_E
+{
+    HI_UNF_PMOC_WKUP_IR = 0,      /**<Woken by the IR module*/                /**<CNcomment:被IR唤醒 */
+    HI_UNF_PMOC_WKUP_KEYLED,      /**<Woken by the keys on the front panel*/  /**<CNcomment:被前面板KEY唤醒 */
+    HI_UNF_PMOC_WKUP_TIMEOUT,     /**<Woken by the timing interrupt*/         /**<CNcomment:被定时中断唤醒 */
+    HI_UNF_PMOC_WKUP_ETH,         /**<Woken by the ethernet interrupt*/       /**<CNcomment:被网络中断唤醒 */
+    HI_UNF_PMOC_WKUP_USB,         /**<Woken by the USB interrupt*/            /**<CNcomment:被USB鼠标键盘中断唤醒 */
+    HI_UNF_PMOC_WKUP_GPIO,        /**<Woken by the GPIO interrupt*/           /**<CNcomment:被GPIO中断唤醒 */
+    HI_UNF_PMOC_WKUP_CEC,        /**<Woken by the CEC */                     /**<CNcomment:被CEC 唤醒 */
+    HI_UNF_PMOC_WKUP_BUTT
+}HI_UNF_PMOC_ACTUAL_WKUP_E;
+
+typedef enum hiUNF_PMOC_SCENE_E
+{
+    HI_UNF_PMOC_SCENE_STANDARD = 0,  /**<Standard scenario*/                    /**<CNcomment:标准场景 */
+    HI_UNF_PMOC_SCENE_ETH,           /**<Forward scenario over the ETH port */  /**<CNcomment:网口转发场景(不支持) */
+    HI_UNF_PMOC_SCENE_PHONE,         /**<Calling scenario(not support)*/        /**<CNcomment:通话场景(不支持) */
+    HI_UNF_PMOC_SCENE_BUTT
+}HI_UNF_PMOC_SCENE_E;
+
+typedef enum hiUNF_PMOC_ETH_E
+{
+    HI_UNF_PMOC_ETH_0 = 0x01,        /**<The first ETH.*/    /**<CNcomment:第1个网口*/
+    HI_UNF_PMOC_ETH_1 = 0x02,        /**<The second ETH.*/   /**<CNcomment:第2个网口*/
+    HI_UNF_PMOC_ETH_BUTT = 0x04
+}HI_UNF_PMOC_ETH_E;
+
+/**Defines the modules working in smart standby */
+/**CNcomment:智能待机时不下电模块定义 */
+typedef enum hiUNF_PMOC_HOLD_MOD_E
+{
+    HI_UNF_PMOC_HOLD_ETH = 0x0001,   /**<Keep eth working */    /**<CNcomment:网口不下电 */
+    HI_UNF_PMOC_HOLD_WIFI = 0x0002,  /**<Keep WIFI working */   /**<CNcomment:WIFI不下电 */
+    HI_UNF_PMOC_HOLD_USB = 0x0004,   /**<Keep USB working */    /**<CNcomment:USB不下电 */
+    HI_UNF_PMOC_HOLD_TUNER = 0x0008, /**<Keep tuner working */  /**<CNcomment:Tuner不下电 */
+    HI_UNF_PMOC_HOLD_DEMUX = 0x0010, /**<Keep demux working */  /**<CNcomment:Demux不下电 */
+    HI_UNF_PMOC_HOLD_SDIO = 0x0020,  /**<Keep SDIO working */   /**<CNcomment:SD卡不下电 */
+    HI_UNF_PMOC_HOLD_SCI = 0x0040,   /**<Keep SCI working */    /**<CNcomment:SCI不下电 */
+    HI_UNF_PMOC_HOLD_VENC = 0x0080,  /**<Keep VENC working */   /**<CNcomment:VENC不下电 */
+    HI_UNF_PMOC_HOLD_PNG = 0x0100,   /**<Keep PNG working */    /**<CNcomment:PNG不下电 */
+    HI_UNF_PMOC_HOLD_JPGE = 0x0200,  /**<Keep JPGE working */   /**<CNcomment:JPGE不下电 */
+    HI_UNF_PMOC_HOLD_JPEG = 0x0400,  /**<Keep JPEG working */   /**<CNcomment:JPEG不下电 */
+    HI_UNF_PMOC_HOLD_WDG = 0x0800,   /**<Keep WDG working */    /**<CNcomment:WDG不下电 */
+    HI_UNF_PMOC_HOLD_HDMI = 0x1000,  /**<Keep HDMI working */   /**<CNcomment:HDMI不下电 */
+    HI_UNF_PMOC_HOLD_VO = 0x2000,    /**<Keep VO working */     /**<CNcomment:VO不下电 */
+    HI_UNF_PMOC_HOLD_DISP = 0x4000,  /**<Keep DISP working */   /**<CNcomment:DISP不下电 */
+    HI_UNF_PMOC_HOLD_AO = 0x8000,    /**<Keep AO working */     /**<CNcomment:AO不下电 */
+    HI_UNF_PMOC_HOLD_AI = 0x10000,   /**<Keep AI working */     /**<CNcomment:AI不下电 */
+    HI_UNF_PMOC_HOLD_ADSP = 0x20000, /**<Keep ADSP working */   /**<CNcomment:ADSP不下电 */
+    HI_UNF_PMOC_HOLD_CIPHER = 0x40000, /**<Keep CIPHER working */   /**<CNcomment:CIPHER不下电 */
+    HI_UNF_PMOC_HOLD_VDEC = 0x80000, /**<Keep VDEC working */   /**<CNcomment:VDEC不下电 */
+    HI_UNF_PMOC_HOLD_VPSS = 0x100000, /**<Keep VPSS working */  /**<CNcomment:VPSS不下电 */
+    HI_UNF_PMOC_HOLD_OTP = 0x200000, /**<Keep OTP working */    /**<CNcomment:OTP不下电 */
+    HI_UNF_PMOC_HOLD_TDE = 0x400000, /**<Keep TDE working */    /**<CNcomment:TDE不下电 */
+    HI_UNF_PMOC_HOLD_I2C = 0x800000, /**<Keep I2C working */    /**<CNcomment:I2C不下电 */
+    HI_UNF_PMOC_HOLD_GPIO = 0x1000000,/**<Keep GPIO working */  /**<CNcomment:GPIO不下电 */
+    HI_UNF_PMOC_HOLD_BUTT = 0x80000000,
+}HI_UNF_PMOC_HOLD_MOD_E;
+
+#define PMOC_WKUP_IRKEY_MAXNUM 6
+#define FILTER_VALUE_COUNT   (31)
+#define FILTER_COUNT         (4)
+
+typedef struct hiUNF_PMOC_WAKEUP_FRAME
+{
+    HI_U32  u32MaskBytes;  /**<Mask byte, bitN to control u8Value[N]. 0: invalid, 1: valid*/  /**<CNcomment: 对应value的掩码, bitN对应u8Value[N], 0代表无效，1代表有效 */
+    HI_U8   u8Offset;      /**<Filter offset, should be bigger than or equal to 12*/          /**<CNcomment: 过滤器偏移量。需要大于或等于12*/
+    HI_U8   u8Value[FILTER_VALUE_COUNT];   /**<Filter value*/                                 /**<CNcomment: 过滤器的值*/
+    HI_BOOL bFilterValid;  /**<Valid filter, 0: invalid, 1: valid*/                           /**<CNcomment: 过滤器是否有效，0代表无效，1代表有效*/
+}HI_UNF_PMOC_WAKEUP_FRAME_S, *HI_UNF_WAKEUP_FRAME_S_PTR;
+
+typedef struct hiUNF_PMOC_NETWORK
+{
+    HI_UNF_PMOC_ETH_E          enEthIndex;         /**<Eth index, can set several eth once*/  /**<CNcomment: 网口序号，可以同时设置多个网口*/
+    HI_BOOL                    bUcPacketEnable;    /**<Single packet enable*/                 /**<CNcomment: 单播包使能 */
+    HI_BOOL                    bMagicPacketEnable; /**<Magic packet enable*/                  /**<CNcomment: 魔法包使能*/
+    HI_BOOL                    bWakeupFrameEnable; /**<Wakeup Frame enable*/                  /**<CNcomment: 唤醒帧使能 */
+    HI_UNF_PMOC_WAKEUP_FRAME_S stFrame[FILTER_COUNT];         /**<Filter frame*/              /**<CNcomment: 唤醒帧数据 */
+    HI_U32                     u32TimeToDeepStandby;          /**<time to deep standby(unit:s)*/      /**<CNcomment: 定时切换到真待机的时间(单位:秒) */
+}HI_UNF_PMOC_NETWORK_S, *HI_UNF_PMOC_NETWORK_S_PTR;
+
+/**Defines the standby wake-up conditions.*/
+/**CNcomment:待机唤醒的条件定义*/
+typedef struct hiUNF_PMOC_WKUP_S
+{
+    /**<Number of supported values of the power key. For the raw IR remote control, the number cannot be greater than the maximum key value 6 that is defined by the macro definition PMOC_WKUP_IRKEY_MAXNUM. Only one key value is supported for other remote controls.*/
+    /**<CNcomment:能够支持power键值个数，raw 型红外遥控: 不能超越PMOC_WKUP_IRKEY_MAXNUM(<=6)宏定义所述个数键值，其余类型只能支持一个键值*/
+    HI_U32 u32IrPmocNum;
+
+    HI_U32 u32IrPowerKey0[PMOC_WKUP_IRKEY_MAXNUM];  /**<Lower-bit value of the power key on an IR remote control*/  /**<CNcomment:红外遥控 power 低位键值 */
+    HI_U32 u32IrPowerKey1[PMOC_WKUP_IRKEY_MAXNUM];  /**<Upper-bit value of the power key on an IR remote control*/  /**<CNcomment:红外遥控 power 高位键值 */
+    HI_U32 u32IrSymbol[64];                         /**<Value of the raw power key of IR*/                          /**<CNcomment:红外遥控唤醒原始电平对 */
+    HI_U32 u32KeypadPowerKey;                           /**<Value of the power key*/                                    /**<CNcomment:按键 power键值 */
+    HI_U32 u32WakeUpTime;                               /**<Preconfigured Wake-up time, in second*/                     /**<CNcomment:唤醒定时时间 ,单位为 秒  */
+    HI_UNF_PMOC_NETWORK_S stNetwork;                    /**<Network parameter*/                                         /**<CNcomment:网络唤醒参数*/
+    HI_BOOL bMouseKeyboardEnable;                       /**<Mouse and key wake-up enable*/                              /**<CNcomment:鼠标键盘唤醒使能*/
+    HI_BOOL bResumeResetEnable;                         /**<When resume, reset board enable*/                           /**<CNcomment:待机唤醒重启使能*/
+    HI_BOOL bGpioWakeUpEnable;                          /**<Gpio wake up enable */                                      /**<CNcomment:GPIO唤醒使能*/
+    HI_U32 u32GpioNo;                                   /**<Gpio wake up number */                                      /**<CNcomment:GPIO唤醒端口*/
+    HI_BOOL bCECWakeUpEnable;                          /**< CEC wake up enable */                                      /**<CNcomment:CEC唤醒使能*/
+}HI_UNF_PMOC_WKUP_S, *HI_UNF_PMOC_WKUP_S_PTR;
+
+/**Configures the time displayed on the front panel in standby mode.*/
+/**CNcomment:待机时的前面板显示的时间配置 */
+typedef struct hiUNF_PMOC_TIME_S
+{
+    HI_U32 u32Hour;            /**<Hour*/     /**<CNcomment:时 */
+    HI_U32 u32Minute;          /**<Minute*/   /**<CNcomment:分 */
+    HI_U32 u32Second;          /**<Second*/   /**<CNcomment:秒 */
+}HI_UNF_PMOC_TIME_S, *HI_UNF_PMOC_TIME_S_PTR;
+
+/**Configures the display mode of the front panel in standby mode.*/
+/**CNcomment:待机时的前面板显示配置 */
+typedef struct hiUNF_PMOC_STANDBY_MODE_S
+{
+    HI_U32             u32Mode;      /**<0: no display; 1: display the digits represented by u32DispCod; 2: display the time represented by stTimeInfo*/     /**<CNcomment:0 : 无显示 1 : 显示u32DispCode代表的数字; 2 : 显示stTimeInfo代表的时间. */
+    HI_U32             u32DispCode;  /**<Digits displayed on the front panel when u32Mode is 1, value range from 0000 to 9999, do not support hex */         /**<CNcomment:u32Mode为1时，前面板显示的数字，取值范围从0000到9999，不支持16进制数 */
+    HI_UNF_PMOC_TIME_S stTimeInfo; /**<Time displayed on the front panel when u32Mode is 2*/                                                                 /**<CNcomment:u32Mode为2时，前面板显示的时间*/
+}HI_UNF_PMOC_STANDBY_MODE_S, *HI_UNF_PMOC_STANDBY_MODE_S_PTR;
+
+/**Type of the device that is woken in standby mode*/
+/**CNcomment:待机唤醒的设备类型 */
+typedef struct hiUNF_PMOC_DEV_TYPE_S
+{
+    HI_UNF_IR_CODE_E     irtype;    /**<Type of the IR remote control*/  /**<CNcomment:红外遥控类型 */
+    HI_UNF_KEYLED_TYPE_E kltype;  /**<Type of the front panel*/        /**<CNcomment:前面板类型 */
+}HI_UNF_PMOC_DEV_TYPE_S, *HI_UNF_PMOC_DEV_TYPE_S_PTR;
+
+/**Mode of last wakeup*/
+/**CNcomment:上一次触发唤醒的参数*/
+typedef struct hiUNF_PMOC_WAKEUP_MODE_S
+{
+    HI_UNF_PMOC_ACTUAL_WKUP_E  enWakeUpMode; /**<Wake-up mode returned from last wakeup*/     /**<CNcomment:上一次待机唤醒的模式 */
+    HI_U64                     u64IRPowerKey;  /**<The IR power key of last wakeup*/          /**<CNcomment:上一次待机唤醒的遥控器按键值 */
+    HI_U32                     u32GPIONo;     /**<Gpio number of last wakeup*/                /**<CNcomment:上一次待机唤醒的GPIO端口*/
+}HI_UNF_PMOC_WAKEUP_MODE_S, *HI_UNF_PMOC_WAKEUP_MODE_S_PTR;
+
+/** Define of chip temperature */
+/**CNcomment: 芯片温度结构体*/
+typedef struct hiUNF_PMOC_CHIP_TEMP_S
+{
+    HI_S32 s32ChipSensor1Temp; /**<The temperature of chip sensor1 in millidegree Celsius */  /**<CNcomment:芯片第一个传感器的温度，单位毫度 */
+    HI_S32 s32ChipSensor2Temp; /**<Reserved now*/ /**<CNcomment: 当前保留 */
+    HI_S32 s32ChipSensor3Temp; /**<Reserved now*/ /**<CNcomment: 当前保留 */
+    HI_S32 s32ChipSensor4Temp; /**<Reserved now*/ /**<CNcomment: 当前保留 */
+}HI_UNF_PMOC_CHIP_TEMP_S;
+
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      PMOC */
+/** @{ */  /** <!-- [PMOC] */
+/*---- pm ----*/
+
+/**
+\brief Starts the power management on chip (PMoC) device.
+CNcomment:\brief 打开低功耗模块设备。CNend
+
+\attention \n
+The ARM can be switched to another operating mode and then to low-power mode only after the PMoC device is started.\n
+CNcomment:在打开低功耗模块设备后，才能切换ARM的工作模式，继而进入低功耗状态。CNend
+
+\param N/A                                                               CNcomment:无 CNend
+\retval HI_SUCCESS Success                                               CNcomment:成功 CNend
+\retval ::HI_ERR_PMOC_FAILED_INIT  The PMoC device fails to open.        CNcomment:PMoC设备打开失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_Init(HI_VOID);
+
+/**
+\brief Stops the PMoC device.
+CNcomment:\brief 关闭低功耗设备。CNend
+
+\attention \n
+N/A
+\param  N/A                                                             CNcomment:无 CNend
+\retval HI_SUCCESS Success                                              CNcomment:成功 CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.         CNcomment:设备未打开 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_DeInit(HI_VOID);
+
+/**
+\brief Sets the mode to which the ARM is switched and obtains the wake-up mode.
+CNcomment:\brief 设置ARM要切换到的模式，同时获取ARM唤醒的方式。CNend
+
+\attention \n
+If the ARM enters the HI_UNF_PMOC_MODE_SLEEP mode, programs stop running at once. The subsequent code can be executed only after the ARM is woken up.\n
+Before enabling the standby mode, you must start the IR device, key device on the front panel; otherwise, the interrupts of these devices are masked. As a result, the corresponding wake-up modes cannot be achieved.\n
+Do not access DDRs after the ARM enters the sleep mode. Therefore, the functions of display output, video output, DEMUX input, and audio/video decoding must be disabled.\n
+CNcomment:ARM进入HI_UNF_PMOC_MODE_SLEEP真待机模式后程序立即停止运行，必须在唤醒后才能继续执行后面的代码\n
+进入待机模式前，必须打开IR（遥控器）设备、前面板KEY设备，否则对应模块的中断被屏蔽，不能实现该种模式的唤醒\n
+进入真待机时，必须确保不对DDR进行访问。所以必须关闭显示输出、视频输出、DEMUX输入、音视频解码等。CNend
+
+\param[in] enSystemMode   Mode of the ARM in low-power mode                CNcomment: 置低功耗下ARM所处模式。CNend
+
+\param[out]  penWakeUpStatus Wake-up mode returned from the HI_UNF_PMOC_MODE_SLEEP mode. For details about the definition, see the description of ::HI_UNF_PMOC_ACTUAL_WKUP_E. \n
+                         CNcomment: 从HI_UNF_PMOC_MODE_SLEEP状态返回时的唤醒方式。具体含义请参考::HI_UNF_PMOC_ACTUAL_WKUP_E CNend
+\retval HI_SUCCESS Success                                                 CNcomment:成功 CNend
+\retval ::HI_ERR_PMOC_NOT_INIT   The PMoC device is not started.           CNcomment:PMoC设备未打开 CNend
+\retval ::HI_ERR_PMOC_INVALID_PARA  The parameter is invalid.              CNcomment:非法参数 CNend
+\retval ::HI_ERR_PMOC_FAILED_STANDBY  It fails to enter standby            CNcomment:进入待机失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_SwitchSystemMode(HI_UNF_PMOC_MODE_E enSystemMode, HI_UNF_PMOC_ACTUAL_WKUP_E * penWakeUpStatus);
+
+/**
+\brief Sets the wake-up mode of the ARM.
+CNcomment:\brief 设置ARM唤醒方式。CNend
+
+\attention \n
+You can query the original IR code values by referring to IR remote manuals.\n
+In addition, you can query the relationships between the keys and key IDs by checking the connection between hardware and chips.\n
+CNcomment:IR原始码值可以通过遥控器的使用手册得到\n
+按键与键值的对应关系可以通过硬件和芯片的连接关系得到。CNend
+
+\param[in] pstAttr  Wake-up mode of the ARM                             CNcomment:ARM唤醒方式。CNend
+\retval HI_SUCCESS Success                                              CNcomment:成功 CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.         CNcomment:PMoC设备未打开 CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The pointer is invalid.            CNcomment:非法指针 CNend
+\retval ::HI_ERR_PMOC_INVALID_PARA  The parameter is invalid.           CNcomment:非法参数 CNend
+\retval ::HI_ERR_PMOC_FAILED_SETWAKEUPVAL It fails to set power val.    CNcomment:设置唤醒方式失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_SetWakeUpAttr(HI_UNF_PMOC_WKUP_S_PTR pstAttr);
+
+/**
+\brief Gets the wake-up mode of the ARM.
+CNcomment:\brief 获取已设置的ARM唤醒方式。CNend
+
+\attention \n
+
+\param[out] pstAttr  Wake-up mode of the ARM                            CNcomment:ARM唤醒方式。CNend
+\retval HI_SUCCESS Success                                              CNcomment:成功 CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.         CNcomment:PMoC设备未打开 CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The pointer is invalid.            CNcomment:非法指针 CNend
+\retval ::HI_ERR_PMOC_INVALID_PARA  The parameter is invalid.           CNcomment:非法参数 CNend
+\retval ::HI_ERR_PMOC_FAILED_GETWAKEUPVAL It fails to set power val.    CNcomment:获取唤醒方式失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_GetWakeUpAttr(HI_UNF_PMOC_WKUP_S_PTR pstAttr);
+
+
+/**
+\brief set display content when wake up.
+CNcomment:\brief 设置唤醒显示内容。CNend
+
+\attention \n
+content that the panel display when standby
+CNcomment:待机时面板显示指定内容\n CNend
+
+\param[in] pstStandbyMode  display content:time or channel or no display   CNcomment:显示内容:时间 or 频道 or 无显示。CNend
+\retval HI_SUCCESS  success                                                CNcomment:成功 CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.            CNcomment:PMoC设备未打开 CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The pointer is invalid.               CNcomment:非法指针 CNend
+\retval ::HI_ERR_PMOC_INVALID_PARA  The parameter is invalid.              CNcomment:非法参数 CNend
+\retval ::HI_ERR_PMOC_FAILED_STANDBY  It fails to set standby display      CNcomment:设置唤醒内容失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_SetStandbyDispMode(HI_UNF_PMOC_STANDBY_MODE_S_PTR pstStandbyMode);
+
+/**
+\brief Obtains the current system mode.
+CNcomment:\brief 获取系统当前模式。CNend
+
+\attention \n
+This API is abandoned and only used for forward compatible. It always returns normal state.\n
+CNcomment:此接口已废弃，始终返回普通模式，仅为兼容之前版本使用。\n CNend
+
+\param[in] penSystemMode  Mode to be obtained                   CNcomment:需要获取的模式。CNend
+\retval HI_SUCCESS Success                                      CNcomment:成功 CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started. CNcomment:PMoC设备未打开 CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The pointer is invalid.    CNcomment:非法指针 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_ReadSystemMode(HI_UNF_PMOC_MODE_E * penSystemMode);
+
+/**
+\brief Sets the operating scenario.
+CNcomment:\brief 设置工作场景。CNend
+
+\attention \n
+Only the standby scenario is supported currently.\n
+CNcomment:目前仅支持标准待机场景\n CNend
+
+\param[in] eScene  Standby scenario                               CNcomment:待机场景。CNend
+\retval HI_SUCCESS Success                                        CNcomment:成功 CNend
+\retval ::HI_ERR_PMOC_NOT_INIT    The PMoC device is not started. CNcomment:PMoC设备未打开 CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The parameter is invalid.    CNcomment:非法参数 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_SetScene(HI_UNF_PMOC_SCENE_E eScene);
+
+/**
+\brief Sets the types of the devices related to standby such as front panel and IR remote control.
+CNcomment:\brief 设置目前前面板同红外遥控等待机相关设备的类型。CNend
+
+\attention \n
+
+\param[in] pdevType  Standby device that needs to be supported in standby       CNcomment:待机时需要支持的待机设备。CNend
+\retval HI_SUCCESS  success                                                CNcomment:成功 CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.            CNcomment:PMoC设备未打开 CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The pointer is invalid.               CNcomment:非法指针 CNend
+\retval ::HI_ERR_PMOC_INVALID_PARA  The parameter is invalid.              CNcomment:非法参数 CNend
+\retval ::HI_ERR_PMOC_FAILED_STANDBY  It fails to set standby devices.     CNcomment:设置唤醒设备失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_SetDevType(HI_UNF_PMOC_DEV_TYPE_S_PTR pdevType);
+
+/**
+\brief when standby, GPIO pin control 12v and 5v power,relate to hardware.
+CNcomment:\brief 用于待机时,GPIO管脚控制12V0和5V0电源，与硬件相关。CNend
+
+\attention \n
+when standby, the outside power controled by STANDBY_PWROFF pin, the function can be ignored.\n
+when some part of outside power controled by GPIO pin, use this function will decrease standby power.\n
+CNcomment:待机时外围电源全部由管脚STANDBY_PWROFF控制时，不用理会该接口；\n
+当部分外围电源由GPIO管脚去控制时,合理调用该接口用于降低待机功耗。CNend
+
+\param[in] u32GpioNo  GPIO pin index, choose the fifth[40,47] CNcomment:GPIO管脚索引号,取第5组为[40, 47] CNend
+\param[in] bHighOrLow GPIO output control                     CNcomment:GPIO管脚输出控制 CNend
+\retval HI_SUCCESS  success                                                CNcomment:成功 CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.            CNcomment:PMoC设备未打开 CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The pointer is invalid.               CNcomment:非法指针 CNend
+\retval ::HI_ERR_PMOC_INVALID_PARA  The parameter is invalid.              CNcomment:非法参数 CNend
+\retval ::HI_ERR_PMOC_FAILED_STANDBY  It fails to set standby Gpio.        CNcomment:设置待机Gpio管脚失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_SetPwrOffGpio(HI_U32 u32GpioNo, HI_BOOL bHighOrLow);
+
+/**
+\brief Get the period during standby status.
+CNcomment:\brief 获取从待机到唤醒持续的时间。CNend
+
+\attention \n
+
+\param[out] pu32Period  The period of standby. CNcomment:待机持续的时间 CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.            CNcomment:PMoC设备未打开 CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The pointer is invalid.               CNcomment:非法指针 CNend
+\retval ::HI_ERR_PMOC_INVALID_PARA  The parameter is invalid.              CNcomment:非法参数 CNend
+\retval ::HI_ERR_PMOC_FAILED_GETPERIOD  It fails to get standby period.    CNcomment:获取待机时间失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_GetStandbyPeriod(HI_U32 *pu32Period);
+
+
+/**
+\brief Switch to smart standby status.
+CNcomment:\brief 进入智能待机状态。CNend
+
+\attention \n
+
+\param[in] u32HoldModules  The modules working in smart standby .          CNcomment:待机时不下电的模块 CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.            CNcomment:PMoC设备未打开 CNend
+\retval ::HI_SUCCESS            Standby success.                           CNcomment:待机成功 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_EnterSmartStandby(HI_U32 u32HoldModules);
+
+/**
+\brief Quit smart standby status.
+CNcomment:\brief 退出智能待机状态。CNend
+
+\attention \n
+
+\param  N/A                                                                CNcomment:无 CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.            CNcomment:PMoC设备未打开 CNend
+\retval ::HI_SUCCESS            Quit standby success.                      CNcomment:唤醒成功 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_QuitSmartStandby(HI_VOID);
+
+/**
+\brief Get the Parameters of last wake up.
+CNcomment:\brief 获取触发待机唤醒的参数。CNend
+
+\attention \n
+
+\param[out] pstAttr  The Parameters of last waking up. CNcomment:触发上一次唤醒的参数 CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.            CNcomment:PMoC设备未打开 CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The pointer is invalid.               CNcomment:非法指针 CNend
+\retval ::HI_ERR_PMOC_INVALID_PARA  The parameter is invalid.              CNcomment:非法参数 CNend
+\retval ::HI_ERR_PMOC_FAILED_GETWAKEUPMODE  It fails to get parameters of last waking up.    CNcomment:获取唤醒参数失败 CNend
+\retval ::HI_SUCCESS            Getting waking up parameters succeeded.            CNcomment:获取唤醒参数成功 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PMOC_GetWakeUpMode(HI_UNF_PMOC_WAKEUP_MODE_S_PTR pstAttr);
+
+/**
+\brief Get the temperatures of the chip.
+CNcomment:\brief 获取当前芯片的温度。CNend
+
+\attention \n
+
+\param[out] pstChipTemp  The temperatures of the chip sensors. CNcomment:当前芯片中传感器的温度 CNend
+\retval ::HI_ERR_PMOC_NOT_INIT  The PMoC device is not started.            CNcomment:PMoC设备未打开 CNend
+\retval ::HI_ERR_PMOC_INVALID_POINT  The pointer is invalid.               CNcomment:非法指针 CNend
+\retval ::HI_ERR_PMOC_INVALID_PARA  The parameter is invalid.              CNcomment:非法参数 CNend
+\retval ::HI_ERR_PMOC_FAILED_GETTEMPERATURE  It fails to get chip temp.    CNcomment:获取芯片温度失败 CNend
+\see \n
+N/A
+*/
+
+HI_S32 HI_UNF_PMOC_GetChipTemp(HI_UNF_PMOC_CHIP_TEMP_S *pstChipTemp);
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_PMOC_H__ */
diff -uNr a/include/hi_unf_pq.h b/include/hi_unf_pq.h
--- a/include/hi_unf_pq.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_pq.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,636 @@
+/******************************************************************************
+
+  Copyright (C), 2012-2014, Hisilicon Tech. Co., Ltd.
+
+******************************************************************************
+  File Name     : hi_unf_pq.h
+  Version       : Initial Draft
+  Author        : sdk
+  Created       : 2014/4/23
+  Description   :
+
+******************************************************************************/
+
+#ifndef __HI_UNF_PQ_H__
+#define __HI_UNF_PQ_H__
+
+#include "hi_type.h"
+#include "hi_unf_disp.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+/******************************************************************************/
+
+
+/********************************Struct Definition********************************/
+/** \addtogroup      PQ */
+/** @{ */  /** <!-- [PQ] */
+
+/**<Image Mode Set Different Parameters Under Different Mode*/
+/**<CNcomment:图像模式选择；在不同的模式下配置不同的参数 CNend*/
+typedef enum hiUNF_PQ_IMAGE_MODE_E
+{
+    HI_UNF_OPTION_MODE_NATURAL    = 0,  /**<Natural mode*/ /**<CNcomment:自然模式 CNend*/
+    HI_UNF_OPTION_MODE_PERSON     = 1,  /**<Person mode*/ /**<CNcomment:人物模式 CNend*/
+    HI_UNF_OPTION_MODE_FILM       = 2,  /**<Film mode*/ /**<CNcomment:电影模式 CNend*/
+    HI_UNF_OPTION_MODE_UD         = 3,  /**<User Defined mode*/ /**<CNcomment:用户自定义模式 CNend*/
+    HI_UNF_OPTION_MODE_NORMAL     = 4,  /**<Normal mode*/ /**<CNcomment:正常模式 CNend*/
+    HI_UNF_OPTION_MODE_VIDEOPHONE = 5,  /**<Video Phone mode*/ /**<CNcomment:可视电话模式 CNend*/
+    HI_UNF_OPTION_MODE_GALLERY    = 6,  /**<Gallery mode*/ /**<CNcomment:图库模式 CNend*/
+
+    HI_UNF_OPTION_MODE_BUTT,
+} HI_UNF_PQ_IMAGE_MODE_E;
+
+typedef enum hiUNF_PQ_HDR_MODE_E
+{
+    HI_UNF_PQ_HDR_PROCESS_SCENE_HDR10_TO_SDR   = 0,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_HDR10_TO_HDR10 = 1,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_HDR10_TO_HLG   = 2,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_HLG_TO_SDR     = 3,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_HLG_TO_HDR10   = 4,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_HLG_TO_HLG     = 5,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_SLF_TO_SDR     = 6,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_SLF_TO_HDR10   = 7,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_SLF_TO_HLG     = 8,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_SDR_TO_SDR     = 9,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_SDR_TO_HDR10   = 10,
+    HI_UNF_PQ_HDR_PROCESS_SCENE_SDR_TO_HLG     = 11,
+
+    HI_UNF_PQ_HDR_PROCESS_SCENE_BUTT,
+} HI_UNF_PQ_HDR_PROCESS_SCENE_E;
+
+/******************************************************************************/
+typedef struct hiUNF_PQ_SETHDROFFSET_S
+{
+    HI_UNF_PQ_HDR_PROCESS_SCENE_E enHdrProcessScene;
+    HI_U32       u32HdrMode;
+    HI_U32       u32Bright;
+    HI_U32       u32Contrast;
+    HI_U32       u32Satu;
+    HI_U32       u32Hue;
+    HI_U32       u32R;
+    HI_U32       u32G;
+    HI_U32       u32B;
+    HI_U32       u32darkCv;
+    HI_U32       u32brightCv;
+    HI_U32       u32ACCdark;
+    HI_U32       u32ACCbrigt;
+} HI_UNF_PQ_SETHDROFFSET_S;
+/******************************************************************************/
+
+/**<Demo Mode*/
+/**<CNcomment:卖场模式 CNend*/
+typedef enum hiUNF_PQ_DEMO_E
+{
+    HI_UNF_PQ_DEMO_SHARPNESS = 0,   /**<Sharpen */ /**<CNcomment:锐化 CNend*/
+    HI_UNF_PQ_DEMO_DCI,             /**<Dynamic Contrast Improvement */ /**<CNcomment:自动对比度调节 CNend*/
+    HI_UNF_PQ_DEMO_COLOR,           /**<Automatic Color Management */ /**<CNcomment:智能颜色调节 CNend*/
+    HI_UNF_PQ_DEMO_SR,              /**<Super Resolution */ /**<CNcomment:超级分辨率 CNend*/
+    HI_UNF_PQ_DEMO_TNR,             /**<Time Noise Reduction */ /**<CNcomment:时域噪声消除 CNend*/
+    HI_UNF_PQ_DEMO_DEI,             /**<De interlace */ /**<CNcomment:去隔行 CNend*/
+    HI_UNF_PQ_DEMO_DBM,             /**<Digital Noise Reduction; include DB DM DR DS*/ /**<CNcomment:数字噪声消除 CNend*/
+    HI_UNF_PQ_DEMO_SNR,             /**<Space Noise Reduction */ /**<CNcomment:空域噪声消除 CNend*/
+    HI_UNF_PQ_DEMO_ALL,             /**<All Algorithm */ /**<CNcomment:全部算法 CNend*/
+
+    HI_UNF_PQ_DEMO_BUTT
+} HI_UNF_PQ_DEMO_E;
+
+/**<Demo Display Mode*/
+/**<CNcomment:卖场显示模式 CNend*/
+typedef enum hiUNF_PQ_DEMO_MODE_E
+{
+    HI_UNF_PQ_DEMO_MODE_FIXED_R,    /**<Fixed Enable Right */ /**<CNcomment:固定右侧使能 CNend*/
+    HI_UNF_PQ_DEMO_MODE_FIXED_L,    /**<Fixed Enable Left */ /**<CNcomment:固定左侧使能 CNend*/
+    HI_UNF_PQ_DEMO_MODE_SCROLL_R,   /**<Enable Right; and Roll from Left to right */ /**<CNcomment:右侧使能；从左向右移动 CNend*/
+    HI_UNF_PQ_DEMO_MODE_SCROLL_L,   /**<Enable Left; and Roll from Left to right */ /**<CNcomment:左侧使能；从左向右移动 CNend*/
+
+    HI_UNF_PQ_DEMO_MODE_BUTT
+} HI_UNF_PQ_DEMO_MODE_E;
+
+/**<Algorithm Moudle*/
+/**<CNcomment:算法模块 CNend*/
+typedef enum hiUNF_PQ_MODULE_E
+{
+    HI_UNF_PQ_MODULE_SHARPNESS = 0, /**<Sharpen */ /**<CNcomment:锐化 CNend*/
+    HI_UNF_PQ_MODULE_DCI,           /**<Dynamic Contrast Improvement */ /**<CNcomment:自动对比度调节 CNend*/
+    HI_UNF_PQ_MODULE_COLOR,         /**<Automatic Color Management */ /**<CNcomment:智能颜色调节 CNend*/
+    HI_UNF_PQ_MODULE_SR,            /**<Super Resolution */ /**<CNcomment:超级分辨率 CNend*/
+    HI_UNF_PQ_MODULE_TNR,           /**<Time Noise Reduction */ /**<CNcomment:时域噪声消除 CNend*/
+    HI_UNF_PQ_MODULE_DBM,           /**<Digital Noise Reduction; include DB DM DR DS*/ /**<CNcomment:数字噪声消除 CNend*/
+    HI_UNF_PQ_MODULE_SNR,           /**<Space Noise Reduction */ /**<CNcomment:空域噪声消除 CNend*/
+    HI_UNF_PQ_MODULE_MCDI,          /**<Motion Compensation DeInterlace */ /**<CNcomment:基于运动补偿的去隔行算法 CNend*/
+
+    HI_UNF_PQ_MODULE_ALL,           /**<All Algorithm */ /**<CNcomment:全部算法 CNend*/
+
+    HI_UNF_PQ_MODULE_BUTT
+} HI_UNF_PQ_MODULE_E;
+
+/**<Spuer Resolution Demo Mode*/
+/**<CNcomment:SR演示模式 CNend*/
+typedef enum hiUNF_PQ_SR_DEMO_E
+{
+    HI_UNF_PQ_SR_DISABLE  = 0, /**<Close SR */ /**<CNcomment:关SR,只开缩放 CNend*/
+    HI_UNF_PQ_SR_ENABLE_R,     /**<SR open at right hand side */ /**<CNcomment:右边SR CNend*/
+    HI_UNF_PQ_SR_ENABLE_L,     /**<SR open at left hand side */ /**<CNcomment:左边SR CNend*/
+    HI_UNF_PQ_SR_ENABLE_A,     /**<SR open all screen */ /**<CNcomment:全屏SR CNend*/
+
+    HI_UNF_PQ_SR_DEMO_BUTT
+} HI_UNF_PQ_SR_DEMO_E;
+
+/**<Custom Colors Parameter*/
+/**<CNcomment:自定义颜色参数 CNend*/
+typedef struct  hiUNF_PQ_SIX_BASE_S
+{
+    HI_U32  u32Red;       /**<Red; Range:0~100 */ /**<CNcomment:红色；范围:0~100 CNend*/
+    HI_U32  u32Green;     /**<Green; Range:0~100 */ /**<CNcomment:红色；范围:0~100 CNend*/
+    HI_U32  u32Blue;      /**<Blue; Range:0~100 */ /**<CNcomment:红色；范围:0~100 CNend*/
+
+    HI_U32  u32Cyan;      /**<Cyan; Range:0~100 */ /**<CNcomment:青色；范围:0~100 CNend*/
+    HI_U32  u32Magenta;   /**<Magenta; Range:0~100 */ /**<CNcomment:品红；范围:0~100 CNend*/
+    HI_U32  u32Yellow;    /**<Yellow; Range:0~100 */ /**<CNcomment:黄色；范围:0~100 CNend*/
+} HI_UNF_PQ_SIX_BASE_S;
+
+/**<Custom Color Temperature Parameter*/
+/**<CNcomment:自定义色温参数 CNend*/
+typedef struct  hiUNF_PQ_COLORTEMPERATURE_S
+{
+    HI_U32  u32Red;       /**<Red; Range:0~100 */ /**<CNcomment:红色；范围:0~100 CNend*/
+    HI_U32  u32Green;     /**<Green; Range:0~100 */ /**<CNcomment:绿色；范围:0~100 CNend*/
+    HI_U32  u32Blue;      /**<Blue; Range:0~100 */ /**<CNcomment:蓝色；范围:0~100 CNend*/
+} HI_UNF_PQ_COLORTEMPERATURE_S;
+
+/**<Portrait Colors Parameter*/
+/**<CNcomment:人像模式参数 CNend*/
+typedef enum hiUNF_PQ_FLESHTONE_E
+{
+    HI_UNF_PQ_FLESHTONE_GAIN_OFF  = 0,   /**<Portrait Model Strength Off */ /**<CNcomment:人像模式关闭 CNend*/
+    HI_UNF_PQ_FLESHTONE_GAIN_LOW  = 1,   /**<Portrait Model Strength Low */ /**<CNcomment:人像模式强度低 CNend*/
+    HI_UNF_PQ_FLESHTONE_GAIN_MID  = 2,   /**<Portrait Model Strength Middle */ /**<CNcomment:人像模式强度中 CNend*/
+    HI_UNF_PQ_FLESHTONE_GAIN_HIGH = 3,   /**<Portrait Model Strength High */ /**<CNcomment:人像模式强度高 CNend*/
+
+    HI_UNF_PQ_FLESHTONE_GAIN_BUTT
+}  HI_UNF_PQ_FLESHTONE_E;
+
+/**<Color Optimization Model*/
+/**<CNcomment:颜色增强类型 CNend*/
+typedef enum hiUNF_PQ_COLOR_SPEC_MODE_E
+{
+    HI_UNF_PQ_COLOR_MODE_RECOMMEND  = 0, /**<Optimization Model */ /**<CNcomment:最优模式 CNend*/
+    HI_UNF_PQ_COLOR_MODE_BLUE       = 1, /**<Blue Model */ /**<CNcomment:蓝色增强模式 CNend*/
+    HI_UNF_PQ_COLOR_MODE_GREEN      = 2, /**<Green Model */ /**<CNcomment:绿色增强模式 CNend*/
+    HI_UNF_PQ_COLOR_MODE_BG         = 3, /**<Cyan Model */ /**<CNcomment:蓝绿增强模式 CNend*/
+    HI_UNF_PQ_COLOR_MODE_ORIGINAL   = 4, /**<Original Model */ /**<CNcomment:原始颜色模式 CNend*/
+
+    HI_UNF_PQ_COLOR_MODE_BUTT
+} HI_UNF_PQ_COLOR_SPEC_MODE_E;
+
+/**<Intelligent Colors Form*/
+/**<CNcomment:智能颜色类型 CNend*/
+typedef enum hiUNF_PQ_COLOR_ENHANCE_E
+{
+    HI_UNF_PQ_COLOR_ENHANCE_FLESHTONE       = 0,  /**<Portrait Model */ /**<CNcomment:人像模式 CNend*/
+    HI_UNF_PQ_COLOR_ENHANCE_SIX_BASE        = 1,  /**<Custom Model */ /**<CNcomment:自定义颜色 CNend*/
+    HI_UNF_PQ_COLOR_ENHANCE_SPEC_COLOR_MODE = 2,  /**<Special Color Model */ /**<CNcomment:颜色增强模式 CNend*/
+
+    HI_UNF_PQ_COLOR_ENHANCE_BUTT
+} HI_UNF_PQ_COLOR_ENHANCE_E;
+
+/**<Intelligent Colors Parameter*/
+/**<CNcomment:智能颜色参数 CNend*/
+typedef struct  hiUNF_PQ_COLOR_ENHANCE_S
+{
+    HI_UNF_PQ_COLOR_ENHANCE_E  enColorEnhanceType;  /**<Color Model */ /**<CNcomment增强类型 CNend*/
+    union
+    {
+        HI_UNF_PQ_FLESHTONE_E        enFleshtone;   /**<Portrait Model Parameter */ /**<CNcomment人像模式参数 CNend*/
+        HI_UNF_PQ_SIX_BASE_S         stSixBase;     /**<Custom Model Parameter */ /**<CNcomment自定义颜色参数 CNend*/
+        HI_UNF_PQ_COLOR_SPEC_MODE_E  enColorMode;   /**<Special Color Model Parameter */ /**<CNcomment颜色增强参数 CNend*/
+    } unColorGain;
+} HI_UNF_PQ_COLOR_ENHANCE_S;
+
+typedef enum hiUNF_PQ_IMAGE_TYPE_E
+{
+    HI_UNF_PQ_IMAGE_GRAPH = 0,          /**<graph image */ /**<CNcomment: 图形图像 CNend*/
+    HI_UNF_PQ_IMAGE_VIDEO,              /**<video image */ /**<CNcomment: 视频图像 CNend*/
+
+    HI_UNF_PQ_IMAGE_BUTT
+} HI_UNF_PQ_IMAGE_TYPE_E;
+
+typedef struct hiUNF_PQ_IMAGE_PARAM_S
+{
+    HI_U32       u32Brightness;         /**<Brightness; Range:0~100; recommended: 50 */ /**<CNcomment:亮度；范围: 0~100；推荐值: 50 CNend*/
+    HI_U32       u32Contrast;           /**<Contrast; Range:0~100; recommended: 50 */ /**<CNcomment:对比度；范围: 0~100；推荐值: 50 CNend*/
+    HI_U32       u32Hue;                /**<HuePlus; Range:0~100; recommended: 50 */ /**<CNcomment:色调；范围: 0~100；推荐值: 50 CNend*/
+    HI_U32       u32Saturation;         /**<Saturation; Range:0~100; recommended: 50 */ /**<CNcomment:饱和度；范围: 0~100；推荐值: 50 CNend*/
+} HI_UNF_PQ_IMAGE_PARAM_S;
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      PQ */
+/** @{ */  /** <!-- [PQ] */
+
+/******************************************************************************/
+/**
+ \brief Set PQ mode . CNcomment: 设置图像模式 CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment: 目标通道号 CNend
+ \param[in] enImageMode Destination DISP channel PQ mode CNcomment: 目标通道图像模式 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_PQ_SetImageMode(HI_UNF_DISP_E enChan, HI_UNF_PQ_IMAGE_MODE_E enImageMode);
+
+
+/**
+ \brief Get PQ mode . CNcomment: 获取图像模式 CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment: 目标通道号 CNend
+ \param[out] penImageMode  pointer of image mode CNcomment: 指针类型，指向图像模式 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_PQ_GetImageMode(HI_UNF_DISP_E enChan, HI_UNF_PQ_IMAGE_MODE_E *penImageMode);
+
+/**
+ \brief Set the default PQ configuration for video parameter test.  CNcomment: 为入网指标测试设置PQ 的默认值CNend
+ \attention \n
+ \param[in] N/A CNcomment: 无 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \see \n
+ N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_PQ_SetDefaultParam(HI_VOID);
+
+
+/**
+ \brief Initializes the picture quality unit (PQU). CNcomment: 初始化PQ CNend
+ \attention \n
+Before calling the PQU, you must call this application programming interface (API).
+CNcomment: 调用PQ模块要求首先调用该接口 CNend
+ \param[in] N/A CNcomment: 无 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \retval ::HI_ERR_PQ_DEV_NOT_EXIST No PQ device exists. CNcomment: 设备不存在 CNend
+ \retval ::HI_ERR_PQ_NOT_DEV_FILE The file is not a PQ file. CNcomment: 文件非设备 CNend
+ \retval ::HI_ERR_PQ_DEV_OPENED The PQ device fails to be started. CNcomment: 打开设备失败 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_PQ_Init(HI_VOID);
+
+
+/**
+ \brief Deinitializes the PQU. CNcomment: 去初始化PQ CNend
+ \attention \n
+ \param[in] N/A CNcomment: 无 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_PQ_DeInit(HI_VOID);
+
+
+/**
+ \brief Get Brightness. CNcomment:获取亮度 CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment: 目标通道号 CNend
+ \param[out] pu32Brightness   CNcomment: 亮度值；有效范围: 0~100 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetBrightness(HI_UNF_DISP_E enChan, HI_U32 *pu32Brightness);
+
+
+/**
+ \brief Set Brightness. CNcomment:设置亮度 CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment: 目标通道号 CNend
+ \param[in] u32Brightness; Range:0~100 CNcomment: 亮度值；有效范围: 0~100 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetBrightness(HI_UNF_DISP_E enChan, HI_U32 u32Brightness);
+
+
+/**
+ \brief Get Contrast. CNcomment:获取对比度 CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel  CNcomment: 目标通道号 CNend
+ \param[out] pu32Contrast; Range:0~100  CNcomment: 对比度；有效范围: 0~100 CNend
+ \retval ::HI_SUCCESS Success  CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetContrast(HI_UNF_DISP_E enChan, HI_U32 *pu32Contrast);
+
+
+/**
+ \brief Set Contrast. CNcomment:设置对比度 CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment: 目标通道号 CNend
+ \param[in] u32Contrast; Range:0~100  CNcomment: 对比度；有效范围: 0~100 CNend
+ \retval ::HI_SUCCESS Success  CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetContrast(HI_UNF_DISP_E enChan, HI_U32 u32Contrast);
+
+
+/**
+ \brief Get Saturation. CNcomment:获取饱和度 CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment: 目标通道号 CNend
+ \param[out] pu32Saturation; Range:0~100  CNcomment: 饱和度；有效范围: 0~100 CNend
+ \retval ::HI_SUCCESS Success  CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetSaturation(HI_UNF_DISP_E enChan, HI_U32 *pu32Saturation);
+
+
+/**
+ \brief Set Saturation. CNcomment:设置饱和度 CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment: 目标通道号 CNend
+ \param[in] u32Saturation; Range:0~100  CNcomment: 饱和度；有效范围: 0~100 CNend
+ \retval ::HI_SUCCESS Success  CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetSaturation(HI_UNF_DISP_E enChan, HI_U32 u32Saturation);
+
+
+/**
+ \brief Get Hue. CNcomment:获取色调 CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment: 目标通道号 CNend
+ \param[out] pu32Hue; Range:0~100  CNcomment: 色调；有效范围: 0~100 CNend
+ \retval ::HI_SUCCESS Success  CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetHue(HI_UNF_DISP_E enChan, HI_U32 *pu32Hue);
+
+
+/**
+ \brief Set Hue. CNcomment:设置色调 CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment: 目标通道号 CNend
+ \param[in] u32Hue; Range:0~100  CNcomment: 色调；有效范围: 0~100 CNend
+ \retval ::HI_SUCCESS Success  CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetHue(HI_UNF_DISP_E enChan, HI_U32 u32Hue);
+
+/**
+\brief  set color temperature. CNcomment:设置色温 CNend
+\attention \n
+none.CNcomment:无 CNend
+\param[in] enDisp              DISP channel ID.CNcomment:DISP通道号 CNend
+\param[in] colortemp           temperature value. the range is 0~100, 0 means the min value. \n
+CNcomment:显示输出色温增益值。范围为0～100。0：表示最小色温增益；100：表示最大色温增益 CNend
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_PQ_SetColorTemperature(HI_UNF_DISP_E enChan, HI_UNF_PQ_COLORTEMPERATURE_S stColorTemperature);
+
+
+/**
+\brief  set color temperature. CNcomment:设置色温 CNend
+\attention \n
+none.CNcomment:无 CNend
+\param[in] enDisp              DISP channel ID.CNcomment:DISP通道号 CNend
+\param[in] colortemp           temperature value. the range is 0~100, 0 means the min value. \n
+CNcomment:显示输出色温增益值。范围为0～100。0：表示最小色温增益；100：表示最大色温增益 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_PQ_GetColorTemperature(HI_UNF_DISP_E enChan, HI_UNF_PQ_COLORTEMPERATURE_S *pstColorTemperature);
+
+/**
+ \brief Set Basic image para. CNcomment:设置图像基本参数. CNend
+ \attention \n
+ \param[in] enType: Graph or Video  CNcomment: 设置的是图形还是视频 CNend
+ \param[in] enChan: Destination DISP channel  CNcomment: 目标通道号 CNend
+ \param[in] stParam:Basic Image Param CNcomment:图像基本参数CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetBasicImageParam(HI_UNF_PQ_IMAGE_TYPE_E enType, HI_UNF_DISP_E enChan, HI_UNF_PQ_IMAGE_PARAM_S stParam);
+
+
+/**
+ \brief Get Basic image para. CNcomment:获取图像基本参数 CNend
+ \attention \n
+ \param[in] enType: Graph or Video  CNcomment: 选择的是图形还是视频 CNend
+ \param[in] enChan: Destination DISP channel  CNcomment: 目标通道号 CNend
+ \param[in] pstParam:Basic Image Param CNcomment:图像基本参数 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetBasicImageParam(HI_UNF_PQ_IMAGE_TYPE_E enType, HI_UNF_DISP_E enChan, HI_UNF_PQ_IMAGE_PARAM_S *pstParam);
+
+
+/**
+ \brief Get SR Demo Mode. CNcomment:获取SR演示类型 CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment: 目标通道号 CNend
+ \param[out] *penType, SR Demo Mode  CNcomment:指针，SR 显示模式 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetSRMode(HI_UNF_DISP_E enChan, HI_UNF_PQ_SR_DEMO_E *penType);
+
+
+/**
+ \brief  Set SR Demo Mode. CNcomment:设置SR演示类型 CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment: 目标通道号 CNend
+ \param[in] enType, SR Demo Mode  CNcomment:SR 显示模式 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetSRMode(HI_UNF_DISP_E enChan, HI_UNF_PQ_SR_DEMO_E enType);
+
+
+/**
+ \brief Get Sharpness. CNcomment:获取清晰度 CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment: 目标通道号 CNend
+ \param[out] pu32Sharpness; Range:0~100  CNcomment: 清晰度；有效范围: 0~100 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetSharpness(HI_UNF_DISP_E enChan, HI_U32 *pu32Sharpness);
+
+
+/**
+ \brief Set Sharpness. CNcomment:设置清晰度 CNend
+ \attention \n
+ \param[in] enChan Destination DISP channel CNcomment: 目标通道号 CNend
+ \param[in] u32Sharpness; Range:0~100  CNcomment: 清晰度；有效范围: 0~100 CNend
+ \retval ::HI_SUCCESS  Success CNcomment: 成功 CNend
+ */
+HI_S32 HI_UNF_PQ_SetSharpness(HI_UNF_DISP_E enChan, HI_U32 u32Sharpness);
+
+/**
+ \brief Get Color Enhance Type and Para. CNcomment:获取颜色增强的类型和参数 CNend
+ \attention \n
+ \param[out] pstColorEnhanceParam  CNcomment:颜色增强的类型和参数 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetColorEnhanceParam(HI_UNF_PQ_COLOR_ENHANCE_S *pstColorEnhanceParam);
+
+
+/**
+ \brief Set Color Enhance Type and Para. CNcomment:设置颜色增强的类型和参数 CNend
+ \attention \n
+ \param[out] stColorEnhanceParam  CNcomment:颜色增强的类型和参数 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetColorEnhanceParam(HI_UNF_PQ_COLOR_ENHANCE_S stColorEnhanceParam);
+
+
+/** Dynamic Contrast Improvement(DCI)
+ \brief Get Dynamic Contrast Improvement(DCI) Range  CNcomment:获取DCI（动态对比度增强）的强度范围 CNend
+ \attention \n
+ \param[out] pu32DCIlevel; Range:0~100 CNcomment:动态对比度等级；有效范围: 0~100 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetDynamicContrast(HI_U32 *pu32DCIlevel);
+
+
+/**
+ \brief Get DCI Range  CNcomment:获取DCI强度范围 CNend
+ \attention \n
+ \param[in] u32DCIlevel; Range:0~100 CNcomment:动态对比度等级；有效范围: 0~100 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetDynamicContrast(HI_U32 u32DCIlevel);
+
+
+/**
+ \brief Get noise reduction strength CNcomment:获取降噪强度 CNend
+ \attention \n
+ \param[out] pu32NRLevel: noise reduction level; Range:0~100 CNcomment:降噪等级；有效范围: 0~100 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetNR(HI_UNF_DISP_E enChan, HI_U32 *pu32NRLevel);
+
+
+/**
+ \brief  Set noise reduction strength CNcomment:设置降噪强度 CNend
+ \attention \n
+ \param[in] u32NRLevel: noise reduction level; Range:0~100 CNcomment:降噪等级；有效范围: 0~100 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetNR(HI_UNF_DISP_E enChan, HI_U32 u32NRLevel);
+
+/**
+ \brief Get digital noise reduction strength CNcomment:获取数字降噪强度 CNend
+ \attention \n
+ \param[out] pu32NRLevel: noise reduction level; Range:0~100 CNcomment:数字降噪等级；有效范围: 0~100 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetDNR(HI_UNF_DISP_E enChan, HI_U32 *pu32DNRLevel);
+
+
+/**
+ \brief  Set digital noise reduction strength CNcomment:设置数字降噪强度 CNend
+ \attention \n
+ \param[in] u32NRLevel: noise reduction level; Range:0~100 CNcomment:数字降噪等级；有效范围: 0~100 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetDNR(HI_UNF_DISP_E enChan, HI_U32 u32DNRLevel);
+
+
+
+/**
+ \brief  Set Algorithm Moudle on-off  CNcomment:设置算法模块开关 CNend
+ \attention \n
+ \param[in] enFlags   CNcomment:算法模块 CNend
+ \param[in] u32OnOff  CNcomment:算法开关 CNend
+ \retval ::HI_SUCCESS Success CNcomment:成功 CNend
+ */
+HI_S32 HI_UNF_PQ_SetPQModule(HI_UNF_PQ_MODULE_E enFlags, HI_U32 u32OnOff);
+
+
+/**
+ \brief Get Algorithm Moudle on-off  CNcomment:获取算法模块开关 CNend
+ \attention \n
+ \param[in]  enFlags   CNcomment:算法模块 CNend
+ \param[out] pu32OnOff CNcomment:算法开关 CNend
+ \retval ::HI_SUCCESS  Success CNcomment:成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetPQModule(HI_UNF_PQ_MODULE_E enFlags, HI_U32 *pu32OnOff);
+
+
+/**
+ \brief Set Demo Mode on-off  CNcomment:设置卖场模式开关 CNend
+ \attention \n
+ \param[in] enFlags   CNcomment:算法模块 CNend
+ \param[in] u32OnOff  CNcomment:卖场模式开关 CNend
+ \retval ::HI_SUCCESS CNcomment:成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetDemo(HI_UNF_PQ_DEMO_E enFlags, HI_U32 u32OnOff);
+
+
+/**
+ \brief Set Demo Display Mode  CNcomment:设置卖场显示模式 CNend
+ \attention \n
+ \param[in] enChan    CNcomment:显示通道 CNend
+ \param[in] enMode    CNcomment:卖场显示模式 CNend
+ \retval ::HI_SUCCESS Success CNcomment:成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetDemoMode(HI_UNF_DISP_E enChan, HI_UNF_PQ_DEMO_MODE_E enMode);
+
+
+/**
+ \brief Get Demo Display Mode  CNcomment:获取卖场显示模式 CNend
+ \attention \n
+ \param[in] enChan    CNcomment:显示通道 CNend
+ \param[out] enMode   CNcomment:卖场显示模式 CNend
+ \retval ::HI_SUCCESS Success CNcomment:成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetDemoMode(HI_UNF_DISP_E enChan, HI_UNF_PQ_DEMO_MODE_E *penMode);
+
+/**
+ \brief Set Demo Display Mode Coordinate CNcomment:设置卖场显示坐标 CNend
+ \attention \n
+ \param[in] u32X Range:0~100 Default:50 CNcomment:卖场显示分界线横坐标 有效范围:0~100 默认值:50 CNend
+ \retval ::HI_SUCCESS Success CNcomment:成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_SetDemoCoordinate(HI_U32 u32X);
+
+
+/**
+ \brief Get Demo Display Mode Coordinate CNcomment:获取卖场显示模式坐标 CNend
+ \attention \n
+ \param[out] pu32X  Range:0~100 Default:50 CNcomment:卖场显示分界线横坐标 有效范围:0~100 默认值:50 CNend
+ \retval ::HI_SUCCESS Success CNcomment:成功 CNend
+
+ */
+HI_S32 HI_UNF_PQ_GetDemoCoordinate(HI_U32 *pu32X);
+
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* End of #ifndef __HI_UNF_PQ_H__ */
+
+
diff -uNr a/include/hi_unf_pvr.h b/include/hi_unf_pvr.h
--- a/include/hi_unf_pvr.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_pvr.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,1530 @@
+/******************************************************************************
+
+  Copyright (C) Hisilicon Technologies Co., Ltd. 2008-2018. All rights reserved.
+
+ ******************************************************************************
+  File Name     : hi_unf_pvr.h
+  Version       : Initial draft
+  Author        : HiSilicon multimedia software group
+  Created Date   : 2008-04-09
+  Description   : hi_pvr_api.h header file
+  Change History:
+  Date        : 2008-04-09
+    Author      : sdk
+    Description: This file is created.
+
+******************************************************************************/
+/**
+ * \file
+ * \brief Describes the information about the personal video recorder (PVR). CNcomment: 提供PVR的相关信息 CNend
+ */
+#ifndef __HI_UNF_PVR_H__
+#define __HI_UNF_PVR_H__
+
+#include "hi_type.h"
+#include "hi_debug.h"
+#include "hi_unf_cipher.h"
+#include "hi_unf_common.h"
+#include "hi_unf_avplay.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"
+{
+#endif
+#endif /* End of #ifdef __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup    PVR */
+/** @{ */  /** <!--[PVR]*/
+
+/**Recommended value of the recording attribute u32ScdBufSize*//** CNcomment: 录制属性中u32ScdBufSize的推荐值 */
+#define PVR_STUB_SC_BUF_SZIE (7*4*2048)
+
+/**Recommended value of the recording attribute u32DavBufSize when the recording attribute enTsPacketType is HI_UNF_PVR_TS_PACKET_188 and Resolution is FHD and below*//** CNcomment:  当录制属性中enTsPacketType为HI_UNF_PVR_TS_PACKET_188,且分辨率为FHD及以下时,录制属性中u32DavBufSize的推荐值 */
+#define PVR_STUB_TSDATA_SIZE (188*12*2048)
+
+/**Recommended value of the recording attribute u32DavBufSize when the recording attribute enTsPacketType is HI_UNF_PVR_TS_PACKET_192 and Resolution is FHD and below*//**<CNcomment: 当录制属性中enTsPacketType为HI_UNF_PVR_TS_PACKET_192,且分辨率为FHD及以下时,录制属性中u32DavBufSize的推荐值 */
+#define PVR_STUB_TSDATA_SIZE_192 (192*12*2048)
+
+/*****************Macro Definition*******************************/
+/**Maximum length of the file name, in byte*//** CNcomment:  文件名最大长度，单位:字节*/
+#define PVR_MAX_FILENAME_LEN            256
+/**Maximum length of the encryption key, in byte. Note: The valid key length may not be the maximum length, and depends on the encryption algorithm.*/
+/** CNcomment: 加密密钥最大长度，单位:字节。注意: 密钥的有效长度不一定是最大长度，而是由加密的算法决定 */
+#define PVR_MAX_CIPHER_KEY_LEN          128
+/**Maximum length of the user data, in byte*//** CNcomment:  用户数据最大长度， 单位:字节 */
+#define PVR_MAX_USERDATA_LEN            (1024*1024)
+#define PVR_MAX_CADATA_LEN              (16*1024)
+/**<Maximum number of PID for one recording*//**<CNcomment: 一路录制支持的最大PID个数*/
+#define HI_UNF_PVR_REC_MAX_PID_NUM (32)
+
+/**<Flag value of trick play with audio*//**<CNcomment: 带声音的特技播放速度标志值*/
+#define HI_UNF_PVR_TRICK_WITH_AUDIO_ENABLE     (0x0A000000)
+
+/***********************************************************
+                Data Structure Definition
+ ***********************************************************/
+
+/***** Common Data Structures*****/
+
+/** Secure mode type*/
+/**CNcomment:安全模式类型*/
+typedef enum hiUNF_PVR_SECURE_MODE_E
+{
+    HI_UNF_PVR_SECURE_MODE_NONE = 0,        /** <no security protection*/ /**<CNcomment:无安全保护*/
+    HI_UNF_PVR_SECURE_MODE_TEE,             /** <trustedzone security protection*/ /**<CNcomment:trustedzone安全保护*/
+
+    HI_UNF_PVR_SECURE_MODE_BUTT
+} HI_UNF_PVR_SECURE_MODE_E;
+
+/**Cyclic control data structure of the PVR index file*//** CNcomment: PVR index文件中循环控制结构信息 */
+typedef struct hiPVR_CYC_HEADER_INFO_S
+{
+    HI_U32 u32StartFrame;     /**<Offset of the start frame in the index file. The start frame is at u32StartFrame.*//**<CNcomment: 码流的起始帧在index文件中的偏移, 起始帧放在u32StartFrame的位置*/
+    HI_U32 u32EndFrame;       /**<Offset of the end frame in the index file. The end frame is at u32EndFrame - 1.*//**<CNcomment: 码流的结束帧在index文件中的偏移, 结束帧放在u32EndFrame-1的位置*/
+    HI_U32 u32LastFrame;      /**<Offset of the last frame in the index file. The last frame is at u32LastFrame - 1.*//**<CNcomment: index文件中结尾帧的偏移, 结尾帧放在u32LastFrame-1的位置*/
+    HI_U32 u32IsRewind;       /**<Whether to record the file in rewind mode. 0: no rewind; 1: rewind*//**<CNcomment: 文件是否回绕录制, 0 非回绕, 1 回绕*/
+}PVR_CYC_HEADER_INFO_S;
+
+/**Structure of the file header in the PVR index file*//** CNcomment: PVR index文件中文件头信息结构 */
+typedef struct hiPVR_IDX_HEADER_INFO_S
+{
+    HI_U32 u32StartCode;                          /**<Start code (0x5A5A5A5A)*//**<CNcomment: 起始码(0x5A5A5A5A) */
+    HI_U32 u32HeaderLen;                          /**<Length from u32StartCode to UsrData*//**<CNcomment: 从u32StartCode开始到UsrData结束的长度 */
+    PVR_CYC_HEADER_INFO_S stCycInfo;              /**<Records the cyclic control information in the index file*//**<CNcomment: index中录制环回控制信息 */
+    HI_U64 u64ValidSize;                          /**<Size of the valid content in a file, in byte*//**<CNcomment:文件中有效内容大小 单位Byte */
+    HI_U32 u32Reserved;                           /**<Reserved, for alignment*//**<CNcomment:保留，用作对齐 */
+    HI_U32 u32UsrDataInfoLen;                     /**<User information length*//**<CNcomment: 用户信息长度 */
+    HI_U32 u32CADataInfoLen;
+}PVR_IDX_HEADER_INFO_S;
+
+/**Index data saved in the PVR index file*//** CNcomment: PVR index文件中保存的索引数据结构 */
+typedef struct hiPVR_INDEX_ENTRY_S
+{
+    HI_U16 u16FrameTypeAndGop;                    /**<2-bit frame type and 14-bit group of pictures (GOP)*/
+    HI_U16 u16UpFlowFlag;                         /**<DAV overflow flag*/
+    HI_U32 s32CycTimes;                           /**<Number of times that the file is rewound*/
+    HI_U64 u64GlobalOffset;                       /**<Total global offset (rewind ignored), in byte*/
+    HI_U32 u32DisplayTimeMs;                      /**<Display time (in ms), no rewind*/
+    HI_U32 u32FrameSize;                          /**<Frame size*/
+    HI_U64 u64Offset;                             /**<Frame offset in a stream file*/
+    HI_U32 u32PtsMs;                              /**<Presentation time stamp (PTS), in ms*/
+    HI_U16 u16IndexType;                          /**<Index type*/
+    HI_U16 u161stFrameOfTT;                       /**<Useless*/
+}PVR_INDEX_ENTRY_S,*PTR_PVR_INDEX_ENTRY;
+
+
+/**Encryption or decryption configuration of the PVR*//** CNcomment:  PVR加解密配置 */
+typedef struct hiUNF_PVR_CIPHER_S
+{
+    HI_BOOL             bDoCipher;                             /**<Whether to perform encryption or decryption. When this parameter is set to HI_FALSE, other parameters are invalid.*//**<CNcomment:  是否进行加密或者解密，此项配置为HI_FALSE时，其他项没有意义 */
+    HI_UNF_CIPHER_ALG_E enType;                                /**<Encryption or decryption algorithm type that supports only the AES, DES, and 3DES*//**<CNcomment: 加密或者解密的算法类型，只支持AES、DES、3DES */
+    HI_U8               au8Key[PVR_MAX_CIPHER_KEY_LEN];        /**<In normal PVR,it's cipher key.If advance security PVR, it's Keyladder's first session key*//**<CNcomment: 普通PVR方案中，作为Cipher的密钥，高安全PVR方案中，作为Keyladder的一级会话密钥 */
+    HI_U32              u32KeyLen;                             /**<Cipher key length*//**<CNcomment: 密钥长度 */
+}HI_UNF_PVR_CIPHER_S;
+
+/**Type of the PVR event*//** CNcomment:  PVR事件类型 */
+typedef enum hiUNF_PVR_EVENT_E
+{
+    HI_UNF_PVR_EVENT_PLAY_EOF                       = 0x001,          /**<A file is played at the end of file (EOF).*//**<CNcomment:  播放到文件尾 */
+    HI_UNF_PVR_EVENT_PLAY_SOF                       = 0x002,          /**<A file is played to the start of file (SOF).*//**<CNcomment:  回退到文件头 */
+    HI_UNF_PVR_EVENT_PLAY_ERROR                     = 0x003,          /**<An internal error occurs during playing.*//**<CNcomment:  播放内部错误 */
+    HI_UNF_PVR_EVENT_PLAY_REACH_REC                 = 0x004,          /**<The playing speed reaches the recording speed during time shift.*//**<CNcomment:  时移的时候播放追上录制 */
+    HI_UNF_PVR_EVENT_PLAY_FIRST_FRAME_DISPLAYED     = 0x005,          /**<the first deocded frame have been displayed out by the tv.*//**<CNcomment: 第一帧已被显示*/
+    HI_UNF_PVR_EVENT_PLAY_RESV                      = 0x00f,          /**<Reserved*//**<CNcomment:  保留 */
+    HI_UNF_PVR_EVENT_REC_DISKFULL                   = 0x010,          /**<The disk is full.*//**<CNcomment:  磁盘满 */
+    HI_UNF_PVR_EVENT_REC_ERROR                      = 0x011,          /**<An internal error occurs during recording.*//**<CNcomment:  录制内部错误 */
+    HI_UNF_PVR_EVENT_REC_OVER_FIX                   = 0x012,          /**<The length of the recorded data reaches the specified length. after report this event, in non-rewind mode, pvr stop recording; In rewind mode, pvr keep recording.*//**<CNcomment: 录制长度达到指定的长度. 上报这个事件后，非回绕录制模式下停止录制；回绕录制模式下继续录制 */
+    HI_UNF_PVR_EVENT_REC_REACH_PLAY                 = 0x013,          /**<The recording speed reaches the playing speed during time shift.*//**<CNcomment:  时移的时候录制追上播放 */
+    HI_UNF_PVR_EVENT_REC_DISK_SLOW                  = 0x014,          /**<The storage speed of the disk is slower than the recording speed.*//**<CNcomment: 磁盘存储速度慢于录制速度 */
+    HI_UNF_PVR_EVENT_REC_REWIND_TO_LINEAR_COMPLETE  = 0x015,          /**<Rewinding switch to non-rewinding completed.the success or failure of the callback event reported*//**<CNcomment: 回绕模式切换至非回绕模式完成，是否切换成功由回调函数进行上报*/
+    HI_UNF_PVR_EVENT_RECFILE_LINEARIZATION_COMPLETE = 0x016,          /**<File linearization completed.the success or failure of the callback event reported*//**<CNcomment:  文件线性化完成 是否线性化成功由回调函数进行上报*/
+    HI_UNF_PVR_EVENT_REC_EOS                        = 0x017,          /**<all the data in the record buffer is received.*//*<CNcomment:PVR已收取到所有录制buffer的TS数据*/
+    HI_UNF_PVR_EVENT_REC_RESV                       = 0x01f,          /**<Reserved*//**<CNcomment:  保留 */
+    HI_UNF_PVR_EVENT_BUTT                           = 0x020           /**<Invalid event type*//**<CNcomment: 无效的事件类型 */
+} HI_UNF_PVR_EVENT_E;
+
+/**Callback function of PVR event*//** CNcomment: PVR事件回调函数 */
+typedef void (*eventCallBack)(HI_U32 u32ChnID, HI_UNF_PVR_EVENT_E EventType, HI_S32 s32EventValue, HI_VOID *args);
+
+/**Type of recorded and played streams of the PVR*//** CNcomment: PVR录制、播放的码流类型 */
+typedef enum hiUNF_PVR_STREAM_TYPE_E
+{
+    HI_UNF_PVR_STREAM_TYPE_TS,        /**<Transport stream (TS)*//**<CNcomment:  TS流 */
+    HI_UNF_PVR_STREAM_TYPE_PES,       /**<Packetized elementary stream (PES)*//**<CNcomment: PES流 */
+    HI_UNF_PVR_STREAM_TYPE_ALL_TS,    /**<All types of streams. That is, the streams at all frequencies are recorded.*//**<CNcomment: 全码流录制，录制整个频点的所有码流 */
+    HI_UNF_PVR_STREAM_TYPE_OTHER,     /**<Invalid*//**<CNcomment:  无效的类型 */
+    HI_UNF_PVR_STREAM_TYPE_BUTT
+} HI_UNF_PVR_STREAM_TYPE_E;
+
+/**Index type*//** CNcomment: 索引类型 */
+typedef enum hiUNF_PVR_REC_INDEX_TYPE_E
+{
+    HI_UNF_PVR_REC_INDEX_TYPE_NONE,      /**<No index is created. You need to select this type when recording all streams.*//**<CNcomment: <不建索引。全码流录制的时候请使用此类型  */
+    HI_UNF_PVR_REC_INDEX_TYPE_VIDEO,     /**<The index is created based on videos.*//**<CNcomment: <针对视频建立索引。 */
+    HI_UNF_PVR_REC_INDEX_TYPE_AUDIO,     /**<The index is created based on audios. *//**<CNcomment: <针对音频建立索引。 */
+    HI_UNF_PVR_REC_INDEX_TYPE_BUTT       /**<Invalid*//**<CNcomment: <无效的索引类型。   */
+} HI_UNF_PVR_REC_INDEX_TYPE_E;
+
+/**Information about a stream file recorded by the PVR*//** CNcomment:  PVR录制的码流文件信息 */
+typedef struct hiUNF_PVR_FILE_ATTR_S
+{
+    HI_UNF_PVR_REC_INDEX_TYPE_E enIdxType;          /**<Index type*//**<CNcomment:  索引类型 */
+    HI_U32                      u32FrameNum;        /**<For a video file: number of frames in the file. For an audio file: number of PESs in the file*//**<CNcomment:  对视频文件：文件帧数;对音频文件：文件中的PES数 */
+    HI_U32                      u32StartTimeInMs;   /**<Start time of the file, in ms*//**<CNcomment: 文件内容的起始时间，起始帧PTS，单位ms */
+    HI_U32                      u32EndTimeInMs;     /**<End time of the file, in ms*//**<CNcomment: 文件内容的结束时间，结束帧PTS，单位ms  */
+    HI_U64                      u64ValidSizeInByte; /**<Valid data length of the file, in byte *//**<CNcomment:  文件的有效数据长度，单位byte */
+} HI_UNF_PVR_FILE_ATTR_S;
+
+/***** Data Structures for Recording  *****/
+/** Record statuses*/
+/**INVALID -> INIT -> RUNNING -> STOPPING ->    STOP ->    INVALID  (saveIndex)  (saveStream)*/
+
+/**Status of a recording channel*//** CNcomment: 录制通道的状态 */
+typedef enum hiUNF_PVR_REC_STATE_E
+{
+  HI_UNF_PVR_REC_STATE_INVALID,        /**<Not initialized*//**<CNcomment:  未初始化。    */
+  HI_UNF_PVR_REC_STATE_INIT,           /**<Initialized*//**<CNcomment:  初始化。      */
+  HI_UNF_PVR_REC_STATE_RUNNING,        /**<Recording*//**<CNcomment:  录制中。      */
+  HI_UNF_PVR_REC_STATE_PAUSE,          /**<Pause*//**<CNcomment:  暂停中        */
+  HI_UNF_PVR_REC_STATE_STOPPING,       /**<Stopping*//**<CNcomment: 正在停止。    */
+  HI_UNF_PVR_REC_STATE_STOP,           /**<<Stopped*//**<CNcomment: 已经停止。    */
+  HI_UNF_PVR_REC_STATE_PID_CHANGE,     /**<PID is changing*//**<CNcomment: PID正在切换*/
+  HI_UNF_PVR_REC_STATE_BUTT            /**<Invalid*//**<CNcomment: 无效的状态值。*/
+} HI_UNF_PVR_REC_STATE_E;
+
+/**<Record pid info when pid changed.*//**<CNcomment: 记录Pid变更时需要的pid信息*/
+typedef struct hiUNF_PVR_PID_CHANGE_INFO_S
+{
+    HI_U32                      u32PidNum;                              /**<pid number in u32PidList.*//**<CNcomment: 记录pidList中pid的个数。*/
+    HI_UNF_PVR_REC_INDEX_TYPE_E enIndexType;                            /**<Index type.*//**<CNcomment: 索引类型*/
+    HI_U32                      u32IndexPid;                            /**<Index PID.*//**<CNcomment: 索引PID。*/
+    HI_UNF_VCODEC_TYPE_E        enVidType;                              /**<Video Type.*//**<CNcomment:待建立索引的码流的视频编码协议, 索引类型是HI_UNF_PVR_REC_INDEX_TYPE_VIDEO时才需要配置,静态属性 */
+    HI_U32                      u32PidList[HI_UNF_PVR_REC_MAX_PID_NUM]; /**<Pid List*//**<CNcomment: pid列表。*/
+}HI_UNF_PVR_PID_CHANGE_INFO_S;
+
+/**<Packet Type of stream.*//**<CNcomment: 码流的包类型*/
+typedef enum hiUNF_PVR_TS_PACKET_TYPE_E
+{
+    HI_UNF_PVR_TS_PACKET_188 = 0,       /**<Packet size is 188 byte*//**<CNcomment: 码流中包大小为188字节*/
+    HI_UNF_PVR_TS_PACKET_192,           /**<Packet size is 192 byte*//**<CNcomment: 码流中包大小为192字节*/
+    HI_UNF_PVR_TS_PACKET_BUTT           /**<Invalid*//**<CNcomment: 无效的包类型*/
+}HI_UNF_PVR_TS_PACKET_TYPE_E;
+
+/**<PID is changing callback type. <CNcomment: PID变更回调函数类型CNend
+\param[in] u32ChnId  Record chanel ID CNcomment:录制通道IDCNend
+\param[in] pstOldPidInfo    Pointer to the old pid info CNcomment:PID变更前的PID信息CNend
+\param[in] pstNewPidInfo    Pointer to the new pid info CNcomment:PID变更后的PID信息CNend
+\param[in] pArgs    user data CNcomment:用户私有数据CNend
+*/
+typedef HI_S32 ( *PidChangeCallBack)(HI_U32 u32ChnId, HI_UNF_PVR_PID_CHANGE_INFO_S *pstOldPidInfo, HI_UNF_PVR_PID_CHANGE_INFO_S *pstNewPidInfo, HI_VOID *pArgs);
+
+/**Attributes of a recording channel*//** CNcomment: 录制通道属性数据结构 */
+typedef struct hiUNF_PVR_REC_ATTR_S
+{
+    HI_UNF_PVR_REC_INDEX_TYPE_E enIndexType;                           /**<Index type, static attribute.*//**<CNcomment:  索引类型，静态属性。 */
+    HI_UNF_VCODEC_TYPE_E        enIndexVidType;                        /**<Video encoding protocol with which the stream (for which an index is to be created) complies. The protocol (static attribute) needs to be set only when the index type is HI_UNF_PVR_REC_INDEX_TYPE_VIDEO.*/
+                                                                       /**<CNcomment: 待建立索引的码流的视频编码协议, 索引类型是HI_UNF_PVR_REC_INDEX_TYPE_VIDEO时才需要配置,静态属性  */
+    HI_U32                      u32IndexPid;                           /**<Index PID, static attribute.*//**<CNcomment:  索引PID，静态属性*/
+    HI_U32                      u32DemuxID;                            /**<Recording DEMUX ID, static attribute.*//**<CNcomment:  录制DEMUX号，静态属性。*/
+    HI_U32                      u32DavBufSize;                         /**<Size (in byte) of a data stream buffer, static attribute.*//**<CNcomment:  数据流缓冲区大小，单位为Byte，静态属性。  */
+    HI_U32                      u32ScdBufSize;                         /**<Size (in byte) of an index data buffer, static attribute.*//**<CNcomment:  索引数据缓存区大小，单位为Byte，静态属性。*/
+    HI_U32                      u32UsrDataInfoSize;                    /**<Size (in byte) of the private user data, static attribute.*//**<CNcomment:  用户私有数据大小，单位为Byte，静态属性。  */
+    HI_BOOL                     bIsClearStream;                        /**<Whether to record streams as clear streams, static attribute. This item indicates that the stored streams are clear streams or scrambled streams. If the programs to be recorded are scrambled streams, the clear streams can be recorded only after a descrambler is configured for the audio/video channel of the DEMUX.
+                                                                       The recording module of the PVR does not descramble the scrambled streams.*/
+                                                                       /**<CNcomment: 是否把码流录制成清流，静态属性。此项的意思是存下来的码流是清流还是加扰流。如果待录制的节目是加扰流，需要在录制DEMUX上启动一路CA才能录制清流,PVR录制模块并不负责对加扰流的解扰操作。*/
+    HI_UNF_PVR_STREAM_TYPE_E    enStreamType;                          /**<Type of the data to be recorded, static attribute.*//**<CNcomment: 待录制的数据类型，静态属性。*/
+    HI_UNF_PVR_CIPHER_S         stEncryptCfg;                          /**<Stream encryption configuration, static attribute.*//**<CNcomment: 码流加密配置信息，静态属性。*/
+    HI_U64                      u64MaxFileSize;                        /**<Size of the file to be recorded, static attribute. If the value is 0, it indicates that there is no limit on the file size. The minimum file size is 52428800 bytes (50 MB). If the disk space is sufficient, it is recommended to set the file size to a value greater than 512 MB. The file size cannot be 0 in rewind mode. */
+                                                                       /**<CNcomment: 待录制的文件大小，为0时表示无限制，静态属性。最小值为50M,如果磁盘空间足够的话，推荐配置为512M以上。配置为回绕时不允许把文件大小和文件播放时间都配置为0。 */
+    HI_U64                      u64MaxTimeInMs;                        /**<Max play time of the file to be recorded, static attribute. If the value is 0, it indicates that there is no limit on the file play time. The minimum file time is 60*1000 MS (1 Min).  The file size  and file time cannot both be 0 in rewind mode.*/
+                                                                       /**<CNcomment: 待录制的文件的最长播放时间长度，为0时表示无限制，静态属性。最小播放时间为60*1000毫秒(1分钟)。回绕模式下，不能将文件最大大小和文件最长播放时间同时设置为0。*/
+    HI_BOOL                     bRewind;                               /**<Whether to rewind, If this item is set to HI_TRUE, the PVR rewinds to the file header to record streams after the recorded file size reaches u64MaxFileSize. If this item is set to HI_FALSE, the PVR stops recording after the recorded file size reaches u64MaxFileSize.*/
+                                                                       /**<CNcomment: 是否回绕。如配置为HI_TRUE，录制文件大小到达u64MaxFileSize后，会回绕到文件头继续进行录制；如配置为HI_FALSE，则录制文件大小到达u64MaxFileSize后，会停止录制。*/
+    HI_CHAR                     szFileName[PVR_MAX_FILENAME_LEN];      /**<Name of a stream file, static attribute*//**<CNcomment: 码流文件名，静态属性。*/
+    HI_U32                      u32FileNameLen;                        /**<Length of a stream file name, static attribute. You need to set the item to strlen (szFileName).*//**<CNcomment: 码流文件名长度，静态属性。取值为strlen（szFileName）即可 */
+    HI_UNF_PVR_SECURE_MODE_E    enSecureMode;                          /**<Secure channel indication*/ /**<CNcomment:安全通道标示*/
+    HI_BOOL                     bAppendRec;                            /**<Whether to append record,static attribute.If this item is set to HI_TRUE, and the parameters transferred from the upper-layer meets the:(a).add the recording file name the same as that of the before.(b). corresponding to the file name of the file is a wrap-around. (c). bRewind is HI_FALSE. (d). be consistent with the index type. (e).PID information is consistent with the previously.
+                                                                                                                   (f). was recording time of the recording files must be greater than or equal to 60s. (g). maximum file size or the maximum recording time is exceeded.The Append recording starts.Otherwise,Append recording failed.If this item is set to HI_FALSE,not need to Append recording.*/
+                                                                        /**<CNcomment: 是否续录，静态属性。如果配置为HI_TRUE，且上层传入的参数满足：(a)、追加录制文件名与之前保持一致.(b)、文件名对应的文件是非回绕的。(c)、bRewind是HI_FALSE。(d)、索引类型与之前保持一致。(e)、PID信息与之前保持一致.
+                                                                                                                    (f)、被续录文件的录制时间需不小于60s。(g)、最大录制文件大小或最大录制时间是否超出。 否则续录失败。如果设置为HI_FALSE,则不进行续录*/
+    HI_UNF_PVR_TS_PACKET_TYPE_E enTsPacketType;                        /**<Packet Type of the stream to be recorded.*//**<CNcomment: 待录制码流的包类型*/
+    HI_U32                      u32Reserved;
+}HI_UNF_PVR_REC_ATTR_S;
+
+/**Status of a PVR buffer*//** CNcomment:定义PVR缓冲区的状态信息 */
+typedef struct hiUNF_PVR_BUF_STATUS_S
+{
+    HI_U32 u32BufSize;       /**<Buffer size*//**<CNcomment: 缓冲区大小       */
+    HI_U32 u32UsedSize;      /**<Used buffer size*//**<CNcomment: 缓冲区已使用大小 */
+} HI_UNF_PVR_BUF_STATUS_S;
+
+typedef struct hiUNF_PVR_APPEND_REC_INFO_S
+{
+    HI_BOOL bAppendRec;            /**<if current record is appended*//**<CNcomment: 当前是否是追加录制。    */
+    HI_U32 u32Reserved;
+    HI_U64 u64AppendOffset;        /**<the offset of beginning to append, only valid if bAppRec=HI_TRUE*//**<CNcomment: 追加录制的位置, 仅在追加录制时有效。    */
+}HI_UNF_PVR_APPEND_REC_INFO_S;
+
+/**Status of a recording channel.
+The following describes the relationships among u32CurTimeInMs, u32StartTimeInMs, and u32EndTimeInMs by taking examples:
+1. Assume that the total recording time is 10000 ms, and no rewind occurs. In this case, u32StartTimeInMs is 0 ms, u32EndTimeInMs is 10000 ms, and u32CurTimeInMs is 10000 ms.
+2. Assume that the total recording time is 10000 ms, and rewind occurs at 8000 ms. In this case, u32StartTimeInMs is 2000 ms, u32EndTimeInMs is 10000 ms, and u32CurTimeInMs is 8000 ms.
+*/
+/** CNcomment:录制通道状态数据结构.
+对u32CurTimeInMs、u32StartTimeInMs、u32EndTimeInMs三者的关系举例说明如下：
+1・假设从开始录制后一共录制了10000毫秒，如果没有发生回绕，那么u32StartTimeInMs 为0，u32EndTimeInMs 为10000， u32CurTimeInMs为10000。
+2・假设从开始录制后一共录制了10000毫秒，并且在第8000毫秒的时候发生了回绕，那么u32StartTimeInMs 为2000，u32EndTimeInMs 为10000， u32CurTimeInMs为8000。
+*/
+typedef struct hiUNF_PVR_REC_STATUS_S
+{
+    HI_UNF_PVR_REC_STATE_E      enState;                 /**<Current status of a channel*//**<CNcomment: 通道所处的状态。    */
+    HI_U32                      u32Reserved;             /**<Reserved, for alignment*//**<CNcomment: 保留，用作对齐。    */
+    HI_U64                      u64CurWritePos;          /**<Current recording position of file, in byte*//**<CNcomment: 当前录制写文件的位置（单位：byte）。 */
+    HI_U32                      u32CurWriteFrame;        /**<Number of currently recorded frames*//**<CNcomment: 当前录制的帧数。                  */
+    HI_U32                      u32CurTimeInMs;          /**<Current recording time (in ms). The value is the valid time for recording the file.*//**<CNcomment: 当前录制的毫秒数。其值为录制文件的实际有效时长。*/
+    HI_U32                      u32StartTimeInMs;        /**<Actual start time for recording files. Before the recording is rewound, the time is that of the first frame; after the recording is rewound, the time is the rewind time.*//**<CNcomment: 录制文件的实际起始点。录制回绕前，为第一帧时间；录制回绕后，为回绕点的时间。 */
+    HI_U32                      u32EndTimeInMs;          /**<Time of the end frame in the recorded file. Before the recording is rewound, the time is that of the last frame.*//**<CNcomment:录制文件中结束帧的时间，没有环回前即最后一帧的时间。    */
+    HI_UNF_PVR_BUF_STATUS_S     stRecBufStatus;          /**<Status of the recording channel buffer*//**<CNcomment:录制通道缓冲区状态。    */
+    HI_UNF_PVR_APPEND_REC_INFO_S stAppendRecInfo;        /**the infomation for append-recording*//**<CNcomment:追加录制信息。    */
+}HI_UNF_PVR_REC_STATUS_S;
+
+/** Data structures for playing */
+
+/**Playing direction of the PVR: forward*//** CNcomment:PVR播放方向:往前播放 */
+#define HI_UNF_PVR_PLAY_DIRECTION_FORWARD             (1)
+/**Playing direction of the PVR: backward*//** CNcomment: PVR播放方向:往后播放 */
+#define HI_UNF_PVR_PLAY_DIRECTION_BACK                (-1)
+
+/**Type of the playing position*//** CNcomment: 播放位置类型 */
+typedef enum hiUNF_PVR_PLAY_POS_TYPE_E
+{
+  HI_UNF_PVR_PLAY_POS_TYPE_SIZE,              /**<The playing position is expressed by size (in byte). This type is not supported currently.*//**<CNcomment: 用大小（单位：byte）表示位置（暂不支持） */
+  HI_UNF_PVR_PLAY_POS_TYPE_TIME,              /**<The playing position is expressed by time (in ms).*//**<CNcomment: 用时间（单位：ms）数表示位置 */
+  HI_UNF_PVR_PLAY_POS_TYPE_FRAME,             /**<The playing position is expressed by the number of frames or PESs. This type is not supported currently.*//**<CNcomment: 用帧数（或者PES数）表示位置（暂不支持）  */
+  HI_UNF_PVR_PLAY_POS_TYPE_BUTT               /**<Invalid*//**<CNcomment:无效的位置类型*/
+} HI_UNF_PVR_PLAY_POS_TYPE_E;
+
+/**Status of a playing channel*//** CNcomment: 播放通道的状态  */
+typedef enum hiUNF_PVR_PALY_STATE_E
+{
+    HI_UNF_PVR_PLAY_STATE_INVALID,       /**<Not initialized*//**<CNcomment: 未初始化            */
+    HI_UNF_PVR_PLAY_STATE_INIT,          /**<Initialized*//**<CNcomment: 初始化              */
+    HI_UNF_PVR_PLAY_STATE_PLAY,          /**<Normal playing*//**<CNcomment: 正常播放中          */
+    HI_UNF_PVR_PLAY_STATE_PAUSE,         /**<Pause*//**<CNcomment: 暂停                */
+    HI_UNF_PVR_PLAY_STATE_FF,            /**<Fast forward*//**<CNcomment: 快进                */
+    HI_UNF_PVR_PLAY_STATE_FB,            /**<Fast backward*//**<CNcomment: 快退                */
+    HI_UNF_PVR_PLAY_STATE_SF,            /**<Slow forward*//**<CNcomment: 慢放                */
+    HI_UNF_PVR_PLAY_STATE_SB,            /**<Slow backward*//**<CNcomment:慢退         */
+    HI_UNF_PVR_PLAY_STATE_STEPF,         /**<Step forward*//**<CNcomment:逐帧播放            */
+    HI_UNF_PVR_PLAY_STATE_STEPB,         /**<Step backward*//**<CNcomment: 逐帧倒放            */
+    HI_UNF_PVR_PLAY_STATE_STOP,          /**<Stop*//**<CNcomment: 停止                */
+    HI_UNF_PVR_PLAY_STATE_BUTT           /**<Invalid*//**<CNcomment: 无效的状态值        */
+} HI_UNF_PVR_PLAY_STATE_E;
+
+/**Identifier of the playing speed*//** CNcomment: 播放速度标识 */
+typedef enum hiUNF_PVR_PLAY_SPEED_E
+{
+    HI_UNF_PVR_PLAY_SPEED_NORMAL            = 1024,                                     /**<Normal playing speed*//**<CNcomment:正常速度播放。    */
+    HI_UNF_PVR_PLAY_SPEED_2X_FAST_FORWARD   = 2 * HI_UNF_PVR_PLAY_SPEED_NORMAL,         /**<Fast forward at two times the normal speed*//**<CNcomment:2倍速快放。            */
+    HI_UNF_PVR_PLAY_SPEED_4X_FAST_FORWARD   = 4 * HI_UNF_PVR_PLAY_SPEED_NORMAL,         /**<Fast forward at four times the normal speed*//**<CNcomment:4倍速快放。            */
+    HI_UNF_PVR_PLAY_SPEED_8X_FAST_FORWARD   = 8 * HI_UNF_PVR_PLAY_SPEED_NORMAL,         /**<Fast forward at eight times the normal speed*//**<CNcomment:8倍速快放。            */
+    HI_UNF_PVR_PLAY_SPEED_12X_FAST_FORWARD   = 12 * HI_UNF_PVR_PLAY_SPEED_NORMAL,         /**<Fast forward at 12 times the normal speed*//**<CNcomment:12倍速快放。            */
+    HI_UNF_PVR_PLAY_SPEED_16X_FAST_FORWARD  = 16 * HI_UNF_PVR_PLAY_SPEED_NORMAL,        /**<Fast forward at 16 times the normal speed*//**<CNcomment:16倍速快放。           */
+    HI_UNF_PVR_PLAY_SPEED_24X_FAST_FORWARD   = 24 * HI_UNF_PVR_PLAY_SPEED_NORMAL,         /**<Fast forward at 24 times the normal speed*//**<CNcomment:24倍速快放。            */
+    HI_UNF_PVR_PLAY_SPEED_32X_FAST_FORWARD  = 32 * HI_UNF_PVR_PLAY_SPEED_NORMAL,        /**<Fast forward at 32 times the normal speed*//**<CNcomment:32倍速快放。           */
+    HI_UNF_PVR_PLAY_SPEED_64X_FAST_FORWARD  = 64 * HI_UNF_PVR_PLAY_SPEED_NORMAL,        /**<Fast forward at 64 times the normal speed*//**<CNcomment:64倍速快放。           */
+    HI_UNF_PVR_PLAY_SPEED_1X_FAST_BACKWARD  = -1 * HI_UNF_PVR_PLAY_SPEED_NORMAL,        /**<Fast backward at 1 times the normal speed, not support*//**<CNcomment:1倍速倒播，暂不支持。 */
+    HI_UNF_PVR_PLAY_SPEED_2X_FAST_BACKWARD  = -2 * HI_UNF_PVR_PLAY_SPEED_NORMAL,        /**<Fast backward at two times the normal speed*//**<CNcomment:2倍速快退。            */
+    HI_UNF_PVR_PLAY_SPEED_4X_FAST_BACKWARD  = -4 * HI_UNF_PVR_PLAY_SPEED_NORMAL,        /**<Fast backward at four times the normal speed*//**<CNcomment:4倍速快退。            */
+    HI_UNF_PVR_PLAY_SPEED_8X_FAST_BACKWARD  = -8 * HI_UNF_PVR_PLAY_SPEED_NORMAL,        /**<Fast backward at eight times the normal speed*//**<CNcomment:8倍速快退。            */
+    HI_UNF_PVR_PLAY_SPEED_12X_FAST_BACKWARD   = -12 * HI_UNF_PVR_PLAY_SPEED_NORMAL,         /**<Fast backward at 12 times the normal speed*//**<CNcomment:12倍速快退。            */
+    HI_UNF_PVR_PLAY_SPEED_16X_FAST_BACKWARD = -16 * HI_UNF_PVR_PLAY_SPEED_NORMAL,       /**<Fast backward at 16 times the normal speed*//**<CNcomment:16倍速快退。           */
+    HI_UNF_PVR_PLAY_SPEED_24X_FAST_BACKWARD   = -24 * HI_UNF_PVR_PLAY_SPEED_NORMAL,         /**<Fast backward at 24 times the normal speed*//**<CNcomment:24倍速快退。            */
+    HI_UNF_PVR_PLAY_SPEED_32X_FAST_BACKWARD = -32 * HI_UNF_PVR_PLAY_SPEED_NORMAL,       /**<Fast backward at 32 times the normal speed*//**<CNcomment:32倍速快退。           */
+    HI_UNF_PVR_PLAY_SPEED_64X_FAST_BACKWARD = -64 * HI_UNF_PVR_PLAY_SPEED_NORMAL,       /**<Fast backward at 64 times the normal speed*//**<CNcomment:64倍速快退。           */
+    HI_UNF_PVR_PLAY_SPEED_0_75X_SLOW_FORWARD   = HI_UNF_PVR_PLAY_SPEED_NORMAL * 3/ 4,         /**<Slow forward at 3/4 times the normal speed*//**<CNcomment:3/4倍速慢放。          */
+    HI_UNF_PVR_PLAY_SPEED_2X_SLOW_FORWARD   = HI_UNF_PVR_PLAY_SPEED_NORMAL / 2,         /**<Slow forward at 1/2 times the normal speed*//**<CNcomment:1/2倍速慢放。          */
+    HI_UNF_PVR_PLAY_SPEED_4X_SLOW_FORWARD   = HI_UNF_PVR_PLAY_SPEED_NORMAL / 4,         /**<Slow forward at 1/4 times the normal speed*//**<CNcomment:1/4倍速慢放。          */
+    HI_UNF_PVR_PLAY_SPEED_8X_SLOW_FORWARD   = HI_UNF_PVR_PLAY_SPEED_NORMAL / 8,         /**<Slow forward at 1/8 times the normal speed*//**<CNcomment:1/8倍速慢放。          */
+    HI_UNF_PVR_PLAY_SPEED_16X_SLOW_FORWARD  = HI_UNF_PVR_PLAY_SPEED_NORMAL / 16,        /**<Slow forward at 1/16 times the normal speed*//**<CNcomment:1/16倍速慢放。         */
+    HI_UNF_PVR_PLAY_SPEED_32X_SLOW_FORWARD  = HI_UNF_PVR_PLAY_SPEED_NORMAL / 32,        /**<Slow forward at 1/32 times the normal speed*//**<CNcomment:1/32倍速慢放。         */
+    HI_UNF_PVR_PLAY_SPEED_64X_SLOW_FORWARD  = HI_UNF_PVR_PLAY_SPEED_NORMAL / 64,        /**<Slow forward at 1/64 times the normal speed*//**<CNcomment:1/64倍速慢放。         */
+    HI_UNF_PVR_PLAY_SPEED_0_75X_SLOW_BACKWARD  = HI_UNF_PVR_PLAY_SPEED_NORMAL *3/ (-4),      /**<Slow backward at 3/4 times the normal speed.*//**<CNcomment:3/4倍速慢退。  */
+    HI_UNF_PVR_PLAY_SPEED_2X_SLOW_BACKWARD  = HI_UNF_PVR_PLAY_SPEED_NORMAL / (-2),      /**<Slow backward at 1/2 times the normal speed. *//**<CNcomment:1/2倍速慢退。  */
+    HI_UNF_PVR_PLAY_SPEED_4X_SLOW_BACKWARD  = HI_UNF_PVR_PLAY_SPEED_NORMAL / (-4),      /**<Slow backward at 1/4 times the normal speed.*//**<CNcomment:1/4倍速慢退。  */
+    HI_UNF_PVR_PLAY_SPEED_8X_SLOW_BACKWARD  = HI_UNF_PVR_PLAY_SPEED_NORMAL / (-8),      /**<Slow backward at 1/8 times the normal speed. This mode is not supported currently.*//**<CNcomment:1/8倍速慢退，暂不支持。  */
+    HI_UNF_PVR_PLAY_SPEED_16X_SLOW_BACKWARD = HI_UNF_PVR_PLAY_SPEED_NORMAL / (-16),     /**<Slow backward at 1/16 times the normal speed. This mode is not supported currently.*//**<CNcomment:1/16倍速慢退，暂不支持。 */
+    HI_UNF_PVR_PLAY_SPEED_32X_SLOW_BACKWARD = HI_UNF_PVR_PLAY_SPEED_NORMAL / (-32),     /**<Slow backward at 1/32 times the normal speed. This mode is not supported currently.*//**<CNcomment:1/32倍速慢退，暂不支持。 */
+    HI_UNF_PVR_PLAY_SPEED_64X_SLOW_BACKWARD = HI_UNF_PVR_PLAY_SPEED_NORMAL / (-64),     /**<Slow backward at 1/64 times the normal speed. This mode is not supported currently.*//**<CNcomment:1/64倍速慢退，暂不支持。 */
+
+    HI_UNF_PVR_PLAY_SPEED_0_5X_WITH_AUDIO = (HI_UNF_PVR_PLAY_SPEED_NORMAL / 2) | HI_UNF_PVR_TRICK_WITH_AUDIO_ENABLE,    /**<Slow forward with audio at 0.5 times the normal speed*//**<CNcomment:0.5倍速带声音慢放。*/
+    HI_UNF_PVR_PLAY_SPEED_0_8X_WITH_AUDIO = (4 * HI_UNF_PVR_PLAY_SPEED_NORMAL / 5) | HI_UNF_PVR_TRICK_WITH_AUDIO_ENABLE,     /**<Slow forward with audio at 0.8 times the normal speed*//**<CNcomment:0.8倍速带声音慢放。*/
+    HI_UNF_PVR_PLAY_SPEED_0_9X_WITH_AUDIO = (9 * HI_UNF_PVR_PLAY_SPEED_NORMAL / 10) | HI_UNF_PVR_TRICK_WITH_AUDIO_ENABLE,    /**<Slow forward with audio at 0.9 times the normal speed*//**<CNcomment:0.9倍速带声音慢放。*/
+    HI_UNF_PVR_PLAY_SPEED_1_1X_WITH_AUDIO = (11 * HI_UNF_PVR_PLAY_SPEED_NORMAL / 10) | HI_UNF_PVR_TRICK_WITH_AUDIO_ENABLE,    /**<Fast forward with audio at 1.1 times the normal speed*//**<CNcomment:1.1倍速带声音快放。*/
+    HI_UNF_PVR_PLAY_SPEED_1_2X_WITH_AUDIO = (6 * HI_UNF_PVR_PLAY_SPEED_NORMAL / 5) | HI_UNF_PVR_TRICK_WITH_AUDIO_ENABLE,    /**<Fast forward with audio at 1.2 times the normal speed*//**<CNcomment:1.2倍速带声音快放。*/
+    HI_UNF_PVR_PLAY_SPEED_1_5X_WITH_AUDIO = (3 * HI_UNF_PVR_PLAY_SPEED_NORMAL / 2) | HI_UNF_PVR_TRICK_WITH_AUDIO_ENABLE,    /**<Fast forward with audio at 1.5 times the normal speed*//**<CNcomment:1.5倍速带声音快放。*/
+    HI_UNF_PVR_PLAY_SPEED_BUTT                                                          /**<Invalid value*//**<CNcomment:无效的速度值。         */
+} HI_UNF_PVR_PLAY_SPEED_E;
+
+/**Trick mode*//** CNcomment: 特技播放的模式  */
+typedef struct hiUNF_PVR_PLAY_MODE_S
+{
+    HI_UNF_PVR_PLAY_SPEED_E               enSpeed;    /**<For details about the playing speed, see the description of HI_UNF_PVR_PLAY_SPEED_E.*//**<CNcomment: 速度，见HI_UNF_PVR_PLAY_SPEED_E的定义 */
+}HI_UNF_PVR_PLAY_MODE_S;
+
+typedef enum hiUNFPVR_TRICKPLAYTOEND_ACTION_E
+{
+    HI_UNF_PVR_TRICKPLAYTOEND_ACTION_STOP = 0, /**report event and stop channel when fast forward to end of the file or fast backward to the start**//**<CNcomment:快进到尾或快退到头：上报事件和停止播放通道**/
+    HI_UNF_PVR_TRICKPLAYTOEND_ACTION_PLAY,     /**report event and switch to normal play when fast forward to end of the file or fast backward to the start**//**<CNcomment:快进到尾或快退到头：上报事件和切换到正常播放**/
+    HI_UNF_PVR_TRICKPLAYTOEND_ACTION_BUTT        /**Invalid option**//**<CNcomment:非法选项**/
+}HI_UNF_PVR_TRICKPLAYTOEND_ACTION_E;
+
+/**Attributes of a playing channel*//** CNcomment:播放通道属性 */
+typedef struct hiUNF_PVR_PLAY_ATTR_S
+{
+    HI_UNF_PVR_STREAM_TYPE_E        enStreamType;                         /**<Type of the played stream, static attributes. At present, only the TS is supported.*//**<CNcomment: 播放码流类型，目前只支持TS，静态属性。*/
+    HI_BOOL                         bIsClearStream;                       /**<Whether the stream to be played is the clear stream, static attribute. Scrambled streams can be played in normal mode only rather than in trick mode.*//**<CNcomment: 待播放的码流是否清流，静态属性。加扰流不支持特技播放，只支持正常播放 */
+    HI_UNF_PVR_CIPHER_S             stDecryptCfg;                         /**<Decryption configuration, static attribute                  *//**<CNcomment: 解密配置，静态属性。                  */
+    HI_CHAR                         szFileName[PVR_MAX_FILENAME_LEN];     /**<Name of the file that contains the streams to be played, static attribute        *//**<CNcomment: 待播放码流的文件名，静态属性。        */
+    HI_U32                          u32FileNameLen;                       /**<Length of the file name, static attribute. You need to set the item to strlen (szFileName).*//**<CNcomment: 文件名长度，静态属性。取值为strlen（szFileName）即可 */
+    HI_UNF_PVR_SECURE_MODE_E        enSecureMode;                         /**<Secure channel indication*/ /**<CNcomment:安全通道标示*/
+    HI_UNF_PVR_TRICKPLAYTOEND_ACTION_E  enTrickPlayToEndAction;             /**option for timeshift play, reference the HI_UNF_PVR_TRICKPLAYTOEND_ACTION_E**//**<CNcomment:时移播放选项，快进到尾或快退到头采取的动作**/
+}HI_UNF_PVR_PLAY_ATTR_S;
+
+
+/**Description of the playing position*//** CNcomment: 播放位置描述  */
+typedef struct hiUNF_PVR_PLAY_POSITION_S
+{
+    HI_UNF_PVR_PLAY_POS_TYPE_E  enPositionType;       /**<Position type*//**<CNcomment: 位置类型。           */
+    HI_S32                      s32Whence;            /**<Offset type, including SEEK_SET, SEEK_CUR, or SEEK_END*//**<CNcomment:偏移类型，取值范围为SEEK_SET/SEEK_CUR/SEEK_END。*/
+    HI_S64                      s64Offset;            /**<Offset. If the offset type is time, the offset is in the unit of millisecond; if the offset type is frame, the offset is in the unit of frame.*//**<CNcomment:偏移。 偏移类型为时间时，单位毫秒；偏移类型为帧时，单位为一帧 */
+}HI_UNF_PVR_PLAY_POSITION_S;
+
+/**Information required for creating an index file*//** CNcomment: 创建索引文件需要的信息 */
+typedef struct hiUNF_PVR_GEN_IDX_ATTR_S
+{
+    HI_U32                      u32UsrDataInfoLen;         /**<Length of the user data*//**<CNcomment: 用户数据长度 */
+    HI_U32                      u32IdxPid;                 /**<Index PID*//**<CNcomment: 针对哪个Pid建立索引 */
+    HI_UNF_PVR_REC_INDEX_TYPE_E enIdxType;                 /**<Index type*//**<CNcomment: 索引类型 */
+}HI_UNF_PVR_GEN_IDX_ATTR_S;
+
+/**Status of a playing channel*//** CNcomment:播放通道的状态 */
+typedef struct hiUNF_PVR_PLAY_STATUS_S
+{
+    HI_UNF_PVR_PLAY_STATE_E     enState;                              /**<Status of a playing channel*//**<CNcomment:播放通道状态。                                  */
+    HI_UNF_PVR_PLAY_SPEED_E     enSpeed;                              /**<Playing speed of a playing channel*//**<CNcomment: 播放通道的播放速度。                            */
+    HI_U64                      u64CurPlayPos;                        /**<Start position (byte) of the current frame in the file*//**<CNcomment:当前播放帧的起始在文件中的位置（byte数）。      */
+    HI_U32                      u32CurPlayFrame;                      /**<Start position (number of frames or PESs) of the current frame in the file*//**<CNcomment:当前播放帧在文件中的位置（帧数或者PES数）       */
+    HI_U32                      u32CurPlayTimeInMs;                   /**<PTS of the current frame, in ms*//**<CNcomment: 当前播放帧的PTS, 单位毫秒。                     */
+}HI_UNF_PVR_PLAY_STATUS_S;
+
+/**<Data file attribution *//** CNcomment:数据文件属性*/
+typedef struct hiUNF_PVR_DATA_ATTR_S
+{
+    HI_U32     u32ChnID;                              /**<PVR channel, just consider one channel*//**<CNcomment: PVR通道，现在可以只考虑一种通道的情况 */
+    HI_CHAR    CurFileName[PVR_MAX_FILENAME_LEN];     /**<Current reading file 's name include direction.If there are multi-node, the file name maybe different*//**<CNcomment: 当前正在读取的文件名，包括绝对路径。多个节点情况下，该文件名有可能会变。  */
+    HI_CHAR    IdxFileName[PVR_MAX_FILENAME_LEN+5];
+    HI_U64     u64FileStartPos;                       /**<Position of start frame ,it should be considered if rewind record ,0 invalid*//**<CNcomment:文件的开始位置，主要在文件环回的情况下需要考虑,为0时表示无效  */
+    HI_U64     u64FileEndPos;                         /**<Position of end frame ,it should be considered if rewind record ,0 invalid*//**<CNcomment:文件的结束位置，主要在文件环回的情况下需要考虑,为0时表示无效   */
+    HI_U64     u64GlobalOffset;
+    HI_U64     u64FileReadOffset;
+} HI_UNF_PVR_DATA_ATTR_S;
+
+/**<save buffer infomation *//**<CNcomment: 保存buffer 信息*/
+typedef struct hiUNF_PVR_BUF_S
+{
+    HI_U8 *pu8VirAddr;        /**<virtual address*//**<CNcomment:虚拟地址*/
+    HI_U32 u32PhyAddr;        /**<physical address*//**<CNcomment:物理地址*/
+    HI_U32 u32Len;            /**<buffer length*//**<CNcomment:buffer 长度*/
+}HI_UNF_PVR_BUF_S;
+
+/**<Read or write data extra callback *//** CNcomment:外部读、写数据回调函数*/
+typedef enum hiUNF_PVR_EXTRA_CALLBACK_E
+{
+    HI_UNF_PVR_EXTRA_READ_CALLBACK,          /**<Read data callback *//**<CNcomment:读数据或播放回调函数*/
+    HI_UNF_PVR_EXTRA_WRITE_CALLBACK,         /**<Write data callback*//**<CNcomment:写数据或录制回调函数*/
+    HI_UNF_PVR_EXTRA_CALLBACK_BUTT           /**<Invalid*//**<CNcomment: 无效的状态值        */
+} HI_UNF_PVR_EXTRA_CALLBACK_E;
+
+/**<the record channel attribute ID *//** CNcomment:录制通道参数的ID*/
+typedef enum hiUNF_PVR_REC_ATTR_ID_E
+{
+    HI_UNF_PVR_REC_ATTR_ID_REWIND = 0,                   /**<change the rewind attribute,only support changing the rewind attribute to not rewind, HI_BOOL*//** <CNcomment: 改变回绕属性，仅支持回绕变更为非回绕*/
+    HI_UNF_PVR_REC_ATTR_ID_FILE_FRAGMENT_SIZE,           /**<set the file fragment size when recording in merged storage PVR, HI_U64*//**<CNcomment:当PVR进行合并存储录制时，设置录制文件分片大小*/
+    HI_UNF_PVR_REC_ATTR_ID_BUTT                          /**<Invalid*//**<CNcomment: 无效的状态值        */
+} HI_UNF_PVR_REC_ATTR_ID_E;
+
+/**Attributes of Linearization channel*//** CNcomment:线性化通道属性 */
+typedef struct hiUNF_PVR_LINEARIZATION_ATTR_S
+{
+    HI_CHAR                     szSrcFileName[PVR_MAX_FILENAME_LEN];     /**<File name to be linearized, static attribute        *//**<CNcomment: 待修复的文件名，静态属性。        */
+    HI_U32                      u32SrcFileNameLen;                       /**<Length of the file name, static attribute. You need to set the item to strlen (szSrcFileName).*//**<CNcomment: 文件名长度，静态属性。取值为strlen（szSrcFileName）即可 */
+    HI_CHAR                     szDstFileName[PVR_MAX_FILENAME_LEN];     /**<After the linearization of the file name, static attribute        *//**<CNcomment: 修复完成保存的文件名，静态属性。        */
+    HI_U32                      u32DstFileNameLen;                       /**<Length of the file name, static attribute. You need to set the item to strlen (szDstFileName).*//**<CNcomment: 文件名长度，静态属性。取值为strlen（szDstFileName）即可 */
+}HI_UNF_PVR_LINEARIZATION_ATTR_S;
+
+/**status of Linearization channel*//** CNcomment:线性化通道状态 */
+typedef struct hiUNF_PVR_LINEARIZATION_STATUS_S
+{
+    HI_U32  u32TotalFrameNum;               /**The total number of frames currently processed for the file..*//**<CNcomment: 当前处理文件的总帧数*/
+    HI_U32  u32CurrentFixFrameNum;          /**The current number of frames processed..*//**<CNcomment: 当前已处理的帧个数*/
+}HI_UNF_PVR_LINEARIZATION_STATUS_S;
+
+/**<Callback function type when asynchronously processing truncate. CNcomment:异步处理truncate时的回调函数类型CNend
+\param[in] pszSrcFileName  Pointer to the original file name CNcomment:指针类型，指向原文件名CNend
+\param[in] u32SrcFileNameLen    The length of original file name CNcomment:原文件名的长度CNend
+\param[in] pszDstFileName    Pointer to the destination file name  CNcomment:指针类型，指向目标文件名CNend
+\param[in] u32DstFileNameLen   The length of destination file name  CNcomment:目标文件名的长度CNend
+\param[in] s32ErrCode The error code of truncate CNcomment:truncate过程中的错误码CNend
+\param[in] pArgs    User private data CNcomment:用户私有数据CNend
+\note: This callback function only needs to be processed asynchronously CNcomment:该回调函数仅在异步处理时需要CNend
+*/
+typedef HI_S32 (*TruncateCallBack)(HI_CHAR *pszSrcFileName, HI_U32 u32SrcFileNameLen, HI_CHAR *pszDstFileName, HI_U32 u32DstFileNameLen, HI_S32 s32ErrCode, HI_VOID *pArgs);
+
+/*Attributes of truncate*/
+typedef struct hiUNF_PVR_RECFILE_TRUNCATE_INFO_S
+{
+    HI_BOOL             bSync;                  /**Whether need to be synchronized*//**<CNcomment: 是否需要同步处理*/
+    HI_U32              u32PaddingTimeMs;       /**Redundant data that guarantees data integrity*//**<CNcomment: 冗余长度，保证数据完整性*/
+    HI_BOOL             bTruncateHead;          /**Whether need to be deal with Head*//**<CNcomment: 是否需要处理头部*/
+    HI_U32              u32StartTimeMs;         /**Expected starting position*//**<CNcomment: 期望的起始位置*/ /*实际处理后的起始位置 <= u32StartTimeMs-u32PaddingTimeMs*/
+    HI_BOOL             bTruncateTail;          /**Whether need to be deal with Tail*//**<CNcomment: 是否需要处理尾部*/
+    HI_U32              u32EndTimeMs;           /**Expected end position*//**<CNcomment: *期望的尾部位置*/ /*实际处理后的结束位置 >= u32EndTimeMs+u32PaddingTimeMs*/
+    TruncateCallBack    pfnAsyncCB;             /**The callback funcation of Asynchronously*//**<CNcomment: 异步处理时处理完成的回调函数*/
+    HI_VOID             *pArgs;                 /**The private data of callback*//**<CNcomment: 回调函数的私有数据，底层不作任何处理，直接透传*/
+}HI_UNF_PVR_RECFILE_TRUNCATE_INFO_S;
+
+/**<Read or write data extra callback type. CNcomment:外部读、写数据回调函数类型CNend
+\param[in] pstDataAttr  Pointer to the attributes of current used data file CNcomment:指针类型，指向通道属性配置 CNend
+\param[in] pu8DataAddr    Pointer to the virtual address CNcomment:指针类型，指向虚拟地址CNend
+\param[in] u32PhyAddr    Pointer to the physical address CNcomment:指针类型，指向物理地址CNend
+\param[in] u32Offset    offset CNcomment:偏移量CNend
+\param[in] u32DataSize buffer size CNcomment:buffer 的长度CNend
+*/
+typedef HI_S32 ( *ExtraCallBack)(HI_UNF_PVR_DATA_ATTR_S *pstDataAttr, HI_U8 *pu8DataAddr, HI_U32 u32PhyAddr, HI_U32 u32Offset, HI_U32 u32DataSize);
+
+/**<Read or write data extend callback type. CNcomment:外部读、写数据回调函数类型CNend
+\param[in] pstDataAttr  Pointer to the attributes of current used data file CNcomment:指针类型，指向通道属性配置 CNend
+\param[in] pstDstBuf    Pointer to the attributes of destination buffer CNcomment:指针类型，指向目的buffer 属性CNend
+\param[in] pstSrcBuf    Pointer to the attributes of source buffer CNcomment:指针类型，指向源buffer 属性CNend
+\param[in] u32Offset    offset CNcomment:偏移量CNend
+\param[in] u32DataSize buffer size CNcomment:buffer 的长度CNend
+\param[in] pUserData    user data CNcomment:用户私有数据CNend
+\note: This callback has two different from the ExtraCallBack: 1) support different address for src/dst buffer; 2) support the use of user's private data. the address of src/dst buffer are different for tee record.
+	   CNcomment:与ExtraCallBack相比：1)该回调函数支持源和目的buffer不同地址；2)支持用户私有数据。TEE录制时，源和目的buffer地址不同。CNend
+*/
+typedef HI_S32 (*ExtendCallBack)(HI_UNF_PVR_DATA_ATTR_S *pstDataAttr, HI_UNF_PVR_BUF_S *pstDstBuf, HI_UNF_PVR_BUF_S *pstSrcBuf,
+                                    HI_U32 u32Offset, HI_U32 u32DataSize, HI_VOID *pUserData);
+
+/**Defines the attributes when an recording channel is in Flushing Stream Status.*/
+/**CNcomment:定义PVR录制通道Flush Stream时属性设置结构体 */
+typedef struct hiUNF_PVR_FLUSH_STREAM_OPT_S
+{
+    HI_U32          u32Reserved;
+}HI_UNF_PVR_FLUSH_STREAM_OPT_S;
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      PVR  */
+/** @{ */  /** <!-- [PVR]*/
+
+/***** Application programming interfaces (APIs) for the PVR recoding module*****/
+
+/**
+\brief Initializes the PVR recording module. CNcomment:初始化PVR录制模块 CNend
+\attention \n
+If you initialize the PVR recording module repeatedly, the error code HI_SUCCESS is returned.
+Before using the APIs of the PVR recording module, you must call this API. Otherwise, other APIs are unavailable.
+CNcomment: 重复初始化返回成功.
+每个进程使用PVR录制模块接口前，必须先调用此接口，否则其他接口均无法使用 CNend
+\param N/A CNcomment: 无 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_FAILURE This API fails to be called due to system errors. CNcomment: 出现系统错误，API调用失败 CNend
+\see \n
+::HI_UNF_PVR_RecDeInit
+*/
+HI_S32 HI_UNF_PVR_RecInit(HI_VOID);
+
+/**
+\brief Deinitializes the PVR recording module. CNcomment: 去初始化PVR录制模块 CNend
+\attention \n
+If you deinitialize the PVR recording module repeatedly, the error code HI_SUCCESS is returned.\n
+Before deintializing the PVR recording module, you must release all the recording channels. Otherwise,
+the error code HI_ERR_PVR_BUSY is returned.
+CNcomment:重复去初始化返回成功\n
+去初始化PVR录制模块前务必保证本进程内所有录制通道都已经释放，如果还有录制通道没有释放，此接口将会返回错误码HI_ERR_PVR_BUSY CNend
+\param N/A CNcomment:无 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_FAILURE This API fails to be called due to system errors.CNcomment: 出现系统错误，API调用失败 CNend
+\retval ::HI_ERR_PVR_BUSY  The PVR recording module is being used. CNcomment: 录制模块还在使用中 CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized. CNcomment: 录制模块未初始化 CNend
+\see \n
+::HI_UNF_PVR_RecInit
+*/
+HI_S32 HI_UNF_PVR_RecDeInit(HI_VOID);
+
+/**
+\brief Creates a recording channel. CNcomment: 创建1路录制通道 CNend
+\attention \n
+The PVR recording module automatically generates an .idx index file based on the file name specified in pAttr. \n
+The PVR recording module splits the recorded streams files to ensure that the size of each file is not greater than 4 GB (the size of each file is about 3.99 GB). \n
+The names of streams files are szFileName, szFileName.0001, szFileName.0002, szFileName.0003, szFileName.0004.\n
+If the file specified in pAttr already exists, it is replaced.\n
+If the index file to be created by the PVR recording module already exists, the file is also replaced.\n
+If the PVR calls the APIs of other modules (such as the APIs of the audio module, video module, and DEMUX module), the error codes of other modules may be returned.\n
+the error codes of other modules may be returned. For details, see the definitions of the error codes of corresponding modules.This description is applicable to the following APIs.
+This description is applicable to the following APIs.
+CNcomment:PVR录制模块会根据pAttr中指定的文件名自动生成一个后缀名为".idx"索引文件\n
+PVR录制模块会对录制的码流文件进行分割，以确保码流文件不超过4G的大小（每个文件的大小约为3.99G），
+生成的码流文件依次为szFileName，szFileName.0001，szFileName.0002，szFileName.0003，szFileName.0004・・・\n
+如果pAttr中指定的文件已经存在，那么这个文件会被覆盖\n
+如果PVR录制模块将要创建的索引文件已经存在，则索引文件也会被覆盖\n
+由于PVR使用到了其他模块的API接口函数（比如音视频API接口和DEMUX API接口），因此返回的错误码有可能是其他模块的错误码，
+具体错误码值请参考相应模块错误码值定义。后面的其他API函数均会有此种情况  CNend
+\param[in] pu32ChnID   ID of the obtained recording channel  CNcomment: 获取到的录制通道ID CNend
+\param[in] pstRecAttr  Pointer to the attributes of a channel   CNcomment:指针类型，指向通道属性配置 CNend
+\retval ::HI_SUCCESS  Success CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized.  CNcomment:录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_NUL_PTR The pointer is null. CNcomment: 指针参数为空 CNend
+\retval ::HI_ERR_PVR_INVALID_PARA  The parameter is invalid.  CNcomment:  参数非法 CNend
+\retval ::HI_ERR_PVR_FILE_INVALID_FNAME  The file name is invalid.  CNcomment:文件名参数非法 CNend
+\retval ::HI_ERR_PVR_FILE_EXIST The file already exists.  CNcomment:文件已经存在 CNend
+\retval ::HI_ERR_PVR_NO_CHN_LEFT  There is no available channel.   CNcomment:已经没有空闲的通道供分配 CNend
+\retval ::HI_ERR_PVR_FILE_CANT_OPEN  The file cannot be opened.  CNcomment: 无法打开文件 CNend
+\retval ::HI_ERR_PVR_INDEX_CANT_MKIDX  The index file cannot be opened.  CNcomment: 无法打开索引文件 CNend
+\retval ::HI_ERR_PVR_REC_INVALID_DMXID The DEMUX ID received during recording is incorrect.  CNcomment: 录制时传入了错误的DEMUX ID CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_RecCreateChn(HI_U32 *pu32ChnID, const HI_UNF_PVR_REC_ATTR_S *pstRecAttr);
+
+/**
+\brief  Releases a specified recording channel. CNcomment: 释放指定的录制通道 CNend
+\attention \n
+CNcomment:If the channel to be released is not stopped, the error code HI_ERR_PVR_BUSY is returned.
+如果待释放的通道没有停止，将返回错误码::HI_ERR_PVR_BUSY CNend
+\param[in] u32ChnID   ID of the channel to be released CNcomment: 需要释放的通道号 CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized. CNcomment: PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID  The channel ID is invalid.  CNcomment: 通道号非法 CNend
+\retval ::HI_ERR_PVR_BUSY  The current operation is forbidden because the channel is busy. CNcomment: 通道忙，不允许进行当前操作 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_RecDestroyChn(HI_U32 u32ChnID);
+
+/**
+\brief Sets the attributes of a recording channel. CNcomment: 设置录制通道属性 CNend
+\attention \n
+You can modify only the dynamic attributes by calling this API.
+CNcomment:只有动态属性才能用此接口改变设置，由于目前属性都是静态的，所以此接口暂时不支持功能设置 CNend
+\param[in] u32ChnID   Channel ID CNcomment: 通道号 CNend
+\param[in] pstRecAttr  Attribute to be set  CNcomment:待设置的属性 CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized. CNcomment:PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID  The channel ID is invalid.  CNcomment: 通道号非法 CNend
+\retval ::HI_ERR_PVR_NOT_SUPPORT  The function is not supported. CNcomment:功能不支持 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_RecSetChn(HI_U32 u32ChnID, const HI_UNF_PVR_REC_ATTR_S *pstRecAttr);
+
+/**
+\brief Obtains the attributes of a recording channel. CNcomment: 获取录制通道属性 CNend
+\attention \n
+N/A
+\param[in] u32ChnID   Channel ID CNcomment: 通道号 CNend
+\param[out] pstRecAttr   Pointer to the obtained channel attributes   CNcomment:指针类型，指向获取到的通道属性配置 CNend
+\retval ::HI_SUCCESS  Success  CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT    The PVR recording module is not initialized.  CNcomment:PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID  The channel ID is invalid.  CNcomment: 通道号非法 CNend
+\retval ::HI_ERR_PVR_NUL_PTR        The pointer is null.  CNcomment:指针参数为空 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT  The specified channel is not initialized.   CNcomment:指定的通道未初始化 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_RecGetChn(HI_U32 u32ChnID, HI_UNF_PVR_REC_ATTR_S *pstRecAttr);
+
+/**
+\brief Starts a recording channel. CNcomment:启动录制通道 CNend
+\attention \n
+N/A
+\param[in] u32ChnID Channel ID   CNcomment:通道号 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT   The PVR recording module is not initialized. CNcomment:PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID    The channel ID is invalid.  CNcomment:通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT   The specified channel is not initialized.  CNcomment: 指定的通道未初始化 CNend
+\retval ::HI_ERR_PVR_ALREADY       The specified channel has been started.  CNcomment: 指定的通道已经启动 CNend
+\retval ::HI_FAILURE                 This API fails to be called due to system errors.  CNcomment:出现系统错误，API调用失败 CNend
+\see \n
+::HI_UNF_PVR_RecStopChn
+*/
+HI_S32 HI_UNF_PVR_RecStartChn(HI_U32 u32ChnID);
+
+/**
+\brief Stops a recording channel. CNcomment: 停止录制通道 CNend
+\attention \n
+If a recording channel is working in time-shift playing mode, the channel cannot be stopped until the time-shift operation stops.
+In this case, the error code HI_ERR_PVR_BUSY is returned if you call this API.
+CNcomment:如果1个录制通道正在进行时移播放操作，则在停止时移播放之前，不允许停止该录制通道 \n
+如果该通道正在进行时移播放操作，将返回错误码HI_ERR_PVR_BUSY CNend
+\param[in] u32ChnID   Channel ID  CNcomment:通道号 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT    The PVR recording module is not initialized.  CNcomment: PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID     The channel ID is invalid.    CNcomment:通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT     The specified channel is not initialized. CNcomment:指定的通道未初始化 CNend
+\retval ::HI_ERR_PVR_ALREADY         The specified channel has been stopped.    CNcomment:指定的通道已经停止 CNend
+\retval ::HI_ERR_PVR_BUSY            The current operation is forbidden because the channel is busy. CNcomment:通道忙，不允许进行当前操作 CNend
+\see \n
+::HI_UNF_PVR_RecStartChn
+*/
+HI_S32 HI_UNF_PVR_RecStopChn(HI_U32 u32ChnID);
+
+/**
+\brief Pauses a recording channel. CNcomment: 暂停录制通道 CNend
+\attention \n
+It should be called under recording mode and can be repeated call.
+CNcomment:只有录制状态调用该接口才有作用，允许重复调用 CNend
+\param[in] u32ChnID   Channel ID  CNcomment:通道号 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_REC_INVALID_STATE  PVR isn't playing or pausing. CNcomment: PVR非播放或者暂停状态 CNend
+\see \n
+::HI_UNF_PVR_RecResumeChn
+*/
+HI_S32 HI_UNF_PVR_RecPauseChn(HI_U32 u32ChnID);
+
+/**
+\brief Resumes a recording channel. CNcomment: 恢复录制通道 CNend
+\attention \n
+It should be called under recording mode and can be repeated call.
+CNcomment:只有录制状态调用该接口才有作用，允许重复调用 CNend
+\param[in] u32ChnID   Channel ID  CNcomment:通道号 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_REC_INVALID_STATE  PVR isn't playing or paused.CNcomment: PVR非播放或者暂停状态 CNend
+\see \n
+::HI_UNF_PVR_RecPauseChn
+*/
+HI_S32 HI_UNF_PVR_RecResumeChn(HI_U32 u32ChnID);
+
+/**
+\brief Obtains the status of a recording channel.CNcomment:  获取录制通道状态 CNend
+\attention \n
+N/A
+\param[in] u32ChnID  Channel ID  CNcomment:通道号 CNend
+\param[out] pstRecStatus   Pointer to the recording status   CNcomment:录制状态信息指针 CNend
+\retval ::HI_SUCCESS Success  CNcomment: 成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT    The PVR recording module is not initialized.  CNcomment:PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID   The channel ID is invalid.   CNcomment: 通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT    The specified channel is not initialized.  CNcomment:指定的通道未初始化 CNend
+\retval ::HI_ERR_PVR_NUL_PTR        The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_RecGetStatus(HI_U32 u32ChnID, HI_UNF_PVR_REC_STATUS_S *pstRecStatus);
+
+
+/***** APIs for the PVR playing module *****/
+/**
+\brief Initializes the PVR playing module. CNcomment: 初始化PVR播放模块 CNend
+\attention \n
+If you initialize the PVR playing module repeatedly, the error code HI_SUCCESS is returned.\n
+Before using the APIs of the PVR playing module, you must call this API. Otherwise, other APIs are unavailable.
+CNcomment:重复初始化返回成功 \n
+每个进程使用PVR播放模块接口前，必须先调用此接口，否则其他接口均无法使用 CNend
+\param N/A
+\retval ::HI_SUCCESS         Success CNcomment:成功 CNend
+\retval ::HI_FAILURE           This API fails to be called due to system errors.    CNcomment:出现系统错误，API调用失败 CNend
+\see \n
+::HI_UNF_PVR_PlayDeInit
+*/
+HI_S32 HI_UNF_PVR_PlayInit(HI_VOID);
+
+/**
+\brief Deinitializes the PVR playing module.  CNcomment:去初始化PVR播放模块 CNend
+\attention \n
+If you deinitialize the PVR recording module repeatedly, the error code HI_SUCCESS is returned.\n
+Before deintializing the PVR playing module, you must release all the playing channels. Otherwise, the error code HI_ERR_PVR_BUSY is returned.
+CNcomment:重复去初始化返回成功 \n
+去初始化PVR播放模块前务必保证本进程内所有播放通道都已经释放，如果还有播放通道没有释放，此接口将会返回错误码::HI_ERR_PVR_BUSY CNend
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE          This API fails to be called due to system errors.   CNcomment: 出现系统错误，API调用失败 CNend
+\retval ::HI_ERR_PVR_BUSY  The PVR playing module is being used.  CNcomment: PVR播放模块还在使用中 CNend
+\retval ::HI_ERR_PVR_NOT_INIT   The PVR recording module is not initialized.CNcomment:  PVR录制模块未初始化 CNend
+\see \n
+::HI_UNF_PVR_PlayInit
+*/
+HI_S32 HI_UNF_PVR_PlayDeInit(HI_VOID);
+
+/**
+\brief Creates a playing channel. CNcomment:创建1路播放通道 CNend
+\attention \n
+The PVR playing module automatically searches for an .idx index file based on the file name specified in pAttr.
+If the index file does not exist, the PVR playing module attempts to play the stream file, but cannot support some features,
+such as fast forward, fast backward, or seek. The features vary according to versions of the software developer's kit (SDK).
+Only the playing function is supported in the current version.
+The played file may be the file that is being recorded (that is, time-shift playing).
+The audio/video player (AVPLAY) indicated by hAVPLAY must be stopped.
+CNcomment:PVR播放模块会根据pAttr中指定的文件名自动寻找后缀名为".idx"的索引文件 \n
+如果索引文件不存在，PVR播放模块也会尝试播放这个文件，但是可能无法支持某些特性，
+比如快进快退或者SEEK操作（根据版本的不同而有所差别，当前版本只支持播放）\n
+播放的文件可以是正在录制的文件（即进行时移播放）
+hAVPlay所代表的avplay必须处于stop状态。 CNend
+\param[out] pu32ChnID  ID of the obtained playing channel  CNcomment: 获取到的播放通道ID CNend
+\param[in] pstPlayAttr  Pointer to the channel attributes CNcomment: 通道属性配置指针 CNend
+\param[in] hAvplay      AVPLAY handle. It specifies the APVPLAY to be used. CNcomment: avplay句柄，标识用哪个avplay来播放 CNend
+\param[in] hTsBuffer  TS buffer handle. It specifies that TS buffer that is used for playback. In general, the TS port corresponding to the TS buffer must be attached to the DEMUX corresponding to the AVPLAY.
+tCNcomment:s buffer句柄，标识用哪个ts buffer来回放，一般来说，此ts buffer对应的ts端口应该是绑定在hAVPlay对应的demux上的 CNend
+\retval ::HI_SUCCESS   Success  CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT       The PVR recording module is not initialized.  CNcomment: PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_NUL_PTR            The pointer is null. CNcomment:  指针参数为空 CNend
+\retval ::HI_ERR_DMX_INVALID_PARA        The parameter is invalid.  CNcomment: 参数非法 CNend
+\retval ::HI_ERR_PVR_FILE_INVALID_FNAME   The file name is invalid.   CNcomment:文件名参数非法 CNend
+\retval ::HI_ERR_PVR_FILE_EXIST          The file already exists.  CNcomment:文件已经存在 CNend
+\retval ::HI_ERR_PVR_NO_CHN_LEFT        There is no available channel. CNcomment:  已经没有空闲的通道供分配 CNend
+\retval ::HI_ERR_PVR_FILE_CANT_OPEN      The file cannot be opened.   CNcomment:  无法打开文件 CNend
+\retval ::HI_ERR_PVR_FILE_NOT_EXIST      The file cannot be played because it does not exist. CNcomment: 文件不存在，无法播放 CNend
+\retval ::HI_ERR_PVR_NO_MEM             The buffer required for playing cannot be allocated due to insufficient memory. CNcomment: 内存不足，无法分配播放需要的Buffer CNend
+\retval ::HI_ERR_PVR_FILE_CANT_READ   The file cannot be read.  CNcomment:   文件读取出错 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_PlayCreateChn(HI_U32 *pu32ChnID, const HI_UNF_PVR_PLAY_ATTR_S *pstPlayAttr, HI_HANDLE hAvplay, HI_HANDLE hTsBuffer);
+
+/**
+\brief Releases a specified playing channel. CNcomment:释放指定的播放通道 CNend
+\attention \n
+If the channel to be released is not stopped, the error code HI_ERR_PVR_BUSY is returned.
+CNcomment:如果待释放的通道没有停止，将返回错误码::HI_ERR_PVR_BUSY CNend
+\param[in] u32ChnID  ID of the channel to be released CNcomment:需要释放的通道号 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT     The PVR recording module is not initialized.   CNcomment: PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID       The channel ID is invalid.  CNcomment: 通道号非法 CNend
+\retval ::HI_ERR_PVR_BUSY  The current operation is forbidden because the channel is busy.  CNcomment: 通道忙，不允许进行当前操作 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_PlayDestroyChn(HI_U32 u32ChnID);
+
+/**
+\brief
+Starts a time-shift playing channel.
+You can call this API to start a time-shift playing channel based on the entered IDs of recording channels. To be specific, this API automatically initializes a playing channel to play files based on the parameter configuration of the corresponding recording channel.
+CNcomment:启动时移播放通道。调用此接口可以根据输入的录制通道号，启动1路时移播放。此接口将根据对应录制通道的参数自动初始化1个播放通道，并开始播放 CNend
+\attention \n
+This API is not recommended. It is used to be compatible with other interfaces. You are recommended to call HI_UNF_PVR_PlayCreateChn and HI_UNF_PVR_PlayStartChn in sequence to start to play. If you want to enable the time-shift playing mode,
+you only need to set same names for the file to be played and recorded file. Then the PVR automatically identifies the same names, and enters the time-shift playing mode.
+After HI_UNF_PVR_PlayStartTimeShift is called, HI_UNF_PVR_PlayCreateChn is automatically called to allocate a playing channel. Therefore, you do not need to call HI_UNF_PVR_PlayNewChn.\n
+In addition, before calling HI_UNF_PVR_PlayStartTimeShift, you must start the corresponding recording channel. Otherwise, the error code HI_ERR_PVR_REC_INVAL_STATE is returned.\n
+After you start a time-shift playing channel by calling this API, the corresponding recording channel cannot be stopped or destroyed until time-shift playing stops.
+CNcomment:不推荐使用此接口，保留此接口只是为了保持与老接口的兼容，推荐使用HI_UNF_PVR_PlayCreateChn后再调用HI_UNF_PVR_PlayStartChn启动播放，如果要进行时移，
+只需要设置播放的文件名与录制的文件名一样即可，PVR会自动识别相同的文件名并进入时移状态。
+调用此接口可以直接启动1路时移播放，接口内部会自动调用HI_UNF_PVR_PlayCreateChn分配播放通道，用户不需要再先调用HI_UNF_PVR_PlayCreateChn创建播放通道 \n
+调用此接口前请确保对应的录制通道已经启动，否则将会返回错误码HI_ERR_PVR_REC_INVAL_STATE \n
+调用此接口启动1路时移后，对应的录制通道将不能被停止或者销毁直到时移播放停止 CNend
+\param[out] pu32PlayChnID   ID of a playing channel CNcomment:播放通道号 CNend
+\param[in] u32RecChnID    ID of the recording channel to be time-shifted CNcomment: 需要时移的录制通道号 CNend
+\param[in] hAvplay     AVPLAY handle. It specifies the APVPLAY to be used.   CNcomment:avplay句柄，标识用哪个avplay来播放 CNend
+\param[in] hTsBuffer    TS buffer handle. It specifies that TS buffer that is used for playback. In general, the TS port corresponding to the TS buffer must be attached to the DEMUX corresponding to the AVPLAY.
+CNcomment:ts buffer句柄，标识用哪个ts buffer来回放，一般来说，此ts buffer对应的ts端口应该是绑定在hAVPlay对应的demux上的 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_NUL_PTR The pointer is null.  CNcomment:指针参数为空 CNend
+\retval ::HI_ERR_PVR_PLAY_INVALID_DMXID The DEMUX ID received during playing is incorrect. CNcomment:播放时传入了错误的DEMUX ID CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID The channel ID is invalid. CNcomment: 通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT The specified channel is not initialized. CNcomment: 指定的通道未初始化 CNend
+\retval ::HI_ERR_PVR_ALREADY  The specified channel has been started. CNcomment:指定的通道已经启动 CNend
+\retval ::HI_ERR_PVR_NO_CHN_LEFT  There is no available playing channel.CNcomment: 已经没有空闲的播放通道供分配 CNend
+\retval ::HI_ERR_PVR_REC_INVALID_STATE  The recording channel is not started.CNcomment:  录制通道没有启动 CNend
+\retval ::HI_ERR_PVR_NO_MEM   The buffer required for playing cannot be allocated due to insufficient memory.CNcomment: 内存不足，无法分配播放需要的Buffer CNend
+\retval ::HI_FAILURE This API fails to be called due to system errors. CNcomment:出现系统错误，API调用失败 CNend
+\see \n
+::HI_UNF_PVR_PlayStopTimeShift
+*/
+HI_S32 HI_UNF_PVR_PlayStartTimeShift(HI_U32 *pu32PlayChnID, HI_U32 u32RecChnID, HI_HANDLE hAvplay, HI_HANDLE hTsBuffer);
+
+/**
+\brief Stops a playing channel.  CNcomment:停止播放通道 CNend
+\attention \n
+This API must work with ::HI_UNF_PVR_PlayStartTimeShift, and this API can be only used to stop the playing channel that is started by calling ::HI_UNF_PVR_PlayStartTimeShift.
+You must call ::HI_UNF_PVR_PlayStopTimeShift rather than ::HI_UNF_PVR_PlayStopChn to stop the playing channel that is started by calling ::HI_UNF_PVR_PlayStartTimeShift.
+
+CNcomment:此接口与::HI_UNF_PVR_PlayStartTimeShift接口必须配对使用，此接口只能停止使用::HI_UNF_PVR_PlayStartTimeShift启动的播放通道 \n
+通过::HI_UNF_PVR_PlayStartTimeShift接口启动的播放通道必须使用此接口来停止，而不允许用::HI_UNF_PVR_PlayStopChn接口来停止 CNend
+\param[in] u32PlayChnID Channel ID  CNcomment:通道号 CNend
+\param[in] pstStopOpt  Pointer to the attribute structure when the AVPLAY stops CNcomment:停止的属性设置 CNend
+\retval ::HI_SUCCESS  SuccessCNcomment: 成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT        The PVR recording module is not initialized. CNcomment: PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID        The channel ID is invalid. CNcomment:  通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT       The specified channel is not initialized.   CNcomment: 指定的通道未初始化 CNend
+\retval ::HI_ERR_PVR_ALREADY            The specified channel has been started.  CNcomment: 指定的通道已经启动 CNend
+\retval ::HI_ERR_PVR_PLAY_INVALID_STATE    The channel status is incorrect. For example, you call this API to stop the playing channel that is started by calling HI_UNF_PVR_PlayStartChn.
+CNcomment:通道状态错误。例如：对用::HI_UNF_PVR_PlayStartChn启动的播放通道调用此接口 CNend
+\see \n
+::HI_UNF_PVR_PlayStartTimeShift
+*/
+HI_S32 HI_UNF_PVR_PlayStopTimeShift(HI_U32 u32PlayChnID, const HI_UNF_AVPLAY_STOP_OPT_S *pstStopOpt);
+
+/**
+\brief Sets the attributes of a playing channel. CNcomment:设置播放通道属性 CNend
+\attention \n
+You can set the dynamic attributes only by calling this API.
+CNcomment:只有动态属性才能通过此接口进行设置，由于目前都是动态属性，所以此接口暂时不提供设置功能。 CNend
+\param[in] u32ChnID    Channel ID CNcomment: 通道号 CNend
+\param[in] pstPlayAttr  Pointer to the channel attributes to be set  CNcomment:指针类型，指向要设置的通道属性配置 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized. CNcomment:PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID The channel ID is invalid.  CNcomment:通道号非法 CNend
+\retval ::HI_ERR_PVR_NOT_SUPPORT  The function is not supported. CNcomment:功能不支持 CNend
+\see \n
+::HI_UNF_PVR_PlayGetChn
+*/
+HI_S32 HI_UNF_PVR_PlaySetChn(HI_U32 u32ChnID, const HI_UNF_PVR_PLAY_ATTR_S *pstPlayAttr);
+
+/**
+\brief  Obtains the attributes of a playing channel. CNcomment:获取播放通道属性 CNend
+\attention \n
+N/A
+\param[in] u32ChnID   Channel ID CNcomment:CNcomment:通道号 CNend
+\param[out] pstPlayAttr   Pointer to the obtained channel attributes CNcomment:指针类型，指向获取到的通道属性配置 CNend
+\retval ::HI_SUCCESS  Success CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT   The PVR recording module is not initialized.CNcomment: PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID   The channel ID is invalid. CNcomment:  通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT   The specified channel is not initialized. CNcomment: 指定的通道未初始化 CNend
+\retval ::HI_ERR_PVR_NUL_PTR      The pointer is null.  CNcomment:  指针参数为空 CNend
+\see \n
+::HI_UNF_PVR_PlaySetChn
+*/
+HI_S32 HI_UNF_PVR_PlayGetChn(HI_U32 u32ChnID, HI_UNF_PVR_PLAY_ATTR_S *pstPlayAttr);
+
+/**
+\brief  Starts a playing channel. CNcomment:启动播放通道 CNend
+\attention \n
+You can call this API to start the channel that is created by calling ::HI_UNF_PVR_PlayCreateChn only once. To pause or resume playing,
+you need to call ::HI_UNF_PVR_PlayPauseChn and ::HI_UNF_PVR_PlayResumeChn respectively.
+CNcomment:调用::HI_UNF_PVR_PlayCreateChn申请的通道只能通过此接口启动一次，如果想要暂停/恢复播放，
+需使用::HI_UNF_PVR_PlayPauseChn和::HI_UNF_PVR_PlayResumeChn接口 CNend
+\param[in] u32ChnID Channel ID  CNcomment:通道号 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT     The PVR recording module is not initialized.  CNcomment:PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID     The channel ID is invalid.  CNcomment: 通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT    The specified channel is not initialized. CNcomment:  指定的通道未初始化 CNend
+\retval ::HI_ERR_PVR_ALREADY        The specified channel has been started.   CNcomment: 指定的通道已经启动 CNend
+\retval ::HI_FAILURE                 This API fails to be called due to system errors. CNcomment: 出现系统错误，API调用失败 CNend
+\see \n
+::HI_UNF_PVR_PlayStopChn
+*/
+HI_S32 HI_UNF_PVR_PlayStartChn(HI_U32 u32ChnID);
+
+/**
+\brief  Stops a playing channel. CNcomment:停止播放通道 CNend
+\attention \n
+This API must work with ::HI_UNF_PVR_PlayStartChn, and this API can be only used to stop the playing channel that is started by calling HI_UNF_PVR_PlayStartChn.
+You must call ::HI_UNF_PVR_PlayStopChn rather than HI_UNF_PVR_PlayStopTimeShift to stop the playing channel that is started by calling HI_UNF_PVR_PlayStartChn.
+CNcomment:此接口与::HI_UNF_PVR_PlayStartChn接口必须配对使用，此接口只能停止使用::HI_UNF_PVR_PlayStartChn启动的播放通道 \n
+通过::HI_UNF_PVR_PlayStartChn接口启动的播放通道必须使用此接口来停止，而不允许用::HI_UNF_PVR_PlayStopTimeShift接口来停止 CNend
+\param[in] u32ChnID  Channel ID CNcomment:通道号 CNend
+\param[in] pstStopOpt  Pointer to the attribute structure when the AVPLAY stops  CNcomment:停止的属性设置 CNend
+\retval ::HI_SUCCESS  Success CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT    The PVR recording module is not initialized. CNcomment: PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID     The channel ID is invalid.  CNcomment: 通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT    The specified channel is not initialized.  CNcomment: 指定的通道未初始化 CNend
+\retval ::HI_ERR_PVR_ALREADY        The specified channel has been started.  CNcomment:  指定的通道已经启动 CNend
+\retval ::HI_ERR_PVR_PLAY_INVALID_STATE The channel status is incorrect. For example, you call this API to stop the playing channel that is started by calling HI_UNF_PVR_PlayStartTimeShift.
+CNcomment:通道状态错误。例如：对用::HI_UNF_PVR_PlayStartTimeShift启动的播放通道调用此接口 CNend
+\see \n
+::HI_UNF_PVR_PlayStartChn
+*/
+HI_S32 HI_UNF_PVR_PlayStopChn(HI_U32 u32ChnID, const HI_UNF_AVPLAY_STOP_OPT_S *pstStopOpt);
+
+/**
+\brief  Pauses a playing channel. CNcomment:暂停播放通道 CNend
+\attention \n
+If you call this API when the channel is paused, the error code HI_SUCCESS is returned.\n
+If you call this API is called when the channel is stopped, the error code HI_ERR_PVR_PLAY_INVALID_STATE is returned.
+CNcomment:在通道已经暂停的情况下再次调用::HI_UNF_PVR_PlayPauseChn暂停通道将返回成功 \n
+在通道已经被停止的情况下调用此接口暂停通道将返回错误码::HI_ERR_PVR_PLAY_INVALID_STATE CNend
+\param[in] u32ChnID  Channel ID  CNcomment:通道号 CNend
+\retval ::HI_SUCCESS  Success CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT      The PVR recording module is not initialized. CNcomment:  PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID     The channel ID is invalid.  CNcomment:  通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT       The specified channel is not initialized.  CNcomment:指定的通道未初始化 CNend
+\retval ::HI_ERR_PVR_PLAY_INVALID_STATE   The channel status is incorrect, that is , the channel has been stopped. CNcomment: 通道状态错误：通道已经停止运行 CNend
+\see \n
+::HI_UNF_PVR_PlayResumeChn
+*/
+HI_S32 HI_UNF_PVR_PlayPauseChn(HI_U32 u32ChnID);
+
+/**
+\brief Resumes a playing channel. You can resume a playing channel or enable a playing channel to exit the pause mode by calling this API.
+CNcomment:恢复播放通道。调用此接口可以恢复播放通道，解除播放通道的暂停状态 CNend
+\attention \n
+This API must work with HI_UNF_PVR_PlayPauseChn. In addition, a channel can be resumed only when it is paused.
+CNcomment:此接口与::HI_UNF_PVR_PlayPauseChn接口必须配对使用，只有在通道已经暂停的情况下才允许恢复通道 CNend
+\param[in] u32ChnID Channel ID  CNcomment:通道号 CNend
+\retval ::HI_SUCCESS Success  CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT       The PVR recording module is not initialized.  CNcomment:PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID      The channel ID is invalid.   CNcomment:通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT     The specified channel is not initialized.   CNcomment:指定的通道未初始化 CNend
+\retval ::HI_ERR_PVR_PLAY_INVALID_STATE The specified channel is not paused.   CNcomment:指定的通道不在暂停状态 CNend
+\see \n
+::HI_UNF_PVR_PlayPauseChn
+*/
+HI_S32 HI_UNF_PVR_PlayResumeChn(HI_U32 u32ChnID);
+
+/**
+\brief Starts the trick playing mode. You can call this API to start the trick playing mode. In this mode, the operations include fast forward, fast backward, slow playing, and normal playing.
+CNcomment:进行特技播放。调用此接口可以进行特技播放，即进行快进、快退、慢放、正常播放等操作 CNend
+\attention \n
+If you want to switch the trick playing mode to the normal playing mode, you only need to the playing speed in trick playing mode to PVR_PLAY_SPEED_NORMAL.
+CNcomment:进入特技播放模式后，如果想退回正常播放模式，只需要设置特技播放模式的速度为PVR_PLAY_SPEED_NORMAL CNend
+\param[in] u32ChnID      Channel ID CNcomment: 通道号 CNend
+\param[in] pstTrickMode   Pointer to the information about the trick playing mode  CNcomment:特技播放模式信息指针 CNend
+\retval ::HI_SUCCESS   Success  CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT        The PVR recording module is not initialized.   CNcomment:PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID     The channel ID is invalid.      CNcomment:通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT       The specified channel is not initialized.   CNcomment:指定的通道未初始化 CNend
+\retval ::HI_ERR_PVR_PLAY_INVALID_STATE   The channel status is incorrect, that is , the channel has been stopped.  CNcomment:通道状态错误：通道已经停止运行 CNend
+\retval ::HI_ERR_DMX_INVALID_PARA      The parameter is invalid.     CNcomment:参数非法 CNend
+\retval ::HI_ERR_PVR_NOT_SUPPORT    The trick playing mode is not supported.  CNcomment:不支持的特技播放模式 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_PlayTPlay(HI_U32 u32ChnID, const HI_UNF_PVR_PLAY_MODE_S *pstTrickMode);
+
+/**
+\brief Seeks a specified position to play, seeks by size and frame is not supported currently. CNcomment:定位到指定位置进行播放,暂不支持按照大小和帧数进行定位 CNend
+\attention \n
+If you call this API when the channel is disabled, the error code :HI_ERR_PVR_PLAY_INVALID_STATE is returned.\n
+If the sought position is out of the boundary, the position is adjusted to the boundary automatically.\n
+If you seek the position backward or from the start of a file, the next I frame in the corresponding position is sought. Otherwise, the previous I frame is sought.\n
+If you seek the position forward or from the end of a file, the previous I frame in the corresponding position is sought. Otherwise, the next I frame is sought.\n
+If no I frame is found, an error code is returned.
+CNcomment:在通道已经停止的情况下调用本接口将返回错误码::HI_ERR_PVR_PLAY_INVALID_STATE\n
+seek时如果超过边界，自动调整到边界\n
+向后seek和从开始seek，则seek到对应位置的下一个I帧，不成功则找前一个I帧\n
+向前seek和从结尾seek，则seek到对应位置的前一个I帧，不成功则找下一个I帧\n
+找不到I帧会返回错误 CNend
+\param[in] u32ChnID  Channel ID  CNcomment:通道号 CNend
+\param[in] pstPosition Pointer to the playing position.  CNcomment:播放位置信息指针 CNend
+\retval ::HI_SUCCESS  Success  CNcomment: 成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT        The PVR recording module is not initialized.  CNcomment:PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID        The channel ID is invalid.   CNcomment:通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT       The specified channel is not initialized.   CNcomment:指定的通道未初始化 CNend
+\retval ::HI_ERR_PVR_PLAY_INVALID_STATE  The channel status is incorrect, that is , the channel has been stopped.  CNcomment: 通道状态错误：通道已经停止运行 CNend
+\retval ::HI_ERR_DMX_INVALID_PARA       The parameter is invalid.   CNcomment: 参数非法 CNend
+\retval ::HI_ERR_PVR_NOT_SUPPORT     The seek mode is not supported.   CNcomment:不支持的Seek模式 CNend
+\retval ::HI_ERR_PVR_FILE_TILL_END       No corresponding frame is sought till the end of a file.  CNcomment:Seek到文件尾没有找到相应的帧 CNend
+\retval ::HI_ERR_PVR_FILE_TILL_START   No corresponding frame is sought till the start of a file.    CNcomment:Seek到文件头没有找到相应的帧 CNend
+\retval ::HI_ERR_PVR_FILE_CANT_READ     The file cannot be read.   CNcomment:读取文件失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_PlaySeek(HI_U32 u32ChnID, const HI_UNF_PVR_PLAY_POSITION_S *pstPosition);
+
+/**
+\brief Plays streams by frame. You can call this API to start step forward mode or step backward mode.
+CNcomment: 逐帧播放。调用此接口可以进行逐帧倒退或者逐帧前进播放 CNend
+\attention \n
+Step backward mode is not supported currently. CNcomment:目前暂时不支持逐帧倒播 CNend
+\param[in] u32ChnID     Channel ID  CNcomment:通道号 CNend
+\param[in] s32Direction  Playing direction. If the value is greater than or equal to 0, the direction is forward; if the value is less than 0, the direction is backward. CNcomment:  播放方向。大于等于0表示前进；小于0表示后退 CNend
+\retval ::HI_SUCCESS  Success  CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT        The PVR recording module is not initialized. CNcomment: PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID      The channel ID is invalid.    CNcomment: 通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT       The specified channel is not initialized.  CNcomment: 指定的通道未初始化 CNend
+\retval ::HI_ERR_PVR_PLAY_INVALID_STATE   The channel status is incorrect, that is , the channel has been stopped. CNcomment: 通道状态错误：通道已经停止运行 CNend
+\retval ::HI_ERR_PVR_NOT_SUPPORT   This function is not supported.  CNcomment:不支持的功能 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_PlayStep(HI_U32 u32ChnID, HI_S32 s32Direction);
+
+/**
+\brief Obtains the playing status of the PVR. CNcomment:获取PVR回放的状态 CNend
+\attention \n
+Before calling this API to obtain the playing status, you must create a player.
+CNcomment:获取播放的状态，注意在播放器创建之后调用 CNend
+\param[in] u32ChnID
+\param[in] pstStatus
+\retval ::HI_SUCCESS Success  CNcomment: 成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized CNcomment: PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID The channel ID is invalid.  CNcomment:通道号非法 CNend
+\retval ::HI_ERR_PVR_BUSY   The system is busy. Please try again later. CNcomment:系统忙，遇到这种情况，请重试。 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_PlayGetStatus(HI_U32 u32ChnID, HI_UNF_PVR_PLAY_STATUS_S *pstStatus);
+
+/**
+\brief Obtains the information about the stream file recorded by the PVR based on the ID of the playing channel.  CNcomment:通过播放通道ID，获取PVR录制的码流文件信息 CNend
+\attention \n
+You can call this API to obtain the fixed information about the file to be played. However, the information is variable in the time-shift scenario.
+You can call ::HI_UNF_PVR_PlayGetStatus to obtain the current playing position during playing.\n
+You can call ::HI_UNF_PVR_RecGetStatus to obtain the current recording position during time shifting.
+In addition, if both recording and playing do not start, you can call ::HI_UNF_PVR_GetFileAttrByFileName to obtain the attributes of a file.
+CNcomment: 调用此接口用来获取播放文件的固定信息，但是对于时移场景这些信息是不断变化的
+在播放过程中可以通过::HI_UNF_PVR_PlayGetStatus接口获取当前的播放位置 \n
+在时移过程中可以通过::HI_UNF_PVR_RecGetStatus接口获取当前的录制位置
+此外，如果既没有启动录制也没有启动播放，可以通过::HI_UNF_PVR_GetFileAttrByFileName接口获取文件属性 CNend
+\param[in] u32ChnID  Channel ID  CNcomment:通道号 CNend
+\param[in] pAttr Pointer to the playing status
+\param[in] pAttr   CNcomment:播放状态信息指针 CNend
+\retval ::HI_SUCCESS  Success  CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT            The PVR playing module is not initialized.  CNcomment:PVR播放模块未初始化 CNend
+\retval ::HI_ERR_PVR_NUL_PTR           The pointer is null.   CNcomment: 空指针错误 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID      The channel ID is invalid.   CNcomment:通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT        The specified channel is not initialized. CNcomment: 指定的通道未初始化 CNend
+\retval ::HI_ERR_PVR_FILE_CANT_OPEN      The file cannot be opened.  CNcomment:无法打开文件 CNend
+\retval ::HI_ERR_PVR_FILE_CANT_READ    The file cannot be read.   CNcomment: 无法读文件 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_PlayGetFileAttr(HI_U32 u32ChnID, HI_UNF_PVR_FILE_ATTR_S *pAttr);
+
+/**
+\brief
+Obtains the information about a stream file.
+By calling this API, you can obtain the information about a specified stream file without creating a playing channel.
+CNcomment:获取码流文件信息。调用此接口可以在不申请播放通道的情况下获取指定码流文件的信息 CNend
+\attention \n
+pFileName points to the name of a stream file rather than an index file.\n
+You can call this API to obtain the attributes of a stream file at any time.
+CNcomment:指向码流文件名而不是索引文件名.任何时候都可以调用此接口获取码流文件的属性 CNend
+\param[in] pFileName Name of a stream file  CNcomment:码流文件名 CNend
+\param[in] pAttr   Pointer to the playing status   CNcomment:播放状态信息指针 CNend
+\retval ::HI_SUCCESS  Success  CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_NUL_PTR       The pointer is null.    CNcomment:空指针错误 CNend
+\retval ::HI_ERR_PVR_FILE_CANT_OPEN  The file cannot be opened.  CNcomment:无法打开文件 CNend
+\retval ::HI_ERR_PVR_FILE_CANT_READ   The file cannot be read. CNcomment:无法读文件 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_GetFileAttrByFileName(const HI_CHAR *pFileName, HI_UNF_PVR_FILE_ATTR_S *pAttr);
+
+/**
+\brief  Writes the user data. CNcomment: 写入用户数据 CNend
+\attention \n
+pFileName points to the name of a stream file rather than an index file.\n
+The value of u32UsrDataLen cannot be greater than that of u32UsrDataInfoSize. The value of u32UsrDataInfoSize (one of recording channel attributes) is set before a file is recorded.
+The user data is saved in the index file.\n
+You need to write the user data after starting a recording channel.
+CNcomment:pFileName指向码流文件名而不是索引文件名 \n
+u32UsrDataLen的取值不能大于录制此文件时在录制通道属性里面指定的u32UsrDataInfoSize的取值 \n
+用户数据被保存在索引文件中 \n
+请在启动录制通道后再写入用户数据信息 CNend
+\param[in] pFileName Name of a stream file CNcomment: 码流文件名 CNend
+\param[in] pInfo    Pointer to the user data. The memory is allocated by customers. CNcomment:用户数据指针，空间由用户分配 CNend
+\param[in] u32UsrDataLen   Length of the user data CNcomment: 用户数据长度 CNend
+\retval ::HI_SUCCESS  Success  CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_NUL_PTR       The pointer is null.   CNcomment: 空指针错误 CNend
+\retval ::HI_ERR_PVR_FILE_CANT_OPEN   The file cannot be opened.CNcomment:无法打开文件 CNend
+\retval ::HI_ERR_PVR_FILE_CANT_READ  The file cannot be read.  CNcomment:无法读文件 CNend
+\retval ::HI_ERR_DMX_INVALID_PARA    The parameter is invalid.  CNcomment: 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_SetUsrDataInfoByFileName(const HI_CHAR *pFileName, HI_U8 *pInfo, HI_U32 u32UsrDataLen);
+
+/**
+\brief  Reads the user data. CNcomment: 读取用户数据 CNend
+\attention \n
+pFileName points to the name of a stream file rather than an index file.\n
+The return value of pUsrDataLen indicates the length of the obtained user data. The value is the smaller one between the values of u32BufLen and actual length of the user data.
+The actual length of the user data is greater than or equal to the maximum length of the user data set by calling HI_UNF_PVR_RecCreateChn. In this way, all user data can be read.\n
+The PVR does not save the length of the user data set by calling HI_UNF_PVR_SetUsrDataInfoByFileName, but save the maximum length of the user data set by calling HI_UNF_PVR_RecCreateChn.
+CNcomment:pFileName指向码流文件名而不是索引文件名 \n
+pUsrDataLen返回读取到的用户数据的长度，其取值为u32BufLen和"实际用户数据长度"二者中的较小值。
+"实际用户数据长度"将不小于HI_UNF_PVR_RecNewChn时配置的最大用户数据长度，以保证能够把全部用户数据读出 \n
+PVR模块不保存HI_UNF_PVR_SetUsrDataInfoByFileName时传入的用户数据长度，只保存HI_UNF_PVR_RecNewChn时配置的最大用户数据长度 CNend
+\param[in] pFileName    Name of a stream file CNcomment:码流文件名 CNend
+\param[in] pInfo    User data buffer. The memory is allocated by customers.   CNcomment:用户数据缓冲区，空间由用户分配 CNend
+\param[in] u32BufLen   Buffer length .CNcomment:缓冲区长度 CNend
+\param[in] pUsrDataLen Actual length of the obtained user data .CNcomment:实际读取到的用户数据长度 CNend
+\retval ::HI_SUCCESS  Success  CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_NUL_PTR        The pointer is null.      CNcomment: 空指针错误 CNend
+\retval ::HI_ERR_PVR_FILE_CANT_OPEN    The file cannot be opened. CNcomment:无法打开文件 CNend
+\retval ::HI_ERR_PVR_FILE_CANT_READ    The file cannot be read.  CNcomment:无法读文件 CNend
+\retval ::HI_ERR_DMX_INVALID_PARA      The parameter is invalid.  CNcomment: 参数非法 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_GetUsrDataInfoByFileName(const HI_CHAR *pFileName, HI_U8 *pInfo, HI_U32 u32BufLen, HI_U32* pUsrDataLen);
+
+/**
+\brief  Registers an event callback function. You can call this API to register a callback function for PVR event. In this way, you can handle the events occurred during PVR recording and playing.
+CNcomment: 注册事件回调函数。调用此接口可以注册PVR事件的回调函数，从而对PVR录制、播放过程中产生的事件进行处理 CNend
+\attention \n
+You can call ::HI_UNF_PVR_UnRegisterEvent to deregister an event. If a registered event is not deregistered, it is always valid.
+For the PVR_EVENT_PLAY_REACH_REC message, it is recommended to stop the playing of the PVR by calling the registered callback function, and switch the playing mode to live mode of the AVPLAY.
+If the recording attribute is set to non-rewind, the PVR_EVENT_REC_OVER_FIX message is reported at the end of recording when the recording length reaches the specified length.
+When the recording attribute is set to rewind, the PVR_EVENT_REC_OVER_FIX message is reported during each rewind. In this case, the value of s32EventValue of the message handling callback function is the times of rewind (counting from 1).
+The PVR_EVENT_REC_REACH_PLAY message is reported when the recording speed will reach the playing speed. In this case, the value of s32EventValue is the number of bytes between the recording position and the playing position.
+CNcomment: 可以使用::HI_UNF_PVR_UnRegisterEvent来反注册1个事件，否则已经注册的事件将一直保持有效
+对于PVR_EVENT_PLAY_REACH_REC消息，建议用户在注册的回调函数中停止PVR播放，并切换到直播模式用AVPLAY进行播放。
+当录制属性配置为不回绕的时候，PVR_EVENT_REC_OVER_FIX消息在录制长度到达指定长度，即将停止录制的时候上报；
+当录制属性配置为回绕的时候，PVR_EVENT_REC_OVER_FIX消息在每次回绕的时候都会上报，此时，消息处理回调函数的s32EventValue参数值为回绕的次数(从1开始计数)。
+PVR_EVENT_REC_REACH_PLAY消息在录制即将追上播放的时候上报，此时，消息处理回调函数的s32EventValue参数值为录制位置距离播放位置的字节数。 CNend
+\param[in] enEventType  Type of the event to be registered.  CNcomment: 想要注册的事件类型 CNend
+\param[in] callBack   Event handling callback function.   CNcomment: 事件处理函数 CNend
+\param[in] args      Parameters of a customized callback function.    CNcomment:用户自定义回调函数的参数 CNend
+\retval ::HI_SUCCESS   Success CNcomment: 成功 CNend
+\retval ::HI_ERR_PVR_INTF_EVENT_INVAL   The event is invalid.  CNcomment: 非法的事件 CNend
+\retval ::HI_ERR_PVR_ALREADY         The registering event has been registered.    CNcomment: 尝试对已经注册的事件再次注册 CNend
+\retval ::HI_ERR_PVR_INTF_EVENT_NOREG    Registration fails because the callback function pointer is incorrect. CNcomment:  回调函数指针出错，无法注册成功 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_RegisterEvent(HI_UNF_PVR_EVENT_E enEventType, eventCallBack callBack, HI_VOID *args);
+
+/**
+\brief  Deregisters a PVR event. CNcomment: 去注册PVR事件的回调函数 CNend
+\attention \n
+You can call this API to deregister an event. If a registered event is not deregistered, it is always valid.
+CNcomment: 可以使用此接口来去注册1个事件，否则已经注册的事件将一直保持有效 CNend
+\param[in] enEventType      Type of the event to be deregistered    CNcomment: 想要去注册的事件类型 CNend
+\retval ::HI_SUCCESS   Success  CNcomment:成功 CNend
+\retval ::HI_ERR_PVR_INTF_EVENT_INVAL  The event is invalid. CNcomment: 非法的事件 CNend
+\retval ::HI_ERR_PVR_INTF_EVENT_NOREG  The deregistering event is not registered. CNcomment: 对没有注册的事件进行去注册 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_UnRegisterEvent(HI_UNF_PVR_EVENT_E enEventType);
+
+/**
+\brief Create index file by ts file. CNcomment:根据码流文件创建索引文件 CNend
+\attention \n
+This function is not supported currently.
+CNcomment: 暂时不支持此功能 CNend
+\param[in] pstTsFileName
+\param[in] pstIdxFileName
+\param[in] pAttr
+\retval ::HI_SUCCESS Success CNcomment:  成功 CNend
+\retval ::HI_ERR_PVR_NOT_SUPPORT  This function is not supported. CNcomment: 不支持此功能 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_CreateIdxFile(HI_U8* pstTsFileName, HI_U8* pstIdxFileName, HI_UNF_PVR_GEN_IDX_ATTR_S* pAttr);
+
+/**
+\brief Controls whether to output debugging information.  CNcomment:配置是否输出调试信息 CNend
+\attention \n
+The debugging information about the severity level higher than the error level is output.
+CNcomment:默认输出error 以上级别的调试信息。注意和全局打印级别配合使用，即此级别需要小于等于全局打印级别才有效 CNend
+\param[in] enDebugLevel  Output level of the debugging information CNcomment: 调试信息输出级别 CNend
+\retval none
+\see \n
+N/A
+*/
+HI_VOID HI_UNF_PVR_ConfigDebugInfo(HI_LOG_LEVEL_E enDebugLevel);
+
+/**
+\brief  Deletes the stream files and index files generated during recording. CNcomment:删除录制时生成的码流文件和索引文件 CNend
+\attention \n
+pFileName points to the name of a stream file rather than an index file.\n
+After this API is called, the stream files and index files generated during stream recording are deleted.
+If a stream file is greater than 4 GB, multiple files named data.ts, data.ts.0001, data.ts.0002, data.ts.0003, and ... are generated. To delete these files, you only need to enter the file name data.ts.
+CNcomment:pFileName指向码流文件名而不是索引文件名\n
+调用此接口后，录制此码流时生成的码流文件和索引文件都将被删除\n
+如果码流文件大于4G将会生成data.ts, data.ts.0001, data.ts.0002, data.ts.0003 ...\n
+等多个文件，但是删除时只需要传入文件名"data.ts"就可以了。 CNend
+\param[in] pFileName  Name of a stream file  CNcomment:码流文件名 CNend
+\retval none
+\see \n
+N/A
+*/
+HI_VOID HI_UNF_PVR_RemoveFile(const HI_CHAR *pFileName);
+
+
+/**
+\brief
+Register extra write callback function.When the stream file need to be extra processed  CNcomment: 注册外部读、写数据回调函数。当文件需要特殊处理时注册，如私有协议加扰的节目。 CNend
+\attention \n
+N/A
+\param[in] u32ChnID    Channel ID  CNcomment:通道号 CNend
+\param[in] enExtraCallbackType  Callback function type CNcomment: 回调函数类型 CNend
+\retval ::HI_SUCCESS Success  CNcomment: 成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized CNcomment: PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID The channel ID is invalid.  CNcomment:通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT   Specified channel is not initialized   CNcomment:   指定的通道未初始? CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_RegisterExtraCallback(HI_U32 u32ChnID, HI_UNF_PVR_EXTRA_CALLBACK_E enExtraCallbackType, ExtraCallBack fCallback, HI_VOID *args);
+
+/**
+\brief Deregisters extra write callback function.When the stream file need to be extra processed  CNcomment:去注册外部读、写数据回调函数。 CNend
+\attention \n
+N/A
+\param[in] u32ChnID  Channel ID  CNcomment:通道号 CNend
+\param[in] enExtraCallbackType  Callback function type CNcomment: 回调函数类型 CNend
+\retval ::HI_SUCCESS Success  CNcomment: 成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized CNcomment: PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID The channel ID is invalid.  CNcomment:通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT   Specified channel is not initialized   CNcomment:   指定的通道未初始化 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_UnRegisterExtraCallBack(HI_U32 u32ChnID, HI_UNF_PVR_EXTRA_CALLBACK_E enExtraCallbackType);
+
+/**
+\brief
+Register extra write callback function.When the stream file need to be extra processed  CNcomment: 注册外部读、写数据回调函数。当文件需要特殊处理时注册，如私有协议加扰的节目。 CNend
+\attention \n
+N/A
+\param[in] u32ChnID    Channel ID  CNcomment:通道号 CNend
+\param[in] enExtraCallbackType  Callback function type CNcomment: 回调函数类型 CNend
+\param[in] fCallback  Callback function CNcomment: 回调函数CNend
+\param[in] pUserData  arguments of the Callback function CNcomment: 回调函数的用户参数CNend
+\retval ::HI_SUCCESS Success  CNcomment: 成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized CNcomment: PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID The channel ID is invalid.  CNcomment:通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT   Specified channel is not initialized   CNcomment:   指定的通道未初始? CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_RegisterExtendCallback(HI_U32 u32ChnID, HI_UNF_PVR_EXTRA_CALLBACK_E enExtraCallbackType, ExtendCallBack fCallback, HI_VOID *pUserData);
+
+/**
+\brief Deregisters extra write callback function.When the stream file need to be extra processed  CNcomment:去注册外部读、写数据回调函数。 CNend
+\attention \n
+N/A
+\param[in] u32ChnID  Channel ID  CNcomment:通道号 CNend
+\param[in] enExtraCallbackType  Callback function type CNcomment: 回调函数类型 CNend
+\param[in] fCallback  Callback function CNcomment: 回调函数 CNend
+\retval ::HI_SUCCESS Success  CNcomment: 成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized CNcomment: PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID The channel ID is invalid.  CNcomment:通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT   Specified channel is not initialized   CNcomment:   指定的通道未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_PARA   invalid input param, E.x.   fCallback hasn't been registered before CNcomment:   非法输入参数，如输入函数指针未被注册CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_UnRegisterExtendCallback(HI_U32 u32ChnID, HI_UNF_PVR_EXTRA_CALLBACK_E enExtraCallbackType, ExtendCallBack fCallback);
+
+/**
+\brief register the callback function Which is called by PVR when the app informs pvr to change the recorded pids CNcomment:注册PID变更回调函数CNend
+\attention \n
+N/A
+\param[in] u32ChnID  Channel ID  CNcomment:通道号 CNend
+\param[in] enExtraCallbackType  Callback function type CNcomment: 回调函数类型 CNend
+\param[in] fCallback  Callback function CNcomment: 回调函数 CNend
+\param[in] pArgs  Callback function's parameters CNcomment: 回调函数需要的参数 CNend
+\retval ::HI_SUCCESS Success  CNcomment: 成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized CNcomment: PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID The channel ID is invalid.  CNcomment:通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT   Specified channel is not initialized   CNcomment:   指定的通道未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_PARA   invalid input param, E.x.   fCallback hasn't been registered before CNcomment:   非法输入参数，如输入函数指针未被注册CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PVR_RegisterPidChangeCallback(HI_U32 u32ChnID, HI_UNF_PVR_EXTRA_CALLBACK_E enExtraCallbackType, PidChangeCallBack fCallback, HI_VOID *pArgs);
+
+/**
+\brief unregister the callback function which is called by PVR when the app informs pvr to change the recorded pids  CNcomment:去注册PID变更回调函数 CNend
+\attention \n
+N/A
+\param[in] u32ChnID  Channel ID  CNcomment:通道号 CNend
+\param[in] enExtraCallbackType  Callback function type CNcomment: 回调函数类型 CNend
+\param[in] fCallback  Callback function CNcomment: 回调函数 CNend
+\retval ::HI_SUCCESS Success  CNcomment: 成功 CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR recording module is not initialized CNcomment: PVR录制模块未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID The channel ID is invalid.  CNcomment:通道号非法 CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT   Specified channel is not initialized   CNcomment:   指定的通道未初始化 CNend
+\retval ::HI_ERR_PVR_INVALID_PARA   invalid input param, E.x.   fCallback hasn't been registered before CNcomment:   非法输入参数，如输入函数指针未被注册CNend
+\see \n
+N/A
+*/
+
+HI_S32 HI_UNF_PVR_UnRegisterPidChangeCallback(HI_U32 u32ChnID, HI_UNF_PVR_EXTRA_CALLBACK_E enExtraCallbackType, PidChangeCallBack fCallback);
+
+
+
+/**
+\brief create pid channel and create the binding relationship of rec channel.  CNcomment:创建PID  通道并建立与录制通道的绑定关系。 CNend
+\attention \n
+You can call this api after creating the rec channl successfully.  CNcomment:该接口必须在成功创建录制通道后被调用
+\param[in] u32ChnID  Channel ID  CNcomment:通道号 CNend
+\param[in] u32Pid  PID value CNcomment: PID 值 CNend
+\retval ::HI_SUCCESS  Success. CNcomment: 成功。CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID  The recorde channel ID is invalid. CNcomment: 通道号非法。CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT  The recorde channel is not initialized. CNcomment:   指定的通道未初始化。CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The recorde channel is not initialized. CNcomment: PVR录制模块未初始化。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment: 模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment: 输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment: 指针参数为空。CNend
+\retval ::HI_ERR_DMX_NOT_SUPPORT  This function is not supported. CNcomment: 不支持此功能。CNend
+\retval ::HI_FAILUER  Call the function failed!. CNcomment:执行失败CNend
+\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecAddPID(HI_U32 u32ChnID, HI_U32 u32Pid);
+
+/**
+\brief destroy pid channel and destroy the relationship with rec channel.  CNcomment:销毁PID  通道并解除与录制通道的绑定关系。 CNend
+\attention \n
+You can call this api before destroying the rec channl.  CNcomment:该接口必须在销毁录制通道前被调用
+\param[in] u32ChnID  Channel ID  CNcomment:通道号 CNend
+\param[in] u32Pid  PID value CNcomment: PID 值 CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID  The recorde channel ID is invalid. CNcomment: 通道号非法。CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT  The recorde channel is not initialized. CNcomment:   指定的通道未初始化。CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The recorde channel is not initialized. CNcomment: PVR录制模块未初始化。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment: 模块没有初始化。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\retval ::HI_FAILUER  Call the function failed!. CNcomment:执行失败CNend
+\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecDelPID(HI_U32 u32ChnID, HI_U32 u32Pid);
+
+/**
+\brief destroy any pid channel which has binding relationship with rec channel.  CNcomment:销毁所有与录制通道有绑定关系的PID 通道。 CNend
+\attention \n
+
+\param[in] u32ChnID  Channel ID  CNcomment:通道号 CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILUER  Call the function failed!. CNcomment:执行失败CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID  The recorde channel ID is invalid. CNcomment: 通道号非法。CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT  The recorde channel is not initialized. CNcomment:   指定的通道未初始化。CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The recorde channel is not initialized. CNcomment: PVR录制模块未初始化。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment: 模块没有初始化。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_DMX_INVALID_PARA  The input parameter is invalid. CNcomment:输入参数非法。CNend
+\retval ::HI_ERR_DMX_NULL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecDelAllPID(HI_U32 u32ChnID);
+
+/**
+\brief change the record pid.  CNcomment: 变更录制的Pid。 CNend
+\attention \n
+\param[in] u32ChnId  Channel ID  CNcomment:通道号 CNend
+\param[in] pstPidInfo  PID info  CNcomment: 变更的PID信息 CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILUER  Call the function failed!. CNcomment:执行失败CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID  The recorde channel ID is invalid. CNcomment: 通道号非法。CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT  The recorde channel is not initialized. CNcomment:   指定的通道未初始化。CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The recorde channel is not initialized. CNcomment: PVR录制模块未初始化。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment: 模块没有初始化。CNend
+\retval ::HI_ERR_DMX_NOT_INIT  The DEMUX module is not initialized. CNcomment:模块没有初始化。CNend
+\retval ::HI_ERR_PVR_NUL_PTR  The pointer is null. CNcomment:指针参数为空。CNend
+\see \n\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecChangePid(HI_U32 u32ChnId, HI_UNF_PVR_PID_CHANGE_INFO_S *pstPidInfo);
+
+/**
+\brief Set the recording channel attribute, only supports the rewind state is set to non-rewind state.  CNcomment: 设置录制通道属性，目前仅支持将回绕状态设置为非回绕状态。 CNend
+\attention \n
+
+\param[in] u32ChnID  Channel ID  CNcomment:通道号 CNend
+\param[in] enRecAttrID  attribute ID  CNcomment:属性ID CNend
+\param[in] pPara  Extra parameters  CNcomment:其他用户参数 CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILUER  Call the function failed!. CNcomment:执行失败CNend
+\retval ::HI_ERR_PVR_INVALID_CHNID  The recorde channel ID is invalid. CNcomment: 通道号非法。CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT  The recorde channel is not initialized. CNcomment:   指定的通道未初始化。CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The PVR module is not initialized. CNcomment: PVR录制模块未初始化。CNend
+\retval ::HI_ERR_PVR_NOT_SUPPORT  The record channel not support this operatin. CNcomment: 当前通道不支持该操作。CNend
+\see \n\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecSetAttr(HI_U32 u32ChnID, HI_UNF_PVR_REC_ATTR_ID_E enRecAttrID, const HI_VOID *pPara);
+
+/**
+\brief Be Linear.  CNcomment: 启动线性化 CNend
+\attention \n
+
+\param[out] pu32ChnId  Channel ID  CNcomment:通道号 CNend
+\param[in] pstRepaireAttr  Linearization parameters  CNcomment:线性化参数 CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILUER  Call the function failed!. CNcomment:执行失败CNend
+\retval ::HI_ERR_PVR_NUL_PTR  null pointer. CNcomment: 空指针。CNend
+\retval ::HI_ERR_PVR_INVALID_PARA  The parameter is invalid. CNcomment: 参数非法。CNend
+\retval ::HI_ERR_PVR_FILE_NOT_EXIST  The specified file does not exist. CNcomment:   指定的源文件不存在。CNend
+\retval ::HI_ERR_PVR_NOT_INIT  The recorde channel is not initialized. CNcomment: PVR录制模块未初始化。CNend
+\retval ::HI_ERR_PVR_NOT_SUPPORT  The record channel not support this operatin. CNcomment: 当前通道不支持该操作。CNend
+\retval ::HI_ERR_PVR_CHN_NOT_INIT  The recorde channel is not initialized. CNcomment:   指定的通道未初始化。CNend
+\retval ::HI_ERR_PVR_FILE_CANT_OPEN  The specified file is not open. CNcomment: 指定文件不可打开。CNend
+\retval ::HI_ERR_PVR_FILE_CANT_READ  The specified file is not readable. CNcomment: 指定文件不可读。CNend
+\see \n\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecFileStartLinearization(HI_U32 *pu32ChnId, const HI_UNF_PVR_LINEARIZATION_ATTR_S *pstRepaireAttr);
+
+/**
+\brief Get linear progress.  CNcomment: 获取线性化进度 CNend
+\attention \n
+
+\param[in] u32ChnId  Channel ID  CNcomment:通道号 CNend
+\param[out] pstLineariztionStatus  Linearization channel status  CNcomment:线性化通道状态CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILUER  Call the function failed!. CNcomment:执行失败CNend
+\retval ::HI_ERR_PVR_NUL_PTR  null pointer. CNcomment: 空指针。CNend
+\see \n\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecFileLinearizationGetStatus(HI_U32 u32ChnId, HI_UNF_PVR_LINEARIZATION_STATUS_S *pstLineariztionStatus);
+
+/**
+\brief stop Linear.  CNcomment: 停止线性化 CNend
+\attention \n
+
+\param[in] pu32ChnId  Channel ID  CNcomment:通道号 CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILUER  Call the function failed!. CNcomment:执行失败CNend
+\see \n\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecFileStopLinearization(HI_U32 u32ChnId);
+
+/**
+\brief Be Linear.  CNcomment: 对指定PVR录制文件按指定条件进行截断CNend
+\attention \n
+\param[in] pszSrcFileName  The original file name to be processed CNcomment:待处理的原文件名 CNend
+\param[in] u32SrcFileNameLen  The length of the original file name CNcomment:原文件 名长度 CNend
+\param[in] pszDstFileName  The Destination file name to be processed CNcomment:待处理的目标文件名 CNend
+\param[in] u32DstFileNameLen  The length of the Destination file name CNcomment:目标文件 名长度 CNend
+\param[in] pstTruncInfo  Pointer to the attributes of truncate CNcomment:指针类型，指向truncate属性配置CNend
+\retval ::HI_SUCCESS  Success. CNcomment:成功。CNend
+\retval ::HI_FAILUER  Call the function failed!. CNcomment:执行失败CNend
+\retval ::HI_ERR_PVR_NUL_PTR  null pointer. CNcomment: 空指针。CNend
+\retval ::HI_ERR_PVR_INVALID_PARA  The parameter is invalid. CNcomment: 参数非法。CNend
+\retval ::HI_ERR_PVR_NOT_SUPPORT  PVR does not support current operation. CNcomment: PVR当前不支持该操作。CNend
+\retval ::HI_ERR_PVR_FILE_NOT_EXIST  The specified file does not exist. CNcomment:   指定的源文件不存在。CNend
+\retval ::HI_ERR_PVR_FILE_CANT_OPEN  The specified file is not open. CNcomment: 指定文件不可打开。CNend
+\retval ::HI_ERR_PVR_FILE_CANT_READ  The specified file is not readable. CNcomment: 指定文件不可读。CNend
+\retval ::HI_ERR_PVR_NO_MEM  Failed to malloc memory. CNcomment: 申请内存失败CNend
+\retval ::HI_ERR_PVR_FILE_INVALID_FNAME  Invalid file name. CNcomment: 无效的文件名CNend
+\see \n\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecFileTruncate(const HI_CHAR *pszSrcFileName, HI_U32 u32SrcFileNameLen, const HI_CHAR *pszDstFileName, HI_U32 u32DstFileNameLen, const HI_UNF_PVR_RECFILE_TRUNCATE_INFO_S *pstTruncInfo);
+
+
+/**
+\brief notify the record channel that the stream is end, PVR will try to receive all the un-aligned by 47K ts data from demux and report
+\        the event of HI_UNF_PVR_EVENT_REC_EOS if all the ts data has been received. if this api is not called, PVR won't receive the un-aligned of 47K ts data from the demux.
+\CNcomment:通知录制通道前端数据已结束，PVR将收取demux端所有非47K对齐的数据，并且支持上报事件HI_UNF_PVR_EVENT_REC_EOS.
+\ CNcomment       如果不调用该接口，PVR不会收取demux端非47K对齐的数据.CNend
+\ attention: before calling the API, APP should make sure that no data is injected to the port of demux used by the record channel;
+\                  if this API is called, the length of ts data reported by ExtraCallBack/ExtendCallBack isn't always aligned
+\                  for the recording which the injecting data is always running(E.x. dvb/iptv recording), this API should not be called.
+\ CNcomment注意: 在调用该API之前，APP需要保证前端没有数据到达录制通道使用的demux port口CNend
+\ CNcomment              调用该函数会导致ExtraCallBack/ExtendCallBack回调上报的数据长度不一定总是对齐的.CNend
+\ CNcomment              对于头端数据不会中断的录制(如dvb/iptv录制)，不需要调用该接口.CNend
+\param[in] u32ChnId  Channel ID  CNcomment:通道号 CNend
+\param[in] pstOpt  Pointer used for expansion. You can set it to NULL  CNcomment:指针类型，待扩展使用，设为为NULL即可 CNend
+\retval ::HI_SUCCESS if successing to configure, others if failure. CNcomment:成功返回HI_SUCCESS，出错返回其他值。CNend
+\see \n\see \nN/A
+*/
+HI_S32 HI_UNF_PVR_RecFlushStream(HI_U32 u32RecChnID, HI_UNF_PVR_FLUSH_STREAM_OPT_S *pstOpt);
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* End of #ifdef __cplusplus */
+
+
+#endif /* End of #ifndef __HI_UNF_PVR_H__ */
diff -uNr a/include/hi_unf_pwm.h b/include/hi_unf_pwm.h
--- a/include/hi_unf_pwm.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_pwm.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,162 @@
+/******************************************************************************
+
+   Copyright (C), 2011-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+   File Name     : hi_unf_pwm.h
+   Version       : Initial Draft
+   Author        : Hisilicon multimedia software group
+   Created       : 2013/10/28
+   Description   :
+   History       :
+   1.Date        : 2013/10/28
+    Author      : sdk
+    Modification: Created file
+
+ *******************************************************************************/
+
+/**
+ * \file
+ **\brief : define PWM module information
+ * \brief supply infor about display.
+ */
+
+#ifndef __HI_UNF_PWM_H__
+#define __HI_UNF_PWM_H__
+
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      PWM */
+/** @{ */  /** <!-- [PWM] */
+
+/**enum define about PWM*/
+/**CNcomment: 定义PWM枚举*/
+typedef enum hiUNF_PWM_E
+{
+    HI_UNF_PWM_0 = 0,   /**< PWM0 */
+    HI_UNF_PWM_1,       /**< PWM1 */
+    HI_UNF_PWM_2,       /**< PWM2 */
+    
+    HI_UNF_PWM_BUTT
+}HI_UNF_PWM_E;
+
+/**Define the PWM attributes*/
+/**CNcomment: 定义PWM属性结构体*/
+typedef struct hiUNF_PWM_ATTR_S
+{
+    HI_U32      u32Freq;        /**< Frequency(HZ)*//**< CNcomment: 频率, 单位HZ*/
+    HI_U32      u32DutyRatio;   /**< Duty ratio(calculated to three decimal places)*//**<CNcomment: 占空比，保留小数点后三位*/
+}HI_UNF_PWM_ATTR_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      PWM */
+/** @{ */  /** <!-- [PWM] */
+
+/**
+\brief Initializes the PWM module.CNcomment:初始化PWM模块 CNend
+\attention \n
+Before calling anyother interface, you must call this application programming interface (API) first.
+CNcomment 在调用PWM模块其他接口前，要求首先调用本接口 CNend
+\param  N/A
+\retval ::HI_SUCCESS                  Success CNcomment:成功 CNend
+\retval ::HI_ERR_PWM_DEV_NOT_EXIST    There is no PWM. CNcomment:PWM设备不存在 CNend
+\retval ::HI_ERR_PWM_OPEN_ERR         Open PWM failed. CNcomment:PWM打开失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PWM_Init(HI_VOID);
+
+/**
+\brief DeInitializes the PWM module.CNcomment:去初始化PWM模块 CNend
+\attention N/A
+\param  N/A
+\retval ::HI_SUCCESS                  Success CNcomment:成功 CNend
+\retval ::HI_ERR_PWM_DEV_NOT_EXIST    There is no PWM. CNcomment:PWM设备不存在 CNend
+\retval ::HI_ERR_PWM_CLOSE_ERR        Open PWM failed. CNcomment:PWM关闭失败 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PWM_DeInit(HI_VOID);
+
+/**
+\brief Opem PWM.CNcomment:打开PWM CNend
+\attention N/A
+\param[in] enPWM  PWM device. CNcomment:PWM设备，见::HI_UNF_PWM_E CNend
+\retval ::HI_SUCCESS                  Success CNcomment:成功 CNend
+\retval ::HI_ERR_PWM_INVALID_PARA     Parameter is invalid. CNcomment:参数无效 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PWM_Open(HI_UNF_PWM_E enPWM);
+
+/**
+\brief Close PWM.CNcomment:关闭PWM CNend
+\attention N/A
+\param[in] enPWM  PWM device. CNcomment:PWM设备，见::HI_UNF_PWM_E CNend
+\retval ::HI_SUCCESS                  Success CNcomment:成功 CNend
+\retval ::HI_ERR_PWM_INVALID_PARA     Parameter is invalid. CNcomment:参数无效 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PWM_Close(HI_UNF_PWM_E enPWM);
+
+/**
+\brief Set PWM attributes.CNcomment:获取PWM属性 CNend
+\attention N/A
+\param[in] enPWM  PWM device. CNcomment:PWM设备，见::HI_UNF_PWM_E CNend
+\param[out] pstAttr  Pointer of PWM attributes. CNcomment:PWM属性指针，见::HI_UNF_PWM_ATTR_S CNend
+\retval ::HI_SUCCESS                  Success CNcomment:成功 CNend
+\retval ::HI_ERR_PWM_INVALID_PARA     Parameter is invalid. CNcomment:参数无效 CNend
+\retval ::HI_ERR_PWM_INVALID_OPT      Opration is invalid. CNcomment:操作无效 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PWM_GetAttr(HI_UNF_PWM_E enPWM, HI_UNF_PWM_ATTR_S *pstAttr);
+
+/**
+\brief Set PWM attributes.CNcomment:设置PWM属性 CNend
+\attention N/A
+\param[in] enPWM  PWM device. CNcomment:PWM设备，见::HI_UNF_PWM_E CNend
+\param[in] pstAttr  Pointer of PWM attributes. CNcomment:PWM属性指针，见::HI_UNF_PWM_ATTR_S CNend
+\retval ::HI_SUCCESS                  Success CNcomment:成功 CNend
+\retval ::HI_ERR_PWM_INVALID_PARA     Parameter is invalid. CNcomment:参数无效 CNend
+\retval ::HI_ERR_PWM_INVALID_OPT      Opration is invalid. CNcomment:操作无效 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PWM_SetAttr(HI_UNF_PWM_E enPWM, HI_UNF_PWM_ATTR_S *pstAttr);
+
+/**
+\brief Send signal to PWM.CNcomment:向PWM发送信号 CNend
+\attention N/A
+\param[in] enPWM  PWM device. CNcomment:PWM设备，见::HI_UNF_PWM_E CNend
+\param[in] u32CarrierTimeUs  The duration of carrier signal(us). CNcomment:载波信号持续时间(us) CNend
+\param[in] u32LowLevelTimeUs  The duration of low-level signal(us). CNcomment:低信号持续时间(us) CNend
+\retval ::HI_SUCCESS                  Success CNcomment:成功 CNend
+\retval ::HI_ERR_PWM_INVALID_PARA     Parameter is invalid. CNcomment:参数无效 CNend
+\retval ::HI_ERR_PWM_INVALID_OPT      Opration is invalid. CNcomment:操作无效 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_PWM_SendSignal(HI_UNF_PWM_E enPWM, HI_U32 u32CarrierTimeUs, HI_U32 u32LowLevelTimeUs);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif
+
+#endif
+
+
diff -uNr a/include/hi_unf_sci.h b/include/hi_unf_sci.h
--- a/include/hi_unf_sci.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_sci.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,652 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+******************************************************************************
+ File Name     : hi_unf_sci.h
+Version       : Initial draft
+Author        : HiSilicon multimedia software group
+Created Date   : 2008-06-05
+Last Modified by:
+Description   : Application programming interfaces (APIs) of the external chip software (ECS)
+Function List :
+Change History:
+******************************************************************************/
+#ifndef __HI_UNF_SCI_H__
+#define __HI_UNF_SCI_H__
+
+#include "hi_common.h"
+#include "hi_error_mpi.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      SCI */
+/** @{*/  /** <!-- [SCI] */
+
+/**Output configuration of the smart card interface clock (SCICLK) pin*/
+/** CNcomment:SCICLK引脚输出配置*/
+typedef enum  hiUNF_SCI_MODE_E
+{
+    HI_UNF_SCI_MODE_CMOS = 0, /**<Complementary metal-oxide semiconductor (CMOS) output*/   /**<CNcomment:CMOS输出*/
+    HI_UNF_SCI_MODE_OD, /**<Open drain (OD) output*/                                  /**<CNcomment:OD输出*/
+    HI_UNF_SCI_MODE_BUTT
+} HI_UNF_SCI_MODE_E;
+
+/**SCI port*/
+/** CNcomment:SCI 端口 */
+typedef enum hiUNF_SCI_PORT_E
+{
+    HI_UNF_SCI_PORT0, /**< SCI port 0*/  /**<CNcomment:SCI端口0*/
+    HI_UNF_SCI_PORT1, /**< SCI port 1*/  /**<CNcomment:SCI端口1*/
+    HI_UNF_SCI_PORT_BUTT
+} HI_UNF_SCI_PORT_E;
+
+/**Status of the SCI card*/
+/** CNcomment:智能卡状态 */
+typedef enum hiUNF_SCI_STATUS_E
+{
+    HI_UNF_SCI_STATUS_UNINIT = 0, /**<The SCI card is not initialized.(Reserved status) */               /**<CNcomment: SCI未初始化。(预留状态) */
+    HI_UNF_SCI_STATUS_FIRSTINIT, /**<The SCI card is being initialized.(Reserved status)*/             /**<CNcomment:SCI初始化过程中。(预留状态)*/
+    HI_UNF_SCI_STATUS_NOCARD, /**<There is no SCI card.*/                          /**<CNcomment:无卡 */
+    HI_UNF_SCI_STATUS_INACTIVECARD, /**<The SCI card is not activated (unavailable).*/   /**<CNcomment:卡未完成激活（卡无效） */
+
+    //   HI_UNF_SCI_STATUS_CARDFAULT, /**<The SCI card is faulty.*/                        /**<CNcomment:卡故障*/
+    HI_UNF_SCI_STATUS_WAITATR, /**<The SCI card is waiting for the ATR data.*/      /**<CNcomment:等待ATR*/
+    HI_UNF_SCI_STATUS_READATR, /**<The SCI card is receiving the ATR data.*/        /**<CNcomment:正在接收ATR*/
+    HI_UNF_SCI_STATUS_ATR_ERROR, /**<The ATR is wrong.*/                        /**<CNcomment:ATR错误*/
+    HI_UNF_SCI_STATUS_READY, /**<The SCI card is available (activated).*/         /**<CNcomment:卡可以使用（卡激活） */
+    HI_UNF_SCI_STATUS_RX, /**<The SCI card is busy receiving data.*/           /**<CNcomment:卡忙（接收数据中） */
+    HI_UNF_SCI_STATUS_TX /**<The SCI card is busy transmitting data.*/        /**<CNcomment:卡忙（发送数据中） */
+} HI_UNF_SCI_STATUS_E;
+
+/**SCI protocol*/
+/** CNcomment:SCI 协议 */
+typedef enum hiUNF_SCI_PROTOCOL_E
+{
+    HI_UNF_SCI_PROTOCOL_T0, /**<7816 T0 protocol*/   /**<CNcomment:7816 T0 协议 */
+    HI_UNF_SCI_PROTOCOL_T1, /**<7816 T1 protocol*/   /**<CNcomment:7816 T1 协议 */
+    HI_UNF_SCI_PROTOCOL_T14, /**<7816 T14 protocol*/  /**<CNcomment:7816 T14 协议 */
+    HI_UNF_SCI_PROTOCOL_BUTT
+} HI_UNF_SCI_PROTOCOL_E;
+
+/**SCI active level*/
+/** CNcomment:SCI有效电平*/
+typedef enum hiUNF_SCI_LEVEL_E
+{
+    HI_UNF_SCI_LEVEL_LOW, /**<Active low*/   /**<CNcomment:低电平有效 */
+    HI_UNF_SCI_LEVEL_HIGH, /**<Active high*/  /**<CNcomment:高电平有效 */
+    HI_UNF_SCI_LEVEL_BUTT
+} HI_UNF_SCI_LEVEL_E;
+
+/** Secure mode type*/
+/**CNcomment:安全模式类型*/
+typedef enum hiUNF_SCI_SECURE_MODE_E
+{
+    HI_UNF_SCI_SECURE_MODE_NONE = 0,        /** <no security protection*/ /**<CNcomment:无安全保护*/
+    HI_UNF_SCI_SECURE_MODE_TEE,             /** <trustedzone security protection*/ /**<CNcomment:trustedzone安全保护*/
+
+    HI_UNF_SCI_SECURE_MODE_BUTT
+} HI_UNF_SCI_SECURE_MODE_E;
+
+/**SCI system parameters*/
+/**CNcomment:SCI 系统参数 */
+typedef struct hiUNF_SCI_PARAMS_S
+{
+    HI_UNF_SCI_PORT_E     enSciPort; /**<SCI port ID*/                                                      /**<CNcomment:SCI 端口号 */
+    HI_UNF_SCI_PROTOCOL_E enProtocolType; /**<Used protocol type*/                                    /**<CNcomment:使用的协议类型 */
+    HI_U32                ActalClkRate; /**<Actual clock rate conversion factor F*/                     /**<CNcomment:实际的F 值时钟转换因子 */
+    HI_U32                ActalBitRate; /**<Actual bit rate conversion factor D*/                         /**<CNcomment:实际的D 值比特率转换因子 */
+    HI_U32                Fi; /**<Clock factor returned by the answer to reset (ATR)*/                      /**<CNcomment:ATR 返回的时钟因子 */
+    HI_U32                Di; /**<Bit rate factor returned by the ATR*/                                     /**<CNcomment:ATR 返回的比特率因子 */
+    HI_U32                GuardDelay; /**<Extra guard time N*/                                        /**<CNcomment:N 值额外增加的保护时间*/
+    HI_U32                CharTimeouts; /**<Character timeout of T0 or T1*/                             /**<CNcomment:T0 或T1的字符超时时间*/
+    HI_U32                BlockTimeouts; /**<Block timeout of T1 */                                     /**<CNcomment:T1的块超时时间*/
+    HI_U32                TxRetries; /**<Number of transmission retries*/                                   /**<CNcomment:发送重试次数*/
+} HI_UNF_SCI_PARAMS_S, *HI_UNF_SCI_PARAMS_S_PTR;
+
+/** @}*/  /** <!-- ==== Structure Definition End ====*/
+
+
+
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      SCI*/
+/** @{*/  /** <!-- [SCI] */
+
+/**
+ \brief Initializes the SCI.   CNcomment:SCI初始化。CNend
+ \attention \n
+ \param  N/A                   CNcomment:无。CNend
+ \retval 0 Success             CNcomment:成功。CNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_Init(HI_VOID);
+
+/**
+ \brief Deinitializes the SCI. CNcomment:SCI去初始化。CNend
+ \attention \n
+ \param  N/A                   CNcomment:无。CNend
+ \retval 0 Success             CNcomment:0 成功。CNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_DeInit(HI_VOID);
+
+/**
+ \brief Set the SCI SecurityMod.              CNcomment:SCI设置安全模式。CNend
+ \attention \n
+ \param[in]  SecurityMode        System mode  CNcomment:安全模式模式类型
+ \retval 0 Success               CNcomment:0 成功。CNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_SetSecurityMode(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_SECURE_MODE_E SecurityMode);
+
+/**
+ \brief Starts an SCI device to initialize it based on the input port and protocol. If there is an SCI card, the card is also initialized.\n
+CNcomment:打开SCI（Smart Card Interface）设备，针对输入的端口和协议，进行SCI接口设备的初始化；如果卡存在，则同时对卡进行初始化。CNend
+\attention \n
+After an SCI device is started, it is initialized based on the default configuration.\n
+If you modify the configuration, you need to call HI_UNF_SCI_ResetCard for the modifications to take effect.\n
+If you remove and then insert the SCI card, you need to call HI_UNF_SCI_ResetCard to reset the card.\n
+You need to set frequency parameters when enabling an SCI device. The actual SCI clock provided by the chip is obtained by using the clock divider.\n
+The clock divider is calculated based on the externally transferred clock frequency parameters. The fractional part of the clock divider is discarded during calculation. \n
+Therefore, an enhanced error occurs when the SCI clock is obtained by dividing the system clock by the clock divider. You need to set the actual output frequency of \n
+the SCI card based on the close output frequency. The SCI clock is calculated as follows: Fsci_clk = Frefclk/[(Clkicc + 1) x 2]. Where, Frefclk is the 96 MHz system clock, \n
+Fsci_clk is the SCI clock required by peripherals, and clkicc is the required clock divider of registers. clkicc is calculated as follows: Clkicc = Frefclk/(2 x Fsci_clk) - 1. \n
+The clkicc may be a floating point value, but only the integral part is used. Therefore, the configured frequency is different from the actual frequency.\n
+
+CNcomment: 打开后SCI设备采用默认配置对设备进行初始化。\n 
+之后如果更改了配置，需要调用HI_UNF_SCI_ResetCard来使配置生效。\n 
+之后如果对卡进行拔插，需要调用HI_UNF_SCI_ResetCard来进行复位。\n 
+打开设备的时候需要设置频率参数，而芯片实际给SCI 的时钟是由外部传入的 \n
+时钟频率参数计算的分频因子分频得来，因为计算公式会舍弃计算的分频因子的小数部分，\n
+所以通过系统时钟分频之后给卡的时钟会存在增量误差，实际配置考虑与需求最接近的值来 \n
+设置和权衡，具体算法 Fsci_clk = Frefclk/[(Clkicc + 1) x 2];其中Frefclk是系统96M时钟，Fsci_clk是外部需要设置的 \n
+sci时钟,实际要配入寄存器分频因子Clkicc = Frefclk/(2 x Fsci_clk) - 1;clkicc 有时候计算出来是浮点数，但只取整，\n
+所以设置的频率与实际频率有偏差。CNend
+
+ \param[in] enSciPort     ID of an SCI port. The port ID can be 0 or 1.  CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param[in] enSciProtocol Protocol type.                                  CNcomment:协议类型。CNend
+ \param[in] u32Frequency    Frequency of the SCI card to be set, in kHz. For the T0 and T1 cards, the frequency ranges from 1 MHz to 5 MHz; for the T14 card, the frequency must be set to 6 MHz.  CNcomment:要设置的SCI卡频率。对于T0，T1卡，支持频率1MHz～5MHz；对于T14卡，6MHz才能通信成功。单位为khz。CNend
+ \retval 0 Success.                                                       CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  SCI  No SCI device is started.           CNcomment:设备未打开。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.            CNcomment:参数非法。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_Open(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_PROTOCOL_E enSciProtocol, HI_U32 u32Frequency);
+
+/**
+ \brief Stops an SCI device.
+CNcomment:关闭SCI设备。CNend
+
+ \attention \n
+This API cannot be called repeatedly.
+CNcomment:重复关闭会返回成功。CNend
+
+ \param[in] enSciPort     ID of an SCI port. The port ID can be 0 or 1.  CNcomment:SCI端口号，取值范围为0和1。CNend
+ \retval 0 Success.                                                       CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_NOT_INIT   No SCI device is started.               CNcomment:SCI设备未打开。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.            CNcomment:参数非法。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_Close(HI_UNF_SCI_PORT_E enSciPort);
+
+/**
+ \brief Performs a warm reset on an SCI card.
+CNcomment:复位SCI卡。CNend
+
+ \attention \n
+If no SCI card is inserted, the reset fails.\n
+If you modify the configuration of an SCI device, you need to call HI_S32 HI_UNF_SCI_ResetCard for the modifications to take effect.\n
+In addition, if you remove and insert an SCI card after calling HI_UNF_SCI_Open, you also need to call HI_S32 HI_UNF_SCI_ResetCard to reset the card.
+CNcomment:没有插入卡，复位会失败。\n
+当更改了SCI设备的配置后，需要调用该接口使配置生效。\n
+在调用打开SCI设备接口后，对卡进行拔插，也需要调用该接口进行复位。CNend
+
+ \param[in] enSciPort   ID of an SCI port. The port ID can be 0 or 1                                             CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param[in] bWarmResetValid   Reset mode.  HI_TRUE: warm reset; HI_FALSE: cold reset (recommended)    			 CNcomment:复位方式。HI_TRUE: 热复位; HI_FALSE: 冷复位（推荐用这种方式）。CNend
+ \retval 0 Success.                                                                                              CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  No SCI device is started.                                                        CNcomment:SCI设备未打开。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                    CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             			 CNcomment:不可用的选项。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_ResetCard(HI_UNF_SCI_PORT_E enSciPort, HI_BOOL bWarmResetValid);
+
+/**
+ \brief Deactivates an SCI card.
+CNcomment:去激活SCI卡。CNend
+
+ \attention \n
+After an SCI card is deactivated, the card cannot be read or written until it is reset.
+CNcomment:去激活卡后，无法读写数据。只有重新复位卡后，才能继续读写。CNend
+
+ \param[in] enSciPort ID of an SCI port. The port ID can be 0 or 1.         CNcomment:SCI端口号，取值范围为0和1。CNend
+ \retval 0   Success.                                                        CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_NOT_INIT No SCI device is started.                    CNcomment:SCI设备未打开。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.               CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                 CNcomment:不可用的选项。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_DeactiveCard(HI_UNF_SCI_PORT_E enSciPort);
+
+/**
+ \brief Obtains the ATR data of an SCI card.
+CNcomment:获取SCI卡ATR数据。CNend
+
+ \attention \n
+N/A
+ \param[in]  enSciPort  ID of an SCI port. The port ID can be 0 or 1.                                             CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param[out]  pu8AtrBuf   Address for storing the obtained ATR data.                                               CNcomment:获取的ATR数据的存储地址。CNend
+ \param[in]  u32AtrBufSize  Length of the ATR data read from the buffer.                                          CNcomment:ATR 数据读取 buffer 长度。CNend
+ \param[out]  pu8AtrRcvCount Actual number of ATR data segments.                                                   CNcomment:实际获取的ATR数据个数。CNend
+ \retval 0   Success.                                                                                             CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_NOT_INIT   No SCI device is started.                                                        CNcomment:SCI设备未打开。CNend
+ \retval ::HI_ERR_SCI_NULL_PTR The pointer is invalid.                                                      	  CNcomment: 非法指针。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                     CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_NO_ATR  There is no ATR data.                                                               CNcomment:无ATR数据。CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             			  				  CNcomment:不可用的选项。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_GetATR(HI_UNF_SCI_PORT_E enSciPort, HI_U8 *pu8AtrBuf, HI_U32 u32AtrBufSize, HI_U8 *pu8AtrRcvCount);
+
+/**
+ \brief Obtains the status of an SCI card.
+CNcomment:获取SCI卡状态。CNend
+
+ \attention \n
+This API is a non-block API. You can transfer data to an SCI card by calling HI_UNF_SCI_Send or HI_UNF_SCI_Receive only when the card status is HI_UNF_SCI_STATUS_READY.\n
+CNcomment:此接口是无阻塞函数，在卡的状态为HI_UNF_SCI_STATUS_READY时，才可调用HI_UNF_SCI_Send或HI_UNF_SCI_Receive接口与卡进行数据交互。CNend
+
+ \param[in] enSciPort  ID of an SCI port. The port ID can be 0 or 1.                                             CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param[out] penSCIStatus  Status of an SCI card.                                                                CNcomment: SCI卡状态。CNend
+ \retval 0 Success.                                                                                              CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  No SCI device is started.                                                        CNcomment:SCI设备未打开。CNend
+ \retval ::HI_ERR_SCI_NULL_PTR The pointer is invalid.                                                      	 CNcomment:非法指针。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                    CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             			 CNcomment:不可用的选项。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_GetCardStatus(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_STATUS_E *penSciStatus);
+
+/**
+ \brief Transmits data to an SCI card.
+CNcomment:向SCI卡发送数据。CNend
+
+ \attention \n
+Data must be transmitted based on application protocols.\n
+Data cannot be transmitted consecutively.\n
+In addition, data is transmitted and received in block mode. Therefore, when a large number of data is being transmitted, the transmission may fail if the timeout is too small.\n
+CNcomment:发送数据需要按照应用协议来发送 \n
+不能连续两次发送而中间不接收数据 \n
+发送读取都是阻塞的，因此发送大量的数据时，受到超时时间的限制，如果超时值比较短，有可能发送失败。CNend
+
+ \param[in] enSciPort   ID of an SCI port. The port ID can be 0 or 1.                                            CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param[in]  pSciSendBuf Address for storing the data to be transmitted.                                          CNcomment:发送数据的存储地址。CNend
+ \param[in] u32SendLen  Number of data segments (in byte) to be transmitted.                                      CNcomment:发送数据的个数,单位为 BYTE。CNend
+ \param[out]  pu32ActLen Number of transmitted data segments (in byte).                                            CNcomment:实际发送数据个数,单位为 BYTE。CNend
+ \param[in] u32TimeoutMs Wait timeout (in ms). 0: not blocked; 0xFFFFFFFF: infinite block.                        CNcomment:等待超时值, 单位是毫秒, 0 - 不阻塞, 0xFFFFFFFF-永久阻塞。CNend
+ \retval 0 Success.                                                                                               CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  SCI  No SCI device is started.                                                   CNcomment:设备未打开。CNend
+ \retval ::HI_ERR_SCI_NULL_PTR  The pointer is invalid.                                                     	 CNcomment:非法指针。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA The parameter is invalid.                                                     CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             			CNcomment:不可用的选项。CNend
+ \retval ::HI_ERR_SCI_SEND_ERR  The transmission operation fails.                                             	CNcomment: 发送操作失败。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_Send(HI_UNF_SCI_PORT_E enSciPort, HI_U8 *pSciSendBuf, HI_U32 u32SendLen, HI_U32 *pu32ActLen,
+                       HI_U32 u32TimeoutMs);
+
+/**
+ \brief Receives data from an SCI card.
+CNcomment:从SCI卡接收数据。CNend
+
+ \attention \n
+You must set the data length obtained by each upper-layer application based on the protocol. If the length of the obtained data is greater than that of the returned data, this API is returned after timeout occurs.\n
+CNcomment:上层应用程序必须根据协议来配置所获取的长度，如果希望获取的长度超出实际能够返回的长度，则只能等到超时到期才能返回。CNend
+
+ \param[in] enSciPort  ID of an SCI port. The port ID can be 0 or 1.                                             CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param[out]  pSciReceiveBuf   Address for storing the received data.                                              CNcomment:接收数据的存储地址。CNend
+ \param[in] u32ReceiveLen  Number of data segments (in byte) to be received.                                      CNcomment:期望接收数据的个数,单位为 BYTE。CNend
+ \param[out]  pu32ActLen   Number of received data segments (in byte).                                             CNcomment:实际接收数据个数,单位为 BYTE。CNend
+ \param[in] u32TimeOutMs  Wait timeout (in ms). 0: not blocked; 0xFFFFFFFF: infinite block.                       CNcomment:等待超时值, 单位是毫秒, 0 - 不阻塞, 0xFFFFFFFF-永久阻塞。CNend
+ \retval 0 Success.                                                                                               CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_NOT_INIT   No SCI device is started.                                                       CNcomment:SCI设备未打开。CNend
+ \retval ::HI_ERR_SCI_NULL_PTR  The pointer is invalid.                                                     	 CNcomment: 非法指针。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                    CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             			 CNcomment:不可用的选项。CNend
+ \retval ::HI_ERR_SCI_RECEIVE_ERR  The reception operation fails.                                             	CNcomment:接收操作失败。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_Receive(HI_UNF_SCI_PORT_E enSciPort, HI_U8 *pSciReceiveBuf, HI_U32 u32ReceiveLen, HI_U32 *pu32ActLen,
+                          HI_U32 u32TimeOutMs);
+
+/**
+ \brief Sets the active level of the VCCEN signal.
+CNcomment:配置VCCEN信号线的有效电平。CNend
+ \attention \n
+The active level needs to be set based on the circuits of hardware, and the low level is active by default.\n
+After changing the active level, you need to call HI_UNF_SCI_ResetCard for the modification take effect.\n
+CNcomment:需要根据硬件电路进行配置，默认为低电平有效，更改此项配置后需要调用HI_UNF_SCI_ResetCard才能使新的配置有效。CNend
+
+ \param[in] enSciPort ID of an SCI port. The port ID can be 0 or 1.                                              CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param[in] enSciVcc  Active level of a signal. HI_FALSE: active low; HI_TRUE: active high  Active level of a signal. HI_FALSE: active low; HI_TRUE: active high.  CNcomment:信号线的有效电平。HI_FALSE：低电平有效，HI_TRUE：高电平有效。CNend
+ \retval 0   Success.                                                                                             CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_NOT_INIT   No SCI device is started.                                                       CNcomment:SCI设备未打开。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                    CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             			 CNcomment:不可用的选项。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_ConfigVccEn(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_LEVEL_E enSciVcc);
+
+/**
+ \brief Sets the active level of the DETECT signal.
+CNcomment:配置DETECT信号线的有效电平。CNend
+
+ \attention \n
+The active level needs to be set based on the circuits of hardware, and the high level is active by default.\n
+After changing the active level, you need to call HI_UNF_SCI_ResetCard for the modification take effect.\n
+CNcomment:需要根据硬件电路进行设置，默认为高电平有效，更改此项配置后需要调用HI_UNF_SCI_ResetCard才能使新的配置有效。CNend
+
+ \param[in] enSciPort  ID of an SCI port. The port ID can be 0 or 1.                                             CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param[in] enSciDetect Active level of a signal. HI_FALSE: active low; HI_TRUE: active high.                     CNcomment:信号线的有效电平。HI_FALSE：低电平有效，HI_TRUE：高电平有效。CNend
+ \retval 0  Success.                                                                                              CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  No SCI device is started.                                                        CNcomment:SCI设备未打开。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                    CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             			 CNcomment:不可用的选项。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_ConfigDetect(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_LEVEL_E enSciDetect);
+
+/**
+ \brief Sets the mode of a clock signal.
+CNcomment:设置时钟线的模式。CNend
+ \attention \n
+The mode needs to be set based on the circuits of hardware, and the OD mode is selected by default.\n
+After changing the mode, you need to call HI_UNF_SCI_ResetCard for the modification take effect.\n
+CNcomment:需要根据硬件电路进行设置，默认为OD模式，更改此项配置后需要调用HI_UNF_SCI_ResetCard才能使新的配置有效。CNend
+
+ \param[in] enSciPort  ID of an SCI port. The port ID can be 0 or 1.                                             CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param[in] enClkMode  Mode of a clock signal.                                                                    CNcomment:时钟线的模式。CNend
+ \retval 0 Success.                                                                                               CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  No SCI device is started.                                                        CNcomment:SCI设备未打开。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                    CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                            			 CNcomment:不可用的选项。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_ConfigClkMode(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_MODE_E enClkMode);
+
+/**
+ \brief Sets the mode of a clock signal.
+CNcomment:设置RESET线的模式。CNend
+ \attention \n
+The mode needs to be set based on the circuits of hardware, and the OD mode is selected by default.\n
+After changing the mode, you need to call HI_UNF_SCI_ResetCard for the modification take effect.\n
+CNcomment:需要根据硬件电路进行设置，默认为OD模式，更改此项配置后需要调用HI_UNF_SCI_ResetCard才能使新的配置有效。CNend
+
+ \param[in] enSciPort  ID of an SCI port. The port ID can be 0 or 1.                                             CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param[in] enClkMode  Mode of a reset signal.                                                                    CNcomment:时钟线的模式。CNend
+ \retval 0 Success.                                                                                               CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  No SCI device is started.                                                        CNcomment:SCI设备未打开。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                    CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                            			                 CNcomment:不可用的选项。CNend
+ \retval ::HI_ERR_SCI_NOTSUPPORT	Current chipset not support config RESET output type.                        CNcomment:当前芯片不支持配置RESET输出类型。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_ConfigResetMode(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_MODE_E enResetMode);
+
+/**
+ \brief Sets the mode of a clock signal.
+CNcomment:设置POWEREN线的模式。CNend
+ \attention \n
+The mode needs to be set based on the circuits of hardware, and the OD mode is selected by default.\n
+After changing the mode, you need to call HI_UNF_SCI_ResetCard for the modification take effect.\n
+CNcomment:需要根据硬件电路进行设置，默认为OD模式，更改此项配置后需要调用HI_UNF_SCI_ResetCard才能使新的配置有效。CNend
+
+ \param[in] enSciPort  ID of an SCI port. The port ID can be 0 or 1.                                             CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param[in] enClkMode  Mode of a poweren signal.                                                                    CNcomment:时钟线的模式。CNend
+ \retval 0 Success.                                                                                               CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  No SCI device is started.                                                        CNcomment:SCI设备未打开。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                    CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                            			                 CNcomment:不可用的选项。CNend
+ \retval ::HI_ERR_SCI_NOTSUPPORT	Current chipset not support config POWEREN output type.                      CNcomment:当前芯片不支持配置POWEREN输出类型。CNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_ConfigVccEnMode(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_MODE_E enVccEnMode);
+
+
+/**
+ \brief Changes the card slot.
+CNcomment:切换卡槽。CNend
+
+ \attention \n
+When you call HI_UNF_SCI_Open, the primary card is used by default, that is, port 0 is used.\n
+After you switch to a new SCI device, all the preceding SCI APIs are called to operate the new SCI device.\n
+In addition, after a new SCI device is switched, the device is initialized based on the default configuration.\n
+If any modifications are made, you need to call HI_UNF_SCI_ResetCard for the modifications to take effect.\n
+If the SCI port to be switched to is the same as the current active port, an error code is returned.\n
+CNcomment:调用HI_UNF_SCI_Open时，默认打开的为主卡，即端口0。\n
+切换到新的SCI设备后，上述所有SCI接口即对新的SCI设备进行操作。\n
+切换到新的SCI设备采用默认配置对设备进行初始化。\n
+之后如果更改了配置，需要调用HI_UNF_SCI_ResetCard来使配置生效。\n
+希望切换到的SCI端口与当前有效端口相同时，会返回失败。CNend
+
+ \param[in] enSciPort  ID of an SCI port. The port ID can be 0 or 1.                                             CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param[in] enSciProtocol  Protocol type.                                                                         CNcomment:协议类型。CNend
+ \param[in] u32Frequency Frequency of the SCI card to be set, in kHz. For the T0 and T1 cards, the frequency ranges from 1 MHz to 5 MHz; for the T14 card, the frequency must be set to 6 MHz. CNcomment:要设置的SCI卡频率。对于T0，T1卡，支持频率1MHz~5MHz；对于T14卡，只支持6MHz。单位为kHz。CNend
+ \retval 0  Success.                                                                                              CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  No SCI device is started.                                                        CNcomment:SCI设备未打开。CNend
+ \retval ::HI_ERR_SCI_NULL_PTR The pointer is invalid.                                                      	 CNcomment:非法指针。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                                    CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             			 CNcomment:不可用的选项。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_SwitchCard(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_PROTOCOL_E enSciProtocol, HI_U32 u32Frequency);
+
+/**
+ \brief Sets the clock rate factor (in ETU) and baud rate regulator factor for special cards.
+CNcomment:对特殊卡需要设置指定etu 时钟率因子，波特率调节因子。CNend
+
+ \attention \n
+This API needs to be called only for special cards.
+The configured values must match the clock rate conversion factor F and bit rate regulator factor D defined in the protocol.
+You can also set the factors to the values defined in the card specifications. Note that the values must be set correctly.
+CNcomment:只有特需要求的卡需要设置，普通卡不需要调用此接口设置，
+设置的值要与协议中规定的F时钟转率转换因子、D比特率调节因子兼容，
+或者设置为卡规范中规定的值，不可随意设置。CNend
+
+ \param [in] 	enSciPort	ID of an SCI port. The port ID can be 0 or 1.                                             CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param [in] 	u32ClkFactor  Clock rate conversion factor, ranging from 372 to 2048. For details, see the factor F and card features in the protocol.	CNcomment:时钟转率因子372～2048 ，具体设置参考协议的F因子和卡特性。CNend
+ \param [in] 	u32BaudFactor	Baud rate regulator factor 1, 2 x n (n = 1-16). For details, see the factor D and card features in the protocol. CNcomment:波特率校正因子1、2*n (n=1～16) ，具体设置参考协议D因子和卡特性。CNend
+ \retval  0 	Success.                                                                                               CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  No SCI device is started.                                                          CNcomment:SCI设备未打开。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA The parameter is invalid.                                                       CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             			   CNcomment:不可用的选项。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_SetEtuFactor(HI_UNF_SCI_PORT_E enSciPort, HI_U32 u32ClkFactor, HI_U32 u32BaudFactor);
+
+/**
+ \brief \brief Sets the extra guard time for transmitting two consecutive bytes from the terminal to an IC card. The guard time is the interval between the start edges of two consecutive bytes.
+CNcomment:设置终端向IC卡发送连续的两个字节起始沿额外增加的间隔时间。CNend
+
+ \attention \n
+This setting is performed based on related features only for the cards that require extra character guard time.
+In general, the default value is used or the interval guard time is automatically set based on the ART analysis result.
+CNcomment:只有特需要求的卡，需要额外设置字符保护时间的才能根据卡的相关特性设置，
+不可随意设置。一般使用系统默认值，或者系统根据ATR解析自动设置。CNend
+ \param [in] 	enSciPort	ID of an SCI port. The port ID can be 0 or 1.      	CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param [in] 	u32GuardTime  Extra guard time, ranging from 0 to 254 ETU.	   	CNcomment:额外间隔保护的范围0～254  etu。CNend
+ \retval 0  Success.	                                                       		CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_NOT_INIT   No SCI device is started.                  		CNcomment:SCI设备未打开。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.               		CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                          CNcomment:不可用的选项。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_SetGuardTime(HI_UNF_SCI_PORT_E enSciPort, HI_U32 u32GuardTime);
+
+/**
+ \brief Sets the baud rate supported by the SCI card through protocol and parameters selection (PPS) negotiation or performs negotiation by using the F and D factors returned by the ATR to switch the protocol of a card.
+CNcomment:通过PPS 协商可以设置卡所支持的波特率或者用ATR 传回的F、D因子进行协商，支持多协议卡的协议切换。CNend
+\attention \n
+PPS negotiation is available only when the SCI card supports this function.
+The negotiated baud rate must be supported by the SCI card.
+The command words for negotiation must comply with the specifications defined in section 9.2 "PPS request and response" in the 7816-3 protocol.
+CNcomment:要进行PPS 协商首先卡必须支持该功能，
+要协商的波特率内容必须是卡所规定的支持的波特率范围，
+请求协商的命令字需符合7816-3 中9.2 PPS request and response。CNend
+
+ \param [in] 	enSciPort	ID of an SCI port. The port ID is 0 or 1.                                 CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param [in] 	pSciSendBuf  PPS negotiation command combined based on card specifications. If the default negotiation mode is used, the command word can be left empty.   CNcomment:根据卡规范组合的PPS协商命令，若使用系统默认的协商方式，命令字的内容可为空。CNend
+ \param [in]	Sendlen	   Length of the command word to be transmitted, ranging from 0 bytes to 5 bytes. The value 0 indicates that the default negotiation mode is used.   CNcomment: 发送命令字的长度(0～5),设置为0表示使用系统默认的协商命令方式。CNend
+ \param [in]	RecTimeouts  PPS response timeout after commands are transmitted. The value ranges from 1 ms to 10000 ms.  CNcomment: 发送完命令之后，接收PPS 响应的超时时间(1-10000),单位是毫秒。CNend
+ \retval 0 	Success.                                                                               		CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_NOT_INIT   No SCI device is started.                                         		CNcomment:SCI设备未打开。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                                      		CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_NULL_PTR		The pointer is null.                                          		CNcomment:空指针。CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                                          	CNcomment:不可用的选项。CNend
+ \retval ::HI_ERR_SCI_RECEIVE_ERR  A reception error occurs.                                       		CNcomment:接收错误。CNend
+ \retval ::HI_ERR_SCI_PPS_PTYPE_ERR 	The protocol type for PPS negotiation is incorrect.           		CNcomment:PPS协商的协议类型错误。CNend
+ \retval ::HI_ERR_SCI_PPS_FACTOR_ERR 	The F factor and D factor for PPS negotiation are incorrect. 	        CNcomment:PPS协商的F、D因子错误。CNend
+ \retval ::HI_ERR_SCI_PPS_NOTSUPPORT_ERR  The PPS negotiation type is not supported.               		CNcomment:不支持的PPS协商类型。CNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_NegotiatePPS(HI_UNF_SCI_PORT_E enSciPort, HI_U8 *pSciSendBuf, HI_U32 Sendlen, HI_U32 RecTimeouts);
+
+/**
+ \brief  Obtains the PPS data for the card response after PPS negotiation is successful.
+CNcomment:PPS 协商成功之后,通过该接口可获得卡响应的PPS 数据。CNend
+ \attention \n
+This API takes effect only after PPS negotiation is successful.
+CNcomment:要等PPS 协商成功之后,使用该接口才有实际意义。CNend
+
+ \param [in] 	enSciPort	ID of an SCI port. The port ID is 0 or 1.                   CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param [out] 	pRecBuf   Address of the buffer for storing the data to be received.   	CNcomment:待接收的数据buffer 地址。CNend
+ \param [out]	pDataLen	  Required length of the received data.                      CNcomment:期望接收数据的长度。CNend
+ \retval 0  Success.	                                                                	CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                        	CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_NULL_PTR	The pointer is null.                                	CNcomment:空指针。CNend
+ \retval ::HI_ERR_SCI_PPS_NOTSUPPORT_ERR  The PPS negotiation type is not supported. 	CNcomment:不支持的PPS协商类型。CNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_GetPPSResponData(HI_UNF_SCI_PORT_E enSciPort, HI_U8* pRecBuf, HI_U32* pDataLen);
+
+/**
+brief  Obtains the SCI parameter values including the protocol, ATR clock factor, ATR bit rate factor, actual clock factor, actual bit rate factor, number of retries, guard delay, character wait timeout, and block wait timeout.
+CNcomment:获取sci 参数包括协议、ATR 时钟和比特率因子、实际设置的时钟因子和比特率因子，
+发送重试次数、GuardDelay 、字符等待超时、块等待超时。CNend
+ \attention \n
+This API is available only after HI_UNF_SCI_Init and HI_UNF_SCI_ResetCard are called.
+CNcomment:要等 到初始化复位之后,才能使用该接口。CNend
+
+ \param [in] 	enSciPort	 ID of an SCI port. The port ID is 0 or 1.                      CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param [out] 	pParams   Pointer to the data type of the data structure to be received.   	CNcomment:待接收的结构体数据类型指针。CNend
+ \retval 0 	Success.                                                                     	CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA The parameter is invalid.                             	CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_NULL_PTR		The pointer is null.                                    CNcomment:空指针。CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                                	CNcomment:不可用的选项。CNend
+ \retval ::HI_ERR_SCI_NOT_INIT  	The SCI device is not initialized.                      CNcomment:没完成初始化。CNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_GetParams(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_PARAMS_S_PTR pParams);
+
+/**
+ \brief  Sets the character timeout of T0 and T1 separately based on the current protocol type.
+CNcomment:根据当前协议类型分别可设置T0、T1的字符超时时间。CNend
+
+ \attention \n
+The timeout can be set only after the SCI card is reset successfully. The protocol type must be consistent with the current card type. In general, the timeout is obtained by parsing the ATR. That is, the timeout needs to be set only when card communication fails.
+CNcomment:要等卡复位成功之后,才能进行设置，协议类型参数必须与当前卡类型一致，一般情况都是根据ATR解析，只有特殊卡情况才需要设置。CNend
+
+ \param [in] 	enSciPort	ID of an SCI port. The port ID is 0 or 1.   CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param [in] 	enSciProtocol  Protocol type.                           	CNcomment:协议类型。CNend
+ \param [in]	MaxCharTime  Maximum character timeout. The value of MaxCharTime for T0 ranges from 960 to 244800, and the value of MaxCharTime for T1 ranges from 12 to 32779.	  CNcomment:设置最大的字符超时时间，设置范围T0(960～244800),T1(12～32779)。CNend
+ \retval 0 	Success.                                                  	CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.         	CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.             	CNcomment:不可用的选项。CNend
+ \retval ::HI_ERR_SCI_NO_ATR  	The SCI card fails to be reset.        	CNcomment:没复位成功。CNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_SetCharTimeout(HI_UNF_SCI_PORT_E enSciPort, HI_UNF_SCI_PROTOCOL_E enSciProtocol, HI_U32 MaxCharTime);
+
+/**
+ \brief  Sets the block timeout of T1.
+CNcomment:设置T1的块超时时间。CNend
+\attention \n
+The timeout can be set only after the SCI card is reset successfully. In general, the timeout is obtained by parsing the ATR. That is, the timeout needs to be set only in special cases
+CNcomment:要等卡复位成功之后,才能进行设置，一般情况都是根据ATR解析，只有特殊卡情况才需要设置。CNend
+
+ \param [in] 	enSciPort	 ID of an SCI port. The port ID is 0 or 1.                         	CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param [in] 	MaxBlockTime   Maximum block timeout. The value ranges from 971 to 491531.   	CNcomment:设置块超时的最大值，范围(971～491531)。CNend
+ \retval 0 	Success.                                                                        		CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA The parameter is invalid.                                		CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                                   	CNcomment:不可用的选项。CNend
+ \retval ::HI_ERR_SCI_NO_ATR  		The SCI card fails to be reset.                            	CNcomment:没复位成功。CNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_SetBlockTimeout(HI_UNF_SCI_PORT_E enSciPort, HI_U32 MaxBlockTime);
+
+/**
+ \brief  Sets the maximum number of transmission retries after a check error occurs.
+CNcomment:设置校验错误后重发送最大次数。CNend
+\attention \n
+The number can be set only after the SCI card is reset successfully.
+CNcomment:要等卡复位成功之后,才能进行设置。CNend
+
+ \param [in] 	enSciPort	ID of an SCI port. The port ID is 0 or 1.                   CNcomment:SCI端口号，取值范围为0和1。CNend
+ \param [in] 	TxRetryTimes   Number of transmission retries, ranging from 0 to 7.    	CNcomment:次数范围(0～7)。CNend
+ \retval 0 	Success.                                                                  	CNcomment:成功。CNend
+ \retval ::HI_ERR_SCI_INVALID_PARA  The parameter is invalid.                         	CNcomment:参数非法。CNend
+ \retval ::HI_ERR_SCI_INVALID_OPT	The option is invalid.                             	CNcomment:不可用的选项。CNend
+ \retval ::HI_ERR_SCI_NO_ATR  	The SCI card fails to be reset.	                       	CNcomment:没复位成功。CNend
+
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SCI_SetTxRetries(HI_UNF_SCI_PORT_E enSciPort, HI_U32 TxRetryTimes);
+
+/** @}*/  /** <!-- ==== API Declaration End ====*/
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_SCI_H__ */
diff -uNr a/include/hi_unf_session_manager.h b/include/hi_unf_session_manager.h
--- a/include/hi_unf_session_manager.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_session_manager.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,189 @@
+/******************************************************************************
+
+Copyright (C), 2017, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_unf_session_manager.h
+Version       : Initial draft
+Author        : Hisilicon hisecurity team
+Created       : 2017-08-11
+Last Modified :
+Description   : Session manager(known as SMG)plays an important role in SMP.It protects modules that are working
+                in SMP from attacking.Known attacking measures are :buffer address distortion, module
+                attachment switching ,etc.Before SMG takes effect, it should be initialized ,intent need to
+                be set and related modules in SMP need to be added.
+Function List :
+History       :
+******************************************************************************/
+#ifndef __HI_UNF_SESSION_MANAGER_H__
+#define __HI_UNF_SESSION_MANAGER_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* End of #ifdef __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      HI_UNF_SESSION_MANAGER */
+/** @{ */  /** <!-- [HI_UNF_SESSION_MANAGER] */
+
+
+/** the type of session manager attribute */
+typedef struct
+{
+    HI_U32 u32SessionID;
+} HI_UNF_SM_ATTR_S;
+
+/** the type of session manager modid */
+typedef enum
+{
+    HI_UNF_SM_MODULE_KEYLADDER = 0,
+    HI_UNF_SM_MODULE_DESCRAMBLER,
+    HI_UNF_SM_MODULE_CIPHER,
+    HI_UNF_SM_MODULE_PLCIPHER,
+    HI_UNF_SM_MODULE_DEMUX,
+    HI_UNF_SM_MODULE_VDEC,
+    HI_UNF_SM_MODULE_AVPLAY,
+    HI_UNF_SM_MODULE_PVR,
+    HI_UNF_SM_MOODULE_BUTT
+} HI_UNF_SM_MODULE_E;
+
+typedef enum
+{
+    HI_UNF_SM_CIPHER_TYPE_ENCRYPT,
+    HI_UNF_SM_CIPHER_TYPE_DECRYPT,
+    HI_UNF_SM_CIPHER_TYPE_BUTT
+} HI_UNF_SM_CIPHER_TYPE_E;
+
+typedef struct
+{
+    union
+    {
+        HI_UNF_SM_CIPHER_TYPE_E enCipherType;
+        HI_U32 u32DemuxID;
+        HI_U32 u32Reserve;
+    } unModAttr;
+    HI_HANDLE hHandle;
+} HI_UNF_SM_MODULE_S;
+
+typedef enum
+{
+    HI_UNF_SM_INTENT_DEFAULT = 0,
+    HI_UNF_SM_INTENT_WATCH,
+    HI_UNF_SM_INTENT_RECORD,
+    HI_UNF_SM_INTENT_EXPORT,
+    HI_UNF_SM_INTENT_BUTT
+} HI_UNF_SM_INTENT_E;
+
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      HI_UNF_SESSION_MANAGER */
+/** @{ */  /** <!-- [HI_UNF_SESSION_MANAGER] */
+
+/**
+\brief Init the session manager device
+\param  None
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_SM_Init(HI_VOID);
+
+
+/**
+\brief Deinit the session manager device
+\param  None
+\retval HI_SUCCESS  Success
+\retval HI_FAILURE  Failure
+*/
+HI_S32 HI_UNF_SM_DeInit(HI_VOID);
+
+/**
+\brief Create a session manager instance.
+\attention \n
+\param[out] phSM       Handle of session manager.
+\param[in] pstSMAttr   Pointer to the attributes of session manager.
+\retval HI_SUCCESS     Success
+\retval HI_FAILURE     Failure
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SM_Create(HI_HANDLE *phSM, HI_UNF_SM_ATTR_S *pstSMAttr);
+
+/**
+\brief add handle need to be managed by session manager.
+\attention \n
+\param[in] hSM         Handle of session manager.
+\param[in] enModID     Handle module.
+\param[in] pstModule   Resource need to manager.
+\retval HI_SUCCESS     Success
+\retval HI_FAILURE     Failure
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SM_AddResource(HI_HANDLE hSM, HI_UNF_SM_MODULE_E enModID, HI_UNF_SM_MODULE_S *pstModule);
+
+/**
+\brief del handle need to be remove by session manager.
+\attention \n
+\param[in] hSM         Handle of session manager.
+\param[in] enModID     Handle module.
+\param[in] pstModule   Resource need to manager.
+\retval HI_SUCCESS     Success
+\retval HI_FAILURE     Failure
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SM_DelResource(HI_HANDLE hSM, HI_UNF_SM_MODULE_E enModID, HI_UNF_SM_MODULE_S *pstModule);
+
+/**
+\brief destroy session manager.
+\attention \n
+\param[in] hSM         Handle of session manager.
+\retval HI_SUCCESS     Success
+\retval HI_FAILURE     Failure
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SM_Destroy(HI_HANDLE hSM);
+
+/**
+\brief get session manager handle by service id.
+\attention \n
+\param[in] u32SessionID     source handle module.
+\param[out] pSM             handle to search.
+\retval HI_SUCCESS     Success
+\retval HI_FAILURE     Failure
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SM_GetSMHandleBySID(HI_U32 u32SessionID, HI_HANDLE *pSM);
+
+/**
+\brief set session manager intent.
+\attention \n
+\param[in] hSM         session manager handle.
+\param[in] enIntent    intent to set.
+\retval HI_SUCCESS     Success
+\retval HI_FAILURE     Failure
+\see \n
+N/A
+*/
+
+HI_S32 HI_UNF_SM_SetIntent(HI_HANDLE hSM, HI_UNF_SM_INTENT_E enIntent);
+
+
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* End of #ifdef __cplusplus */
+
+#endif /* End of #ifndef HI_UNF_SESSION_MANAGER*/
diff -uNr a/include/hi_unf_so.h b/include/hi_unf_so.h
--- a/include/hi_unf_so.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_so.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,449 @@
+/**
+ \file
+ \brief Subtitle output Module
+ \author Shenzhen Hisilicon Co., Ltd.
+ \version 1.0
+ \author
+ \date 2010-03-10
+ */
+
+#ifndef __HI_UNF_SO_H__
+#define __HI_UNF_SO_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif /* __cplusplus */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup     SUBTITLEOUT */
+/** @{ */  /** <!-- 【SUBTITLEOUT】 */
+
+/** Number of palette *//** CNcomment:调色板颜色个数 */
+#define HI_UNF_SO_PALETTE_ENTRY (256)
+
+/** Invalid pts value *//** CNcomment:无效的PTS值 */
+#define HI_UNF_SO_NO_PTS        (-1)
+
+/** The max node in SO *//** CNcomment:SO能缓存的最大节点数 */
+#define HI_UNF_SO_MAX_NODE_NUM  (20)
+
+/** The max buffer size *//** CNcomment:SO最大的缓存长度 */
+#define HI_UNF_SO_MAX_BUFFER_SIZE (0x200000)
+
+
+/** Subtitle type *//** CNcomment:字幕类型 */
+typedef enum hiUNF_SO_SUBTITLE_TYPE_E
+{
+    HI_UNF_SUBTITLE_BITMAP = 0x0,  /**<Bmp subtitle *//**<CNcomment:图像字幕 */
+    HI_UNF_SUBTITLE_TEXT,          /**<Text subtitle *//**<CNcomment:string字幕 */
+    HI_UNF_SUBTITLE_ASS,           /**<Ass/ssa sbutitle *//**<CNcomment:ass字幕 */
+    HI_UNF_SUBTITLE_BUTT
+} HI_UNF_SO_SUBTITLE_TYPE_E;
+
+/** Message type of subtitle *//** CNcomment:显示消息，对于teltext，含显示和擦除两个消息 */
+typedef enum hiUNF_SO_DISP_MSG_TYPE_E
+{
+    HI_UNF_SO_DISP_MSG_NORM  = 0x0,     /**<Draw the subtitle *//**<CNcomment:正常显示数据 */
+    HI_UNF_SO_DISP_MSG_ERASE,           /**<Clear the subtitle *//**<CNcomment:擦除 */
+    HI_UNF_SO_DISP_MSG_END              /**<Message of drawing a page *//**<CNcomment:整页显示结束 */
+} HI_UNF_SO_DISP_MSG_TYPE_E;
+
+/** The parameter of clear region *//** CNcomment:擦除参数 */
+typedef struct hiUNF_SO_CLEAR_PARAM_S
+{
+    HI_U32 x, y, w, h;     /**<Postion of clearing *//**<CNcomment:擦除位置和高宽信息 */
+    HI_S64 s64ClearTime;   /**<Clear operation time,larger than or equal to s64NodePts+u32Duration*//**<CNcomment:擦除操作发生的时间,大于等于s64NodePts+u32Duration */
+    HI_S64 s64NodePts;     /**<the present pts of sub *//**<CNcomment:字幕显示时间戳 */
+    HI_U32 u32Duration;    /**<the present duration of sub *//**<CNcomment:字幕显示时间长度 */
+} HI_UNF_SO_CLEAR_PARAM_S;
+
+/** Color components  *//** CNcomment:颜色结构 */
+typedef struct hiUNF_SO_COLOR_S
+{
+    HI_U8 u8Red;      /**<Red component *//**<CNcomment:R分量颜色值 */
+    HI_U8 u8Green;    /**<Green component *//**<CNcomment:G分量颜色值 */
+    HI_U8 u8Blue;     /**<Blue component *//**<CNcomment:B分量颜色值 */
+    HI_U8 u8Alpha;    /**<Alpha component *//**<CNcomment:透明度，值为0为透明，0xFF为不透明 */
+} HI_UNF_SO_COLOR_S;
+
+/** Information of bitmap subtitle *//** CNcomment:图像字幕信息 */
+typedef struct hiUNF_SO_GFX_S
+{
+    HI_S64 s64Pts;         /**<Start a display time, unit is Millisecond *//**<CNcomment:显示时间戳，单位ms */
+    HI_U32 u32Duration;    /**<Duration of displaying, unit is Millisecond *//**<CNcomment:显示时长，单位ms */
+    HI_U32 u32Len;         /**<Bytes of subtitle data *//**<CNcomment:数据长度，单位字节 */
+    HI_U8  *pu8PixData;    /**<Data of subtitle *//**<CNcomment:图像数据 */
+
+    HI_UNF_SO_DISP_MSG_TYPE_E enMsgType;                   /**<Type of display message *//**<CNcomment:显示消息类型 */
+    HI_UNF_SO_COLOR_S stPalette[HI_UNF_SO_PALETTE_ENTRY];  /**<Palette *//**<CNcomment:调色板，ARGB8888 */
+    HI_S32 s32BitWidth;    /**<Bits of Pix *//**<CNcomment:象素位宽 , 可以为 2,4,8位*/
+    HI_U32 x, y, w, h;     /**<Position of display subtitle *//**<CNcomment:显示位置和高宽信息 */
+    HI_U32 u32CanvasWidth;   /**<Display canvas width *//**<CNcomment:显示画布的宽度信息 */
+    HI_U32 u32CanvasHeight;  /**<Display canvas height *//**<CNcomment:显示画布的高度信息 */
+} HI_UNF_SO_GFX_S;
+
+/** Infomation of text subtitle *//** CNcomment:文本字幕信息 */
+typedef struct hiUNF_SO_TEXT_S
+{
+    HI_S64 s64Pts;              /**<Start a display time, unit is Millisecond *//**<CNcomment:显示时间戳，单位ms */
+    HI_U32 u32Duration;         /**<Duration of displaying, unit is Millisecond *//**<CNcomment:显示时长，单位ms */
+    HI_U32 u32Len;              /**<Bytes of subtitle data *//**<CNcomment:字幕数据长度，单位字节 */
+    HI_U8 *pu8Data;             /**<Data of subtitle *//**<CNcomment:字幕数据 */
+
+    HI_U32 x, y, w, h;          /**<Position of display subtitle *//**<CNcomment:显示位置和高宽信息 */
+} HI_UNF_SO_TEXT_S;
+
+/** Infomation of ass/ssa subtitle *//** CNcomment:ass字幕信息 */
+typedef struct hiUNF_SO_ASS_S
+{
+    HI_S64 s64Pts;                /**<Start a display time, unit is Millisecond *//**<CNcomment:显示时间戳，单位ms */
+    HI_U32 u32Duration;           /**<Duration of displaying, unit is Millisecond *//**<CNcomment:显示时长，单位ms */
+    HI_U32 u32FrameLen;           /**<Bytes of subtitle data *//**<CNcomment:帧长度，单位字节 */
+    HI_U8  *pu8EventData;         /**<Data of subtitle *//**<CNcomment:帧数据 */
+    HI_U32 u32ExtradataSize;      /**<Length of extra data *//**<CNcomment:扩展数据长度，单位字节 */
+    HI_U8  *pu8Extradata;         /**<Extra data *//**<CNcomment:扩展数据 */
+} HI_UNF_SO_ASS_S;
+
+/** Infomation of subtitle *//** CNcomment:字幕信息 */
+typedef struct hiUNF_SO_SUBTITLE_INFO_S
+{
+    HI_UNF_SO_SUBTITLE_TYPE_E eType; /**<type *//**<CNcomment:字幕类型 */
+
+    union
+    {
+        HI_UNF_SO_GFX_S  stGfx;      /**<Gfx subtitle *//**<CNcomment:图形字幕 */
+        HI_UNF_SO_TEXT_S stText;     /**<Text subtitle *//**<CNcomment:文本字幕 */
+        HI_UNF_SO_ASS_S  stAss;      /**<Ass subtitle *//**<CNcomment:ASS字幕 */
+    } unSubtitleParam;
+} HI_UNF_SO_SUBTITLE_INFO_S;
+
+/**
+\brief Call back funtion of getting current play time.
+CNcomment:获取当前播放帧的时间戳，如果当前时间无效，ps64CurrentPts赋值为HI_UNF_SO_NO_PTS。CNend
+\attention \n
+None
+\param[in] pUserData Userdata.CNcomment:注册传入的用户数据。CNend
+\param[out] ps64CurrentPts Current play time. CNcomment:当前播放帧时间戳，单位ms。CNend
+
+\retval ::HI_SUCCESS
+
+\see \n
+None
+*/
+typedef HI_S32 (*HI_UNF_SO_GETPTS_FN)(HI_VOID* pUserData, HI_S64 *ps64CurrentPts);
+
+/**
+\brief Callback funtion of drawing the subtitle. CNcomment:字幕画图回调函数。CNend
+\attention \n
+None
+\param[in] pUserData Userdata. CNcomment:注册传入的用户数据。CNend
+\param[in] pstInfo Information of subtitle. CNcomment:字幕信息。CNend
+\param[in] pArg User data. CNcomment:扩展数据。CNend
+
+\retval ::HI_SUCCESS
+
+\see \n
+None
+*/
+typedef HI_S32 (*HI_UNF_SO_ONDRAW_FN)(HI_VOID* pUserData, const HI_UNF_SO_SUBTITLE_INFO_S *pstInfo, HI_VOID *pArg);
+
+/**
+\brief Call back funtion of clearing the subtitle. CNcomment:字幕显示到时清除函数。CNend
+\attention \n
+None
+\param[in] pUserData User data. CNcomment:注册传入的用户数据。CNend
+\param[out] pArg Parameter of clearing the subtitle, Type is HI_UNF_SO_CLEAR_PARAM_S. CNcomment:擦除参数，指向HI_UNF_SO_CLEAR_PARAM_S结构。CNend
+
+\retval ::HI_SUCCESS
+
+\see \n
+None
+*/
+typedef HI_S32 (*HI_UNF_SO_ONCLEAR_FN)(HI_VOID* pUserData, HI_VOID *pArg);
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      SUBTITLEOUT */
+/** @{*/  /** <!-- [SUBTITLEOUT]*/
+
+/**
+\brief  Init SO module. CNcomment:subtitle output 模块初始化。CNend
+\attention \n
+None
+\param None
+
+\retval ::HI_SUCCESS Init success. CNcomment:初始化成功。CNend
+\retval ::HI_FAILURE Operation fail. CNcomment:初始化失败。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_Init(HI_VOID);
+
+/**
+\brief  Deinit SO module. CNcomment:subtitle output 模块去初始化。CNend
+\attention \n
+None
+\param None
+
+\retval ::HI_SUCCESS  Deinit success. CNcomment:去初始化成功。CNend
+\retval ::HI_FAILURE Operation fail. CNcomment:去初始化失败。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_DeInit(HI_VOID);
+
+/**
+\brief  Creates an SO instance. CNcomment:创建一个so实例。CNend
+\attention \n
+None
+\param[out] phdl Handle of SO instance. CNcomment:播放器实例。CNend
+
+\retval ::HI_SUCCESS  Create success. CNcomment:创建成功，句柄有效。CNend
+\retval ::HI_FAILURE  Operation fail. CNcomment:创建失败。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_Create(HI_HANDLE *phdl);
+
+/**
+\brief  Destroy an SO instance. CNcomment:销毁一个so实例。CNend
+\attention \n
+None
+\param[in] handle Handle of SO instance. CNcomment:so实例句柄。CNend
+
+\retval ::HI_SUCCESS  Destroy success. CNcomment:销毁成功。CNend
+\retval ::HI_FAILURE  Operation fail. CNcomment:销毁失败，参数非法。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_Destroy(HI_HANDLE handle);
+
+/**
+\brief  Setting offset time of the subtitle. CNcomment:设置字幕时间偏移。CNend
+\attention \n
+None
+\param[in] handle Handle of SO instance. CNcomment:so实例句柄。CNend
+\param[in] s64OffsetMs Offset of subtitle, unit is Millisecondes.CNcomment:字幕显示时间偏移值，单位ms。CNend
+
+\retval ::HI_SUCCESS  Operation success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Operation fail. CNcomment:失败。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_SetOffset(HI_HANDLE handle, HI_S64 s64OffsetMs);
+
+/**
+\brief  Register the callback function of getting current play time. CNcomment:注册时间戳获取回调函数，so通过获取当前播放时间戳同步字幕。CNend
+\attention \n
+None
+\param[in] handle Handle of SO instance.CNcomment:so实例句柄。CNend
+\param[in] pstCallback Callback function. CNcomment:回调函数参数。CNend
+\param[in] pUserData User data. CNcomment:用户数据。CNend
+
+\retval ::HI_SUCCESS  Register success. CNcomment:注册成功。CNend
+\retval ::HI_FAILURE  Parameter invalid. CNcomment:注册失败。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_RegGetPtsCb(HI_HANDLE handle, HI_UNF_SO_GETPTS_FN pstCallback, HI_VOID* pUserData);
+
+/**
+\brief  Register the callback function of drawing subtitle.
+CNcomment:注册字幕绘制清除回调函数，如果设置了该函数，则so使用该函数实现字幕输出，字幕显示时长到达后，so调用清除函数通知清除。CNend
+\attention \n
+None
+\param[in] handle Handle of SO instance. CNcomment:so实例句柄。CNend
+\param[in] pfnOnDraw Callback function of drawing subtitle. CNcomment:绘制函数。CNend
+\param[in] pfnOnClear Callback function of clearing subtitle. CNcomment:清除函数。CNend
+\param[in] pUserData User data. CNcomment:用户数据。CNend
+
+\retval ::HI_SUCCESS  Register success. CNcomment:注册成功。CNend
+\retval ::HI_FAILURE Parameter invalid. CNcomment:注册失败。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_RegOnDrawCb(HI_HANDLE handle, HI_UNF_SO_ONDRAW_FN pfnOnDraw,
+                                          HI_UNF_SO_ONCLEAR_FN pfnOnClear, HI_VOID* pUserData);
+
+/**
+\brief  Set the surface of drawing subtitle, if you do not set the ondraw callback function, SO painting subtitles with the surface.
+CNcomment:设置字幕绘制画布句柄，如果没有设置ondraw回调函数，则so使用设置的画布句柄输出字幕。CNend
+\attention \n
+This feature is not implemented. CNcomment:该功能未实现。CNend
+\param[in] handle Handle of SO instance.CNcomment:so实例句柄。CNend
+\param[in] hSurfaceHandle Handle of surface. CNcomment:画布句柄。CNend
+
+\retval ::HI_SUCCESS Success of setting surface. CNcomment:设置成功。CNend
+\retval ::HI_FAILURE  Operation invalid. CNcomment:设置失败。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_SetDrawSurface(HI_HANDLE handle, HI_HANDLE hSurfaceHandle);
+
+/**
+\brief  Set the font of drawing subtitle.
+CNcomment:设置字幕显示字体，该设置仅对设置画布输出字幕的方式起作用。CNend
+\attention \n
+This feature is not implemented. CNcomment:该功能未实现。CNend
+\param[in] handle Handle of SO instance.CNcomment:so实例句柄。CNend
+\param[in] hFont Handle of font instance.CNcomment:创建的字体句柄。CNend
+
+\retval ::HI_SUCCESS  Success.CNcomment:设置成功。CNend
+\retval ::HI_FAILURE  Operation invalid. CNcomment:设置失败。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_SetFont(HI_HANDLE handle, HI_HANDLE hFont);
+
+/**
+\brief Set the color of drawing text subtitle.
+CNcomment:设置字幕显示颜色，该设置仅对设置画布输出字幕的方式起作用。CNend
+\attention \n
+This feature is not implemented. CNcomment:该功能未实现。CNend
+\param[in] handle Handle of SO instance. CNcomment:so实例句柄。CNend
+\param[in] u32Color Value of the color. CNcomment:颜色值。CNend
+
+\retval ::HI_SUCCESS  Success. CNcomment:设置成功。CNend
+\retval ::HI_FAILURE  Operation invalid. CNcomment:设置失败。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_SetColor(HI_HANDLE handle, HI_U32 u32Color);
+
+/**
+\brief Set the position of display subtitle.
+CNcomment:设置字幕显示坐标，该设置仅对设置画布输出字幕的方式起作用。CNend
+\attention \n
+This feature is not implemented. CNcomment:该功能未实现。CNend
+\param[in] handle Handle of SO instance. CNcomment:so实例句柄。CNend
+\param[in] u32x Value of x coordinate.CNcomment:x坐标。CNend
+\param[in] u32y Value of y coordinate. CNcomment:y坐标。CNend
+
+\retval ::HI_SUCCESS  Success. CNcomment:设置成功。CNend
+\retval ::HI_FAILURE  Parameter invalid. CNcomment:设置失败。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_SetPos(HI_HANDLE handle, HI_U32 u32x, HI_U32 u32y);
+
+/**
+\brief  Getting the number in the butitle queue.
+CNcomment:获取缓冲buffer中未显示的字幕数据个数。CNend
+\attention \n
+None
+\param[in] handle Handle of SO instance. CNcomment:so实例句柄。CNend
+\param[out] pu32SubNum Number of subtitles in queue. CNcomment:缓冲字幕个数。CNend
+
+\retval ::HI_SUCCESS Success. CNcomment:成功。CNend
+\retval ::HI_FAILURE Operation fail. CNcomment:失败。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_GetSubNumInBuff(HI_HANDLE handle, HI_U32 *pu32SubNum);
+
+/**
+\brief Clear the subtitles in queue.
+CNcomment:清除字幕缓冲中的数据，字幕切换时，需调用该接口清除so字幕缓存。CNend
+\attention \n
+None
+\param[in] handle Handle of SO instance. CNcomment:so实例句柄。CNend
+
+\retval ::HI_SUCCESS Success. CNcomment:成功。CNend
+\retval ::HI_FAILURE Operation invalid. CNcomment:失败。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_ResetSubBuf(HI_HANDLE handle);
+
+/**
+\brief  Clear the subtitles in queue by PTS. If PTS is 0, the same as HI_UNF_SO_ResetSubBuf.
+CNcomment:清除字幕缓冲中的数据,小于指定PTS的字幕缓冲被清除.如果指定PTS值为0,这个接口等效于HI_UNF_SO_ResetSubBuf。CNend
+\attention \n
+None
+\param[in] handle Handle of SO instance. CNcomment:so实例句柄。CNend
+
+\retval ::HI_SUCCESS Success. CNcomment:成功。CNend
+\retval ::HI_FAILURE Operation invalid. CNcomment:失败。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_ResetSubBuf_ByPts(HI_HANDLE handle, HI_S64 s64Pts);
+
+/**
+\brief  Send subtitles to SO queue. If the data size and the number is larger than the value set by the user, then the transmission fails.
+CNcomment:发送字幕数据给so，如果缓冲size和个数都超过用户设置的值，则发送失败。CNend
+\attention \n
+None
+\param[in] handle Handle of SO instance. CNcomment:so实例句柄。CNend
+\param[in] pstSubInfo Data of subtitle. CNcomment:字幕信息。CNend
+\param[in] u32TimeOut Timeout of sending subtitle. CNcomment:发送超时时间，单位ms。CNend
+
+\retval ::HI_SUCCESS  Success. CNcomment:发送成功。CNend
+\retval ::HI_FAILURE  Operation fail.CNcomment:发送失败。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_SendData(HI_HANDLE handle, const HI_UNF_SO_SUBTITLE_INFO_S *pstSubInfo, HI_U32 u32TimeOutMs);
+
+/**
+\brief  Get current subt data in SO queue.
+CNcomment:获取SO 队列中，当前正在处理的字幕数据。CNend
+\attention \n
+None
+\param[in] handle Handle of SO instance. CNcomment:so实例句柄。CNend
+\param[in] pstSubInfo Data of subtitle. CNcomment:字幕信息。CNend
+
+\retval ::HI_SUCCESS  Success. CNcomment:发送成功。CNend
+\retval ::HI_FAILURE  Operation fail.CNcomment:发送失败。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_GetCurData(HI_HANDLE handle, HI_UNF_SO_SUBTITLE_INFO_S *pstSubInfo);
+
+/**
+\brief  Setting max interval time of the subtitle.
+CNcomment:设置字幕最大的时间偏差。CNend
+\attention \n
+None
+\param[in] handle Handle of SO instance. CNcomment:so实例句柄。CNend
+\param[in] u32IntervalMs max interval of subtitle, unit is Millisecondes.
+CNcomment:字幕最大的时间偏差值，单位ms。CNend
+
+\retval ::HI_SUCCESS  Operation success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Operation fail. CNcomment:失败。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_SO_SetMaxInterval(HI_HANDLE handle, HI_U32 u32IntervalMs );
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_SO_H__ */
diff -uNr a/include/hi_unf_sound.h b/include/hi_unf_sound.h
--- a/include/hi_unf_sound.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_sound.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,1931 @@
+/******************************************************************************
+  Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+  File Name     : hi_unf_sound.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/1/22
+  Last Modified :
+  Description   : header file for audio and video output control
+  Function List :
+  History       :
+  1.Date        :
+  Author        : z67193
+  Modification  : Created file
+******************************************************************************/
+/**
+ * \file
+ * \brief Describes the information about the SOUND (SND) module. CNcomment:提供SOUND的相关信息 CNend
+ */
+
+#ifndef  __HI_UNF_SND_H__
+#define  __HI_UNF_SND_H__
+
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/********************************Macro Definition********************************/
+/** \addtogroup      SOUND */
+/** @{ */  /** <!-- 【SOUND】 */
+
+/**Maximum sound outputport*/
+/**CNcomment:最大sound输出端口*/
+#define HI_UNF_SND_OUTPUTPORT_MAX (16)
+#define HI_UNF_SND_EQ_BANDNUM_MAX (10)
+
+/** @} */  /** <!-- ==== Macro Definition end ==== */
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      SOUND */
+/** @{ */  /** <!--  【SOUND】 */
+
+/**Defines the ID of the audio output (AO) device.*/
+/**CNcomment:定义音频输出设备号*/
+typedef enum hiUNF_SND_E
+{
+    HI_UNF_SND_0,           /**<AO device 0*/ /**<CNcomment:音频输出设备0 */
+    HI_UNF_SND_1,           /**<AO device 1*/ /**<CNcomment:音频输出设备1 */
+    HI_UNF_SND_2,           /**<AO device 2*/ /**<CNcomment:音频输出设备2 */
+    HI_UNF_SND_BUTT
+} HI_UNF_SND_E;
+
+/**Audio volume attribute*/
+/**CNcomment:音频音量属性*/
+typedef struct hiHI_UNF_SND_GAIN_ATTR_S
+{
+    HI_BOOL bLinearMode; /**< gain type of volume*/ /**<CNcomment:音量模式 */
+    HI_S32  s32Gain; /**<Linear gain(bLinearMode is HI_TRUE) , ranging from 0 to 100*/ /**<CNcomment:线性音量: 0~100 */
+                     /**<Decibel gain(bLinearMode is HI_FALSE) , ranging from -70dB to 0dB */ /**<CNcomment: dB音量:-70~0*/
+} HI_UNF_SND_GAIN_ATTR_S;
+
+/**Audio L/R channel volume attribute*/
+/**CNcomment:音频左右声道音量属性*/
+typedef struct hiHI_UNF_SND_ABSGAIN_ATTR_S
+{
+    HI_BOOL bLinearMode; /**< gain type*/ /**<CNcomment:音量模式 */
+    HI_S32  s32GainL; /**<Linear left ch gain(bLinearMode is HI_TRUE) , ranging from 0 to 100*/ /**<CNcomment:左声道线性音量: 0~100 */
+                     /**<Decibel left ch gain(bLinearMode is HI_FALSE) , ranging from -81dB to 18dB */ /**<CNcomment: 左声道dB音量:-81~+18*/
+    HI_S32  s32GainR; /**<Linear right ch gain(bLinearMode is HI_TRUE) , ranging from 0 to 100*/ /**<CNcomment:右声道线性音量: 0~100 */
+                  /**<Decibel right ch gain(bLinearMode is HI_FALSE) , ranging from -81dB to 18dB */ /**<CNcomment: 右声道dB音量:-81~+18*/
+} HI_UNF_SND_ABSGAIN_ATTR_S;
+
+/**High Precision Gain, ranging from -81dB to 18dB, step 0.125dB*/
+/**CNcomment:高精度增益，范围从-81dB到18dB，步长为0.125dB*/
+typedef struct hiHI_UNF_SND_PRECIGAIN_ATTR_S
+{
+    HI_S32 s32IntegerGain; /**<Interger part of high preicision gain*/ /**<CNcomment: 高精度增益的整数部分*/
+    HI_S32 s32DecimalGain; /**<decimal part of high preicision gain, if -0.125dB, value is -125*/ /**<CNcomment: 高精度增益的小数部分 如0.125，则值为125*/
+}HI_UNF_SND_PRECIGAIN_ATTR_S;
+
+/**Audio Track Type: Master, Slave, Virtual channel,LowLatency channel*/
+/**CNcomment:音频Track类型:主通道 辅通道 虚拟通道 低延时通道*/
+/**LowLatency channel not support attach avplay and the data only support 48K,stereo,16Bit.Only support one lowlatency track in a sound*/
+/**CNcomment:低延时通道不支持AVPLAY绑定，此通道只支持采样率为48K,双声道,16位位宽的音频数据,仅支持创建一个低延时通道*/
+typedef enum hiHI_UNF_SND_TRACK_TYPE_E
+{
+    HI_UNF_SND_TRACK_TYPE_MASTER = 0,
+    HI_UNF_SND_TRACK_TYPE_SLAVE,
+    HI_UNF_SND_TRACK_TYPE_VIRTUAL,
+    HI_UNF_SND_TRACK_TYPE_LOWLATENCY,
+
+    HI_UNF_SND_TRACK_TYPE_OTTSOUND,      /**< Ott sound(PCM) MS12 ONLY. Such as app ui audio*/
+    HI_UNF_SND_TRACK_TYPE_SYSTEMAUDIO,   /**< System sound(PCM) MS12 ONLY.*/
+    HI_UNF_SND_TRACK_TYPE_APPAUDIO,      /**< App audio(PCM) MS12 ONLY. Such as tts audio*/
+    HI_UNF_SND_TRACK_TYPE_BUTT
+} HI_UNF_SND_TRACK_TYPE_E;
+
+/**Audio output attribute */
+/**CNcomment:音频输出属性*/
+typedef struct hiHI_UNF_AUDIOTRACK_ATTR_S
+{
+    HI_UNF_SND_TRACK_TYPE_E     enTrackType;        /**<Track Type*/ /**<CNcomment:Track类型*/
+    HI_U32                      u32FadeinMs;        /**<Fade in time(unit:ms)*/ /**<CNcomment:淡入时间(单位: ms)*/
+    HI_U32                      u32FadeoutMs;       /**<Fade out time(unit:ms)*/ /**<CNcomment:淡出时间(单位: ms)*/
+    HI_U32                      u32OutputBufSize;   /**<Track output buffer size*/ /**<CNcomment:Track输出缓存大小*/
+    HI_U32                      u32BufLevelMs;      /**<Output buffer data size control(ms),default 400ms*/ /**<CNcomment:输出缓存中数据量控制(ms),默认400ms*/
+    HI_U32                      u32StartThresholdMs;  /**<Track start threshold (ms), default value is 50ms, max value is equal to u32BufLevelMs, only valid for master track*/
+                                                      /**<CNcomment:Track启动门限，默认值是50ms，最大值为u32BufLevelMs，此属性只对master track有效*/
+} HI_UNF_AUDIOTRACK_ATTR_S;
+
+/**Audiotrack config parameter*/
+/**CNcomment:音频 Track配置参数*/
+typedef struct hiHI_UNF_AUDIOTRACK_CONFIG_S
+{
+    HI_U32      u32ConfigType;        /**<Track config type*/ /**<CNcomment:Track配置类型*/
+    HI_VOID*    pConfigData;          /**<Track config data*/ /**<CNcomment:Track配置数据*/
+} HI_UNF_AUDIOTRACK_CONFIG_S;
+
+/**Audio outputport: DAC0,I2S0,SPDIF0,HDMI0,ARC0*/
+/**CNcomment:音频输出端口:DAC0,I2S0,SPDIF0,HDMI0,ARC0*/
+typedef enum hiUNF_SND_OUTPUTPORT_E
+{
+    HI_UNF_SND_OUTPUTPORT_DAC0 = 0,
+
+    HI_UNF_SND_OUTPUTPORT_I2S0,
+
+    HI_UNF_SND_OUTPUTPORT_I2S1,
+
+    HI_UNF_SND_OUTPUTPORT_SPDIF0,
+
+    HI_UNF_SND_OUTPUTPORT_HDMI0,
+
+    HI_UNF_SND_OUTPUTPORT_ARC0,
+
+    HI_UNF_SND_OUTPUTPORT_EXT_DAC1 = 0x50,
+
+    HI_UNF_SND_OUTPUTPORT_EXT_DAC2,
+
+    HI_UNF_SND_OUTPUTPORT_EXT_DAC3,
+
+    HI_UNF_SND_OUTPUTPORT_ALL = 0x7fff,
+
+    HI_UNF_SND_OUTPUTPORT_BUTT,
+} HI_UNF_SND_OUTPUTPORT_E;
+
+/**Defines internal Audio DAC outport attribute */
+/**CNcomment:定义内置音频DAC输出端口属性*/
+typedef struct hiUNF_SND_DAC_ATTR_S
+{
+    HI_U32 u32Reserved;
+} HI_UNF_SND_DAC_ATTR_S;
+
+/**Defines  Audio I2S outport attribute */
+/**CNcomment:定义音频I2S输出端口属性*/
+typedef struct hiUNF_SND_I2S_ATTR_S
+{
+    HI_UNF_I2S_ATTR_S  stAttr;
+}  HI_UNF_SND_I2S_ATTR_S;
+
+/**Defines  S/PDIF outport attribute */
+/**CNcomment:定义S/PDIF输出端口属性*/
+typedef struct hiUNF_SND_SPDIF_ATTR_S
+{
+    HI_U32 u32Reserved;
+}  HI_UNF_SND_SPDIF_ATTR_S;
+
+/**Defines  HDMI Audio outport attribute */
+/**CNcomment:定义HDMI音频输出端口属性*/
+typedef struct hiUNF_SND_HDMI_ATTR_S
+{
+    HI_U32 u32Reserved;
+} HI_UNF_SND_HDMI_ATTR_S;
+
+/**Defines  HDMI ARC outport attribute */
+/**CNcomment:定义HDMI音频回传通道端口属性*/
+typedef struct hiUNF_SND_ARC_ATTR_S
+{
+    HI_U32 u32Reserved;
+} HI_UNF_SND_ARC_ATTR_S;
+
+/**Defines  Audio outport attribute */
+/**CNcomment:定义音频输出端口属性*/
+typedef struct hiUNF_SND_OUTPORT_S
+{
+    HI_UNF_SND_OUTPUTPORT_E enOutPort;
+    union
+    {
+        HI_UNF_SND_DAC_ATTR_S   stDacAttr;
+        HI_UNF_SND_I2S_ATTR_S   stI2sAttr;
+        HI_UNF_SND_SPDIF_ATTR_S stSpdifAttr;
+        HI_UNF_SND_HDMI_ATTR_S  stHDMIAttr;
+        HI_UNF_SND_ARC_ATTR_S   stArcAttr;
+    } unAttr;
+} HI_UNF_SND_OUTPORT_S;
+
+/**Defines  Render attribute */
+/**CNcomment:定义Render引擎属性*/
+typedef struct hiUNF_SND_RENDER_ATTR_S
+{
+	HI_CHAR* pCommPath;
+} HI_UNF_SND_RENDER_ATTR_S;
+
+/**Defines  Audio Sound device attribute */
+/**CNcomment:定义Sound设备属性*/
+typedef struct hiHI_UNF_SND_ATTR_S
+{
+    HI_U32                  u32PortNum;  /**<Outport number attached sound*/ /**<CNcomment:绑定到Sound设备的输出端口数*/
+    HI_UNF_SND_OUTPORT_S    stOutport[HI_UNF_SND_OUTPUTPORT_MAX];  /**<Outports attached sound*/ /**<CNcomment:绑定到Sound设备的输出端口*/
+    HI_UNF_SAMPLE_RATE_E    enSampleRate;       /**<Sound samplerate*/ /**<CNcomment:Sound设备输出采样率*/
+    HI_U32                  u32MasterOutputBufSize; /**<Sound master channel buffer size*/ /**<CNcomment:Sound设备主输出通道缓存大小*/
+    HI_U32                  u32SlaveOutputBufSize;  /**<Sound slave channel buffer size*/ /**<CNcomment:Sound设备从输出通道缓存大小*/
+} HI_UNF_SND_ATTR_S;
+
+/**define SND CAST config  struct */
+/**CNcomment:定义声音共享配置结构体*/
+typedef struct hiUNF_SND_CAST_ATTR_S
+{
+    HI_U32  u32PcmFrameMaxNum;     /**<Max frame of the PCM data at cast buffer*/ /**<CNcomment: 最大可缓存帧数*/
+    HI_U32  u32PcmSamplesPerFrame; /**<Number of sample of the PCM data*/ /**<CNcomment: PCM数据采样点数量*/
+    HI_BOOL bAddMute;              /**<Add mute frame in cast or not>*/ /**<CNcomment: cast是否插入静音帧*/
+} HI_UNF_SND_CAST_ATTR_S;
+
+/**HDMI MODE:AUTO,LPCM,RAW,HBR2LBR*/
+/**CNcomment:HDMI 模式:AUTO,LPCM,RAW,HBR2LBR*/
+typedef enum hiHI_UNF_SND_HDMI_MODE_E
+{
+    HI_UNF_SND_HDMI_MODE_LPCM = 0,       /**<HDMI LCPM2.0*/ /**<CNcomment: 立体声pcm*/
+    HI_UNF_SND_HDMI_MODE_RAW,            /**<HDMI Pass-through.*/ /**<CNcomment: HDMI透传*/
+    HI_UNF_SND_HDMI_MODE_HBR2LBR,        /**<HDMI Pass-through force high-bitrate to low-bitrate.*/ /**<CNcomment: 蓝光次世代音频降规格输出*/
+    HI_UNF_SND_HDMI_MODE_AUTO,           /**<automatically match according to the EDID of HDMI */ /**<CNcomment: 根据HDMI EDID能力自动匹配*/
+    HI_UNF_SND_HDMI_MODE_BUTT
+} HI_UNF_SND_HDMI_MODE_E;
+
+/**SPDIF MODE:LPCM,RAW*/
+/**CNcomment:SPDIF 模式:LPCM,RAW*/
+typedef enum hiHI_UNF_SND_SPDIF_MODE_E
+{
+    HI_UNF_SND_SPDIF_MODE_LPCM,           /**<SPDIF LCPM2.0*/ /**<CNcomment: 立体声pcm*/
+    HI_UNF_SND_SPDIF_MODE_RAW,            /**<SPDIF Pass-through.*/ /**<CNcomment: SPDIF透传*/
+    HI_UNF_SND_SPDIF_MODE_BUTT
+} HI_UNF_SND_SPDIF_MODE_E;
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/**SPDIF Category Code Setting*/
+/**CNcomment:设置SPDIF Category Code类型*/
+typedef enum hiHI_UNF_SND_SPDIF_CATEGORYCODE_E
+{
+    HI_UNF_SND_SPDIF_CATEGORY_GENERAL = 0x00,       /**<General*/                  /**<CNcomment:通用*/
+    /*broadcast reception of digitally encoded audio
+    with/without video signals*/
+    HI_UNF_SND_SPDIF_CATEGORY_BROADCAST_JP = 0x10,  /**<Japan*/                    /**<CNcomment:日本*/
+    HI_UNF_SND_SPDIF_CATEGORY_BROADCAST_USA,        /**<United States*/            /**<CNcomment:美国*/
+    HI_UNF_SND_SPDIF_CATEGORY_BROADCAST_EU,         /**<Europe*/                   /**<CNcomment:欧洲*/
+    /*digital converter & signal-processing products*/
+    HI_UNF_SND_SPDIF_CATEGORY_PCM_CODEC = 0x20,     /**<PCM Encoder/Decoder*/      /**<CNcomment:PCM编解码*/
+    HI_UNF_SND_SPDIF_CATEGORY_DIGITAL_SNDSAMPLER,   /**<Digital Sound Sampler*/    /**<CNcomment:数字音频采样器*/
+    HI_UNF_SND_SPDIF_CATEGORY_DIGITAL_MIXER,        /**<Digital Signal Mixer*/     /**<CNcomment:数字信号混音器*/
+    HI_UNF_SND_SPDIF_CATEGORY_DIGITAL_SNDPROCESSOR, /**<Digital Sound Processor*/  /**<CNcomment:数字音频处理器*/
+    HI_UNF_SND_SPDIF_CATEGORY_SRC,                  /**<Sample Rate Converter*/    /**<CNcomment:采样率转换器*/
+    /*laser optical products*/
+    HI_UNF_SND_SPDIF_CATEGORY_MD = 0x30,            /**<MiniDisc*/                 /**<CNcomment:迷你磁光盘*/
+    HI_UNF_SND_SPDIF_CATEGORY_DVD,                  /**<Digital Versatile Disc*/   /**<CNcomment:数字多功能光盘*/
+    /*musical instruments, microphones and other sources
+    that create original sound*/
+    HI_UNF_SND_SPDIF_CATEGORY_SYNTHESISER = 0x40,   /**<Synthesiser*/              /**<CNcomment:合成器*/
+    HI_UNF_SND_SPDIF_CATEGORY_MIC,                  /**<Microphone*/               /**<CNcomment:麦克风*/
+    /*magnetic tape or magnetic disc based products*/
+    HI_UNF_SND_SPDIF_CATEGORY_DAT = 0x50,           /**<Digital Audio Tape*/       /**<CNcomment:数字录音带*/
+    HI_UNF_SND_SPDIF_CATEGORY_DCC,                  /**<Digital Compact Cassette*/ /**<CNcomment:数字盒式磁带录音机*/
+    HI_UNF_SND_SPDIF_CATEGORY_VCR,                  /**<Video Cassette Recorder*/  /**<CNcomment:盒式磁带录像机*/
+
+    HI_UNF_SND_SPDIF_CATEGORY_BUTT
+} HI_UNF_SND_SPDIF_CATEGORYCODE_E;
+
+/**SPDIF SCMS Mode Setting*/
+/**CNcomment:设置SPDIF SCMS模式*/
+typedef enum hiHI_UNF_SND_SPDIF_SCMSMODE_E
+{
+    HI_UNF_SND_SPDIF_SCMSMODE_COPYALLOW,                /**<Copy Allow*/      /**<CNcomment:允许复制*/
+    HI_UNF_SND_SPDIF_SCMSMODE_COPYONCE,                 /**<Copy Once*/       /**<CNcomment:可复制一次*/
+    HI_UNF_SND_SPDIF_SCMSMODE_COPYNOMORE,               /**<Copy NoMore*/     /**<CNcomment:不可复制*/
+    HI_UNF_SND_SPDIF_SCMSMODE_COPYPROHIBITED,           /**<Copy prohibited*/ /**<CNcomment:禁止复制*/
+    HI_UNF_SND_SPDIF_SCMSMODE_BUTT
+} HI_UNF_SND_SPDIF_SCMSMODE_E;
+
+/**audio effect type, HI_UNF_AUDIO_EFFECT_TYPE_E keep consistent with effect type of ARM/DSP*/
+/**CNcomment:音效类型，HI_UNF_AUDIO_EFFECT_TYPE_E 必须 ARM/DSP 保持唯一值 */
+typedef enum
+{
+    HI_UNF_SND_AEF_TYPE_DOLBYDV258 = 0x000,  /**<Dolby audio effect*/ /**<CNcomment: Dolby音效*/
+
+    HI_UNF_SND_AEF_TYPE_SRS3D = 0x010,      /**<SRS audio effect*/ /**<CNcomment: SRS音效*/
+
+    HI_UNF_SND_AEF_TYPE_BASE = 0x080,       /**<Base audio effect*/ /**<CNcomment: 自研音效*/
+} HI_UNF_SND_AEF_TYPE_E;
+
+typedef enum hiUNF_PEQ_FILTER_TYPE_E
+{
+    HI_UNF_PEQ_FILTER_TYPE_HP = 0,  /**<high-pass filter*/ /**<CNcomment: 高通滤波器 */
+    HI_UNF_PEQ_FILTER_TYPE_LS = 1,  /**<low-shelving filter*/ /**<CNcomment: 低频搁架滤波器 */
+    HI_UNF_PEQ_FILTER_TYPE_PK = 2,  /**<peaking filter*/ /**<CNcomment: 峰值滤波器 */
+    HI_UNF_PEQ_FILTER_TYPE_HS = 3,  /**<high-shelving filter*/ /**<CNcomment: 高频搁架滤波器  */
+    HI_UNF_PEQ_FILTER_TYPE_LP = 4,  /**<low-pass filter*/ /**<CNcomment: 低通滤波器 */
+    HI_UNF_PEQ_FILTER_TYPE_BUTT
+} HI_UNF_PEQ_FILTER_TYPE_E;
+
+/**Defines PEQ band attribute*/
+/**CNcomment:PEQ 频带属性*/
+typedef struct hiHI_UNF_SND_PEQ_BAND_ATTR_S
+{
+    HI_UNF_PEQ_FILTER_TYPE_E enFltType; /**<filter type of the band*/ /**<CNcomment: 某一频带的滤波器类型*/
+    HI_U32 u32freq;  /**<center frequency of the band, HP and LS[20, 4000], PK[20, 22000], HS[4000, 22000], LP[50, 22000]*/
+                     /**<CNcomment: 某一频带的中心频率,范围: HP and LS[20, 4000], PK[20, 22000], HS[4000, 22000], LP[50, 22000]*/
+    HI_U32 u32Q; /**<Q value of the band, if 2.5, value is 25, range:HS and LS[0.7, 1], PK[0.5, 10],HP and LP is fix to be 0.7*/
+                 /**<CNcomment: 某一频带的q值,如值为2.5,设置值为25,范围: HS and LS[0.7, 1], PK[0.5, 10], 高低通内部固定为0.7*/
+    HI_S32 s32Gain; /**<gain of the band, if -2.125, value is -2125,Gain ranging from -15 to 15 step by 0.125dB*/
+                    /**<CNcomment: 某一频带的增益,如值为-2.125,设置值为-2125,范围:[-15, 15],精度0.125*/
+} HI_UNF_SND_PEQ_BAND_ATTR_S;
+
+/**Defines PEQ attribute */
+/**CNcomment:PEQ属性 */
+typedef struct hiHI_UNF_SND_PEQ_ATTR_S
+{
+    HI_U32 u32BandNum; /**<the PEQ band number,u32BandNum ranging from 5 to 10*/ /**<CNcomment: PEQ频带数量,范围:[5,10]*/
+    HI_UNF_SND_PEQ_BAND_ATTR_S stEqParam[HI_UNF_SND_EQ_BANDNUM_MAX];/**<PEQ band attribute*/ /**<CNcomment: PEQ频带属性*/
+} HI_UNF_SND_PEQ_ATTR_S;
+
+/**Defines DRC attribute */
+/**CNcomment:DRC属性*/
+typedef struct hiHI_UNF_SND_DRC_ATTR_S
+{
+    HI_U32  u32AttackTime;   /**<the attack time(unit:ms),ranging from 20 to 2000*/ /**<CNcomment: 开始生效时间(单位:ms),范围:[20, 2000]*/
+    HI_U32  u32ReleaseTime;  /**<the release time(unit:ms),ranging from 20 to 2000*/ /**<CNcomment: 开始失效时间(单位:ms),范围:[20, 2000]*/
+    HI_S32  s32Thrhd;  /**<the threshold value, if -2.125, value is -2125, threshold ranging from -80dB to -1dB step by 0.125dB*/
+                       /**<CNcomment: 开始限幅幅值,如值为-2.125,设置值为-2125,步长为0.125dB,范围:[-80dB, -1dB)*/
+    HI_S32  s32Limit;  /**<the maximum value, if -2.125, value is -2125, threshold ranging from -80dB to -1dB step by 0.125dB*/
+                       /**<CNcomment: 最大限幅幅值,如值为-2.125,设置值为-2125,步长为0.125dB,范围:[-80dB, -1dB)*/
+    HI_U32  u32RefMode;  /**<refmode(0:process both channel together mode, 1:process each channel independently mode)*/ /**<CNcomment:  0: 原始版本效果， 1：单声道处理， 其余配置无效*/
+    HI_U32  u32SpeedCtrlMode;  /**<speedctrlmode(0:normal mode, 1:fast mode)*/ /**<CNcomment: 0: 原始版本效果， 1: 较快速控制， 其余配置无效*/
+} HI_UNF_SND_DRC_ATTR_S;
+
+/**Defines  AVC attribute */
+/**CNcomment:AVC属性*/
+typedef struct hiHI_UNF_SND_AVC_ATTR_S
+{
+    HI_S32  s32ThresholdLevel;  /**<the threshold value, if -32.125, value is -32125, ranging from -40dB to -16dB step by 0.125dB*/
+                                /**<CNcomment: 达到最大抬升增益的转折电平,如值为-32.125,设置值为-32125,步长为0.125dB,范围(-40dB, -16dB)*/
+    HI_S32  s32Gain;            /**<the gain value, if 2.125, value is 2125,ranging from 0dB to 8dB step by 0.125dB*/
+                                /**<CNcomment: 抬升增益,如值为2.125,设置值为2125,步长为0.125dB,范围:[0dB, 8dB]*/
+    HI_S32  s32LimiterLevel;    /**<the target level value, if -2.125, value is -2125, ranging from -40dB to 0dB step by 0.125dB*/
+                                /**<CNcomment:目标值,如值为-2.125,设置值为-2125,步长为0.125dB,范围:(-40dB, 0dB]*/
+    HI_U32  u32AttackTime;      /**<the attack time(unit:ms),ranging from 20 to 2000,default value 50(recommended)*/ /**<CNcomment: 开始生效时间(单位:ms),范围:[20, 2000]，默认值50，不建议修改*/
+    HI_U32  u32ReleaseTime;     /**<the release time(unit:ms),ranging from 20 to 2000,default value 100(recommended)*/ /**<CNcomment: 开始失效时间(单位:ms),范围:[20, 2000]，默认值100，不建议修改*/
+} HI_UNF_SND_AVC_ATTR_S;
+
+/**Audio output latency mode*/
+/**CNcomment:音频输出时延模式*/
+typedef enum
+{
+    HI_UNF_SND_OUTPUTLATENCY_NORMAL = 0,  /**<normal latency MS12 ONLY.*/ /**<CNcomment:通用时延*/
+    HI_UNF_SND_OUTPUTLATENCY_LOW,         /**<low latency MS12 ONLY*/     /**<CNcomment:低时延*/
+    HI_UNF_SND_OUTPUTLATENCY_BUTT,
+} HI_UNF_SND_OUTPUTLATENCY_E;
+
+/******************************* API declaration *****************************/
+/** \addtogroup      SOUND */
+/** @{ */  /** <!--  【SOUND】 */
+
+/**
+\brief Initializes an AO device. CNcomment:初始化音频输出设备 CNend
+\attention \n
+Before calling the SND module, you must call this application programming interface (API). CNcomment:调用SND模块要求首先调用该接口 CNend
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_Init(HI_VOID);
+
+/**
+\brief Deinitializes an AO device. CNcomment:去初始化音频输出设备 CNend
+\attention \n
+N/A
+\param N/A
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_DeInit(HI_VOID);
+
+/**
+\brief Obtains the default configured parameters of an AO device. CNcomment:获取音频输出设备默认设置参数 CNend
+\attention \n
+\param[in] enSound     ID of an AO device CNcomment:音频输出设备号 CNend
+\param[out] pstAttr     Audio attributes CNcomment:音频属性 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetDefaultOpenAttr(HI_UNF_SND_E enSound, HI_UNF_SND_ATTR_S* pstAttr);
+
+/**
+\brief Starts an AO device. CNcomment:打开音频输出设备 CNend
+\attention \n
+One port only can attach to one sound.
+CNcomment:每个端口只能绑定一个sound CNend
+\param[in] enSound     ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] pstAttr     Attribute of an AO device CNcomment:音频输出设备参数 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_Open(HI_UNF_SND_E enSound, const HI_UNF_SND_ATTR_S* pstAttr);
+
+/**
+\brief Destroys a AO SND instance. CNcomment:销毁音频输出Sound实例 CNend
+\attention \n
+An instance cannot be destroyed repeatedly. CNcomment:不支持重复销毁 CNend
+\param[in] enSound     ID of an AO device CNcomment:音频输出设备号 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_Close(HI_UNF_SND_E enSound);
+
+
+/**
+\brief Sets the mute status of  AO ports. CNcomment:音频输出静音开关设置 CNend
+\attention \n
+N/A
+\param[in] enSound
+\param[in] enOutPort CNcomment:sound输出端口 CNend
+\param[in] bMute
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SetMute(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL bMute);
+
+/**
+\brief Obtains the mute status of AO ports. CNcomment:获取音频输出的静音开关状态 CNend
+\attention \n
+N/A
+\param[in] enSound CNcomment:
+\param[in] enOutPort CNcomment:sound输出端口 CNend
+\param[out] pbMute CNcomment:
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetMute(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL* pbMute);
+
+/**
+\brief Sets the output mode of the HDMI(Auto/PCM/RAW/HBR2LBR).
+\attention \n
+\param[in] enSound CNcomment:音频输出设备号  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment:音频输出端口 CNend
+\param[in] enHdmiMode HDMI mode CNcomment:HDMI模式CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SetHdmiMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_HDMI_MODE_E enHdmiMode);
+
+/**
+\brief Gets the output mode of the HDMI.
+\attention \n
+\param[in] enSound CNcomment:音频输出设备号  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment:音频输出端口 CNend
+\param[out] Pointer to the obtained HDMI mode CNcomment:获取到的HDMI模式的指针CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetHdmiMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_HDMI_MODE_E* penHdmiMode);
+
+/**
+\brief Sets the output mode of the SPDIF(PCM/RAW).
+\attention \n
+\param[in] enSound CNcomment:音频输出设备号  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment:音频输出端口 CNend
+\param[in] enHdmiMode SPDIF mode CNcomment:SPDIF模式CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_ID    The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SetSpdifMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_MODE_E enSpdifMode);
+
+/**
+\brief Gets the output mode of the SPDIF.
+\attention \n
+\param[in] enSound CNcomment:音频输出设备号  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment:音频输出端口 CNend
+\param[out] penSpdifMode Pointer to the obtained SPDIF mode CNcomment:获取到的SPDIF模式的指针CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_ID    The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetSpdifMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_MODE_E* penSpdifMode);
+
+/**
+ \brief Sets the output volume value. CNcomment:设置输出音量 CNend
+ \attention \n
+If s32Gain is set to a value greater than 100 or 0dB, then return failure. CNcomment:如果s32Gain设置大于100或0dB，返回失败 CNend
+ \param[in] enSound        ID of an AO device CNcomment:音频输出设备号 CNend
+ \param[in] enOutPort  Audio OutputPort     CNcomment:音频输出端口 CNend
+ \param[in] pstGain     Volume value CNcomment:设置的音量值 CNend
+ \retval ::HI_SUCCESS Success CNcomment:成功 CNend
+ \retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+ \retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+ \retval ::HI_ERR_AO_INVALID_PARA       The parameter is invalid. CNcomment:无效的参数 CNend
+ \retval ::HI_ERR_SND_INVALID_ID        The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+ \retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment:指针参数为空 CNend
+ \see \n
+N/A
+ */
+HI_S32   HI_UNF_SND_SetVolume(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, const HI_UNF_SND_GAIN_ATTR_S* pstGain);
+
+/**
+\brief Obtains the output volume value. CNcomment:获取输出音量 CNend
+\attention \n
+The default linear volume value is 100 and abslute volume is 0dB. CNcomment:查询的默认音量值为100(线性音量) and 0dB(绝对音量) CNend
+\param[in] enSound         ID of an AO device CNcomment:音频输出设备号 CNend
+ \param[in] enOutPort  Audio OutputPort     CNcomment:音频输出端口 CNend
+ \param[out] pstGain    Pointer to the obtained volume value CNcomment:指针类型，获取到的音量值 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetVolume(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_GAIN_ATTR_S* pstGain);
+
+/**
+\brief Sets the category code of the SPDIF.
+\attention \n
+\param[in] enSound CNcomment:音频输出设备号  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment:音频输出端口 CNend
+\param[in] enSpdifCategoryCode  SPDIF category code CNcomment:SPDIF 输出设备分类码CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_ID    The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetSpdifCategoryCode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_CATEGORYCODE_E enSpdifCategoryCode);
+
+/**
+\brief Gets the category code of the SPDIF.
+\attention \n
+\param[in] enSound CNcomment:音频输出设备号  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment:音频输出端口 CNend
+\param[out] enSpdifCategoryCode Pointer to the obtained category code CNcomment:获取到的分类码的指针CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN      Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_ID          The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR            The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetSpdifCategoryCode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_CATEGORYCODE_E* penSpdifCategoryCode);
+
+/**
+\brief Sets the SCMS mode of the SPDIF(COPYALLOW/COPYONCE/COPYPROHIBITED).
+\attention \n
+\param[in] enSound CNcomment:音频输出设备号  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment:音频输出端口 CNend
+\param[in] enSpdifSCMSMode  SPDIF SCMS mode CNcomment:SPDIF SCMS 模式CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_ID    The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetSpdifSCMSMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_SCMSMODE_E enSpdifSCMSMode);
+
+/**
+\brief Gets the SCMS mode of the SPDIF.
+\attention \n
+\param[in] enSound CNcomment:音频输出设备号  CNend
+\param[in] enOutPort  Audio OutputPort   CNcomment:音频输出端口 CNend
+\param[out] enSpdifSCMSMode Pointer to the obtained SPDIF SCMS mode CNcomment:获取到的SPDIF SCMS模式的指针CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN      Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_ID          The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR            The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetSpdifSCMSMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_SPDIF_SCMSMODE_E* enSpdifSCMSMode);
+
+/**
+\brief Sets the sampling rate during audio output. CNcomment:设置音频输出时的采样率 CNend
+\attention \n
+At present, the sampling rate cannot be set, and it is fixed at 48 kHz. The streams that are not sampled at 48 kHz are resampled at 48 kHz.
+CNcomment:目前输出采样率默认为48k(实际输出采样率为48K~192K)，支持从8K到192K码流输入，因最大支持6倍重采样，\n
+因此当设定输出采样率为192K时(实际输出采样率为192K)，播小于32K的码流会出错(此时不影响其它采样率的码流切换)\n
+然而当设定输出采样率为8K时(实际输出采样率为8K~192K)，此时不能通过HDMI输出小于32K的码流(HDMI不支持) CNend
+\param[in] enSound          ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enSampleRate    Audio sampling rate. For details, see the description of ::HI_UNF_SAMPLE_RATE_E. CNcomment:音频采样率。请参见::HI_UNF_SAMPLE_RATE_E CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetSampleRate(HI_UNF_SND_E enSound, HI_UNF_SAMPLE_RATE_E enSampleRate);
+
+/**
+\brief Obtains the sampling rate during audio output. CNcomment:获取音频输出时的采样率 CNend
+\attention \n
+The 48 kHz sampling rate is returned by default. CNcomment:此接口默认返回48kHz采样率 CNend
+\param[in] enSound           ID of an AO device CNcomment:音频输出设备号 CNend
+\param[out] penSampleRate   Pointer to the type of the audio sampling rate CNcomment:指针类型，音频采样率的类型 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetSampleRate(HI_UNF_SND_E enSound, HI_UNF_SAMPLE_RATE_E* penSampleRate);
+
+/**
+\brief set aduiodelay for output port. CNcomment: 设置音频端口延时CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enOutPort output port .CNcomment:输出端口号 CNend
+\param[in] u32DelayMs Audio delay ms .CNcomment:延时时长 CNend
+\retval ::HI_SUCCESS success. CNcomment: 成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_SetDelayCompensationMs(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_U32 u32DelayMs);
+
+/**
+\brief get aduiodelay for output port. CNcomment: 获取音频端口延时CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enOutPort output port .CNcomment:输出端口号 CNend
+\param[in] pu32DelayMs Audio delay ms .CNcomment:延时时长 CNend
+\retval ::HI_SUCCESS success. CNcomment: 成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_GetDelayCompensationMs(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_U32* pu32DelayMs);
+
+/**
+\brief enable ADAC audio output. CNcomment: 设置ADAC 是否输出 CNend
+\attention \n
+none. CNcomment:无
+\param[in] enSound ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] bEnable enable ADAC output .CNcomment:设置ADAC 是否输出 CNend
+\retval ::HI_SUCCESS CNcomment: success.成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_SetAdacEnable(HI_UNF_SND_E enSound, HI_BOOL bEnable);
+
+/**
+\brief Sets the smart volume for audio output. CNcomment:音频输出进行智能音量处理处理开关设置 CNend
+\attention \n
+1. The smart volume is disabled by default.\n
+2. The smart volume is valid only for the track.\n
+3. The smart volume is enabled only when the program is switched.
+CNcomment:1. 默认关闭该智能音量\n
+2. 智能音量仅对track有效\n
+3. 智能音量仅在切换节目时触发 CNend
+\param[in] hTrack           Track handle CNcomment:Track 句柄 CNend
+\param[in] bSmartVolume     Smart volume enable, HI_TRUE: enabled; HI_FALSE: disabled CNcomment:是否打开智能音量。HI_TRUE：打开；HI_FALSE：关闭 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE Failure CNcomment:失败 CNend
+\retval ::HI_ERR_AO_NOTSUPPORT Unsupport CNcomment:不支持 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetTrackSmartVolume(HI_HANDLE hTrack, HI_BOOL bEnable);
+
+/**
+\brief Obtains the status of the smart volume for audio output. CNcomment:获取音频输出智能音量开关状态 CNend
+\attention \n
+\param[in] hTrack           Track handle CNcomment:Track 句柄 CNend
+\param[out] pbSmartVolume     Pointer to the enable status of the smart volume CNcomment:指针类型，是否打开智能音量 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE Failure CNcomment:失败 CNend
+\retval ::HI_ERR_AO_NOTSUPPORT Unsupport CNcomment:不支持 CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetTrackSmartVolume(HI_HANDLE hTrack, HI_BOOL* pbEnable);
+
+/**
+\brief Seting low latency threshold for audio output. CNcomment: 设置Sound端口低延时限制 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound    ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enOutPort  CNcomment:sound 输出端口 CNend
+\param[in] u32LatecnyMs,  latency ms .CNcomment:设置的延时大小 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_SetLowLatency(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E eOutPort, HI_U32 u32LatecnyMs);
+
+/**
+\brief Geting low latency threshold for audio output. CNcomment: 获取Sound端口低延时 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound    ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enOutPort  CNcomment:sound 输出端口 CNend
+\param[in] pu32LatecnyMs,  latency ms .CNcomment:延时大小 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_GetLowLatency(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E eOutPort, HI_U32* p32LatecnyMs);
+
+/**
+\brief Set the AO track mode. CNcomment:设置音频输出声道模式 CNend
+\attention \n
+N/A
+\param[in] enSound     ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enOutPort   CNcomment:sound输出端口 CNend
+\param[in] enMode     Audio track mode. For details, see the description of ::HI_UNF_TRACK_MODE_E. CNcomment:音频声道模式，请参见::HI_UNF_TRACK_MODE_E CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetTrackMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_TRACK_MODE_E enMode);
+
+/**
+\brief Obtains the AO track mode. CNcomment:获取音频输出声道模式 CNend
+\attention \n
+N/A
+\param[in] enSound     ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enOutPort   CNcomment:sound输出端口 CNend
+\param[out] penMode   Pointer to the AO track mode. For details, see the description of ::HI_UNF_TRACK_MODE_E.
+CNcomment:指针类型，音频声道模式。请参见::HI_UNF_TRACK_MODE_E CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA    The parameter is invalid. CNcomment:无效的参数 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetTrackMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_TRACK_MODE_E* penMode);
+
+/**
+\brief Attaches the SND module to an audio/video player (AVPLAY). CNcomment:绑定音频输出Sound和AV（Audio Video）播放器 CNend
+\attention \n
+Before calling this API, you must create a player and ensure that the player has no output. CNcomment:调用此接口前必须先创建播放器，对应这路播放器没有输出 CNend
+\param[in] hTrack             Instance handle of an AVPLAY CNcomment:Track 实例句柄 CNend
+\param[in] hSource           Instance handle of an AVPLAY CNcomment:AV播放器播放实例句柄 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment:无效的参数 CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_Attach(HI_HANDLE hTrack, HI_HANDLE hSource);
+
+/**
+\brief Detaches the SND module from an AVPLAY. CNcomment:解除Track和AV播放器绑定 CNend
+\attention \n
+N/A
+\param[in] hTrack             Instance handle of an AVPLAY CNcomment:Track 实例句柄 CNend
+\param[in] hSource    Instance handle of an AVPLAY CNcomment:AV播放器播放实例句柄 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_Detach(HI_HANDLE hTrack, HI_HANDLE hSource);
+
+/**
+\brief Sets the mixing weight of an audio player. CNcomment:设置音频Track 混音权重 CNend
+\attention \n
+The output volumes of two players are calculated as follows: (volume x weight 1 + volume x weight 2)/100. The formula of calculating the output volumes of multiple players is similar.
+CNcomment:两个Track 输出音量的计算方法为：（设置的音量%权重1+设置的音量%权重2）/100，多个播放器的计算方法与此类似 CNend
+\param[in] hTrack              ID of an AO device CNcomment:音频输出Track CNend
+\param[in] pstMixWeightGain   the MixWeight Gain, ranging from 0 to 100. 0: minimum value; 100: maximum value CNcomment:权重，范围为0～100。0：最小值；100：最大值 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_SetTrackWeight(HI_HANDLE hTrack, const HI_UNF_SND_GAIN_ATTR_S* pstMixWeightGain);
+
+/**
+\brief Obtains the mixing weight of an audio player. CNcomment:获取音频播放器混音权重 CNend
+\attention \n
+\param[in] hTrack              ID of an AO device CNcomment:音频输出Track CNend
+\param[in] pstMixWeightGain     Pointer to the MixWeight Gain CNcomment:指针类型，权重属性 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment:指针参数为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment:无效的参数 CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetTrackWeight(HI_HANDLE hTrack, HI_UNF_SND_GAIN_ATTR_S* pstMixWeightGain);
+
+/**
+\brief Sets the L/R channel weight of an audio player. CNcomment:设置音频Track左右声道权重 CNend
+\attention \n
+\param[in] hTrack              ID of an AO device CNcomment:音频输出Track CNend
+\param[in] pstAbsWeightGain   the channel Weight Gain CNcomment:权重 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_SetTrackAbsWeight(HI_HANDLE hTrack, const HI_UNF_SND_ABSGAIN_ATTR_S* pstAbsWeightGain);
+
+/**
+\brief Obtains the L/R channel weight of an audio player. CNcomment:获取音频播放器左右声道权重 CNend
+\attention \n
+\param[in] hTrack              ID of an AO device CNcomment:音频输出Track CNend
+\param[in] pstAbsWeightGain     Pointer to the ChannelWeight Gain CNcomment:指针类型，权重属性 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment:指针参数为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment:无效的参数 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_GetTrackAbsWeight(HI_HANDLE hTrack, HI_UNF_SND_ABSGAIN_ATTR_S* pstAbsWeightGain);
+
+/**
+\brief Sets the prescale of an audio player. CNcomment:设置音频Track的预增益 CNend
+\attention \n
+\param[in] hTrack              ID of an AO device CNcomment:音频输出Track CNend
+\param[in] pstPreciGain        Pointer of the prescale CNcomment:预增益参数 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_SetTrackPrescale(HI_HANDLE hTrack, const HI_UNF_SND_PRECIGAIN_ATTR_S* pstPreciGain);
+
+/**
+\brief Obtains the prescale of an audio player. CNcomment:获取音频Track的预增益 CNend
+\attention \n
+\param[in] hTrack              ID of an AO device CNcomment:音频输出Track CNend
+\param[out] pstPreciGain        Pointer to the prescale CNcomment:指针类型，预增益属性 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment:指针参数为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment:无效的参数 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_GetTrackPrescale(HI_HANDLE hTrack, HI_UNF_SND_PRECIGAIN_ATTR_S* pstPreciGain);
+
+/**
+\brief Sets mute or unmute of an audio player. CNcomment:设置单个音频Track 静音功能 CNend
+\attention \n
+\param[in] hTrack              ID of an AO device CNcomment:音频输出Track CNend
+\param[in] bMute               mute or not CNcomment:静音与否 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_SetTrackMute(HI_HANDLE hTrack, HI_BOOL bMute);
+
+/**
+\brief Gets mute status of an audio player. CNcomment:获取单个音频Track的静音状态 CNend
+\attention \n
+\param[in] hTrack              ID of an AO device CNcomment:音频输出Track CNend
+\param[out] pbMute               mute status CNcomment:静音状态 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA       The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_GetTrackMute(HI_HANDLE hTrack, HI_BOOL* pbMute);
+
+/**
+\brief Sets mute or unmute of all players. CNcomment:设置所有音频Track 静音功能 CNend
+\attention \n
+\param[in] enSound              all track of the sound CNcomment:该sound所有track CNend
+\param[in] bMute               mute or not CNcomment:静音与否 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_SetAllTrackMute(HI_UNF_SND_E enSound, HI_BOOL bMute);
+
+/**
+\brief Gets mute status of all players. CNcomment:获取所有音频Track的静音状态 CNend
+\attention \n
+\param[in] enSound              all track of the sound CNcomment:该sound track CNend
+\param[in] pbMute               mute status CNcomment:静音状态 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA       The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_GetAllTrackMute(HI_UNF_SND_E enSound, HI_BOOL* pbMute);
+
+/**
+\brief Set the track channel mode. CNcomment:设置音频Track  声道模式 CNend
+\attention \n
+N/A
+\param[in] hTrack              ID of an AO device CNcomment:音频输出Track CNend
+\param[in] enMode             The audio track mode. For details, see the description of ::HI_UNF_TRACK_MODE_E. CNcomment:音频声道模式，请参见::HI_UNF_TRACK_MODE_E CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetTrackChannelMode(HI_HANDLE hTrack, HI_UNF_TRACK_MODE_E enMode);
+
+/**
+\brief Obtains the track channel mode. CNcomment:获取音频Track 声道模式 CNend
+\attention \n
+N/A
+\param[in] hTrack              ID of an AO device CNcomment:音频输出Track CNend
+\param[out] penMode   Pointer to the audio track mode. For details, see the description of ::HI_UNF_TRACK_MODE_E.
+CNcomment:指针类型，音频声道模式。请参见::HI_UNF_TRACK_MODE_E CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA    The parameter is invalid. CNcomment:无效的参数 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetTrackChannelMode(HI_HANDLE hTrack, HI_UNF_TRACK_MODE_E* penMode);
+
+/**
+ \brief Obtains the default configured parameters of an AO Track. CNcomment:获取音频输出Track默认设置参数 CNend
+ \attention \n
+ \param[in] enTrackType              Track Type CNcomment:Track类型 CNend
+ \param[out] pstAttr     Audio attributes CNcomment:音频属性 CNend
+ \retval ::HI_SUCCESS Success CNcomment:成功 CNend
+ \retval ::HI_FAILURE  Failure  CNcomment:失败 CNend
+ \retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment:指针参数为空 CNend
+ \see \n
+N/A
+ */
+HI_S32   HI_UNF_SND_GetDefaultTrackAttr(HI_UNF_SND_TRACK_TYPE_E enTrackType, HI_UNF_AUDIOTRACK_ATTR_S* pstAttr);
+
+/**
+\brief Create a Track. CNcomment:创建一路Track CNend
+\attention \n
+Create 8 output tracks(master/slave track) and 6 virtual tracks at the most. only create 1 master track on every sound.
+CNcomment:最多可创建8路输出track(master/slave), 6路虚拟track，每个sound只能创建一路master track CNend
+\param[in] enSound     ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] pTrackAttr  Track attributes CNcomment:指针类型，Track  属性 CNend
+\param[out] phTrack   Pointer to the handle of the created Track CNcomment:指针类型，创建的Track 句柄 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE  Failure  CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_CreateTrack(HI_UNF_SND_E enSound, const HI_UNF_AUDIOTRACK_ATTR_S* pTrackAttr, HI_HANDLE* phTrack);
+
+/**
+\brief Destroy a Track. CNcomment:销毁一路Track CNend
+\attention \n
+\param[in] hTrack   the handle of the Track CNcomment:Track 句柄 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment:无效的参数 CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_DestroyTrack(HI_HANDLE hTrack);
+
+/**
+\brief set the attribute of  a track, reversed. CNcomment:设置某一路track的属性， 预留 CNend
+\attention \n
+\param[in] hTrack   the handle of the Track CNcomment:Track 句柄 CNend
+\param[in] stTrackAttr   the attribute of the Track CNcomment:Track 属性 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_ID The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SetTrackAttr(HI_HANDLE hTrack, const HI_UNF_AUDIOTRACK_ATTR_S* pstTrackAttr);
+
+/**
+\brief get the attribute of  a track, reversed. CNcomment:获取某一路track的属性， 预留 CNend
+\attention \n
+1.virtual track Attr not support set.\n
+2.pstTrackAttr struct: just enTrackType&u32BufLevelMs can be set ,other members not support.
+CNcomment:1.虚拟track不支持设置属性\n
+2.pstTrackAttr结构体中仅enTrackType&u32BufLevelMs可以设置，其他成员不支持 CNend
+\param[in] hTrack   the handle of the Track CNcomment:Track 句柄 CNend
+\param[out] pstTrackAttr   the attribute of the Track CNcomment:Track 属性 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_ID The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetTrackAttr(HI_HANDLE hTrack, HI_UNF_AUDIOTRACK_ATTR_S* pstTrackAttr);
+
+/**
+\brief set the config of a track. CNcomment:配置某一路track属性 CNend
+\attention \n
+1.only support ms12 type track.
+CNcomment:1.仅支持ms12类型track CNend
+\param[in] hTrack   the handle of the Track CNcomment:Track 句柄 CNend
+\param[in] pstConfig   the config of the Track CNcomment:Track 配置信息 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_ID The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SetTrackConfig(HI_HANDLE hTrack, const HI_UNF_AUDIOTRACK_CONFIG_S* pstConfig);
+
+/**
+\brief get the config of a track. CNcomment:获取某一路track的配置 CNend
+\attention \n
+1.only support ms12 type track.
+CNcomment:1.仅支持ms12类型track CNend
+\param[in] hTrack   the handle of the Track CNcomment:Track 句柄 CNend
+\param[out] pstConfig   the config of the Track CNcomment:Track 配置信息 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_ID The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetTrackConfig(HI_HANDLE hTrack, HI_UNF_AUDIOTRACK_CONFIG_S* pstConfig);
+
+/**
+\brief Acquire the audio frame from the track. CNcomment:获取某一路track的音频帧 CNend
+\attention \n
+\param[in] hTrack   the handle of the Track CNcomment:Track 句柄 CNend
+\param[in] u32TimeoutMs         acquire timeout.CNcomment:获取超时 CNend
+\param[out] pstAOFrame the audio frame  CNcomment:Track 音频帧 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_INVALID_ID The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_PARA   The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_AcquireTrackFrame(HI_HANDLE hTrack, HI_UNF_AO_FRAMEINFO_S* pstAOFrame, HI_U32 u32TimeoutMs);
+
+/**
+\brief Release the audio frame . CNcomment:释放track 音频帧 CNend
+\attention \n
+\param[in] hTrack   the handle of the Track CNcomment:Track 句柄 CNend
+\param[in] pstAOFrame the audio frame  CNcomment:Track 音频帧 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_INVALID_ID  The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_PARA    The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_ReleaseTrackFrame(HI_HANDLE hTrack, HI_UNF_AO_FRAMEINFO_S* pstAOFrame);
+
+/**
+\brief  Transmits data to a slave track directly. CNcomment:直接将数据送到slave track CNend
+\attention \n
+1. If HI_ERR_AO_OUT_BUF_FULL is returned, you need to transmit the data that fails to be transmitted last time to ensure the audio continuity.
+2. For the PCM data, the restrictions are as follows:
+    s32BitPerSample must be set to 16.
+    bInterleaved must be set to HI_TRUE. Only interlaced mode is supported.
+    u32Channels can be set to 1 or 2.
+    u32PtsMs can be ignored.
+    ps32PcmBuffer indicates the PCM data pointer.
+    ps32BitsBuffer can be ignored.
+    u32PcmSamplesPerFrame indicates the number of audio sampling. The data length (in byte) is calculated as follows: u32PcmSamplesPerFrame x u32Channels x sizeof(HI_u16)
+    u32BitsBytesPerFrame can be ignored.
+    u32FrameIndex can be ignored.
+CNcomment:1 如果返回HI_ERR_AO_OUT_BUF_FULL，需要调度者继续送上次失败数据，才能保证声音的连续
+2 PCM 数据格式在混音器的限制如下
+    s32BitPerSample: 必须为16
+    bInterleaved: 必须为HI_TRUE, 仅支持交织模式
+    u32Channels: 1 或2
+    u32PtsMs: 忽略该参数
+    ps32PcmBuffer: PCM 数据指针
+    ps32BitsBuffer: 忽略该参数
+    u32PcmSamplesPerFrame: 音频样点数, 数据长度(unit:Bytes): u32PcmSamplesPerFrame*u32Channels*sizeof(HI_u16)
+    u32BitsBytesPerFrame: 忽略该参数
+    u32FrameIndex: 忽略该参数 CNend
+\param[in] hTrack   Track handle CNcomment:Track 句柄 CNend
+\param[in] pstAOFrame   Information about the audio data CNcomment:音频数据信息 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_NULL_PTR    The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_PARA    The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_OUT_BUF_FULL  Data fails to be transmitted because the mixer buffer is full. CNcomment:混音缓冲区数据满，送数据失败 CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SendTrackData(HI_HANDLE hTrack, const HI_UNF_AO_FRAMEINFO_S* pstAOFrame);
+
+/**
+\brief Obtains the delay ms of track. CNcomment:获取音频Track延时时间 CNend
+\attention \n
+\param[in] hTrack     ID of ao track CNcomment:音频Track ID CNend
+\param[out] pDelayMs     DelayMs attributes CNcomment:Track延时时间 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetTrackDelayMs(const HI_HANDLE hTrack, HI_U32* pDelayMs);
+
+/**
+\brief Sets the output high precision volume value. CNcomment:设置输出的高精度音量 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound        ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment:音频输出端口 CNend
+\param[in] pstPreciGain     high precision volume value CNcomment:设置的高精度音量值 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_SND_INVALID_ID     The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetPrecisionVolume(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, const HI_UNF_SND_PRECIGAIN_ATTR_S* pstPreciGain);
+
+/**
+\brief Obtains the output high precision volume value. CNcomment:获取输出的高精度音量 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound         ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment:音频输出端口 CNend
+\param[out] pstPreciGain   Pointer to the obtained high precision volume value CNcomment:指针类型，获取到的高精度音量值 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetPrecisionVolume(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_PRECIGAIN_ATTR_S* pstPreciGain);
+
+/**
+\brief Sets the output balance. CNcomment:设置输出的平衡 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound        ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment:音频输出端口 CNend
+\param[in] s32Balance     balance value CNcomment:设置的平衡值 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_SND_INVALID_ID     The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetBalance(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_S32 s32Balance);
+
+/**
+\brief Obtains balance value. CNcomment:获取输出的平衡值 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound         ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment:音频输出端口 CNend
+\param[out] ps32Balance   Pointer to the obtained balance value CNcomment:指针类型，获取到的平衡值 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetBalance(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_S32* ps32Balance);
+
+/**
+\brief Start render engine. CNcomment:启动Render引擎 CNend
+\attention \n
+N/A
+\param[in] enSound  Render of the sound CNcomment:此Sound的Render CNend
+\param[in] pstAttr  Attr of Render CNcomment: Render启动属性 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_StartRender(HI_UNF_SND_E enSound, HI_UNF_SND_RENDER_ATTR_S* pstAttr);
+
+/**
+\brief Stop render engine. CNcomment:关闭Render引擎 CNend
+\attention \n
+N/A
+\param[in] enSound  Render of the sound CNcomment:此Sound的Render CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_StopRender(HI_UNF_SND_E enSound);
+
+/**
+\brief create screen share channel. CNcomment: 获取共享通道设置默认属性 CNend
+\attention \n
+none. CNcomment:无
+\param[in] enSound      display channel.CNcomment:播放通路 CNend
+\param[out] pstAttr      handle of default attr  .CNcomment:设置默认属性句柄 CNend
+\retval ::HI_SUCCESS CNcomment: success.成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32   HI_UNF_SND_GetDefaultCastAttr(HI_UNF_SND_E enSound, HI_UNF_SND_CAST_ATTR_S* pstAttr);
+
+/**
+\brief create screen share channel. CNcomment: 创建声音共享通道 CNend
+\attention \n
+none. CNcomment:无
+\param[in] enSound      display channel.CNcomment:播放通路 CNend
+\param[in] pstAttr      pointer of parameter .CNcomment:指针,属性参数 CNend
+\param[out] phCast      handle of screen share .CNcomment:声音共享句柄 CNend
+\retval ::HI_SUCCESS CNcomment: success.成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_CreateCast(HI_UNF_SND_E enSound, HI_UNF_SND_CAST_ATTR_S* pstAttr, HI_HANDLE* phCast);
+
+/**
+\brief destroy screen share channel. CNcomment: 销毁声音共享通道 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] phCast      handle of screen share .CNcomment:声音共享句柄 CNend
+\retval ::HI_SUCCESS CNcomment: success.成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_DestroyCast(HI_HANDLE hCast);
+
+/**
+\brief enable screen share. CNcomment: 使能声音共享功能 CNend
+\attention \n
+none. CNcomment:无
+\param[in] phCast      handle of screen share .CNcomment:声音共享句柄
+\param[in] bEnable      enable screen share .CNcomment:使能声音共享 CNend
+\retval ::HI_SUCCESS CNcomment: success.成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_SetCastEnable(HI_HANDLE hCast, HI_BOOL bEnable);
+
+/**
+\brief get enable flag of screen share. CNcomment: 获取声音共享是否使能 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] phCast      handle of screen share .CNcomment:声音共享句柄 CNend
+\param[out] bEnable     flag .CNcomment:标志 CNend
+\retval ::HI_SUCCESS CNcomment: success.成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_GetCastEnable(HI_HANDLE hCast, HI_BOOL* pbEnable);
+
+/**
+\brief get frame info of snd cast. CNcomment: 获取声音共享帧信息 CNend
+\attention \n
+Cast pcm data format  s32BitPerSample(16), u32Channels(2),bInterleaved(HI_TRUE), u32SampleRate(same as SND).
+\param[in] hCast      handle of screen share .CNcomment:声音共享句柄 CNend
+\param[out] pstCastFrame        frame info.CNcomment:帧信息 CNend
+\param[in] u32TimeoutMs         acquire timeout.CNcomment:获取超时 CNend
+\retval ::HI_SUCCESS CNcomment: success.成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_V_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AO_CAST_TIMEOUT   no enough data.CNcomment:数据不够 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_AcquireCastFrame(HI_HANDLE hCast, HI_UNF_AO_FRAMEINFO_S* pstCastFrame, HI_U32 u32TimeoutMs);
+
+/**
+\brief release frame info of screen share. CNcomment: 释放声音共享帧信息 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] hCast      handle of screen share .CNcomment:声音共享句柄 CNend
+\param[in] pstCastFrame     frame info.CNcomment:帧信息 CNend
+\param[in] u32TimeoutMs    release timeout.CNcomment:释放超时 CNend
+\retval ::HI_SUCCESS CNcomment: success.成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_ReleaseCastFrame(HI_HANDLE hCast, HI_UNF_AO_FRAMEINFO_S* pstCastFrame);
+
+/**
+\brief Sets the L/R channel weight of snd cast. CNcomment:设置音频Cast左右声道权重 CNend
+\attention \n
+\param[in] hCast              ID of snd cast CNcomment:音频Cast ID CNend
+\param[in] pstAbsWeightGain   the channel Weight Gain, ranging from 0 to 100. 0: minimum value; 100: maximum value CNcomment:权重，范围为0～100。0：最小值；100：最大值 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_SetCastAbsWeight(HI_HANDLE hCast, const HI_UNF_SND_ABSGAIN_ATTR_S* pstAbsWeightGain);
+
+/**
+\brief Obtains the L/R channel weight of audio cast. CNcomment:获取音频Cast左右声道权重 CNend
+\attention \n
+
+\param[in] hCast              ID of snd cast CNcomment:音频Cast ID CNend
+\param[out] pstAbsWeightGain     Pointer to the ChannelWeight Gain CNcomment:指针类型，权重属性 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR               The pointer is null. CNcomment:指针参数为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA            The parameter is invalid. CNcomment:无效的参数 CNend
+\see \n
+N/A
+*/
+HI_S32  HI_UNF_SND_GetCastAbsWeight(HI_HANDLE hCast,  HI_UNF_SND_ABSGAIN_ATTR_S* pstAbsWeightGain);
+
+/**
+\brief Sets the mute status of audio cast. CNcomment:设置音频Cast静音状态 CNend
+\attention \n
+N/A
+\param[in] enSound
+\param[in] enOutPort CNcomment:sound输出端口 CNend
+\param[in] bMute
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_SetCastMute(HI_HANDLE hCast, HI_BOOL bMute);
+
+/**
+\brief Obtains the mute status of audio cast. CNcomment:获取音频Cast静音状态 CNend
+\attention \n
+N/A
+\param[in] enSound CNcomment:
+\param[in] enOutPort CNcomment:sound输出端口 CNend
+\param[out] pbMute CNcomment:
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA        The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_ID      The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\see \n
+N/A
+*/
+HI_S32   HI_UNF_SND_GetCastMute(HI_HANDLE hCast, HI_BOOL* pbMute);
+
+/**
+\brief enable/disable audio effect for output port. CNcomment: 使能输出端口的音频音效 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound    ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enOutPort  output port .CNcomment:输出端口号 CNend
+\param[in] bBypass    enable/disable .CNcomment:使能标记 CNend
+\retval ::HI_SUCCESS  success. CNcomment: 成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_SetAefBypass(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL bBypass);
+
+/**
+\brief get info of audio effect for output port. CNcomment: 获取输出端口的音频音效使能信息 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound    ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enOutPort  output port .CNcomment:输出端口号 CNend
+\param[in] pbBypass   enable/disable .CNcomment:使能标记指针 CNend
+\retval ::HI_SUCCESS  success. CNcomment: 成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_GetAefBypass(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL* pbBypass);
+
+/**
+\brief Registers Audio effect authorize library . CNcomment: 注册音频音效授权库 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] pAefLibFileName  file name of authorize library .CNcomment:授权库文件名 CNend
+\retval ::HI_SUCCESS    success. CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_RegisterAefAuthLib(const HI_CHAR* pAefLibFileName);
+
+/**
+\brief Create audio effect . CNcomment: 根据类型创建一路音效处理 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound    ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enAefType  audio effect type .CNcomment:音效类型 CNend
+\param[in] pstAdvAttr audio effect attribute .CNcomment:音效创建参数 CNend
+\param[in] u32AttrLen audio effect attribute length .CNcomment:音效创建参数指针指向的空间大小 CNend
+\param[out] phAef     the point of audio effect handle  .CNcomment:音效句柄指针 CNend
+\retval ::HI_SUCCESS   success. CNcomment: 成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_CreateAef(HI_UNF_SND_E enSound, HI_UNF_SND_AEF_TYPE_E enAefType, HI_VOID* pstAdvAttr, HI_U32 u32AttrLen, HI_HANDLE* phAef);
+
+/**
+\brief Destroy audio effect . CNcomment: 销毁一路音效 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] phAef  audio effect handle .CNcomment:音效句柄 CNend
+\retval ::HI_SUCCESS success. CNcomment: 成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_DestroyAef(HI_HANDLE hAef);
+
+/**
+\brief start/stop audio effect postprocess. CNcomment: 启动/停止音效处理 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] phAef   audio effect handle .CNcomment:音效句柄 CNend
+\param[in] bEnable start/stop .CNcomment:音效启动/停止 CNend
+\retval ::HI_SUCCESS  success. CNcomment: 成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_SetAefEnable(HI_HANDLE hAef, HI_BOOL bEnable);
+
+/**
+\brief Set audio effect params. CNcomment: 设置音效静态参数 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] phAef  audio effect handle .CNcomment:音效句柄 CNend
+\param[in] u32ParamType parameter type .CNcomment:参数类型 CNend
+\param[in] pstParms     point of parameter .CNcomment:参数指针 CNend
+\param[in] u32ParamLen  input parameter buffer length .CNcomment:音效参数指针指向的空间的大小 CNend
+\retval ::HI_SUCCESSsuccess. CNcomment: 成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_SetAefParams(HI_HANDLE hAef, HI_U32 u32ParamType, const HI_VOID* pstParms, HI_U32 u32ParamLen);
+
+/**
+\brief Get audio effect params. CNcomment: 获取音效静态参数 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] phAef    audio effect handle .CNcomment:音效句柄 CNend
+\param[in] u32ParamType  parameter type .CNcomment:参数类型 CNend
+\param[out] pstParms      point of parameter .CNcomment:参数指针 CNend
+\param[in] u32ParamLen  output parameter buffer length .CNcomment:音效参数指针指向的空间的大小 CNend
+\retval ::HI_SUCCESS     success. CNcomment: 成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_GetAefParams(HI_HANDLE hAef, HI_U32 u32ParamType, HI_VOID* pstParms, HI_U32 u32ParamLen);
+
+/**
+\brief Set audio effect config. CNcomment: 设置音效动态配置 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] phAef  audio effect handle .CNcomment:音效句柄 CNend
+\param[in] u32CfgType   config type .CNcomment:配置类型 CNend
+\param[in] pstConfig    point of config .CNcomment:配置指针 CNend
+\param[in] u32ConfigLen input config buffer length .CNcomment:音效配置参数指针指向的空间的大小 CNend
+\retval ::HI_SUCCESS    success. CNcomment: 成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_SetAefConfig(HI_HANDLE hAef, HI_U32 u32CfgType, const HI_VOID* pstConfig, HI_U32 u32ConfigLen);
+
+/**
+\brief Get audio effect config. CNcomment: 获取音效动态配置 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] phAef   audio effect handle .CNcomment:音效句柄 CNend
+\param[in] u32CfgType  config type .CNcomment:配置类型 CNend
+\param[out] pstConfig   point of config .CNcomment:配置指针 CNend
+\param[in] u32ConfigLen output config buffer length .CNcomment:音效配置参数指针指向的空间的大小 CNend
+\retval ::HI_SUCCESS   success. CNcomment: 成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR          Input pointer is NULL.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_GetAefConfig(HI_HANDLE hAef, HI_U32 u32CfgType, HI_VOID* pstConfig, HI_U32 u32ConfigLen);
+
+/**
+\brief Set audio avc attr. CNcomment: 设置avc属性 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound    ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] pstAvcAttr  the attribute of the avc .CNcomment:avc属性 CNend
+\retval ::HI_SUCCESS   success. CNcomment: 成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_SetAvcAttr(HI_UNF_SND_E enSound, const HI_UNF_SND_AVC_ATTR_S* pstAvcAttr);
+
+/**
+\brief get the attribute of  avc, reversed. CNcomment:获取avc的属性，预留 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound    ID of an AO device CNcomment:音频输出设备号 CNend
+\param[out] pstAvcAttr   the attribute of avc CNcomment:avc 属性 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetAvcAttr(HI_UNF_SND_E enSound, HI_UNF_SND_AVC_ATTR_S* pstAvcAttr);
+
+/**
+\brief start/stop avc process. CNcomment: 启动/停止avc处理功能 CNend
+\attention \n
+none. CNcomment:无
+\param[in] enSound    ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] bEnable    start/stop .CNcomment: 启动/停止 CNend
+\retval ::HI_SUCCESS CNcomment: success.成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_SetAvcEnable(HI_UNF_SND_E enSound, HI_BOOL bEnable);
+
+/**
+\brief Get start/stop status of avc postprocess. CNcomment: 获取avc处理的启动/停止状态 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound    ID of an AO device CNcomment:音频输出设备号 CNend
+\param[out] pbEnable start/stop status .CNcomment:avc启动/停止状态指针 CNend
+\retval ::HI_SUCCESS  success. CNcomment: 成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_GetAvcEnable(HI_UNF_SND_E enSound, HI_BOOL* pbEnable);
+
+/**
+\brief Set audio drc attr. CNcomment: 设置drc属性 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound    ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment:音频输出端口 CNend
+\param[in] pstDrcAttr  the attribute of the drc .CNcomment:drc属性 CNend
+\retval ::HI_SUCCESS   success. CNcomment: 成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_SetDrcAttr(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, const HI_UNF_SND_DRC_ATTR_S* pstDrcAttr);
+
+/**
+\brief Get audio drc attr. CNcomment: 获取drc属性 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound    ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment:音频输出端口 CNend
+\param[in] pstDrcAttr  the attribute of the drc .CNcomment:drc属性 CNend
+\retval ::HI_SUCCESS   success. CNcomment: 成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_GetDrcAttr(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_DRC_ATTR_S* pstDrcAttr);
+
+/**
+\brief start/stop drc process. CNcomment: 启动/停止drc处理功能 CNend
+\attention \n
+none. CNcomment:无
+\param[in] enSound    ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment:音频输出端口 CNend
+\param[in] bEnable    start/stop .CNcomment: 启动/停止 CNend
+\retval ::HI_SUCCESS CNcomment: success.成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_SetDrcEnable(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL bEnable);
+
+/**
+\brief Get start/stop status of drc postprocess. CNcomment: 获取drc处理的启动/停止状态 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound    ID of an AO device CNcomment:音频输出设备号 CNend
+\param[out] pbEnable start/stop status .CNcomment:drc启动/停止状态指针 CNend
+\retval ::HI_SUCCESS  success. CNcomment: 成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_GetDrcEnable(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL* pbEnable);
+
+/**
+\brief Set audio peq attr. CNcomment: 设置peq属性 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound    ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment:音频输出端口 CNend
+\param[in] pstPeqAttr  the attribute of the peq .CNcomment:peq属性 CNend
+\retval ::HI_SUCCESS   success. CNcomment: 成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_SetPeqAttr(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, const HI_UNF_SND_PEQ_ATTR_S* pstPeqAttr);
+
+/**
+\brief get the attribute of  peq, reversed. CNcomment:获取peq的属性，预留 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound    ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment:音频输出端口 CNend
+\param[out] pstPeqAttr   the attribute of peq CNcomment:peq 属性 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_NULL_PTR           The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetPeqAttr(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_UNF_SND_PEQ_ATTR_S* pstPeqAttr);
+
+/**
+\brief start/stop peq process. CNcomment: 启动/停止peq处理功能 CNend
+\attention \n
+none. CNcomment:无
+\param[in] enSound    ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment:音频输出端口 CNend
+\param[in] bEnable    start/stop .CNcomment: 启动/停止 CNend
+\retval ::HI_SUCCESS CNcomment: success.成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_SetPeqEnable(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL bEnable);
+
+/**
+\brief Get start/stop status of peq postprocess. CNcomment: 获取peq处理的启动/停止状态 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound    ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] enOutPort  Audio OutputPort     CNcomment:音频输出端口 CNend
+\param[out] pbEnable start/stop status .CNcomment:peq启动/停止状态指针 CNend
+\retval ::HI_SUCCESS  success. CNcomment: 成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_GetPeqEnable(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTPORT_E enOutPort, HI_BOOL* pbEnable);
+
+/**
+\brief Get snd underload count. CNcomment: 获取声卡欠载次数 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound    ID of an AO device CNcomment:音频输出设备号 CNend
+\param[out] pu32Count underload count .CNcomment:欠载次数 CNend
+\retval ::HI_SUCCESS  success. CNcomment: 成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA      invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_GetUnderloadCount(HI_UNF_SND_E enSound, HI_U32* pu32Count);
+
+/**
+\brief set continue output MS12 only. CNcomment: 设置continue output CNend
+\attention \n
+none. CNcomment:无
+\param[in] enSound    ID of an AO device CNcomment:音频输出设备号 CNend
+\param[in] bEnable    start/stop .CNcomment: 启动/停止 CNend
+\retval ::HI_SUCCESS CNcomment: success.成功 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_SND_SetContinueOutputEnable(HI_UNF_SND_E enSound, HI_BOOL bEnable);
+
+/**
+\brief Obtains continue output MS12 only. CNcomment:获取continue output的使能状态 CNend
+\attention \n
+none. CNcomment:无 CNend
+\param[in] enSound         ID of an AO device CNcomment:音频输出设备号 CNend
+\param[out] pbEnable   Pointer to the obtained continue output status CNcomment:指针类型，获取到的使能状态 CNend
+\retval ::HI_SUCCESS Success CNcomment:成功 CNend
+\retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+\retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+\retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment:无效的参数 CNend
+\retval ::HI_ERR_AO_INVALID_ID       The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+\retval ::HI_ERR_AO_NULL_PTR         The pointer is null. CNcomment:指针参数为空 CNend
+\see \n
+N/A
+*/
+HI_S32 HI_UNF_SND_GetContinueOutputEnable(HI_UNF_SND_E enSound, HI_BOOL* pbEnable);
+
+/**
+ \brief Set audio output latency mode MS12 only.CNcomment:设置音频输出时延模式 CNend
+ \attention \n
+CNcomment: 无CNend
+ \param[in] enSound         ID of an AO device CNcomment:音频输出设备号 CNend
+ \param[in] enMode Output mode .CNcomment:输出模式CNend
+ \retval ::HI_SUCCESS CNcomment: success.成功 CNend
+ \retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+ \retval ::HI_ERR_AO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+ \see \n
+ N/A
+ */
+HI_S32 HI_UNF_SND_SetOutputLatencyMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTLATENCY_E enOutMode);
+
+/**
+ \brief Get audio output latency mode MS12 only.CNcomment:获取音频输出时延模式 CNend
+ \attention \n
+CNcomment: 无CNend
+ \param[in] enSound         ID of an AO device CNcomment:音频输出设备号 CNend
+ \param[out] penMode Return output mode .CNcomment:返回输出模式CNend
+ \retval ::HI_SUCCESS Success CNcomment:成功 CNend
+ \retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+ \retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+ \retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment:无效的参数 CNend
+ \retval ::HI_ERR_AO_INVALID_ID       The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+ \retval ::HI_ERR_AO_NULL_PTR         The pointer is null. CNcomment:指针参数为空 CNend
+ \see \n
+ N/A
+ */
+HI_S32 HI_UNF_SND_GetOutputLatencyMode(HI_UNF_SND_E enSound, HI_UNF_SND_OUTPUTLATENCY_E *penOutMode);
+
+/**
+ \brief Set ATMOS Lock Enable.CNcomment:设置ATMOS Lock 功能使能 CNend
+ \attention \n
+CNcomment: 无CNend
+ \param[in] enSound         ID of an AO device CNcomment:音频输出设备号 CNend
+ \param[in] bAtmosLockEnable   AtmosLock flag .CNcomment:ATMOSLOCK 使能标志 CNend
+ \retval ::HI_SUCCESS Success CNcomment:成功 CNend
+ \retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+ \retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+ \retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment:无效的参数 CNend
+ \retval ::HI_ERR_AO_INVALID_ID       The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+ \see \n
+ N/A
+ */
+HI_S32 HI_UNF_SND_SetAtmosLockEnable(HI_UNF_SND_E enSound, HI_BOOL bAtmosLockEnable);
+
+/**
+ \brief Get ATMOS Lock state.CNcomment:获取ATMOS Lock 状态 CNend
+ \attention \n
+CNcomment: 无CNend
+ \param[in] enSound         ID of an AO device CNcomment:音频输出设备号 CNend
+ \param[out] pbAtmosLockEnable   AtmosLock flag .CNcomment:ATMOSLOCK 状态标志 CNend
+ \retval ::HI_SUCCESS Success CNcomment:成功 CNend
+ \retval ::HI_FAILURE FAILURE CNcomment:失败 CNend
+ \retval ::HI_ERR_AO_SOUND_NOT_OPEN    Sound device is not opened. CNcomment:Sound设备未打开 CNend
+ \retval ::HI_ERR_AO_INVALID_PARA     The parameter is invalid. CNcomment:无效的参数 CNend
+ \retval ::HI_ERR_AO_INVALID_ID       The parameter enSound is invalid. CNcomment:无效Sound ID CNend
+ \see \n
+ N/A
+ */
+HI_S32 HI_UNF_SND_GetAtmosLockEnable(HI_UNF_SND_E enSound, HI_BOOL* pbAtmosLockEnable);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif  /*__HI_UNF_SND_H__*/
+
diff -uNr a/include/hi_unf_spi.h b/include/hi_unf_spi.h
--- a/include/hi_unf_spi.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_spi.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,277 @@
+/******************************************************************************
+Copyright (C), 2004-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_unf_spi.h  
+Version       : Initial Draft  
+Author        : Hisilicon STB SDK group 
+Created       : 2013/4/22  
+Last Modified : 
+Description   : output control  Function 
+Modification  : Created file
+******************************************************************************/
+#ifndef  __HI_UNF_SPI_H__
+#define  __HI_UNF_SPI_H__
+
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+
+/*************************** Structure Definition ****************************/
+
+/** \addtogroup      SPI */
+/** @{*/  /** <!-[SPI]*/
+
+/** SPI device select */
+/** CNcomment: SPI 设备 */
+typedef enum hiUNF_SPI_DEV_E
+{
+    HI_UNF_SPI_DEV_0 =0 ,
+    HI_UNF_SPI_DEV_1 = 1,
+    HI_UNF_SPI_DEV_BUTT
+}HI_UNF_SPI_DEV_E;
+
+/** SPI CS Config */
+/** CNcomment: SPI CS脚配置*/
+typedef enum hiUNF_SPI_CFGCS_E
+{
+    HI_UNF_SPI_LOGIC_CS =0 ,
+    HI_UNF_SPI_GPIO_CS = 1,
+}HI_UNF_SPI_CFGCS_E;
+
+
+/** SPICLOCKOUT polarity */
+/** CNcomment: SPICLOCKOUT 极性值枚举 */
+typedef enum hiUNF_SPI_SPO_E
+{
+    HI_UNF_SPI_SPO_0 = 0,
+    HI_UNF_SPI_SPO_1 = 1 
+}HI_UNF_SPI_SPO_E;
+
+/** SPICLOCKOUT  phase */
+/** CNcomment: SPICLOCKOUT 相位值枚举 */
+typedef enum hiUNF_SPI_SPH_E
+{
+    HI_UNF_SPI_SPH_0 = 0,
+    HI_UNF_SPI_SPH_1 = 1 
+}HI_UNF_SPI_SPH_E;
+
+/** SPI Frame format */
+/** CNcomment: 帧格式 */
+typedef enum hiUNF_SPI_FRF_E
+{
+    HI_UNF_SPI_FRF_MOTO = 0,	/**< Motorola SPI */ /** CNcomment: Motorola SPI*/
+    HI_UNF_SPI_FRF_TI   = 1, 		/**< TI SPI */ /** CNcomment: TI SPI */
+    HI_UNF_SPI_FRF_NM   = 2,		/**< National Microwire */ /** CNcomment: National Microwire */
+    HI_UNF_SPI_FRF_BUTT = 3	
+}HI_UNF_SPI_FRF_E;
+
+/** SPI Data byte order */
+/** CNcomment: 数据大小端定义 */
+typedef enum hiUNF_SPI_BIGEND_E
+{
+	HI_UNF_SPI_BIGEND_LITTLE,	/**< little endian */ /** CNcomment: 小端*/
+	HI_UNF_SPI_BIGEND_BIG			/**< big endian */ /** CNcomment: 大端*/
+}HI_UNF_SPI_BIGEND_E;
+
+/** SPI addition attribute about Motorola SPI */
+/** CNcomment: Motorola SPI 协议专有属性 */
+
+typedef struct hiUNF_SPI_ATTR_MOTO_S
+{
+	HI_UNF_SPI_SPO_E enSpo;	/**< only effactive when enCs is HI_UNF_SPI_FRF_MOTO */ /** CNcomment: 仅在motorola协议有效*/
+	HI_UNF_SPI_SPH_E enSph; /**< only effactive when enCs is HI_UNF_SPI_FRF_MOTO */ /** CNcomment: 仅在motorola协议有效*/
+}HI_UNF_SPI_ATTR_MOTO_S;
+
+/** SPI additional attribute about National Microwire SPI */
+/** CNcomment: National Microwire SPI 协议专有属性 */
+typedef struct hiUNF_SPI_ATTR_NM_S
+{
+	HI_BOOL	bWaitEn;		/**< wait enable. */  /** CNcomment: 等待使能*/
+	HI_U32 u32Waitval;	/**< wait time value. */	/** CNcomment: 等待时间*/
+}HI_UNF_SPI_ATTR_NM_S;
+
+/** SPI additional attribute union */
+/** CNcomment: Motorola SPI/NM 协议专有属性 */
+typedef union
+{
+	HI_UNF_SPI_ATTR_MOTO_S stMoto;
+	HI_UNF_SPI_ATTR_NM_S stNm;
+}HI_UNF_SPI_ATTR_EXT_U;
+
+/** The SPI attribute*/
+/** CNcomment: SPI工作模式属性*/
+typedef struct hiUNF_SPI_ATTR_S
+{
+	HI_UNF_SPI_DEV_E enDev;	/**< chip select */  /** CNcomment: 指定设备*/
+	HI_UNF_SPI_CFGCS_E csCfg; /**< cs select */  /** CNcomment: 选择片选配置*/
+	HI_U32	u32Baud;  /**< baud rate */  /** CNcomment: 波特率*/
+	HI_UNF_SPI_FRF_E enFrf;	/**< frame format */  /** CNcomment: 帧模式*/
+	HI_U32 u32Dss;  /**< number of bits per transfer, 4-15bit, value of u32Dss : [4, 15]. */  /** CNcomment: 设置范围4-15*/
+	HI_UNF_SPI_BIGEND_E enBigend;	/**< byte order */  /** CNcomment: 大小端*/
+	HI_UNF_SPI_ATTR_EXT_U unExtAttr; /**< addition attr when frf is moto or nm. */  /** CNcomment: 模式为MOTO或者NM时使用*/
+	
+}HI_UNF_SPI_ATTR_S;
+
+
+/** @}*/  /** <!-- ==== Structure Definition End ====*/
+
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      SPI*/
+/** @{*/  /** <!-- -SPI=*/
+
+/**
+ \brief Init the SPI device.
+CNcomment:\brief 初始化SPI（the Inter-Integrated Circuit）设备。CNend
+
+ \param N/A                                                               CNcomment:无。CNend
+ \retval 0 Success                                                        CNcomment:成功。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SPI_Init(HI_VOID);
+
+/**
+ \brief  DeInit the SPI device.
+CNcomment:\brief 去初始化SPI设备。CNend
+
+ \param N/A                                                        CNcomment:无。CNend
+ \retval 0 Success                                                 CNcomment: 成功。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_SPI_DeInit(HI_VOID);
+
+
+
+/**
+ \brief Open the SPI device.
+CNcomment:\brief 打开指定SPI设备。CNend
+
+  \attention \n
+ Hi3719MV100/ Hi3718MV100 has SPI0 only.\n
+ CNcomment: Hi3719MV100/ Hi3718MV100 只有SPI0\n CNend
+
+ \param[in] enDev  select device		  CNcomment:指定设备。CNend
+  
+ \retval 0 Success                                                        CNcomment:成功。CNend
+ \retval ::HI_ERR_SPI_OPEN_ERR  Opne Spi Error.	 	   CNcomment:SPI设备打开失败。CNend
+ \see \n
+N/A
+ */
+
+HI_S32 HI_UNF_SPI_Open(HI_UNF_SPI_DEV_E enDev);	
+
+
+/**
+ \brief Close the SPI device.
+CNcomment:\brief 关闭指定SPI设备。CNend
+
+ \param[in] enDev  select device		  CNcomment:指定设备。CNend
+
+ \retval 0 Success                                                        CNcomment:成功。CNend
+ \retval ::HI_ERR_SPI_CLOSE_ERR  Close Spi Error.	 	   CNcomment:SPI设备关闭失败。CNend
+ \see \n
+N/A
+ */
+
+HI_S32 HI_UNF_SPI_Close(HI_UNF_SPI_DEV_E enDev);
+
+/**
+ \brief  Set the SPI working mode.
+CNcomment:\设置SPI工作方式。CNend
+
+ \param[in] enDev  select device		  CNcomment:指定设备。CNend
+ \param[in] stAttr  The attribute of the SPI . CNcomment:SPI的属性。CNend
+
+ \retval 0 Success                                                 CNcomment: 成功。CNend
+ \retval ::	 
+ \see \n
+N/A
+ */
+
+HI_S32 HI_UNF_SPI_SetAttr(HI_UNF_SPI_DEV_E enDev, HI_UNF_SPI_ATTR_S *stAttr);
+
+/**
+ \brief  Get the SPI working mode.
+CNcomment:\获取SPI工作方式相关属性。CNend
+
+ \param[in] enDev  select device          CNcomment:指定设备。CNend
+ \param[out] stAttr  The attribute of the SPI . CNcomment:SPI的属性。CNend
+ 
+ \retval 0 Success                                                 CNcomment: 成功。CNend
+ \retval ::	 
+ \see \n
+N/A
+ */
+
+HI_S32 HI_UNF_SPI_GetAttr(HI_UNF_SPI_DEV_E enDev, HI_UNF_SPI_ATTR_S *stAttr);
+
+/**
+ \brief Trans data by using the SPI.
+CNcomment:\brief SPI数据传输。CNend
+
+ \attention \n
+N/A
+ \param[in] enDev  select device          CNcomment:指定设备。CNend
+ \param[in] pu8Send  Buffer for storing the data to be written       CNcomment:存放待写入数据。CNend
+ \param[in] u32SendCnt  Length of the data to be written        CNcomment:待写数据的长度。CNend
+ \param[in] pu8Read  Buffer for storing the data to be read . CNcomment:存放接收数据。CNend
+ \param[in] u32ReadCnt  Length of the data to be read                                    CNcomment:要读取的数据长度。CNend
+ \retval 0 Success                                                                      CNcomment:成功。CNend
+ \retval ::HI_FAILURE	Read data failed					  	CNcomment:失败。CNend
+ \see \n
+N/A
+ */
+
+HI_S32 HI_UNF_SPI_ReadExt(HI_UNF_SPI_DEV_E enDev, HI_U8 *pu8Send, HI_U32 u32SendCnt, HI_U8 *pu8Read, HI_U32 u32ReadCnt);
+
+/**
+ \brief Reads data by using the SPI.
+CNcomment:\brief SPI数据接收。CNend
+
+ \attention \n
+N/A
+ \param[in] enDev  select device          CNcomment:指定设备。CNend
+ \param[out] pu8Read  Buffer for storing the data to be read . CNcomment:存放接收数据。CNend
+ \param[in] u32ReadCnt  Length of the data to be read                                    CNcomment:要读取的数据长度。CNend
+
+ \retval 0 Success                                                                      CNcomment:成功。CNend
+ \retval ::HI_FAILURE	Read data failed					  	CNcomment:失败。CNend
+ \see \n
+N/A
+ */
+
+HI_S32 HI_UNF_SPI_Read(HI_UNF_SPI_DEV_E enDev, HI_U8 *pu8Read, HI_U32 u32ReadCnt);
+
+/**
+ \brief Reads data by using the SPI.
+CNcomment:\brief SPI数据发送。CNend
+
+ \attention \n
+N/A
+ \param[in] enDev  select device          CNcomment:指定设备。CNend
+ \param[in] pu8Send  Buffer for storing the data to be written       CNcomment:存放待写入数据。CNend
+ \param[in] u32SendCnt  Length of the data to be written        CNcomment:待写数据的长度。CNend
+ 
+ \retval 0 Success                                                                      CNcomment:成功。CNend
+ \retval ::HI_FAILURE	Read data failed					  	CNcomment:失败。CNend
+ \see \n
+N/A
+ */
+
+HI_S32 HI_UNF_SPI_Write(HI_UNF_SPI_DEV_E enDev, HI_U8 *pu8Send, HI_U32 u32SendCnt);
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif /* __cplusplus */
+
+
+#endif
\ No newline at end of file
diff -uNr a/include/hi_unf_subt.h b/include/hi_unf_subt.h
--- a/include/hi_unf_subt.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_subt.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,221 @@
+#ifndef __HI_UNF_SUBT_H__
+#define __HI_UNF_SUBT_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus*/
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      SUBTITLE */
+/** @{ */  /** <!-- 【SUBTITLE】 */
+
+/** Invalid handle in subtitle *//** CNcomment:无效的字幕句柄 */
+#define SUBT_INVALID_HANDLE   (0x0)
+/** the max item(language) in Subtitling descriptor *//** CNcomment:最大的字幕项(语言)个数 */
+#define SUBT_ITEM_MAX_NUM     (32)
+/** the max subtitle instance *//** CNcomment:最大的字幕模块实例 */
+#define SUBT_INSTANCE_MAX_NUM (8)
+
+/** Defines the subtitle data type  *//** CNcomment: 定义字幕数据类型 */
+typedef enum hiUNF_SUBT_DATA_TYPE_E
+{
+    HI_UNF_SUBT_DVB  = 0x1, /**<DVB subtitle *//**<CNcomment: DVB字幕 */
+    HI_UNF_SUBT_SCTE = 0x2, /**<SCTE subtitle *//**<CNcomment: SCTE字幕 */
+    HI_UNF_SUBT_BUTT
+}HI_UNF_SUBT_DATA_TYPE_E;
+
+/** Defines the type used to code the subtitle *//** CNcomment:定义字幕编码类型枚举 */
+typedef enum hiUNF_SUBT_TYPE_E
+{
+    HI_UNF_SUBT_TYPE_BITMAP = 0, /**<Coding of bitmap *//**<CNcomment:位图编码 */
+    HI_UNF_SUBT_TYPE_TEXT,       /**<Coded as a string of characters *//**<CNcomment:文本编码 */
+    HI_UNF_SUBT_TYPE_BUTT
+}HI_UNF_SUBT_TYPE_E;
+
+/** Defines the status of the subtitling page *//** CNcomment:定义字幕页状态枚举 */
+typedef enum hiUNF_SUBT_PAGE_STATE_E
+{
+    HI_UNF_SUBT_PAGE_NORMAL_CASE        = 0,    /**<Page update, use previous page instance to display *//**<CNcomment:局部更新 */
+    HI_UNF_SUBT_PAGE_ACQUISITION_POINT,         /**<Page refresh, use next page instance to display *//**<CNcomment:全屏刷新 */
+    HI_UNF_SUBT_PAGE_MODE_CHANGE,               /**<New page, needed to display the new page *//**<CNcomment:刷新整个字幕页 */
+    HI_UNF_SUBT_PAGE_BUTT
+}HI_UNF_SUBT_PAGE_STATE_E;
+
+/** Defines the data of the subtitle output *//** CNcomment:定义字幕输出数据结构体 */
+typedef struct hiUNF_SUBT_DATA_S
+{
+    HI_UNF_SUBT_TYPE_E enDataType;        /**<The type used to code the subtitle *//**<CNcomment:字幕编码类型 */
+    HI_UNF_SUBT_PAGE_STATE_E enPageState; /**<The status of the subtitling page *//**<CNcomment:字幕页状态 */
+    HI_U32             u32x;              /**<The horizontal address of subtitling page *//**<CNcomment:x坐标 */
+    HI_U32             u32y;              /**<The vertical address of subtitling page *//**<CNcomment:y坐标 */
+    HI_U32             u32w;              /**<The horizontal length of subtitling page *//**<CNcomment:宽度 */
+    HI_U32             u32h;              /**<The vertical length of subtitling page *//**<CNcomment:高度 */
+    HI_U32             u32BitWidth;       /**<Bits in pixel-code *//**<CNcomment:位宽 */
+    HI_U32             u32PTS;            /**<Presentation time stamp *//**<CNcomment:时间戳 */
+    HI_U32             u32Duration;       /**<The period, expressed in ms, after which a page instance is no longer valid *//**<CNcomment:持续时间，单位是ms */
+    HI_U32             u32PaletteItem;    /**<Pixels of palette *//**<CNcomment:调色板长度 */
+    HI_VOID*           pvPalette;         /**<Palette data *//**<CNcomment:调色板数据 */
+    HI_U32             u32DataLen;        /**<Subtitling page data length *//**<CNcomment:字幕数据长度 */
+    HI_U8*             pu8SubtData;       /**<Subtitling page data *//**<CNcomment:字幕数据 */
+    HI_U32             u32DisplayWidth;   /**<Display canvas width *//**<CNcomment:显示画布的宽度 */
+    HI_U32             u32DisplayHeight;  /**<Display canvas height *//**<CNcomment:显示画布的高度 */
+}HI_UNF_SUBT_DATA_S;
+
+/** Defines the item of the subtitling content *//** CNcomment:定义字幕服务项结构体 */
+typedef struct hiUNF_SUBT_ITEM_S
+{
+    HI_U32 u32SubtPID;      /**<The pid for playing subtitle *//**<CNcomment:字幕pid */
+    HI_U16 u16PageID;       /**<The Subtitle page id *//**<CNcomment:字幕页id */
+    HI_U16 u16AncillaryID;  /**<The Subtitle ancillary id *//**<CNcomment:字幕辅助页id */
+}HI_UNF_SUBT_ITEM_S;
+
+/** Defines the callback function which output the subtitling data *//** CNcomment:定义输出字幕数据的回调函数 */
+typedef HI_S32 (*HI_UNF_SUBT_CALLBACK_FN)(HI_VOID* pUserData, HI_UNF_SUBT_DATA_S *pstData);
+
+/** Defines the callback function which get current pts *//** CNcomment:定义获取当前时间戳的回调函数 */
+typedef HI_S32 (*HI_UNF_SUBT_GETPTS_FN)(HI_VOID* pUserData, HI_S64 *ps64Pts);
+
+/** Defines the parameter of subtitle instance *//** CNcomment:定义字幕模块参数结构体 */
+typedef struct hiUNF_SUBT_PARAM_S
+{
+    HI_UNF_SUBT_ITEM_S astItems[SUBT_ITEM_MAX_NUM]; /**<The item of the subtitling content *//**<CNcomment:字幕内容 */
+    HI_U8  u8SubtItemNum;                           /**<Amount of subtitling item *//**<CNcomment:字幕内容个数 */
+    HI_UNF_SUBT_CALLBACK_FN pfnCallback;            /**<Callback function in which output subtitling page data *//**<CNcomment:回调函数，用来输出解码后的字幕数据 */
+    HI_VOID* pUserData;                             /**<User data used in callback function *//**<CNcomment:用户数据，只用在回调函数里面 */
+    HI_UNF_SUBT_DATA_TYPE_E enDataType;             /**<subtitle data type in subt module *//**<CNcomment:在subt模块中用的字幕数据类型 */
+}HI_UNF_SUBT_PARAM_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      SUBTITLE */
+/** @{*/  /** <!-- [SUBTITLE] */
+
+/**
+\brief Initialize subtitle module. CNcomment:初始化字幕模块。CNend
+\attention \n
+none. CNcomment:无。CNend
+\retval ::HI_SUCCESS initialize success. CNcomment:初始化成功。CNend
+\retval ::HI_FAILURE initialize failure. CNcomment:初始化失败。CNend
+\see \n
+none. CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_SUBT_Init(HI_VOID);
+
+/**
+\brief DeInitialize subtitle module. CNcomment:去初始化字幕模块。CNend
+\attention \n
+none. CNcomment:无。CNend
+\retval ::HI_SUCCESS deinitialize success. CNcomment:去初始化成功。CNend
+\retval ::HI_FAILURE deinitialize failure. CNcomment:去初始化失败。CNend
+\see \n
+none. CNcomment:无。CNend
+*/
+ HI_S32 HI_UNF_SUBT_DeInit(HI_VOID);
+
+/**
+\brief Create subtitle module. CNcomment:创建字幕模块。CNend
+\attention \n
+none. CNcomment:无。CNend
+\param[in]  pstSubtParam  parameters used in created subtitle. CNcomment:参数值。CNend
+\param[out] phSubt        subtitle handle. CNcomment:字幕句柄。CNend
+\retval ::HI_SUCCESS create success. CNcomment:创建成功。CNend
+\retval ::HI_FAILURE create failure. CNcomment:创建失败。CNend
+\see \n
+none. CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_SUBT_Create(HI_UNF_SUBT_PARAM_S *pstSubtParam, HI_HANDLE *phSubt);
+
+/**
+\brief Destroy subtitle module. CNcomment:销毁字幕模块。CNend
+\attention \n
+none. CNcomment:无。CNend
+\param[in]  hSubt         subtitle handle. CNcomment:字幕句柄。CNend
+\retval ::HI_SUCCESS destroy success. CNcomment:销毁成功。CNend
+\retval ::HI_FAILURE destroy failure. CNcomment:销毁失败。CNend
+\see \n
+none. CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_SUBT_Destroy(HI_HANDLE hSubt);
+
+/**
+\brief Select one subtitle content to output. CNcomment:切换字幕内容。CNend
+\attention \n
+none. CNcomment:无。CNend
+\param[in]  hSubt         subtitle handle. CNcomment:字幕句柄。CNend
+\param[in]  pstSubtItem   subtitle item. CNcomment:字幕内容项。CNend
+\retval ::HI_SUCCESS switching success. CNcomment:切换成功。CNend
+\retval ::HI_FAILURE switching failure. CNcomment:切换失败。CNend
+\see \n
+none. CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_SUBT_SwitchContent(HI_HANDLE hSubt, HI_UNF_SUBT_ITEM_S *pstSubtItem);
+
+/**
+\brief Reset subtitle module. CNcomment:复位字幕模块。CNend
+\attention \n
+none. CNcomment:无。CNend
+\param[in]  hSubt         subtitle handle. CNcomment:字幕句柄。CNend
+\retval ::HI_SUCCESS reset success. CNcomment:复位成功。CNend
+\retval ::HI_FAILURE reset failure. CNcomment:复位失败。CNend
+\see \n
+none. CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_SUBT_Reset(HI_HANDLE hSubt);
+
+/**
+\brief Update subtitle module. CNcomment:更新字幕模块。CNend
+\attention \n
+none. CNcomment:无。CNend
+\param[in]  hSubt         subtitle handle. CNcomment:字幕句柄。CNend
+\param[in]  pstSubtParam  the new subtitle content. CNcomment:新的字幕内容信息。CNend
+\retval ::HI_SUCCESS update success. CNcomment:更新成功。CNend
+\retval ::HI_FAILURE update failure. CNcomment:更新失败。CNend
+\see \n
+none. CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_SUBT_Update(HI_HANDLE hSubt, HI_UNF_SUBT_PARAM_S *pstSubtParam);
+
+/**
+\brief Inject DVB subtitle stream to decoder. CNcomment:注入字幕数据到解码器。CNend
+\attention \n
+Used the PES packet syntax for carriage of DVB subtitles. CNcomment:DVB字幕传输使用PES格式。CNend
+\param[in]  hSubt         subtitle handle. CNcomment:字幕句柄。CNend
+\param[in]  u32SubtPID    the pid of subtitle stream. CNcomment:字幕流pid。CNend
+\param[in]  pu8Data       subtitle stream data. CNcomment:字幕数据。CNend
+\param[in]  u32DataSize   the size of subtitle stream data. CNcomment:字幕数据长度。CNend
+\retval ::HI_SUCCESS inject success. CNcomment:注入成功。CNend
+\retval ::HI_FAILURE inject failure. CNcomment:注入失败。CNend
+\see \n
+none. CNcomment:无。CNend
+*/
+HI_S32 HI_UNF_SUBT_InjectData(HI_HANDLE hSubt, HI_U32 u32SubtPID, HI_U8* pu8Data, HI_U32 u32DataSize);
+
+/**
+\brief Register the callback function geted current pts.
+CNcomment:注册获取当前时间戳的回调函数。CNend
+\attention \n
+none. CNcomment:无。CNend
+\param[in]  hSubt         subtitle handle. CNcomment:字幕句柄。CNend
+\param[in]  pfnGetPts     callback funtion which geted current pts. CNcomment:获取当前时间戳的回调函数。CNend
+\param[in]  pUserData   userdata which used in callback funtion. CNcomment:回调函数的用户数据。CNend
+\retval   ::HI_SUCCESS    success. CNcomment:成功。CNend
+\retval   ::HI_FAILURE    failure. CNcomment:失败。CNend
+\see \n
+none. CNcomment: 无。CNend
+*/
+HI_S32 HI_UNF_SUBT_RegGetPtsCb(HI_HANDLE hSubt, HI_UNF_SUBT_GETPTS_FN pfnGetPts, HI_VOID* pUserData);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus*/
+
+#endif
diff -uNr a/include/hi_unf_ttx.h b/include/hi_unf_ttx.h
--- a/include/hi_unf_ttx.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_ttx.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,550 @@
+/******************************************************************************
+
+*
+* Copyright (C) 2014 Hisilicon Technologies Co., Ltd.  All rights reserved.
+*
+* This program is confidential and proprietary to Hisilicon  Technologies Co., Ltd. (Hisilicon),
+*  and may not be copied, reproduced, modified, disclosed to others, published or used, in
+* whole or in part, without the express prior written permission of Hisilicon.
+*
+
+******************************************************************************
+  File Name     : hi_unf_ttx.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2011/10/20
+  Description   : Teletext UNF header file
+  History       :
+  1.Date        : 2011/10/20
+    Author      : sdk
+    Modification: Created file
+
+******************************************************************************/
+#ifndef __HI_UNF_TTX_H__
+#define __HI_UNF_TTX_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif  /* End of #ifdef __cplusplus */
+
+/********************************Structure Definition********************************/
+/** \addtogroup      Teletext */
+/** @{ */  /** <!-- [Teletext] */
+
+/** Teletext max line in page *//** CNcomment:teletext页的最大行数 */
+#define HI_UNF_TTX_MAX_LINES (32)
+/** Teletext line size */ /** CNcomment:teletext行的长度 */
+#define HI_UNF_TTX_LINE_SIZE (46)
+
+/** Teletext key support list *//** CNcomment:默认支持的交互方式 */
+typedef enum hiUNF_TTX_KEY_E
+{
+    HI_UNF_TTX_KEY_0,
+    HI_UNF_TTX_KEY_1,
+    HI_UNF_TTX_KEY_2,
+    HI_UNF_TTX_KEY_3,
+    HI_UNF_TTX_KEY_4,
+    HI_UNF_TTX_KEY_5,
+    HI_UNF_TTX_KEY_6,
+    HI_UNF_TTX_KEY_7,
+    HI_UNF_TTX_KEY_8,
+    HI_UNF_TTX_KEY_9, /**<Three number key to open a specified page *//**<CNcomment:三个数字键打开指定页 */
+    HI_UNF_TTX_KEY_PREVIOUS_PAGE, /**<Previous page *//**<CNcomment:上一页 */
+    HI_UNF_TTX_KEY_NEXT_PAGE, /**<Next page *//**<CNcomment:下一页 */
+    HI_UNF_TTX_KEY_PREVIOUS_SUBPAGE, /**<Previous subpage *//**<CNcomment:上一 子页 */
+    HI_UNF_TTX_KEY_NEXT_SUBPAGE, /**<Next subpage *//**<CNcomment:下一 子页 */
+    HI_UNF_TTX_KEY_PREVIOUS_MAGAZINE, /**<Previous magazine *//**<CNcomment:上一杂志 */
+    HI_UNF_TTX_KEY_NEXT_MAGAZINE, /**<Next magazine *//**<CNcomment:下一杂志 */
+    HI_UNF_TTX_KEY_RED,    /**<First link in packet X/27, if inexistence, Show first valid page*//**<CNcomment:X/27 包中的第一个链接，无X/27则显示最近有效页 */
+    HI_UNF_TTX_KEY_GREEN,  /**<Second  link in packet X/27, if inexistence, Show second valid page*//**<CNcomment:X/27 包中的第二个链接，无X/27则显示第二有效页 */
+    HI_UNF_TTX_KEY_YELLOW, /**<Third  link in packet X/27, if inexistence, Show third valid page*//**<CNcomment:X/27 包中的第三个链接，无X/27则显示第三有效页 */
+    HI_UNF_TTX_KEY_CYAN,   /**<Fourth  link in packet X/27, if inexistence, Show fourth valid page. you can replace it with blue key if no cyan key on the user's control unit*/
+                           /**<CNcomment:X/27 包中的第四个链接，无X/27则显示第四有效页。如果遥控器上没有CYAN键，你可以用BLUE键来替代。*/
+    HI_UNF_TTX_KEY_INDEX,  /**<Sixth  link in packet X/27, if inexistence, Show index  page*//**<CNcomment:X/27 包中的第六个链接，无X/27则指向起始页 */
+    HI_UNF_TTX_KEY_REVEAL, /**<Reveal or hide concealed  information *//**<CNcomment:显示/隐藏conceal 信息 */
+    HI_UNF_TTX_KEY_HOLD,   /**<Switch between hold and resume ttx play  *//**<CNcomment:暂停图文播放/恢复图文播放切换 */
+    HI_UNF_TTX_KEY_MIX,    /**<Switch  between  transparent and nontransparent  background *//**<CNcomment:Teletext背景透明/不透明切换 */
+    HI_UNF_TTX_KEY_UPDATE, /**<Update current page*//**<CNcomment:更新当前页 */
+    HI_UNF_TTX_KEY_ZOOM,   /**<Send this cmd sevral times to display the upper,then the lower part of the screen and then return to the normal size teletext page*/
+                           /**<CNcomment:通过连续发送此命令依次显示teletext页面的上半部分、下半部分、全部 */
+    HI_UNF_TTX_KEY_SUBPAGE,/**<switch from page num ipunt mode to subpage input mode*//**<CNcomment:输入页号输入模式转到subpage输入模式 */
+    HI_UNF_TTX_KEY_CANCEL, /**<Hide or display current page except page number, currently not support*//**<CNcomment:隐藏或者显示除了页号外的当前页内容 ,当前暂不支持*/
+    HI_UNF_TTX_KEY_TIME,   /**<Hide or display current time*//**<CNcomment:隐藏或者显示当前时间*/
+    HI_UNF_TTX_KEY_BUTT    /**<Invalid key*//**<CNcomment:无效的按键 */
+} HI_UNF_TTX_KEY_E;
+
+/** Teletext output type *//** CNcomment:Teletext输出的类型 */
+typedef enum hiUNF_TTX_OUTPUT_E
+{
+    HI_UNF_TTX_VBI_OUTPUT,  /**<Only VBI output *//**<CNcomment:VBI 输出 */
+    HI_UNF_TTX_OSD_OUTPUT,  /**<Only OSD output *//**<CNcomment:OSD 输出 */
+    HI_UNF_TTX_DUAL_OUTPUT, /**<VBI OSD dual output *//**<CNcomment:VBI和OSD同时输出 */
+    HI_UNF_TTX_BUTT         /**<Invalid output type *//**<CNcomment:无效输出类型 */
+} HI_UNF_TTX_OUTPUT_E;
+
+/** Teletext type *//** CNcomment:Teletext的类型 */
+typedef enum hiUNF_TTX_TYPE_E
+{
+    HI_UNF_TTX_INITTTX = 1, /**<Initial Teletext page *//**<CNcomment:Teletext 图文 */
+    HI_UNF_TTX_TTXSUBT = 2, /**<Teletext subtitle page *//**<CNcomment:Teletext 字幕 */
+    HI_UNF_TTX_ADDINFO = 3, /**<Nonsupport for the moment <Additional information page *//**<CNcomment:暂不支持附加信息页 */
+    HI_UNF_TTX_PROGSCD = 4, /**<Nonsupport for the moment <Programme schedule page *//**<CNcomment:暂不支持节目指南页 */
+    HI_UNF_TTX_TTXSUBT_HIP = 5, /**<Nonsupport for the moment <Teletext subtitle page for hearing impaired people *//**<CNcomment:暂不支持为听力有障碍的人设置的Teletext字幕页 */
+    HI_UNF_TTX_TTXSUBT_BUTT /**<Invalid teletext type *//**<CNcomment:无效的teletext 类型 */
+} HI_UNF_TTX_TYPE_E;
+
+/** Teletext page type *//** CNcomment:Teletext页的类型 */
+typedef enum hiUNF_TTX_PAGE_TYPE_E
+{
+    HI_UNF_TTX_PAGE_CUR,   /**<Current reveal page *//**<CNcomment:当前显示页 */
+    HI_UNF_TTX_PAGE_INDEX, /**<Initial Teletext page , if  packet X/30 exist, return index page in X/30, otherwise return default index page 100*/
+                           /**<CNcomment:初始页，如果有X/30包，返回X/30包指定初始页，否则返回默认首页100 */
+    HI_UNF_TTX_PAGE_LINK1, /**<First link  in packet  X/27, if  inexistence, return first valid page*//**<CNcomment:X/27包中第1个链接，如果没有，返回当前页最近有效页 */
+    HI_UNF_TTX_PAGE_LINK2, /**<Second link  in packet  X/27, if inexistence, return second valid page*//**<CNcomment:X/27包中第2个链接，如果没有，返回当前页第二有效页 */
+    HI_UNF_TTX_PAGE_LINK3, /**<Third link  in packet  X/27, if  inexistence, return third valid page*//**<CNcomment:X/27包中第3个链接，如果没有，返回当前页第三有效页 */
+    HI_UNF_TTX_PAGE_LINK4, /**<Fourth  link  in packet  X/27, if  inexistence, return fourth valid page*//**<CNcomment:X/27包中第4个链接，如果没有，返回当前页第四有效页 */
+    HI_UNF_TTX_PAGE_LINK5, /**<Fifth link  in packet  X/27, if inexistence, return fifth valid page*//**<CNcomment:X/27包中第5个链接，如果没有，返回0ff:3f7f */
+    HI_UNF_TTX_PAGE_LINK6, /**<Sixth link  in packet  X/27, if inexistence, return Sixth valid page*//**<CNcomment:X/27包中第6个链接，如果没有，返回0ff:3f7f */
+    HI_UNF_TTX_PAGE_BUTT   /**<Invalid  page type *//**<CNcomment:无效页类型 */
+} HI_UNF_TTX_PAGE_TYPE_E;
+
+/** Teletext user command type *//** CNcomment:Teletext命令类型 */
+typedef enum hiUNF_TTX_CMD_E
+{
+    HI_UNF_TTX_CMD_KEY,          /**<(HI_UNF_TTX_KEY_E *)Default alternation type, key *//**<CNcomment:按键，默认的交互方式 */
+    HI_UNF_TTX_CMD_OPENPAGE,     /**<(HI_UNF_TTX_PAGE_ADDR_S *) Open specified page*//**<CNcomment:(HI_UNF_TTX_PAGE_ADDR_S *)打开指定页 */
+    HI_UNF_TTX_CMD_GETPAGEADDR,  /**<(HI_UNF_TTX_GETPAGEADDR_S *)Get current page , index page and  link page  address*//**<CNcomment:(HI_UNF_TTX_GETPAGEADDR_S *) 获取当前、首页、链接页地址 */
+    HI_UNF_TTX_CMD_CHECKPAGE,    /**<(HI_UNF_TTX_CHECK_PARAM_S *) Check the specified page be received or not*//**<CNcomment:(HI_UNF_TTX_CHECK_PARAM_S *) 检查是否收到参数中指定的页 */
+    HI_UNF_TTX_CMD_SETREQUEST,   /**<(HI_UNF_TTX_REQUEST_RAWDATA_S *) Sets up a request for teletext raw data*//**<CNcomment:(HI_UNF_TTX_REQUEST_RAWDATA_S *) 请求获取teletext中的原始数据 */
+    HI_UNF_TTX_CMD_CLEARREQUEST, /**<(HI_UNF_TTX_REQUEST_RAWDATA_S *) Clears a request set up by the HI_UNF_TTX_CMD_SETREQUEST*//**<CNcomment:(HI_UNF_TTX_REQUEST_RAWDATA_S *) 释放由HI_UNF_TTX_CMD_SETREQUEST创建的数据请求 */
+    HI_UNF_TTX_CMD_BUTT          /**<Invalid command type *//**<CNcomment:无效命令类型 */
+} HI_UNF_TTX_CMD_E;
+
+/** G0 char set *//** CNcomment:G0字符集 */
+typedef  enum   hiUNF_TTX_G0SET_E
+{
+    HI_UNF_TTX_G0SET_LATIN,      /**<LATIN G0 Primary Set  *//**<CNcomment:LATIN G0主字符集 */
+    HI_UNF_TTX_G0SET_CYRILLIC_1, /**<CYRILLIC_1 G0 Primary Set *//**<CNcomment:CYRILLIC_1  G0主字符集 */
+    HI_UNF_TTX_G0SET_CYRILLIC_2, /**<CYRILLIC_2 G0 Primary Set*//**<CNcomment:CYRILLIC_2 G0主字符集 */
+    HI_UNF_TTX_G0SET_CYRILLIC_3, /**<CYRILLIC_3 G0 Primary Set*//**<CNcomment:CYRILLIC_3 G0主字符集 */
+    HI_UNF_TTX_G0SET_GREEK,      /**<GREEK G0 Primary Set*//**<CNcomment:GREEK G0主字符集 */
+    HI_UNF_TTX_G0SET_HEBREW,     /**<HEBREW G0 Primary Set*//**<CNcomment:HEBREW  G0主字符集 */
+    HI_UNF_TTX_G0SET_ARABIC,     /**<ARABIC G0 Primary Set*//**<CNcomment:ARABIC G0主字符集 */
+    HI_UNF_TTX_G0SET_BUTT        /**<Invalid G0 Primary Set *//**<CNcomment:无效G0主字符集 */
+} HI_UNF_TTX_G0SET_E;
+
+/** G2 char set *//** CNcomment:G2字符集 */
+typedef enum hiUNF_TTX_G2SET_E
+{
+    HI_UNF_TTX_G2SET_LATIN,    /**<LATIN G2 Set *//**<CNcomment:LATIN G2字符集 */
+    HI_UNF_TTX_G2SET_CYRILLIC, /**<CYRILLIC G2 Set *//**<CNcomment:CYRILLIC G2字符集 */
+    HI_UNF_TTX_G2SET_GREEK,    /**<GREEK G2 Set *//**<CNcomment:GREEK G2字符集 */
+    HI_UNF_TTX_G2SET_ARABIC,   /**<ARABIC G2 Set *//**<CNcomment:ARABIC G2字符集 */
+    HI_UNF_TTX_G2SET_BUTT      /**<Invalid G2 Set *//**<CNcomment:无效G2字符集 */
+}HI_UNF_TTX_G2SET_E;
+
+/** Latin G0 National Option Sub-sets *//** CNcomment:Latin G0国家字符子集 */
+typedef enum hiUNF_TTX_NATION_SET_E
+{
+    HI_UNF_TTX_NATION_SET_PRIMARY,      /**<Latin G0 Primary nation sub set*//**<CNcomment:LATIN主国家子集*/
+    HI_UNF_TTX_NATION_SET_CZECH,        /**<Latin czech slovak nation sub set*//**<CNcomment:LATIN czech/slovak国家子集*/
+    HI_UNF_TTX_NATION_SET_ENGLISH,      /**<Latin english nation sub set*//**<CNcomment:LATIN english国家子集*/
+    HI_UNF_TTX_NATION_SET_ESTONIAN,     /**<Latin estonian nation sub set*//**<CNcomment:LATIN estonian国家子集*/
+    HI_UNF_TTX_NATION_SET_FRENCH,       /**<Latin french nation sub set*//**<CNcomment:LATIN french国家子集*/
+    HI_UNF_TTX_NATION_SET_GERMAN,       /**<Latin german nation sub set*//**<CNcomment:LATIN german国家子集*/
+    HI_UNF_TTX_NATION_SET_ITALIAN,      /**<Latin italish nation sub set*//**<CNcomment:LATIN italish国家子集*/
+    HI_UNF_TTX_NATION_SET_LETTISH,      /**<Latin lettish lithuanian nation sub set*//**<CNcomment:LATIN lithuanian国家子集*/
+    HI_UNF_TTX_NATION_SET_POLISH,       /**<Latin polish nation sub set*//**<CNcomment:LATIN polish国家子集*/
+    HI_UNF_TTX_NATION_SET_PORTUGUESE,   /**<Latin portutuese spanish nation sub set*//**<CNcomment:LATIN portutuese/spanish国家子集*/
+    HI_UNF_TTX_NATION_SET_RUMANIAN,     /**<Latin rumanian nation sub set*//**<CNcomment:LATIN rumanian国家子集*/
+    HI_UNF_TTX_NATION_SET_SERBIAN,      /**<Latin serbian croatian slovenian nation sub set*//**<CNcomment:LATIN serbian/croatian/slovenian国家子集*/
+    HI_UNF_TTX_NATION_SET_SWEDISH,      /**<Latin swedish finnish nation sub set*//**<CNcomment:LATIN finnish国家子集*/
+    HI_UNF_TTX_NATION_SET_TURKISH,      /**<Latin turkish nation sub set*//**<CNcomment:LATIN turkish国家子集*/
+    HI_UNF_TTX_NATION_SET_BUTT          /**<Invalid nation sub Set *//**<CNcomment:无效国家字符子集*/
+
+}HI_UNF_TTX_NATION_SET_E;
+
+/** Teletext char set *//** CNcomment:Teletext字符集 */
+typedef  enum   hiUNF_TTX_CHARSET_E
+{
+    HI_UNF_TTX_CHARSET_G0,  /**<G0  character set *//**<CNcomment:G0 字符集 */
+    HI_UNF_TTX_CHARSET_G1,  /**<G1  character set*//**<CNcomment:G1 字符集 */
+    HI_UNF_TTX_CHARSET_G2,  /**<G2  character set *//**<CNcomment:G2 字符集 */
+    HI_UNF_TTX_CHARSET_G3,  /**<G3  character set *//**<CNcomment:G3 字符集 */
+    HI_UNF_TTX_CHARSET_BUTT /**<Invalid  character set *//**<CNcomment:无效字符集 */
+} HI_UNF_TTX_CHARSET_E;
+
+/** DRCS character size *//** CNcomment:DRCS字符大小 */
+typedef enum hiUNF_TTX_DRCS_SIZE_E
+{
+    HI_UNF_TTX_DRCS_SIZE_NORMAL = 0,  /**<char size is 12*10*//**<CNcomment:字符大小12*10*/
+    HI_UNF_TTX_DRCS_SIZE_SMALL = 1,   /**<char size is 6*5*//**<CNcomment:字符大小6*5*/
+    HI_UNF_TTX_DRCS_SIZE_BUTT         /**<Invalid char size*//**<CNcomment:无效字符大小*/
+}HI_UNF_TTX_DRCS_SIZE_E;
+
+typedef HI_U32 HI_UNF_TTX_COLOR;
+
+/** Teletext page info *//** CNcomment:Teletext页区域信息 */
+typedef struct hiUNF_TTX_PAGEAREA_S
+{
+    HI_U32 u32Row         : 8; /**<The origination  row  number of the area  *//**<CNcomment:区域起始行号 */
+    HI_U32 u32Column      : 8; /**<The origination  column  number of the area *//**<CNcomment:区域起始列号 */
+    HI_U32 u32RowCount    : 8; /**<The count of row the area covers *//**<CNcomment:区域覆盖的列数 */
+    HI_U32 u32ColumnCount : 8; /**<The count of column  the area covers *//**<CNcomment:区域覆盖的行数 */
+} HI_UNF_TTX_PAGEAREA_S;
+
+/** Teletext char attribute *//** CNcomment:Teletext字符属性 */
+typedef  struct  hiUNF_TTX_CHARATTR_S
+{
+    HI_U32               u32Index    : 8; /**<Index of a char in a character set *//**<CNcomment:字符在字符集中的索引 */
+    HI_BOOL              bContiguous : 1; /**<Contiguous mosaic char or not *//**<CNcomment:是否为连续马赛克标志 */
+    HI_UNF_TTX_G0SET_E   enG0Set     : 3; /**<G0 Primary Set  , latin , arabic .... *//**<CNcomment:G0主字符集 */
+    HI_UNF_TTX_G2SET_E   enG2Set     : 3;  /**<G2 set ,latin, cyrillic, greek, arabic*//**<CNcomment:G2主字符集*/
+    HI_UNF_TTX_CHARSET_E enCharSet   : 3; /**<Character set  , G0 ,  G1  ....*//**<CNcomment:字符集 */
+    HI_U32               u8NationSet : 6; /**<Latin National  subset,  English ,French,  German .... *//**<CNcomment:国家字符子集 */
+    HI_U32               u8Reserved  : 8; /**<Reserved *//**<CNcomment:预留 */
+} HI_UNF_TTX_CHARATTR_S;
+
+/** The info of draw char *//** CNcomment:绘制字符的信息 */
+typedef struct hiUNF_TTX_DRAWCAHR_S
+{
+    HI_UNF_TTX_CHARATTR_S  * pstCharAttr;   /**<Character attribution, it can decide the position of a char in  a  font */
+                                            /**<CNcomment:字符属性，决定了一个字符在特定字库中的位置 */
+    HI_UNF_TTX_PAGEAREA_S * pstPageArea;    /**<Area of character in page *//**<CNcomment:字符在页面上的位置 */
+    HI_UNF_TTX_COLOR        u32Foreground;  /**<Foreground color *//**<CNcomment:前景色 */
+    HI_UNF_TTX_COLOR        u32Background;  /**<Background color *//**<CNcomment:背景色 */
+} HI_UNF_TTX_DRAWCAHR_S;
+
+/** The info of draw DRCS character *//** CNcomment:绘制DRCS字符的信息 */
+typedef struct hiUNF_TTX_DRAWDRCSCHAR_S
+{
+    HI_UNF_TTX_PAGEAREA_S  *pstPageArea;      /**<Area of character in page *//**<CNcomment:字符在页面上的位置 */
+    HI_UNF_TTX_COLOR       u32Background;     /**<Background color *//**<CNcomment:背景色 */
+    HI_UNF_TTX_COLOR*      pu32DRCSColorInfo; /**<color info of DRCS char,which define the color value of  every pixel in a DRCS char*/
+                                              /**<CNcomment:DRCS字符颜色信息，指定了DRCS字符每个像素的颜色值*/
+    HI_UNF_TTX_DRCS_SIZE_E enDRCSSize;        /**<size of DRCS char,normal is 12*10,and small is 6*5*//**<CNcomment:DRCS字符大小，正常是12*10,小字符是6*5 */
+}HI_UNF_TTX_DRAWDRCSCHAR_S;
+
+
+/** The filled area *//** CNcomment:填充区域 */
+typedef struct hiUNF_TTX_FILLRECT_S
+{
+    HI_UNF_TTX_PAGEAREA_S * pstPageArea; /**<Destination rectangle  *//**<CNcomment:目的矩形 */
+    HI_UNF_TTX_COLOR        u32Color;    /**<Color *//**<CNcomment:颜色值 */
+} HI_UNF_TTX_FILLRECT_S;
+
+/** Refreshed layer *//** CNcomment:刷新图层 */
+typedef struct hiUNF_TTX_REFRESHLAYER_S
+{
+    HI_UNF_TTX_PAGEAREA_S * pstPageArea; /**<Destination rectangle  *//**<CNcomment:(HI_UNF_TTX_BUFFER_PARAM_S *) 创建缓存 */
+} HI_UNF_TTX_REFRESHLAYER_S;
+
+/** Teletext Buffer info *//** CNcomment:Teletext缓存信息 */
+typedef struct hiUNF_TTX_BUFFER_PARAM_S
+{
+    HI_U32 u32Row     : 8; /**<The row number of buffer page*//**<CNcomment:缓存页面的行数 */
+    HI_U32 u32Column  : 8; /**<The column  number of buffer page*//**<CNcomment:缓存页面的列数 */
+    HI_U32 u8Reserved : 16;/**<Reserved *//**<CNcomment:预留 */
+} HI_UNF_TTX_BUFFER_PARAM_S;
+
+/** The set of callback cmd *//** CNcomment:回调命令集合 */
+typedef enum hiUNF_TTX_CB_E
+{
+    HI_UNF_TTX_CB_TTX_TO_APP_MSG, /**<Send message to GUI pthread *//**<CNcomment:发送绘制消息到GUI线程 */
+    HI_UNF_TTX_CB_APP_FILLRECT,   /**<(HI_UNF_TTX_FILLRECT_S *) Fill rectangle *//**<CNcomment:(HI_UNF_TTX_FILLRECT_S *)矩形填充 */
+    HI_UNF_TTX_CB_APP_DRAWCHAR,   /**<(HI_UNF_TTX_DRAWCAHR_S*)Select a char from a specified font and draw it  in specified rectangle of OSD by specified foreground and background */
+                                  /**<CNcomment:(HI_UNF_TTX_DRAWCAHR_S*) 绘制函数，将指定字符以指定的前、背景色显示在OSD的指定区域 */
+    HI_UNF_TTX_CB_APP_DRAWDRCSCHAR,/**<(HI_UNF_TTX_DRAWDRCSCHAR_S*)draw a DRCS char which specified by the color of every pixel*//**<CNcomment:绘制DRCS字符，字符由每个像素的颜色值确定*/
+    HI_UNF_TTX_CB_APP_REFRESH,    /**<(HI_UNF_TTX_REFRESHLAYER_S*) Refresh layer *//**<CNcomment:(HI_UNF_TTX_REFRESHLAYER_S*) 图层刷新函数 */
+    HI_UNF_TTX_CB_CREATE_BUFF,    /**<(HI_UNF_TTX_BUFFER_PARAM_S *) Create buffer *//**<CNcomment:(HI_UNF_TTX_BUFFER_PARAM_S *) 创建缓存 */
+    HI_UNF_TTX_CB_DESTROY_BUFF,   /**<Destroy buffer *//**<CNcomment:销毁缓存 */
+    HI_UNF_TTX_CB_GETPTS,         /**<(HI_S64 *) Get the PTS of the stream *//**<CNcomment:(HI_S64 *) 获取当前播放码流的PTS */
+    HI_UNF_TTX_CB_BUTT            /**<Invalid callback type*//**<CNcomment:无效回调类型 */
+} HI_UNF_TTX_CB_E;
+
+typedef enum hiUNF_TTX_PACKET_TYPE_E
+{
+    HI_UNF_TTX_PACKET_TYPE_PES,  /**<ETSI EN DVB 300472 teletext syntax data packets, including PES header information*//**<CNcomment:ETSI EN 300472 DVB teletext语法数据包,包括PES头部信息*/
+    HI_UNF_TTX_PACKET_TYPE_RAW,   /**<ETSI EN DVB 300706 teletext syntax data packets, not including PES header information*//**<CNcomment:ETSI EN 300706 DVB teletext语法数据包,不包括PES头部信息*/
+    HI_UNF_TTX_PACKET_TYPE_BUTT,
+}HI_UNF_TTX_PACKET_TYPE_E;
+
+/** Callback function *//** CNcomment:回调函数 */
+typedef HI_S32 (*HI_UNF_TTX_CB_FN)(HI_HANDLE hTTX, HI_UNF_TTX_CB_E enCB, HI_VOID *pvCBParam);
+
+
+typedef enum hiUNF_TTX_LEVEL_E
+{
+    HI_UNF_TTX_LEVEL_1_5 = 0, /**<TTX Level 1.5 *//**<CNcomment:TTX 1.5 级别 */
+    HI_UNF_TTX_LEVEL_2_5 = 1, /**<TTX Level 2.5*//**<CNcomment:TTX 2.5 级别 */
+    HI_UNF_TTX_LEVEL_3_5 = 2, /**<TTX Level 3.5*//**<CNcomment:TTX 3.5 级别 */
+    HI_UNF_TTX_LEVEL_BUTT     /**<Invalid TTX Level*//**<CNcomment:TTX 无效级别 */
+}HI_UNF_TTX_LEVEL_E;
+
+/** Teletext Init param *//** CNcomment:Teletext初始化参数 */
+typedef struct hiUNF_TTX_INIT_PARA_S
+{
+    HI_U8 *pu8MemAddr;       /**<The address of memory, If  0, malloc the memory in the module, Otherwise malloced outside the module */
+                             /**<CNcomment:数据分配的起始地址，如果为0则内部分配 ，否则由外部分配内存 */
+    HI_U32 u32MemSize;       /**<The size of memory,  If  0, the size decided in the module, Otherwise decided outside the module */
+                             /**<CNcomment:数据分配的大小，如果为0 ，由内部决定，否则大小由外部决定 */
+
+    HI_UNF_TTX_LEVEL_E  enTtxLevel; /**<TTX level*//**<CNcomment:TTX 级别 */
+
+    HI_UNF_TTX_CB_FN pfnCB;  /**<Callback function *//**<CNcomment:回调函数 */
+    HI_BOOL          bFlash; /**<Permit flash or not *//**<CNcomment:是否开启闪烁功能 */
+    HI_BOOL          bNavigation; /**<Permit navigation bar *//**<CNcomment:是否提供导航条 */
+} HI_UNF_TTX_INIT_PARA_S;
+
+/** Teletext page address *//** CNcomment:Teletext页属性 */
+typedef struct hiUNF_TTX_PAGE_ADDR_S
+{
+    HI_U8  u8MagazineNum;  /**<Magazine number *//**<CNcomment:杂志号 */
+    HI_U8  u8PageNum;      /**<Page number *//**<CNcomment:页号 */
+    HI_U16 u16PageSubCode; /**<Page sub-code *//**<CNcomment:子页号 */
+} HI_UNF_TTX_PAGE_ADDR_S;
+
+/** Teletext content param *//** CNcomment:Teletext内容参数 */
+typedef struct hiUNF_TTX_CONTENT_PARA_S
+{
+    HI_UNF_TTX_TYPE_E      enType; /**<Teletext content type *//**<CNcomment:Teletext内容类型 */
+    HI_U32                         u32ISO639LanCode;/**<teletext iso639  language code*//**<CNcomment:Teletext  iso639语言*/
+    HI_UNF_TTX_PAGE_ADDR_S stInitPgAddr; /**<Init page address, if Magazine number or Page number be equal to 0xFF,set to 100th page.sub-page numbet default  0*/
+                                         /**<CNcomment:初始页地址，如果杂志号或页号为0xff，则设置为第100页。子页号默认为0 */
+} HI_UNF_TTX_CONTENT_PARA_S;
+
+/** Teletext checked param *//** CNcomment:Teletext检测参数 */
+typedef struct hiUNF_TTX_CHECK_PARAM_S
+{
+    HI_UNF_TTX_PAGE_ADDR_S stPageAddr; /**<page address*//**<CNcomment:页地址  */
+    HI_BOOL                bSucceed;   /**<success or failure*//**<CNcomment:是否成功 */
+} HI_UNF_TTX_CHECK_PARAM_S;
+
+/** Get page address*//** CNcomment:获取Teletext页 */
+typedef struct hiUNF_TTX_GETPAGEADDR_S
+{
+    HI_UNF_TTX_PAGE_TYPE_E enPageType; /**<page type *//**<CNcomment:页类型 */
+    HI_UNF_TTX_PAGE_ADDR_S stPageAddr; /**<page address *//**<CNcomment:页地址*/
+} HI_UNF_TTX_GETPAGEADDR_S;
+
+/** Teletext raw data*//** CNcomment:ttx原始数据 */
+typedef struct hiUNF_TTX_RAWDATA_S
+{
+    HI_U32 u32ValidLines; /**<bit-field lines  0..31 *//**<CNcomment:有效位标识 */
+    HI_U8  au8Lines[HI_UNF_TTX_MAX_LINES][HI_UNF_TTX_LINE_SIZE]; /**<line data *//**<CNcomment:ttx行数据 */
+} HI_UNF_TTX_RAWDATA_S;
+
+/** Callback function in which notified raw data to consumer *//** CNcomment:用于回传ttx原始数据的回调函数 */
+typedef HI_S32 (*HI_UNF_TTX_REQUEST_CALLBACK_FN)(HI_UNF_TTX_RAWDATA_S *pstRawData);
+
+/** Request teletext raw data*//** CNcomment:请求ttx原始数据 */
+typedef struct hiUNF_TTX_REQUEST_RAWDATA_S
+{
+    HI_UNF_TTX_RAWDATA_S *pstRawData;  /**<raw data address*//**<CNcomment:原始数据地址 */
+    HI_UNF_TTX_REQUEST_CALLBACK_FN pfnRequestCallback; /**<Callback function *//**<CNcomment:回调函数 */
+} HI_UNF_TTX_REQUEST_RAWDATA_S;
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/********************************API declaration********************************/
+/** \addtogroup      Teletext  */
+/** @{ */  /** <!-- [Teletext] */
+
+/**
+\brief     Initializes  TTX  module. CNcomment:初始化TTX模块。CNend
+\attention \n
+none.
+\retval ::HI_SUCCESS     success. CNcomment:成功。CNend
+\retval ::HI_FAILURE     failure. CNcomment:失败。CNend
+\see \n
+none.
+*/
+HI_S32 HI_UNF_TTX_Init(HI_VOID);
+
+/**
+\brief  Deinitializes TTX module. CNcomment:去初始化TTX模块。CNend
+\attention \n
+none.
+\retval ::HI_SUCCESS     success. CNcomment:成功。CNend
+\retval ::HI_FAILURE     failure. CNcomment:失败。CNend
+\see \n
+none.
+*/
+HI_S32 HI_UNF_TTX_DeInit(HI_VOID);
+
+/**
+\brief  Create a TTX instance, just support for a single  instance for the moment.  CNcomment:创建TTX实例，目前只支持单实例。CNend
+\attention \n
+After creating a instance  successfully, the instance  default  to be enable , decode and be
+prepared to display teletext. Call  correspond interface to display teletext.
+CNcomment:创建成功后这个实例默认enable，解析并准备显示teletext内容。调用相应的输出控制接口后输出。CNend
+\param[in]  pstInitParam  Initialized  parameter. CNcomment:初始化参数。CNend
+\param[out] phTTX         Teletext instance. CNcomment:Teletext句柄。CNend
+\retval ::HI_SUCCESS      success.  CNcomment:成功。CNend
+\retval ::HI_FAILURE      failure.  CNcomment:失败。CNend
+\see \n
+none.
+*/
+HI_S32 HI_UNF_TTX_Create(HI_UNF_TTX_INIT_PARA_S* pstInitParam, HI_HANDLE* phTTX);
+
+/**
+\brief    Destory  a  teletext instance.  CNcomment:销毁TTX实例。CNend
+\attention \n
+none.
+\param[in] hTTX        Teletext instance. CNcomment:Teletext句柄。CNend
+\retval ::HI_SUCCESS   success.  CNcomment:成功。CNend
+\retval ::HI_FAILURE   failure.  CNcomment:失败。CNend
+\see \n
+none.
+*/
+HI_S32 HI_UNF_TTX_Destroy(HI_HANDLE hTTX);
+
+/**
+\brief   Inject the teletext PES data . CNcomment:注入Teletext PES 数据。CNend
+\attention \n
+none.
+\param[in] hTTX    Teletext instance. CNcomment:Teletext句柄。CNend
+\param[in] pu8Data   Address of data. CNcomment:数据地址。CNend
+\param[in] u32DataSize  the length of data. CNcomment:数据长度。CNend
+\retval ::HI_SUCCESS    success.  CNcomment:成功。CNend
+\retval ::HI_FAILURE    failure.  CNcomment:失败。CNend
+\see \n
+none.
+*/
+HI_S32 HI_UNF_TTX_InjectData(HI_HANDLE hTTX, HI_U8 *pu8Data, HI_U32 u32DataSize);
+
+/**
+\brief   Reset data. CNcomment:清除收到的数据。CNend
+\attention \n
+none.
+\param[in] hTTX   Teletext instance. CNcomment:Teletext句柄。CNend
+\retval ::HI_SUCCESS    success.  CNcomment:成功。CNend
+\retval ::HI_FAILURE    failure.  CNcomment:失败。CNend
+\see \n
+none.
+*/
+HI_S32 HI_UNF_TTX_ResetData(HI_HANDLE hTTX);
+
+/**
+\brief  Set the initial page address of teletext. CNcomment:设置Teletext的初始页。CNend
+\attention \n
+none.
+\param[in] hTTX   Teletext instance. CNcomment:Teletext句柄。CNend
+\param[in] pstContentParam  context  parameter.  CNcomment:内容参数。CNend
+\retval ::HI_SUCCESS    success. CNcomment:成功。CNend
+\retval ::HI_FAILURE    failure. CNcomment:失败。CNend
+\see \n
+none.
+*/
+HI_S32 HI_UNF_TTX_SwitchContent (HI_HANDLE hTTX, HI_UNF_TTX_CONTENT_PARA_S* pstContentParam);
+
+/**
+\brief  All operation related to OSD. CNcomment:和OSD相关的所有操作。CNend
+\attention \n
+none.
+\param[in] hTTX    Teletext instance.   CNcomment:Teletext句柄。CNend
+\param[in] enMsgAction  Action of the message.  CNcomment:消息指定的动作。CNend
+\retval ::HI_SUCCESS    success.   CNcomment:成功。CNend
+\retval ::HI_FAILURE    failure.   CNcomment:失败。CNend
+\see \n
+none.
+*/
+HI_S32 HI_UNF_TTX_Display(HI_HANDLE hTTX, HI_HANDLE hDispalyHandle);
+
+/**
+\brief   Enable  or disable teletext output, and set the type of output.
+CNcomment:使能或关闭teletext输出、设置输出类型。CNend
+\attention \n
+ The parameter can be reset  time after time.   CNcomment: 可重复进行输出设置。CNend
+\param[in] hTTX        Teletext instance.     CNcomment:Teletext句柄。CNend
+\param[in]enOutput     Output  type: OSD,VBI or OSD  VBI dual output.   CNcomment:输出类型:OSD / VBI /OSD-VBI同时输出。CNend
+\param[in] bEnable       HI_TRUE: enable,  HI_FALSE: disable.   CNcomment:HI_TRUE: 使能，HI_FALSE: 关闭。CNend
+\retval ::HI_SUCCESS      success.  CNcomment:成功。CNend
+\retval ::HI_FAILURE      failure.  CNcomment:失败。CNend
+\see \n
+none.
+*/
+HI_S32 HI_UNF_TTX_Output (HI_HANDLE hTTX, HI_UNF_TTX_OUTPUT_E enOutput, HI_BOOL bEnable);
+
+/**
+\brief     The function  of TTX instance to handle user's operation.  CNcomment:TTX实例用户操作处理函数。CNend
+\attention \n
+none.
+\param[in] hTTX     Teletext instance.   CNcomment:Teletext句柄。CNend
+\param[in] enCMD      Type of command.   CNcomment:命令类型。CNend
+\param[in] pvCMDParam     Parameter of  command(The parameter must be  conveted to appropriate  type at every
+ specifical application), when the command is UPDATE or EXIT, the command can be NULL.
+ CNcomment:命令参数(具体应用需要强制转换)，UPDATE/EXIT时可为NULL。CNend
+\param[out] pvCMDParam    Parameter of command , when the command is  GETPAGEADDR, it points to the address of specifical  pages.
+ CNcomment:命令参数，GETPAGEADDR时输出页地址。CNend
+\retval ::HI_SUCCESS    success.  CNcomment:成功。CNend
+\retval ::HI_FAILURE    failure.  CNcomment:失败。CNend
+\see \n
+ Please  consult  the definition of  HI_UNF_TTX_CMD_E.  CNcomment:请参考HI_UNF_TTX_CMD_E定义。CNend
+*/
+HI_S32 HI_UNF_TTX_ExecCmd(HI_HANDLE hTTX,
+                          HI_UNF_TTX_CMD_E enCMD, HI_VOID *pvCMDParam);
+
+/**
+\brief  Setting teletext language of region.
+CNcomment:设置图文区域语言码。CNend
+\attention \n
+None
+\param[in] handle Handle of teletext instance. CNcomment:TTX实例句柄。CNend
+\param[in] pu8Language language code.
+CNcomment:语言码 CNend
+
+\retval ::HI_SUCCESS  Operation success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Operation fail. CNcomment:失败。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_TTX_SetLanguage(HI_HANDLE hTTX, HI_U8* pu8Language);
+
+/**
+\brief  Setting max interval time of the teletext.
+CNcomment:设置图文最大的时间偏差。CNend
+\attention \n
+None
+\param[in] handle Handle of teletext instance. CNcomment:TTX实例句柄。CNend
+\param[in] u32IntervalMs max interval of teletext, unit is Millisecondes.
+CNcomment:图文最大的时间偏差值，单位ms。CNend
+
+\retval ::HI_SUCCESS  Operation success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Operation fail. CNcomment:失败。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_TTX_SetMaxInterval(HI_HANDLE hTTX, HI_U32 u32IntervalMs );
+
+/**
+\brief  Setting teletext packet type.
+CNcomment:设置图文解析的数据包类型。CNend
+\attention \n
+None
+\param[in] handle Handle of teletext instance. CNcomment:TTX实例句柄。CNend
+\param[in] enPacketType the type of teletext packet
+CNcomment:图文数据包类型。CNend
+
+\retval ::HI_SUCCESS  Operation success. CNcomment:成功。CNend
+\retval ::HI_FAILURE  Operation fail. CNcomment:失败。CNend
+
+\see \n
+None
+*/
+HI_S32 HI_UNF_TTX_SetPacketType (HI_HANDLE hTTX, HI_UNF_TTX_PACKET_TYPE_E enPacketType);
+
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif
+#endif
diff -uNr a/include/hi_unf_venc.h b/include/hi_unf_venc.h
--- a/include/hi_unf_venc.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_venc.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,570 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_venc.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2010/04/07
+  Description   :
+  History       :
+  1.Date        : 2010/04/07
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+/** 
+ * \file
+ * \brief Describes the information about video encoding (VENC). CNcomment: 提供VENC的相关信息 CNend
+ */
+
+#ifndef  __HI_UNF_VENC_H__
+#define  __HI_UNF_VENC_H__
+
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif
+
+#define HI_UNF_VENC_TYPE_NUM 3
+
+/********************************Struct Definition********************************/
+/** \addtogroup      VENC */
+/** @{ */  /** <!-- 【VENC】 */
+
+/**H.264 NALU type*/
+/**CNcomment: H.264NALU类型 */
+typedef enum hiUNF_H264E_NALU_TYPE_E
+{
+    HI_UNF_H264E_NALU_PSLICE = 1,       /**<P slice NALU*/ 
+    HI_UNF_H264E_NALU_ISLICE = 5,       /**<I slice NALU*/ 
+    HI_UNF_H264E_NALU_SEI = 6,          /**<SEI NALU*/ 
+    HI_UNF_H264E_NALU_SPS = 7,          /**<SPS NALU*/
+    HI_UNF_H264E_NALU_PPS = 8,          /**<PPS NALU*/ 
+    HI_UNF_H264E_NALU_BUTT
+} HI_UNF_H264E_NALU_TYPE_E;
+
+/**H.263 NALU type*/
+/**CNcomment: H.263NALU类型 */
+typedef enum hiUNF_H263E_PACK_TYPE_E
+{
+    HI_UNF_H263E_NALU_PSLICE = 1,       /**<P slice NALU*/
+    HI_UNF_H263E_NALU_ISLICE = 5,       /**<I slice NALU*/
+    HI_UNF_H263E_NALU_SEI = 6,          /**<SEI NALU*/
+    HI_UNF_H263E_NALU_SPS = 7,          /**<SPS NALU*/
+    HI_UNF_H263E_NALU_PPS = 8,          /**<PPS NALU*/
+    HI_UNF_H263E_NALU_BUTT
+} HI_UNF_H263E_PACK_TYPE_E;
+
+/**MPEG4 package type*/
+/**CNcomment: MPEG4打包类型 */
+typedef enum hiUNF_MPEG4E_PACK_TYPE_E
+{
+    HI_UNF_MPEG4E_PACK_VO    = 1,          /**<VO package*/ /**<CNcomment: VO 包*/
+    HI_UNF_MPEG4E_PACK_VOS   = 2,         /**<VOS package*/ /**<CNcomment: VOS 包*/
+    HI_UNF_MPEG4E_PACK_VOL   = 3,         /**<VOL package*/ /**<CNcomment: VOL 包*/
+    HI_UNF_MPEG4E_PACK_VOP   = 4,         /**<VOP package*/ /**<CNcomment: VOP 包*/
+    HI_UNF_MPEG4E_PACK_SLICE = 5        /**<Slice package*/ /**<CNcomment: SLICE 包*/
+} HI_UNF_MPEG4E_PACK_TYPE_E;
+
+/**HEVC NALU type*/
+/**CNcomment: HEVC NALU类型 */
+typedef enum hiUNF_HEVCE_NALU_TYPE_E
+{
+    HI_UNF_HEVCE_NALU_PSLICE = 1,    /**<P slice NALU*/
+    HI_UNF_HEVCE_NALU_ISLICE,        /**<I slice NALU*/
+    HI_UNF_HEVCE_NALU_VPS,           /**<VPS NALU*/
+    HI_UNF_HEVCE_NALU_SPS,           /**<SPS NALU*/
+    HI_UNF_HEVCE_NALU_PPS,           /**<PPS NALU*/
+    HI_UNF_HEVCE_NALU_SEI,           /**<SEI NALU*/
+    HI_UNF_HEVCE_NALU_BUTT
+} HI_UNF_HEVCE_NALU_TYPE_E;
+
+/*VENC Rate Control Type*/
+/**CNcomment: 编码器码率控制类型*/
+typedef enum hiUNF_VENC_RATECONTROL_TYPE_E
+{
+    HI_UNF_VENC_RATECONTROL_TYPE_CBR,
+    HI_UNF_VENC_RATECONTROL_TYPE_AVBR,
+    HI_UNF_VENC_RATECONTROL_TYPE_BUTT
+} HI_UNF_VENC_RATECONTROL_TYPE_E;
+
+/**Defines the source of input frame rate.*/
+/**CNcomment: 定义编码器输入帧率来源类型的枚举 */
+typedef enum hiUNF_VENC_FRMRATE_TYPE_E
+{
+    HI_UNF_VENC_FRMRATE_TYPE_AUTO,         /**<Use the frame rate calculates from real-time statistics */ /**<CNcomment:内部统计校正实时收到的帧率*/
+    HI_UNF_VENC_FRMRATE_TYPE_STREAM,       /**<Use the frame rate comes from stream*/ /**<CNcomment: 采用码流信息中的帧率 */
+    HI_UNF_VENC_FRMRATE_TYPE_USER,         /**<Use the frame rate set by user*/ /**<CNcomment: 采用用户设置的帧率 */
+    HI_UNF_VENC_FRMRATE_TYPE_BUTT
+}HI_UNF_VENC_FRMRATE_TYPE_E;
+
+/**Data type of the Encoder*/
+/**CNcomment: 编码器数据类型 */
+typedef union hiUNF_VENC_DATA_TYPE_U
+{
+    HI_UNF_H264E_NALU_TYPE_E   enH264EType;	/**<H.264 encoding data*/ /**<CNcomment: h264编码数据*/
+    HI_UNF_H263E_PACK_TYPE_E   enH263EType;	/**<H.263 encoding data*/ /**<CNcomment: h263编码数据*/
+    HI_UNF_MPEG4E_PACK_TYPE_E  enMPEG4EType;    /**<MPEG4 encoding data*/ /**<CNcomment: MPEG4编码数据*/
+    HI_UNF_HEVCE_NALU_TYPE_E   enHEVCEType;     /**<HEVC encoding data*/ /**<CNcomment: HEVC编码数据*/
+}HI_UNF_VENC_DATA_TYPE_U;
+
+/*Output stream attributes structure*/
+/**CNcomment: 输出码流属性结构体 */
+typedef struct hiVENC_STREAM_S
+{
+    HI_U8                   *pu8Addr ;       /**<Stream virtual address*/ /**<CNcomment: 码流虚拟地址*/
+    HI_U32                  u32SlcLen;      /**<Stream length*/ /**<CNcomment: 码流长度*/
+    HI_U32                  u32PtsMs;        /**<Presentation time stamp (PTS), in ms*/ /**<CNcomment: 时间戳，单位是毫秒*/
+    HI_BOOL                 bFrameEnd;       /**<Frame end or not*/ /**<CNcomment: 标识是否为帧结束*/
+    HI_UNF_VENC_DATA_TYPE_U enDataType;      /**Encoding data type*/ /**<CNcomment: 编码数据类型*/
+}HI_UNF_VENC_STREAM_S;
+
+/*Coding channal attributes structure*/
+/**CNcomment: 编码通道属性结构体 */
+typedef struct hiUNF_VENC_CHN_ATTR_S
+{
+    HI_UNF_VCODEC_TYPE_E        enVencType;	      /**<Encoder type*/ /**<CNcomment: 编码器类型 */
+    HI_UNF_VCODEC_CAP_LEVEL_E   enCapLevel;       /**<Encoder level*/ /**<CNcomment: 编码器编码能力 */
+    HI_UNF_H264_PROFILE_E       enVencProfile;    /**<H264 Profile of Encoder,it is just valid for H264 Encoder*/ /**<CNcomment: 编码H264的档次，只在定义了H264协议编码器情况下才有效*/
+    HI_U32                      u32Width;         /**<Width, 4-byte aligned. The width can be configured dynamically in the limit of encoder level.*/
+                                                  /**<CNcomment: 宽度,4对齐,编码能力级范围内可支持动态设置 */
+    HI_U32                      u32Height;        /**<Height, 4-byte aligned.The height can be configured dynamically in the limit of encoder level.*/
+                                                  /**<CNcomment: 高度,4对齐,编码能力级范围内可支持动态设置 */
+    HI_U32                      u32StrmBufSize;   /**<Stream buffer size, the value ranges from 32*1024 to 40*1024*1024.You'd better set larger streamBufferSize if you set larger target bitrate or Qlevel.*/
+                                                  /**<CNcomment: 码流buffer大小,配置的码流buffer大小范围为32x1024到40x1024x1024，如果设置了较高的码率或JPEG图像质量参数，建议适当增大码流buffer大小。*/
+    HI_U32                      u32RotationAngle; /**<Rotation angle. This parameter cannot be set.It must be set to 0.*/ /**<CNcomment: 旋转角度,无效设置,须配置成0*/
+    HI_BOOL                     bSlcSplitEn;      /**<Slice split enable,it is just valid for H264 Encoder*/ /**<CNcomment: 是否使能分割slice,只在定义了H264协议编码器情况下才有效*/
+                                                  /**<CNcomment: 分割的大小，JPGE下以MCU为单位,H264或者MP4以字节为单位, H263不关心 */
+    HI_U32                      u32TargetBitRate; /**<RC parameter for the VENC,it is just valid for H264 Encoder. It can be set dynamically.Some reference values as follows:above 5M for 1080P,above 3M for 720P, about 2M for D1*/
+                                                   /**<CNcomment: Venc下是RC参数,仅在编码H264协议有效，可动态设置.部分参考值如下:1080P下5M以上，720P下3M以上，D1下2M左右*/
+    HI_U32                      u32TargetFrmRate; /**<Target frame rate. It can be set dynamically.*/         /**<CNcomment: 目标帧率,可动态设置 */
+    HI_U32                      u32InputFrmRate;  /**<Input frame rate. It can be set dynamically. The value of u32TargetFrmRate is less than or equal to the value of u32InputFrmRate.
+                                                   ** Attention the if in the mode of attach source to encode the InputFrmRate which set by user is in vain.*/
+                                                  /**<CNcomment: 输入帧率,可动态设置,u32TargetFrmRate <= u32InputFrmRate ,注意在绑定模式编码情况下用户配置的输入帧率将失效*/
+    HI_U32                      u32Gop;           /**<GOP size,it is just valid for H264 Encoder. It can be set dynamically.*/ /**<CNcomment: GOP大小,仅在编码H264协议有效，可动态设置 */
+    HI_U32                      u32MaxQp;         /**<The maximum quantization parameter,it is just valid for H264 Encoder. It can be set dynamically.*/    /**<CNcomment: 最大量化参数,仅在编码H264协议有效，可动态设置*/
+    HI_U32                      u32MinQp;         /**<The minimum quantization parameter,it is just valid for H264 Encoder. It can be set dynamically.*/    /**<CNcomment: 最小量化参数,仅在编码H264协议有效，可动态设置*/
+    HI_BOOL                     bQuickEncode;     /**<Quick Encode Mode enable*/ /**<CNcomment:是否使能快速编码模式*/
+    HI_U8                       u8Priority;       /**<the Priority Level of the channal,should between 0 to the max num of channel minus 1.It can be set dynamically.*/
+                                                  /**<CNcomment: 编码通道的优先级属性，取值范围为0~最大通道数-1,可动态设置*/
+    HI_U32                      u32Qlevel;        /**<The value ranges from 1 to 99 for the JPGE, it is just valid for JPEG Encoder.*/ /**<CNcomment: JPGE取值范围1-99，只在定义了JPEG编码器情况下才有效 */
+    HI_U32                      u32DriftRateThr;  /**<Encoder bitrate fluctuation threshold.If u32DriftRateThr = 20 means the fluctuation of threshold is 20%*/
+                                                  /**<CNcomment: 编码器码率波动阈值，如设置成20，表示波动阈值为20%*/
+
+    HI_U32                      u32SplitSize;     /**<Split size. The size is in the unit of minimum coded unit (MCU) for the JPEG format and byte for the MP4 format. The split size can be ignored in H.263 format.*/
+}HI_UNF_VENC_CHN_ATTR_S;
+
+/*VENC Capability Information Of One Resolution*/
+/**CNcomment: 某一分辨率的编码能力信息*/
+typedef struct hiUNF_VENC_CAP_RESO_S
+{
+    HI_UNF_VCODEC_CAP_LEVEL_E enCapLevel;       /**<support max enCapLevel*//**<CNcomment: 最大编码能力级 */
+    HI_U32  u32Height;                          /**<support max height*//**<CNcomment: 高度 */
+    HI_U32  u32Width;                           /**<support min height*//**<CNcomment: 宽度 */
+    HI_U32  u32MaxFrmRate;                      /**<support max frame rate*//**<CNcomment: 最大帧率 */
+    HI_U32  u32MaxBitRate;                      /**<support max bit rate*//**<CNcomment: 最大码率*/
+    HI_U32  u32MinBitRate;                      /**<support min bit rate*//**<CNcomment: 最小码率*/
+    HI_U32  u32MinBufSize;                      /**<support min stream buffer size*//**<CNcomment: 最大能力级对应的最小码流buffer大小*/
+}HI_UNF_VENC_CAP_RESO_S;
+
+/*VENC Capability Information Of One Encode Type*/
+/**CNcomment: 某一编码协议的编码能力信息*/
+typedef struct hiUNF_VENC_CAP_INFO_S
+{
+    HI_UNF_VCODEC_TYPE_E   enCodecType;         /**<support venc type*//**<CNcomment: 编码类型*/
+    HI_U32                 u32MaxChnNum;        /**<support max channel num*//**<CNcomment: 最大通道数*/
+    HI_UNF_VENC_CAP_RESO_S stMaxReso;           /**<support capability information of max resolution*//**<CNcomment: 最大分辨率对应的能力信息*/
+    HI_UNF_VENC_CAP_RESO_S stMinReso;           /**<support capability information of min resolution*//**<CNcomment: 最小分辨率对应的能力信息*/
+}HI_UNF_VENC_CAP_INFO_S;
+
+/*VENC Capability Information*/
+/**CNcomment: 编码能力信息*/
+typedef struct hiUNF_VENC_CAP_S
+{
+    HI_U32                 u32SupportTypeNum;                   /**<support venc type num*//**<CNcomment: 编码器支持的编码类型数量 */
+    HI_UNF_VENC_CAP_INFO_S stCapInfo[HI_UNF_VENC_TYPE_NUM];     /**<capability information for venc types*//**<CNcomment: 编码器不同编码类型的编码能力信息 */
+}HI_UNF_VENC_CAP_S;
+
+/** @} */  /** <!-- ==== Struct Definition End ==== */
+
+
+/********************************API declaration********************************/
+/** \addtogroup      VENC */
+/** @{ */  /** <!-- 【VENC】 */
+
+/** 
+\brief Initializes the video encoder. CNcomment: 初始化视频编码器 CNend
+\attention \n
+Before using the VENC, you must call this API. CNcomment: 调用VENC模块要求首先调用该接口 CNend
+\param[in] N/A CNcomment: 无 CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+\retval ::HI_ERR_VENC_DEV_NOT_EXIST No VENC device exists. CNcomment: 设备不存在 CNend
+\retval ::HI_ERR_VENC_NOT_DEV_FILE The file is not a VENC file. CNcomment: 文件非设备 CNend
+\retval ::HI_ERR_VENC_DEV_OPEN_ERR The VENC device fails to start. CNcomment: 打开设备失败 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_VENC_Init(HI_VOID);
+
+
+/** 
+\brief Deinitializes the video encoder. CNcomment: 去初始化视频编码器 CNend
+\attention \n
+N/A CNcomment: 无 CNend
+\param[in] N/A CNcomment: 无 CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+\retval ::HI_ERR_VENC_DEV_CLOSE_ERR The video encoder fails to stop. CNcomment: 关闭编码器失败 CNend
+\see \n
+N/A CNcomment: 无  CNend
+*/
+HI_S32 HI_UNF_VENC_DeInit(HI_VOID);
+
+
+/** 
+\brief Obtains the default attributes of a VENC channel. CNcomment: 获取编码通道默认属性 CNend
+\attention \n
+By default, the encoding size is D1, encoding format is H.264, and a frame is a slice.
+CNcomment: 默认D1编码，H.264格式，一帧为一个Slice CNend
+\param[out] pstAttr Pointer to the attributes of a VENC channel. CNcomment: pstAttr 指向编码通道属性的指针 CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+\retval ::HI_ERR_VENC_NULL_PTR The input pointer parameter is null. CNcomment: 输入指针参数为空指针 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_VENC_GetDefaultAttr(HI_UNF_VENC_CHN_ATTR_S *pstAttr);
+
+
+/** 
+\brief Creates a VENC channel. CNcomment: 创建视频编码通道 CNend
+\attention \n
+You must create a VENC channel before video encoding. 
+CNcomment: 进行视频编码要求首先创建编码通道 CNend
+\param[in] pstAttr Pointer to the attributes of a VENC channel. CNcomment: pstAttr 指向编码通道属性的指针 CNend
+\param[out] phVenc Pointer to the handle of a VENC channel. CNcomment: phVenc 指向编码通道句柄的指针 CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功  CNend
+\retval ::HI_ERR_VENC_NULL_PTR The input pointer parameter is null. CNcomment: 输入指针参数有空指针 CNend
+\retval ::HI_ERR_VENC_CREATE_ERR The number of VENC channels exceeds the limit. CNcomment: 编码通道数已满 CNend
+\retval ::HI_ERR_VENC_INVALID_PARA The channel attributes are incorrect. CNcomment: 通道属性设置错误 CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment: 编码器未初始化 CNend
+\see \n
+N/A
+CNcomment: 无  CNend
+*/
+HI_S32 HI_UNF_VENC_Create(HI_HANDLE *phVenc,const HI_UNF_VENC_CHN_ATTR_S *pstAttr);
+
+
+/** 
+\brief Destroys a VENC channel. CNcomment: 销毁视频编码通道 CNend
+\attention \n
+\param[in] hVenc Handle of a VENC channel. CNcomment: CNcomment: hVenc 编码通道句柄 CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No handle exists. CNcomment: 句柄不存在 CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment: 编码器未初始化 CNend
+\see \n
+N/A CNcomment: 无  CNend
+*/
+HI_S32 HI_UNF_VENC_Destroy(HI_HANDLE hVenc);
+
+
+/** 
+\brief Attaches a VENC channel to the video source. CNcomment: 绑定编码通道到视频源 CNend
+\attention \n
+You must call this API before performing encoding and obtaining streams. CNcomment: 开始编码和获取码流之前需要首先调用该接口 CNend
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc 编码通道句柄 CNend
+\param[in] hSrc Data source handle CNcomment: hSrc 视频源句柄 CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment: 编码通道句柄不存在 CNend
+\retval ::HI_ERR_VENC_INVALID_PARA The video source is invalid. CNcomment: 视频源错误  CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment: 编码器未初始化 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_VENC_AttachInput(HI_HANDLE hVenc,HI_HANDLE hSrc);
+
+
+/** 
+\brief Detaches a VENC channel from the video source. CNcomment: 解绑定视频源 CNend
+\attention \n
+You must stop encoding before calling this API.
+CNcomment: 调用该接口需要首先停止编码 CNend
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc 编码通道句柄 CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功  CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment: 编码通道句柄不存在 CNend
+\retval ::HI_ERR_VENC_INVALID_PARA The video source is invalid. CNcomment: 视频源错误 CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment: 编码器未初始化 CNend
+\retval ::HI_ERR_VENC_CHN_INVALID_STAT Invalid state which the video encoder does not stop encoding. CNcomment: 异常状态,编码器未停止编码 CNend
+\retval ::HI_ERR_VENC_CHN_NO_ATTACH The VENC channel doesn't attach any source. CNcomment: 编码通道没有绑定任何源 CNend
+\see \n
+N/A CNcomment: 无  CNend
+*/
+HI_S32 HI_UNF_VENC_DetachInput(HI_HANDLE hVencChn);
+
+
+/** 
+\brief Starts to perform encoding. CNcomment: 开始编码 CNend
+\attention \n
+You must initialize the video encoder, create a VENC channel, and attach the channel to the video source before calling this API.
+CNcomment: 调用该接口需要首先初始化编码器，创建编码通道，绑定视频源 CNend
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc 编码通道句柄 CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment: 编码通道句柄不存在 CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment: 编码器未初始化 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_VENC_Start(HI_HANDLE hVenc);
+
+
+/** 
+\brief Stops encoding. CNcomment: 停止编码 CNend
+\attention \n
+You must initialize the video encoder, create a VENC channel, attach the channel to the video source, and start to perform encoding before calling this API.
+CNcomment: 调用该接口需要首先初始化编码器，创建编码通道，绑定视频源，已经开始编码 CNend
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc 编码通道句柄 CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment: 编码通道句柄不存在 CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment: 编码器未初始化 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_VENC_Stop(HI_HANDLE hVenc);
+
+/** 
+\brief Obtains VENC streams. CNcomment: 获取视频编码码流 CNend
+\attention \n
+You must attach a VENC channel to the video source and start to perform encoding before calling this API.
+The block time (in ms) is configurable. If u32TimeOutMs is set to 0, the block time is 0; if u32TimeOutMs is set to 0xFFFFFFFF, it indicates infinite wait. \n
+If the block time is reached but no data is received, ::HI_ERR_VENC_BUF_EMPTY is returned.\n
+If the wait time is 0 and there is no data, ::HI_ERR_VENC_BUF_EMPTY is returned.
+CNcomment: 调用该接口需要首先绑定视频源，开始编码
+阻塞时间可以设置，时间单位为毫秒，设置为0不等待，设置为0xffffffff一直等待。\n
+若超过阻塞时间，还没有数据到达，则返回::HI_ERR_VENC_BUF_EMPTY\n
+如果等待时间为0，且没有码流数据，则返回::HI_ERR_VENC_BUF_EMPTY\n CNend
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc 编码通道句柄 CNend
+\param[out] pstStream Pointer to the structure for storing streams CNcomment: pstStream 存放码流结构的指针 CNend
+\param[in] u32TimeoutMs: Wait timeout, count in ms CNcomment: u32TimeoutMs：等待超时时间，单位ms CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment: 编码通道句柄不存在 CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment: 编码器未初始化 CNend
+\retval ::HI_ERR_VENC_NULL_PTR The stream pointer is null. CNcomment: 码流指针为空 CNend
+\retval ::HI_ERR_VENC_BUF_EMPTY Streams fail to be obtained. CNcomment: 获取码流失败 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_VENC_AcquireStream(HI_HANDLE hVenc,HI_UNF_VENC_STREAM_S *pstStream, HI_U32 u32TimeoutMs);
+
+
+/** 
+\brief Releases VENC streams. CNcomment: 释放视频编码码流 CNend
+\attention \n
+You must obtain streams and keep the streams unchanged before calling this API.
+The stream which you get first should be release first.
+CNcomment: 调用该接口需要首先获取码流，且不能改变码流内容。
+先获取的码流需要先释放。 CNend
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc 编码通道句柄 CNend
+\param[in] pstStream Pointer to the structure for storing streams CNcomment: pstStream 存放码流结构的指针 CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment: 编码通道句柄不存在 CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment: 编码器未初始化 CNend
+\retval ::HI_ERR_VENC_NULL_PTR The stream pointer is null. CNcomment: 码流指针为空 CNend
+\retval ::HI_ERR_VENC_CHN_RELEASE_ERR Streams fail to be released. CNcomment: 释放码流失败 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_VENC_ReleaseStream(HI_HANDLE hVenc, const HI_UNF_VENC_STREAM_S *pstStream);
+
+
+/** 
+\brief Sets the encoding channel attributes dynamically. CNcomment: 动态设置编码通道属性 CNend
+\attention \n
+You must create a VENC channel before calling this API.
+This API just can change these attributes as follows:input framerate,target output framerate,target output bitrate,gop,
+max/min QP,channel priority, whether use QuickEncode mode and even the encode width and height within the limits of the encoder level.
+Moreover,even though you can't change the attributes of encoder level,encoder type,Stream buffer size,Rotation angle,Slice split enable and so on,
+you should still assign the real value to them at that time.
+It's better that you should call HI_UNF_VENC_GetAttr() to obtain the attributes of a VENC channel before calling this API.
+CNcomment: 调用该接口需要首先创建编码通道 .该接接口只能动态的设置以下通道属性:输入帧率，目标输出帧率，目标输出码率，GOP值，最大/最小量化参数，
+通道优先级， 快速编码使能，甚至在编码能力级范围下动态改变编码宽高。此外，即使该接口不能动态改变编码能力级，编码协议，码流buffer大小，
+旋转角度，分割编码使能等属性，在调用该接口时你还是要给这些通道属性赋上当时的实际值。最好在调用该接口之前调用HI_UNF_VENC_GetAttr()接口获取到当时的通道属性 CNend
+\param[in] Venc Handle of a VENC channel CNcomment: hVenc 编码通道句柄 CNend
+\param[in] pstAttr Pointer to the attributes of a VENC channel CNcomment: pstAttr 存放编码通道属性的指针 CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment: 编码通道句柄不存在 CNend
+\retval ::HI_ERR_VENC_INVALID_PARA The channel attributes are incorrect. CNcomment: 通道属性设置错误 CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment: 编码器未初始化 CNend
+\retval ::HI_ERR_VENC_NULL_PTR The pointer is null. CNcomment: 指针为空 CNend
+\retval ::HI_ERR_VENC_NOT_SUPPORT This change of attributes dosen't be supported. CNcomment: 不支持该属性动态配置 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_VENC_SetAttr(HI_HANDLE hVenc,const HI_UNF_VENC_CHN_ATTR_S *pstAttr);
+
+
+/** 
+\brief Obtains the attributes of a VENC channel. CNcomment: 获取编码通道属性 CNend
+\attention \n
+You must create a VENC channel before calling this API.
+CNcomment: 调用该接口需要首先创建编码通道 CNend
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc 编码通道句柄 CNend
+\param[out] pstAttr Encoding channel attribute CNcomment: pstAttr 编码通道属性 CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment: 编码通道句柄不存在 CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment: 编码器未初始化 CNend
+\retval ::HI_ERR_VENC_NULL_PTR The pointer is null. CNcomment: 指针为空 CNend
+\see \n 
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_VENC_GetAttr(HI_HANDLE hVenc, HI_UNF_VENC_CHN_ATTR_S *pstAttr);
+
+
+/** 
+\brief Applies for I frames. CNcomment: 请求I帧 CNend
+\attention \n
+The video encoder encodes an I frame as soon as possible after you call this API.\n
+You can call this API when you set up a video call or fix errors.\n
+If you call this API repeatedly in a short period, I frames may be not generated each time.\n
+CNcomment: 调用该接口后，编码器会尽快编码出一个I帧来.\n
+此接口一般用于可视电话场景的通话建立和错误恢复.\n
+此接口只是"尽最大能力"尽快编码出一个I帧来，如果在短时间内多次调用此接口，那么不能保证每次调用都能对应编码出一个I帧来.\n CNend
+\param[in] hVencChn Handle of a VENC channel CNcomment: hVencChn 编码通道句柄 CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment: 编码通道句柄不存在 CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment: 编码器未初始化 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_VENC_RequestIFrame(HI_HANDLE hVencChn);
+
+
+/** 
+\brief Input frame to VENC. CNcomment: 向编码器送帧 CNend
+\attention \n
+You must create a VENC channel before calling this API.
+If the venc channel has already attach the source,::HI_ERR_VENC_CHN_INVALID_STAT is returned.
+This API should be matched with the API: HI_UNF_VENC_DequeueFrame.
+HI_UNF_VENC_QueueFrame is used to send frame data to Encoder for user and HI_UNF_VENC_DequeueFrame is used to call the Encoder 
+to receive the frame data which has already be processed.
+CNcomment: 调用该接口需要首先创建编码通道.
+如果编码通道已经绑定源，会返回HI_ERR_VENC_CHN_INVALID_STAT 无效操作 
+该接口需要与 HI_UNF_VENC_DequeueFrame 接口配对使用。
+HI_UNF_VENC_QueueFrame接口用于为用户提供一个接口向编码器送帧供编码，HI_UNF_VENC_DequeueFrame接口是编码器归还已经处理的帧 CNend
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc 编码通道句柄 CNend
+\param[in] pstFrameinfo Frame information struct CNcomment: 帧信息属性 CNend
+\retval ::HI_SUCCESS                      Success CNcomment: 成功 CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST       No VENC channel handle exists. CNcomment: 编码通道句柄不存在 CNend
+\retval ::HI_ERR_VENC_NULL_PTR            The pointer is null. CNcomment: 指针为空 CNend
+\retval ::HI_ERR_VENC_NO_INIT             The video encoder is not initialized. CNcomment: 编码器未初始化 CNend
+\retval ::HI_ERR_VENC_CHN_INVALID_STAT    Invalid state which the VENC channel has already attach source. CNcomment: 异常状态，编码器通道已经绑定源 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_VENC_QueueFrame(HI_HANDLE hVenc, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo);
+
+
+/** 
+\brief release frame from VENC. CNcomment: 向编码器还帧 CNend
+\attention \n
+You must create a VENC channel before calling this API.
+If the venc channel has already attach the source,::HI_ERR_VENC_CHN_INVALID_STAT is returned.
+Refer to the attention of the API: HI_UNF_VENC_QueueFrame.
+If HI_UNF_VENC_DequeueFrame return HI_SUCCESS, it means the corresponding frame buffer could be set free by user. 
+CNcomment: 调用该接口需要首先创建编码通道.
+如果编码通道已经绑定源，会返回HI_ERR_VENC_CHN_INVALID_STAT 无效操作 
+注意事项参照 HI_UNF_VENC_QueueFrame接口。如果HI_UNF_VENC_DequeueFrame接口返回成功，意味着对应的帧存用户可以释放 CNend
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc 编码通道句柄 CNend
+\param[out] pstFrameinfo Frame information struct CNcomment: 帧信息属性 CNend
+\retval ::HI_SUCCESS                       Success CNcomment: 成功 CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST        No VENC channel handle exists. CNcomment: 编码通道句柄不存在 CNend
+\retval ::HI_ERR_VENC_NULL_PTR             The pointer is null. CNcomment: 指针为空 CNend
+\retval ::HI_ERR_VENC_NO_INIT              The video encoder is not initialized. CNcomment: 编码器未初始化 CNend
+\retval ::HI_ERR_VENC_CHN_INVALID_STAT     Invalid state which the VENC channel has already attach source. CNcomment: 异常状态，编码器通道已经绑定源 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_VENC_DequeueFrame(HI_HANDLE hVenc, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo);
+
+/**
+\brief get encoding capbility from VENC. CNcomment: 获取编码器的编码能力 CNend
+\attention \n
+\param[in] N/A CNcomment: 无 CNend
+\param[out] pstCapability Pointer to the capability of VENC CNcomment: pstCapability 存放编码能力信息的指针 CNend
+\retval ::HI_SUCCESS               Success CNcomment: 成功 CNend
+\retval ::HI_ERR_VENC_NULL_PTR     The pointer is null. CNcomment: 指针为空 CNend
+\retval ::HI_FAILURE               Capability fail to be obtained. CNcomment: 获取编码能力信息失败 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_VENC_GetCapability(HI_UNF_VENC_CAP_S *pstCapability);
+
+/**
+\brief set encoding rate control type of VENC. CNcomment: 设置编码器的码率控制类型 CNend
+\attention \n
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc 编码通道句柄 CNend
+\param[in] enRcType Enum of rate control mode CNcomment: enRcType 描述编码码率控制类型的枚举 CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment: 编码通道句柄不存在 CNend
+\retval ::HI_ERR_VENC_INVALID_PARA The channel attributes are incorrect. CNcomment: 通道属性设置错误 CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment: 编码器未初始化 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_VENC_SetRateControlType(HI_HANDLE hVenc, HI_UNF_VENC_RATECONTROL_TYPE_E enRcType);
+
+
+/**
+\brief get encoding rate control type of VENC. CNcomment: 获取编码器的码率控制类型 CNend
+\attention \n
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc 编码通道句柄 CNend
+\param[in] penRcType Enum of rate control mode CNcomment: enRcType 描述编码码率控制类型的枚举的指针 CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment: 编码通道句柄不存在 CNend
+\retval ::HI_ERR_VENC_INVALID_PARA The channel attributes are incorrect. CNcomment: 通道属性设置错误 CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment: 编码器未初始化 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_VENC_GetRateControlType(HI_HANDLE hVenc, HI_UNF_VENC_RATECONTROL_TYPE_E *penRcType);
+
+/**
+\brief set input frame rate source type of VENC. CNcomment: 设置编码器的输入帧率来源类型 CNend
+\attention \n
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc 编码通道句柄 CNend
+\param[in] enInputFrmRateType Enum of input frame rate mode CNcomment: enInputFrmRateType 描述输入帧率来源类型的枚举 CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment: 编码通道句柄不存在 CNend
+\retval ::HI_ERR_VENC_INVALID_PARA The channel attributes are incorrect. CNcomment: 通道属性设置错误 CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment: 编码器未初始化 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_VENC_SetInputFrmRateType(HI_HANDLE hVenc, HI_UNF_VENC_FRMRATE_TYPE_E enInputFrmRateType);
+
+/**
+\brief get input frame rate source type of VENC. CNcomment: 获取编码器的输入帧率来源类型 CNend
+\attention \n
+\param[in] hVenc Handle of a VENC channel CNcomment: hVenc 编码通道句柄 CNend
+\param[in] penInputFrmRateType Enum of input frame rate control mode CNcomment: enRcType 描述编码输入帧率来源类型的枚举的指针 CNend
+\retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+\retval ::HI_ERR_VENC_CHN_NOT_EXIST No VENC channel handle exists. CNcomment: 编码通道句柄不存在 CNend
+\retval ::HI_ERR_VENC_INVALID_PARA The channel attributes are incorrect. CNcomment: 通道属性设置错误 CNend
+\retval ::HI_ERR_VENC_NO_INIT The video encoder is not initialized. CNcomment: 编码器未初始化 CNend
+\see \n
+N/A CNcomment: 无 CNend
+*/
+HI_S32 HI_UNF_VENC_GetInputFrmRateType(HI_HANDLE hVenc, HI_UNF_VENC_FRMRATE_TYPE_E *penInputFrmRateType);
+
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif
+
+#endif//__HI_UNF_VENC_H__
+
diff -uNr a/include/hi_unf_version.h b/include/hi_unf_version.h
--- a/include/hi_unf_version.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_version.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,52 @@
+/******************************************************************************
+ Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+******************************************************************************
+File Name     : hi_unf_version.h
+Version       : Initial Draft
+Author        : Hisilicon multimedia software group
+Created       : 2012/12/23
+Last Modified :
+Description   : this file defines the UNF version code.
+Function List :
+History       :
+******************************************************************************/
+#ifndef __HI_UNF_VERSION_H__
+#define __HI_UNF_VERSION_H__
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+/*--------------------------------------------------------------------------------------------------------------*
+ * Defintion of UNF version code.                                                                               *
+ * CNcomment: 定义UNF接口的版本号 CNend                                                                         *
+ *--------------------------------------------------------------------------------------------------------------*/
+/********************************Struct Definition********************************/
+/** \addtogroup      UNF_VERSION */
+/** @{ */  /** <!-- [UNF_VERSION] */
+
+
+#ifndef UNF_VERSION
+#define UNF_VERSION(major, minor)   (((major) << 8) | (minor))
+#endif
+
+#ifndef UNF_VERSION_CODE
+#define UNF_VERSION_CODE        UNF_VERSION(3, 4)
+#define UNF_SUBVERSION_CODE     0
+#define UNF_PRODUCT_CODE        1
+#endif
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_UNF_VERSION_H__ */
+
diff -uNr a/include/hi_unf_vi.h b/include/hi_unf_vi.h
--- a/include/hi_unf_vi.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_vi.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,351 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_vi.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2010/03/26
+  Description   :
+  History       :
+  1.Date        : 2010/03/26
+    Author      : sdk
+    Modification: Created file
+
+ *******************************************************************************/
+
+/**
+ * \file
+ * \brief Describes the information about video input (VI). CNcomment: 提供VI的相关信息 CNend
+ */
+
+#ifndef  __HI_UNF_VI_H__
+#define  __HI_UNF_VI_H__
+
+#include "hi_type.h"
+#include "hi_unf_common.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif
+
+/********************************Macro Definition********************************/
+/** \addtogroup      VI */
+/** @{ */  /** <!-- 【VI】 */
+/**Maximum external buffer number*/
+/**CNcomment: VI管理外部缓冲区最大个数*/
+#define MAX_VI_EXT_BUF_NUM (16)
+
+/** @} */  /** <!-- ==== Macro Definition end ==== */
+
+/********************************Struct Definition********************************/
+/** \addtogroup      VI */
+/** @{ */  /** <!-- 【VI】 */
+
+/**Input port */
+/**CNcomment: 输入端口 */
+typedef enum hiUNF_VI_E
+{
+    HI_UNF_VI_PORT0 = 0,      /**<Port 0 *//**<CNcomment: 端口0*/
+    HI_UNF_VI_PORT1,          /**<Port 1 *//**<CNcomment: 端口1*/
+    HI_UNF_VI_BUTT
+} HI_UNF_VI_E;
+
+/**Input interface mode */
+/**CNcomment: 输入接口模式 */
+typedef enum hiUNF_VI_INPUT_MODE_E
+{
+    HI_UNF_VI_MODE_BT656_576I = 0,  /**<ITU-R BT.656 YUV4:2:2 standard, 576I *//**<CNcomment: ITU-R BT.656 YUV4:2:2 标准，576I */
+    HI_UNF_VI_MODE_BT656_480I,      /**<ITU-R BT.656 YUV4:2:2 standard, 480I *//**<CNcomment: ITU-R BT.656 YUV4:2:2 标准，480I */
+    HI_UNF_VI_MODE_BT601_576I,      /**<ITU-R BT.601 YUV4:2:2 standard, 576I *//**<CNcomment: ITU-R BT.601 YUV4:2:2 标准 */
+    HI_UNF_VI_MODE_BT601_480I,      /**<ITU-R BT.601 YUV4:2:2 standard, 480I *//**<CNcomment: ITU-R BT.601 YUV4:2:2 标准 */
+    HI_UNF_VI_MODE_BT1120_640X480P, /**<ITU-R BT.1120 YUV4:2:2 standard, 480P *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 标准，640x480P */
+    HI_UNF_VI_MODE_BT1120_480P,     /**<ITU-R BT.1120 YUV4:2:2 standard, 480P *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 标准，720x480P */
+    HI_UNF_VI_MODE_BT1120_576P,     /**<ITU-R BT.1120 YUV4:2:2 standard, 576P *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 标准，720x576P */
+    HI_UNF_VI_MODE_BT1120_720P_50,  /**<ITU-R BT.1120 YUV4:2:2 standard, 720P_50 *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 标准，720P_50 */
+    HI_UNF_VI_MODE_BT1120_720P_60,  /**<ITU-R BT.1120 YUV4:2:2 standard, 720P_60 *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 标准，720P_60 */
+    HI_UNF_VI_MODE_BT1120_1080I_50, /**<ITU-R BT.1120 YUV4:2:2 standard, 1080I_50 *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 标准，1080I_50 */
+    HI_UNF_VI_MODE_BT1120_1080I_60, /**<ITU-R BT.1120 YUV4:2:2 standard, 1080I_60 *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 标准，1080I_60 */
+    HI_UNF_VI_MODE_BT1120_1080P_25, /**<ITU-R BT.1120 YUV4:2:2 standard, 1080P *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 标准，1080P_25 */
+    HI_UNF_VI_MODE_BT1120_1080P_30, /**<ITU-R BT.1120 YUV4:2:2 standard, 1080P *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 标准，1080P_30 */
+    HI_UNF_VI_MODE_BT1120_1080P_50, /**<ITU-R BT.1120 YUV4:2:2 standard, 1080P *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 标准，1080P_50 */
+    HI_UNF_VI_MODE_BT1120_1080P_60, /**<ITU-R BT.1120 YUV4:2:2 standard, 1080P *//**<CNcomment: ITU-R BT.1120 YUV4:2:2 标准，1080P_60 */
+    HI_UNF_VI_MODE_DIGITAL_CAMERA_480P_30,    /**<Digital camera. The data format can be RGB or YCbCr,480P_30*//**<CNcomment:数字摄像头，数据可能是RGB或者YCbCr，480P_30 */
+    HI_UNF_VI_MODE_DIGITAL_CAMERA_576P_30,    /**<Digital camera. The data format can be RGB or YCbCr,576P_30 *//**<CNcomment:数字摄像头，数据可能是RGB或者YCbCr，576P_30*/
+    HI_UNF_VI_MODE_DIGITAL_CAMERA_720P_30,    /**<Digital camera. The data format can be RGB or YCbCr,720P_30 *//**<CNcomment:数字摄像头，数据可能是RGB或者YCbCr，720P_30 */
+    HI_UNF_VI_MODE_DIGITAL_CAMERA_1080P_30,   /**<Digital camera. The data format can be RGB or YCbCr,1080P_30 *//**<CNcomment:数字摄像头，数据可能是RGB或者YCbCr ，1080P_30*/
+    HI_UNF_VI_MODE_HDMIRX,              /**HDMI INPUT *//**<CNcomment: ITU-R YUV4:4:4 标准 逐行信号*/
+    HI_UNF_VI_MODE_BUTT
+} HI_UNF_VI_INPUT_MODE_E;
+
+/**VI frame buffer management mode */
+/**CNcomment: VI帧缓存管理方式 */
+typedef enum hiUNF_VI_BUF_MGMT_E
+{
+    HI_UNF_VI_BUF_ALLOC = 0,  /**<VI alloc buffer *//**<CNcomment: VI申请帧BUF */
+    HI_UNF_VI_BUF_MMAP,       /**<User alloc frame buffer, then maps it to VI *//**<CNcomment: 用户申请帧BUF，并映射给VI */
+    HI_UNF_VI_BUF_BUTT
+} HI_UNF_VI_BUF_MGMT_E;
+
+/**VI frame buffer struct */
+/**CNcomment: VI帧缓存结构体 */
+typedef struct hiUNF_VI_BUFF_ATTR_S
+{
+    HI_VOID *pUsrVirAddr[MAX_VI_EXT_BUF_NUM];  /**<User virtual address *//**<CNcomment: 用户态虚拟地址*/
+    HI_U32 u32PhyAddr[MAX_VI_EXT_BUF_NUM];     /**<Physical address *//**<CNcomment: 物理地址*/
+    HI_U32 u32BufNum;                          /**<Buffer number *//**<CNcomment: 缓冲区个数*/
+    HI_U32 u32Stride;                          /**<Stride of external frame buffer *//**<CNcomment:外部帧存的stride*/
+} HI_UNF_VI_BUFFER_ATTR_S;
+
+
+/**Vvideo 3D to 2D transfer mode */
+/**CNcomment: 3D播放模式 */
+typedef enum hiUNF_VI_3DT2D_MODE_E
+{
+    HI_UNF_VI_3DT2D_OFF = 0,        /**< Keep normal left and right eye 3D format *//**<CNcomment: 保留3D格式的左右眼正常播放图像 */
+    HI_UNF_VI_3DT2D_L,              /**< Keep normal left eye 3D format*//**<CNcomment: 保留3D格式的左眼图像 */
+    HI_UNF_VI_3DT2D_R,              /**< Keep normal right eye 3D format*//**<CNcomment: 保留3D格式的右眼图像 */
+
+    HI_UNF_VI_3DT2D_BUTT,
+} HI_UNF_VI_3DT2D_MODE_E;
+
+
+/**VI attributes */
+/**CNcomment: VI属性 */
+typedef struct hiUNF_VI_ATTR_S
+{
+    HI_BOOL                           bVirtual;             /**<Whether to create virtual VI, only u32BufNum is valid in virtual VI mode *//**<CNcomment: 是否创建虚拟VI，虚拟VI下只有u32BufNum参数有效*/
+    HI_UNF_VI_INPUT_MODE_E            enInputMode;          /**<Video input mode *//**<CNcomment: 视频输入模式 */
+    HI_RECT_S                         stInputRect;          /**<Crop region of a window *//**<CNcomment: 窗口的裁减区域 */
+    HI_UNF_VIDEO_FORMAT_E             enVideoFormat;        /**<Output Video format *//**<CNcomment: 视频格式 */
+    HI_UNF_VI_BUF_MGMT_E              enBufMgmtMode;        /**<VI frame buffer management mode *//**<CNcomment: VI帧缓存管理方式 */
+    HI_U32                            u32BufNum;            /**<Number of available buffers *//**<CNcomment: 可用的帧buf的个数 */
+
+    HI_BOOL                           bInterlace;           /**<Intput video interlace or progressive *//**<CNcomment: 逐行隔行信息 */
+    HI_U32                            u32Width;             /**<Intput video width *//**<CNcomment: 源图像一帧的宽度,3D格式为单眼宽高 */
+    HI_U32                            u32Height;            /**<Intput video height *//**<CNcomment: 源图像一帧的高度，即隔行信号是两场的高度，逐行信号是一帧的高度，3D格式为单眼宽高 */
+    HI_U32                            u32Vblank;	        /**<Intput video field blanking width, used 3d FB*//**<CNcomment: 场消隐区宽度，用于处理3D格式FP */
+    HI_U32                            u32FrameRate;         /**<Intput video intput frequency *//**<CNcomment: 输入帧率 [24Hz,85] */
+    HI_UNF_VIDEO_FRAME_PACKING_TYPE_E en3dFmt;              /**<Intput video format 2D or3D *//**<CNcomment: 2D/3D 格式 */
+    HI_UNF_VIDEO_FORMAT_E             enPixFmt;             /**<Intput pixel format *//**<CNcomment: 输入像素格式 RGB444,YUV444/422 */
+    HI_UNF_PIXEL_BITWIDTH_E           enSrcBitWidth;        /**<Intput pixel Width *//**<CNcomment: 输入位宽 8/10/12BIT */
+    HI_UNF_OVERSAMPLE_MODE_E          enOverSample;         /**<Intput Over Sample format *//**<CNcomment: 过采样模式 */
+    HI_UNF_COLOR_SPACE_E              enColorSpace;         /**<Intput Color Space *//**<CNcomment: 色彩空间 */
+    HI_UNF_VI_3DT2D_MODE_E            enDst3DT2DMode;       /**<video 3D to 2D mode *//**<CNcomment: 静态,3D播放模式，由绑定模块(VENC/VDP)确定 */
+    HI_UNF_PIXEL_BITWIDTH_E           enDstBitWidth;        /**<output pixel Width *//**<CNcomment: 静态,输入为输入位宽为8bit则8bit输出，大于8bit则10bit输出；或则由绑定模块确认输出帧率 */
+} HI_UNF_VI_ATTR_S;
+/** @} */  /** <!-- ==== Struct Definition End ==== */
+
+/********************************API Declaration********************************/
+/** \addtogroup      VI */
+/** @{ */  /** <!-- 【VI】 */
+
+/**
+ \brief Initializes the video input unit (VIU). CNcomment: 初始化VI CNend
+ \attention \n
+Before calling the VIU, you must call this application programming interface (API).
+CNcomment: 调用VI模块要求首先调用该接口 CNend
+ \param[in] N/A CNcomment: 无 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \retval ::HI_ERR_VI_DEV_NOT_EXIST No VI device exists. CNcomment: 设备不存在 CNend
+ \retval ::HI_ERR_VI_NOT_DEV_FILE The file is not a VI file. CNcomment: 文件非设备 CNend
+ \retval ::HI_ERR_VI_DEV_OPENED The VI device fails to be started. CNcomment: 打开设备失败 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_VI_Init(HI_VOID);
+
+/**
+ \brief Deinitializes the VIU. CNcomment: 去初始化VI CNend
+ \attention \n
+ \param[in] N/A CNcomment: 无 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_VI_DeInit(HI_VOID);
+
+/**
+ \brief Obtains the attributes of a VI port. CNcomment: 获取VI端口默认属性 CNend
+ \attention \n
+By default, port 0 is used, half D1 and BT656 formats are used, the data of the odd field is collected, and the semi-planar YUV4:2:0 data is output.
+CNcomment: 默认Port=0, HALF-D1, BT656，采集偶场，输出SemiPlanner YUV4:2:0格式数据 CNend
+ \param[out] pstAttr Pointer to VI attributes CNcomment: VI属性指针 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \retval ::HI_ERR_VI_NULL_PTR The pointer is null. CNcomment: 空指针 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_VI_GetDefaultAttr(HI_UNF_VI_ATTR_S *pstAttr);
+
+/**
+ \brief Set the attributes of a VI port. CNcomment: 设置VI Port属性 CNend
+ \attention \n
+This reserved API is combined with HI_UNF_VI_Create, and cannot be called dynamically.
+CNcomment: 预留接口，与Create合一，不可动态调用 CNend
+ \param[in] hVi VI handle CNcomment: VI句柄 CNend
+ \param[in] pstAttr  Pointer to VI attributes CNcomment: VI属性指针 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \retval ::HI_ERR_VI_NULL_PTR The pointer is null. CNcomment: 空指针 CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment: 句柄错误 CNend
+ \retval ::HI_ERR_VI_CHN_INIT_BUF_ERR An error occurs when the buffer is initialized. CNcomment: 初始化buffer错误 CNend
+ \retval ::HI_ERR_VI_INVALID_PARA The attribute parameters are incorrect. CNcomment: 属性参数错误 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_VI_SetAttr(HI_HANDLE hVI, HI_UNF_VI_ATTR_S *pstAttr);
+
+/**
+ \brief Obtains the attributes of a VI port. CNcomment: 获取VI Port属性 CNend
+ \attention \n
+ \param[in] hVi VI handle CNcomment: VI句柄 CNend
+ \param[out] pstAttr Pointer to VI attributes CNcomment: VI属性指针 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \retval ::HI_ERR_VI_NULL_PTR The pointer is null. CNcomment: 空指针 CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment: 句柄错误 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_VI_GetAttr(HI_HANDLE hVI, HI_UNF_VI_ATTR_S *pstAttr);
+
+/**
+ \brief Enables a VI port to create a VI handle. CNcomment: 打开VI Port，创建Vi句柄 CNend
+ \attention \n
+Before calling the VIU, you must call this API.\n
+Unless the virtual VI is used, the port ID must correspond to the hardware. That is, the hardware and software must use the same port\n
+CNcomment: 调用VI 模块需要首先调用该接口\n
+           除非使用虚拟VI, 否则PortID需要与硬件对应,硬件上使用了哪个Port,那么软件也必须使用哪个Port.\n CNend
+ \param[in] enViPort VI port CNcomment: VI端口 CNend
+ \param[in] pstAttr Pointer to VI attributes CNcomment: VI属性指针 CNend
+ \param[out] phandle hVi Pointer to the VI handle CNcomment: VI句柄指针 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \retval ::HI_ERR_VI_NULL_PTR The pointer is null. CNcomment: 空指针 CNend
+ \retval ::HI_ERR_VI_CHN_INIT_BUF_ERR An error occurs when the buffer is initialized. CNcomment: 初始化buffer错误 CNend
+ \retval ::HI_ERR_VI_INVALID_PARA The attribute parameters are incorrect. CNcomment: 属性参数错误 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+
+HI_S32 HI_UNF_VI_Create(HI_UNF_VI_E enViPort, HI_UNF_VI_ATTR_S *pstAttr, HI_HANDLE *phandle);
+
+/**
+ \brief Disable a VI port to destroy the handle. CNcomment: 关闭VI Port，销毁句柄 CNend
+ \attention \n
+ \param[in] hVi VI handle CNcomment: VI句柄 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment: 句柄错误 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_VI_Destroy(HI_HANDLE hVI);
+
+/**
+ \brief Start VI. CNcomment: 启动VI，销毁句柄 CNend
+ \attention \n
+ \param[in] hVI VI handle CNcomment: VI句柄 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment: 句柄错误 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_VI_Start(HI_HANDLE hVI);
+
+/**
+ \brief Stop VI. CNcomment: 停止VI，销毁句柄 CNend
+ \attention \n
+ \param[in] hVI VI handle CNcomment: VI句柄 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment: 句柄错误 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_VI_Stop(HI_HANDLE hVI);
+
+/**
+ \brief Set external buffer which will be managed by VI. CNcomment: 设置外部缓冲区，由VI管理 CNend
+ \attention \n
+ The interface is only valid in real VI scene, and ::HI_UNF_VI_BUF_MMAP mode should be set.
+ CNcomment: 用户只能在实体VI场景下，设置为::HI_UNF_VI_BUF_MMAP模式时，才能使用此接口\n CNend
+ \param[in] hVI VI handle CNcomment: VI句柄 CNend
+ \param[in] pstBufAttr Buffer attributes CNcomment: 缓冲区属性 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment: 句柄错误 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_VI_SetExternBuffer(HI_HANDLE hVI, HI_UNF_VI_BUFFER_ATTR_S* pstBufAttr);
+
+/**
+ \brief Obtains the address of a frame buffer over a VI port.
+ CNcomment:获取虚拟VI Port 一帧图像Buffer CNend
+ \attention \n
+ The interface can only be used in virual VI scene\n
+CNcomment: 只有在虚拟VI场景下，才可使用此接口还帧\n CNend
+ \param[in] hVI VI handle CNcomment: VI句柄 CNend
+ \param[out] pViBuf Pointer to the VI buffer CNcomment: VI buffer指针 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment: 句柄错误 CNend
+ \retval ::HI_ERR_VI_NULL_PTR The pointer is null. CNcomment: 空指针 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_VI_DequeueFrame(HI_HANDLE hVI, HI_UNF_VIDEO_FRAME_INFO_S *pFrameInfo);
+
+/**
+ \brief Releases the VI frame buffer for the driver.
+ CNcomment: 发送虚拟VI Port 一帧图像Buffer，驱动虚拟Port工作 CNend
+ \attention
+ The interface can only be used in virual VI scene\n
+CNcomment: 只有在虚拟VI场景下，才可使用此接口送帧\n CNend
+ \param[in] hVI VI handle CNcomment: VI句柄 CNend
+ \param[in] pViBuf Pointer to the VI buffer CNcomment: VI buffer指针 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment: 句柄错误 CNend
+ \retval ::HI_ERR_VI_NULL_PTR The pointer is null. CNcomment: 空指针 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_VI_QueueFrame(HI_HANDLE hVI, HI_UNF_VIDEO_FRAME_INFO_S *pFrameInfo);
+
+/**
+ \brief Obtains the address of a YUV picture. CNcomment: 获取一帧YUV 图像地址 CNend
+ \attention \n
+You do not need to call this API generally. It is recommended that you bind the VIU to the video encoder (VENC) or video output unit (VOU) to implement the encoding function or VIVO loopback function.
+CNcomment: 一般情况下，用户不需要调用此接口，推荐直接将VI与VENC或者VO进行绑定以便实现编码或者VIVO环回功能。 CNend
+ \param[in] hVi VI handle CNcomment: VI句柄 CNend
+ \param[out] pViBuf Pointer to the VI buffer CNcomment: VI buffer指针 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment: 句柄错误 CNend
+ \retval ::HI_ERR_VI_NULL_PTR The pointer is null. CNcomment: 空指针 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_VI_AcquireFrame(HI_HANDLE hVI, HI_UNF_VIDEO_FRAME_INFO_S *pFrameInfo, HI_U32 u32TimeoutMs);
+
+/**
+ \brief Releases the frame buffer for the VIU after the VENC or VOU obtains a YUV picture.
+CNcomment: 用户归还一帧YUV 图像地址 CNend
+ \attention \n
+You do not need to call this API generally. It is recommended that you bind the VIU to the VENC or VOU to implement the encoding function or VIVO loopback function.
+CNcomment: 一般情况下，用户不需要调用此接口，推荐直接将VI与VENC或者VO进行绑定以便实现编码或者VIVO环回功能。 CNend
+ \param[in] hVi VI handle CNcomment: VI句柄 CNend
+ \param[in] pViBuf Pointer to the VI buffer CNcomment: VI buffer指针 CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功 CNend
+ \retval ::HI_ERR_VI_CHN_NOT_EXIST The handle is incorrect. CNcomment: 句柄错误 CNend
+ \retval ::HI_ERR_VI_NULL_PTR The pointer is null. CNcomment: 空指针 CNend
+ \see \n
+N/A CNcomment: 无 CNend
+ */
+HI_S32 HI_UNF_VI_ReleaseFrame(HI_HANDLE hVI, const HI_UNF_VIDEO_FRAME_INFO_S *pFrameInfo);
+
+/** @} */  /** <!-- ====API Declaration End ==== */
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif
+#endif
diff -uNr a/include/hi_unf_video.h b/include/hi_unf_video.h
--- a/include/hi_unf_video.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_video.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,662 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_video.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/17
+  Description   :
+  History       :
+  1.Date        : 2009/12/17
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+
+#ifndef __HI_UNF_VIDEO_H__
+#define __HI_UNF_VIDEO_H__
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+#include "hi_common.h"
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      VIDEO */
+/** @{ */  /** <!-- [VIDEO] */
+
+/**Defines the oversample mode.*/
+/**CNcomment: 定义过采样模式*/
+typedef enum hiUNF_OVERSAMPLE_MODE_E
+{
+    HI_UNF_OVERSAMPLE_1X = 0,
+    HI_UNF_OVERSAMPLE_2X,
+    HI_UNF_OVERSAMPLE_4X,
+    HI_UNF_OVERSAMPLE_BUTT,
+} HI_UNF_OVERSAMPLE_MODE_E;
+
+/**Defines the pixel width.*/
+/**CNcomment: 定义像素位宽*/
+typedef enum hiUNF_PIXEL_BITWIDTH_E
+{
+    HI_UNF_PIXEL_BITWIDTH_8BIT = 0,
+    HI_UNF_PIXEL_BITWIDTH_10BIT,
+    HI_UNF_PIXEL_BITWIDTH_12BIT,
+    HI_UNF_PIXEL_BITWIDTH_BUTT,
+} HI_UNF_PIXEL_BITWIDTH_E;
+
+/**Defines color space enum*/
+/**CNcomment: 定义颜色空间枚举*/
+typedef enum hiUNF_COLOR_SPACE_E
+{
+    HI_UNF_COLOR_SPACE_UNKNOWN = 0,
+
+    HI_UNF_COLOR_SPACE_BT601_YUV_LIMITED = 0x10,/* ::::Current Used:::: BT.601  */
+    HI_UNF_COLOR_SPACE_BT601_YUV_FULL,
+    HI_UNF_COLOR_SPACE_BT601_RGB_LIMITED,
+    HI_UNF_COLOR_SPACE_BT601_RGB_FULL,
+
+    HI_UNF_COLOR_SPACE_NTSC1953 = 0x20,
+
+    /* These should be useful.  Assume 601 extents. */
+    HI_UNF_COLOR_SPACE_BT470_SYSTEM_M = 0x30,
+    HI_UNF_COLOR_SPACE_BT470_SYSTEM_BG,
+
+    HI_UNF_COLOR_SPACE_BT709_YUV_LIMITED = 0x40,/* ::::Current Used:::: BT.709 */
+    HI_UNF_COLOR_SPACE_BT709_YUV_FULL,
+    HI_UNF_COLOR_SPACE_BT709_RGB_LIMITED,
+    HI_UNF_COLOR_SPACE_BT709_RGB_FULL,
+    HI_UNF_COLOR_SPACE_BT2020_YUV_LIMITED,/* ::::Current Used:::: BT.2020 */
+    HI_UNF_COLOR_SPACE_BT2020_YUV_FULL,
+    HI_UNF_COLOR_SPACE_BT2020_RGB_LIMITED,
+    HI_UNF_COLOR_SPACE_BT2020_RGB_FULL,   /* ::::Current Used:::: */
+
+    HI_UNF_COLOR_SPACE_REC709 = 0x50,      /* HD and modern captures. */
+
+    HI_UNF_COLOR_SPACE_SMPT170M= 0x60, /* ITU-R 601 -- broadcast NTSC/PAL */
+    HI_UNF_COLOR_SPACE_SMPT240M, /* 1125-Line (US) HDTV */
+
+    HI_UNF_COLOR_SPACE_BT878 = 0x70,    /* broken BT878 extents
+                           (601, luma range 16-253 instead of 16-235) */
+
+    HI_UNF_COLOR_SPACE_XVYCC = 0x80,
+
+    /* I know there will be cameras that send this.  So, this is
+     * unspecified chromaticities and full 0-255 on each of the
+     * Y'CbCr components
+     */
+    HI_UNF_COLOR_SPACE_JPEG = 0x90,
+    HI_UNF_COLOR_SPACE_RGB = 0xa0,
+
+    HI_UNF_COLOR_SPACE_BUTT
+}HI_UNF_COLOR_SPACE_E;
+
+/**Defines the RGB range.*/
+/**CNcomment: 定义RGB 范围*/
+typedef enum hiUNF_RGB_RANGE_E
+{
+    HI_UNF_RGB_DEFAULT,
+    HI_UNF_RGB_LIMIT_RANGE,
+    HI_UNF_RGB_FULL_RANGE,
+    HI_UNF_RGB_RANGE_BUTT
+} HI_UNF_RGB_RANGE_E;
+/**Defines the video norm.*/
+/**CNcomment: 定义视频制式枚举*/
+typedef enum hiUNF_ENC_FMT_E
+{
+    HI_UNF_ENC_FMT_1080P_60 = 0,     /**<1080p 60 Hz*/
+    HI_UNF_ENC_FMT_1080P_50,         /**<1080p 50 Hz*/
+    HI_UNF_ENC_FMT_1080P_30,         /**<1080p 30 Hz*/
+    HI_UNF_ENC_FMT_1080P_25,         /**<1080p 25 Hz*/
+    HI_UNF_ENC_FMT_1080P_24,         /**<1080p 24 Hz*/
+
+    HI_UNF_ENC_FMT_1080i_60,         /**<1080i 60 Hz*/
+    HI_UNF_ENC_FMT_1080i_50,         /**<1080i 50 Hz*/
+
+    HI_UNF_ENC_FMT_720P_60,          /**<720p 60 Hz*/
+    HI_UNF_ENC_FMT_720P_50,          /**<720p 50 Hz */
+
+    HI_UNF_ENC_FMT_576P_50,          /**<576p 50 Hz*/
+    HI_UNF_ENC_FMT_480P_60,          /**<480p 60 Hz*/
+
+    HI_UNF_ENC_FMT_PAL,              /* B D G H I PAL */
+    HI_UNF_ENC_FMT_PAL_N,            /* (N)PAL        */
+    HI_UNF_ENC_FMT_PAL_Nc,           /* (Nc)PAL       */
+
+    HI_UNF_ENC_FMT_NTSC,             /* (M)NTSC       */
+    HI_UNF_ENC_FMT_NTSC_J,           /* NTSC-J        */
+    HI_UNF_ENC_FMT_NTSC_PAL_M,       /* (M)PAL        */
+
+    HI_UNF_ENC_FMT_SECAM_SIN,        /**< SECAM_SIN*/
+    HI_UNF_ENC_FMT_SECAM_COS,        /**< SECAM_COS*/
+
+    HI_UNF_ENC_FMT_1080P_24_FRAME_PACKING,
+    HI_UNF_ENC_FMT_720P_60_FRAME_PACKING,
+    HI_UNF_ENC_FMT_720P_50_FRAME_PACKING,
+
+    HI_UNF_ENC_FMT_861D_640X480_60,
+    HI_UNF_ENC_FMT_VESA_800X600_60,
+    HI_UNF_ENC_FMT_VESA_1024X768_60,
+    HI_UNF_ENC_FMT_VESA_1280X720_60,
+    HI_UNF_ENC_FMT_VESA_1280X800_60,
+    HI_UNF_ENC_FMT_VESA_1280X1024_60,
+    HI_UNF_ENC_FMT_VESA_1360X768_60,
+    HI_UNF_ENC_FMT_VESA_1366X768_60,
+    HI_UNF_ENC_FMT_VESA_1400X1050_60,
+    HI_UNF_ENC_FMT_VESA_1440X900_60,
+    HI_UNF_ENC_FMT_VESA_1440X900_60_RB,
+    HI_UNF_ENC_FMT_VESA_1600X900_60_RB,
+    HI_UNF_ENC_FMT_VESA_1600X1200_60,
+    HI_UNF_ENC_FMT_VESA_1680X1050_60,
+    HI_UNF_ENC_FMT_VESA_1680X1050_60_RB,
+    HI_UNF_ENC_FMT_VESA_1920X1080_60,
+    HI_UNF_ENC_FMT_VESA_1920X1200_60,
+    HI_UNF_ENC_FMT_VESA_1920X1440_60,
+    HI_UNF_ENC_FMT_VESA_2048X1152_60,
+    HI_UNF_ENC_FMT_VESA_2560X1440_60_RB,
+    HI_UNF_ENC_FMT_VESA_2560X1600_60_RB,
+
+    HI_UNF_ENC_FMT_3840X2160_24 = 0x40,
+    HI_UNF_ENC_FMT_3840X2160_25,
+    HI_UNF_ENC_FMT_3840X2160_30,
+    HI_UNF_ENC_FMT_3840X2160_50,
+    HI_UNF_ENC_FMT_3840X2160_60,
+
+    HI_UNF_ENC_FMT_4096X2160_24,
+    HI_UNF_ENC_FMT_4096X2160_25,
+    HI_UNF_ENC_FMT_4096X2160_30,
+    HI_UNF_ENC_FMT_4096X2160_50,
+    HI_UNF_ENC_FMT_4096X2160_60,
+
+    HI_UNF_ENC_FMT_3840X2160_23_976,
+    HI_UNF_ENC_FMT_3840X2160_29_97,
+    HI_UNF_ENC_FMT_720P_59_94,
+    HI_UNF_ENC_FMT_1080P_59_94,
+    HI_UNF_ENC_FMT_1080P_29_97,
+    HI_UNF_ENC_FMT_1080P_23_976,
+    HI_UNF_ENC_FMT_1080i_59_94,
+    HI_UNF_ENC_FMT_BUTT
+}HI_UNF_ENC_FMT_E;
+
+/**Defines the mode of the video decoder.*/
+/**CNcomment: 定义视频解码器模式枚举*/
+typedef enum hiUNF_VCODEC_MODE_E
+{
+    HI_UNF_VCODEC_MODE_NORMAL = 0,   /**<Decode all frames.*/ /**<CNcomment: 解所有帧*/
+    HI_UNF_VCODEC_MODE_IP,           /**<Decode only I frames and P frames.*/ /**<CNcomment: 只解IP帧*/
+    HI_UNF_VCODEC_MODE_I,            /**<Decode only I frames.*/ /**<CNcomment: 只解I帧*/
+    HI_UNF_VCODEC_MODE_DROP_INVALID_B,  /**<Decode all frames except the first B frame sequence behind I frames */ /**<CNcomment: 解所有帧，除了紧跟着I帧后面的B帧*/
+    HI_UNF_VCODEC_MODE_FIRST_I,   /**<only decodes the first I frame in the input buffer */
+    HI_UNF_VCODEC_MODE_BUTT
+} HI_UNF_VCODEC_MODE_E;
+
+/**Defines special control operation of decoder*/
+/**CNcomment: 定义解码器解码的特殊控制选项 */
+typedef enum hiHI_UNF_VCODEC_CTRL_OPTION_E
+{
+    HI_UNF_VCODEC_CTRL_OPTION_NORMAL_DPB = 0x0,
+    HI_UNF_VCODEC_CTRL_OPTION_SIMPLE_DPB = 0x1,
+    HI_UNF_VCODEC_CTRL_OPTION_REPAIR_EN  = 0x2,/**CNcomment: 启动修补，仅用于miracast场景 */
+    HI_UNF_VCODEC_CTRL_OPTION_LINEAR_EN = 0x4, /**CNcomment: 2D输出,仅Hi3716MV430 dongle旋转场景配置 */
+    HI_UNF_VCODEC_CTRL_OPTION_ONLY_VDH_FRMAE_MEM = 0x8, /**CNcomment: 只分配解码器使用的帧存,仅Hi3716MV430 dongle旋转场景配置 */
+    HI_UNF_VCODEC_CTRL_OPTION_MAX
+} HI_UNF_VCODEC_CTRL_OPTION_E;
+
+/**Defines the decoding capability (resolution) of the decoder.*/
+/**CNcomment: 定义解码器解码能力(分辨率) */
+typedef enum hiUNF_VCODEC_CAP_LEVEL_E
+{
+    HI_UNF_VCODEC_CAP_LEVEL_NULL = 0, /**<Do not decode.*/ /**<CNcomment: 不需要解码 */
+    HI_UNF_VCODEC_CAP_LEVEL_QCIF = 0, /**<The resolution of the picture to be decoded is less than or equal to 176x144.*/ /**<CNcomment: 解码的图像大小不超过176*144 */
+    HI_UNF_VCODEC_CAP_LEVEL_CIF,      /**<The resolution of the picture to be decoded less than or equal to 352x288.*/ /**<CNcomment: 解码的图像大小不超过352*288 */
+    HI_UNF_VCODEC_CAP_LEVEL_D1,       /**<The resolution of the picture to be decoded less than or equal to 720x576.*/ /**<CNcomment: 解码的图像大小不超过720*576 */
+    HI_UNF_VCODEC_CAP_LEVEL_720P,     /**<The resolution of the picture to be decoded is less than or equal to 1280x720.*/ /**<CNcomment: 解码的图像大小不超过1280*720 */
+    HI_UNF_VCODEC_CAP_LEVEL_FULLHD,   /**<The resolution of the picture to be decoded is less than or equal to 1920x1080.*/ /**<CNcomment: 解码的图像大小不超过1920*1080 */
+
+    HI_UNF_VCODEC_CAP_LEVEL_1280x800, /**<The resolution of the picture to be decoded is less than or equal to 1280x800.*/ /**<CNcomment: 解码的图像大小不超过1280x800*/
+    HI_UNF_VCODEC_CAP_LEVEL_800x1280, /**<The resolution of the picture to be decoded is less than or equal to 800x1280.*/ /**<CNcomment: 解码的图像大小不超过800x1280*/
+    HI_UNF_VCODEC_CAP_LEVEL_1488x1280, /**<The resolution of the picture to be decoded is less than or equal to 1488x1280.*/ /**<CNcomment: 解码的图像大小不超过1488x1280 */
+    HI_UNF_VCODEC_CAP_LEVEL_1280x1488, /**<The resolution of the picture to be decoded is less than or equal to 1280x1488.*/ /**<CNcomment: 解码的图像大小不超过1280x1488 */
+    HI_UNF_VCODEC_CAP_LEVEL_2160x1280, /**<The resolution of the picture to be decoded is less than or equal to 2160x1280.*/ /**<CNcomment: 解码的图像大小不超过2160x1280 */
+    HI_UNF_VCODEC_CAP_LEVEL_1280x2160, /**<The resolution of the picture to be decoded is less than or equal to 1280x2160.*/ /**<CNcomment: 解码的图像大小不超过1280x2160 */
+    HI_UNF_VCODEC_CAP_LEVEL_2160x2160, /**<The resolution of the picture to be decoded is less than or equal to 2160x2160.*/ /**<CNcomment: 解码的图像大小不超过2160x2160 */
+    HI_UNF_VCODEC_CAP_LEVEL_4096x2160, /**<The resolution of the picture to be decoded is less than or equal to 4096x2160.*/ /**<CNcomment: 解码的图像大小不超过4096x2160 */
+    HI_UNF_VCODEC_CAP_LEVEL_2160x4096, /**<The resolution of the picture to be decoded is less than or equal to 2160x4096.*/ /**<CNcomment: 解码的图像大小不超过2160x4096 */
+    HI_UNF_VCODEC_CAP_LEVEL_4096x4096, /**<The resolution of the picture to be decoded is less than or equal to 4096x4096.*/ /**<CNcomment: 解码的图像大小不超过4096x4096 */
+    HI_UNF_VCODEC_CAP_LEVEL_8192x4096, /**<The resolution of the picture to be decoded is less than or equal to 8192x4096.*/ /**<CNcomment: 解码的图像大小不超过8192x4096 */
+    HI_UNF_VCODEC_CAP_LEVEL_4096x8192, /**<The resolution of the picture to be decoded is less than or equal to 4096x8192.*/ /**<CNcomment: 解码的图像大小不超过4096x8192 */
+    HI_UNF_VCODEC_CAP_LEVEL_8192x8192, /**<The resolution of the picture to be decoded is less than or equal to 8192x8192.*/ /**<CNcomment: 解码的图像大小不超过8192x8192 */
+
+    HI_UNF_VCODEC_CAP_LEVEL_BUTT
+} HI_UNF_VCODEC_CAP_LEVEL_E;
+
+/**Defines the stream type supported by the decoder.*/
+/**CNcomment: 定义解码器支持的码流类型 */
+typedef enum hiUNF_VCODEC_TYPE_E
+{
+    HI_UNF_VCODEC_TYPE_MPEG2,
+    HI_UNF_VCODEC_TYPE_MPEG4,       /**<MPEG4*/
+    HI_UNF_VCODEC_TYPE_AVS,
+    HI_UNF_VCODEC_TYPE_H263,
+    HI_UNF_VCODEC_TYPE_H264,
+    HI_UNF_VCODEC_TYPE_REAL8,
+    HI_UNF_VCODEC_TYPE_REAL9,
+    HI_UNF_VCODEC_TYPE_VC1,
+    HI_UNF_VCODEC_TYPE_VP6,
+    HI_UNF_VCODEC_TYPE_VP6F,
+    HI_UNF_VCODEC_TYPE_VP6A,
+    HI_UNF_VCODEC_TYPE_MJPEG,
+    HI_UNF_VCODEC_TYPE_SORENSON,    /**<SORENSON SPARK */
+    HI_UNF_VCODEC_TYPE_DIVX3,       /**<Not Supportted */
+    HI_UNF_VCODEC_TYPE_RAW,
+    HI_UNF_VCODEC_TYPE_JPEG,        /**<Used only for VENC */
+    HI_UNF_VCODEC_TYPE_VP8,
+    HI_UNF_VCODEC_TYPE_MSMPEG4V1,   /**<MS private MPEG4 */
+    HI_UNF_VCODEC_TYPE_MSMPEG4V2,
+    HI_UNF_VCODEC_TYPE_MSVIDEO1,    /**<MS video */
+    HI_UNF_VCODEC_TYPE_WMV1,
+    HI_UNF_VCODEC_TYPE_WMV2,
+    HI_UNF_VCODEC_TYPE_RV10,
+    HI_UNF_VCODEC_TYPE_RV20,
+    HI_UNF_VCODEC_TYPE_SVQ1,        /**<Apple video */
+    HI_UNF_VCODEC_TYPE_SVQ3,        /**<Apple video */
+    HI_UNF_VCODEC_TYPE_H261,
+    HI_UNF_VCODEC_TYPE_VP3,
+    HI_UNF_VCODEC_TYPE_VP5,
+    HI_UNF_VCODEC_TYPE_CINEPAK,
+    HI_UNF_VCODEC_TYPE_INDEO2,
+    HI_UNF_VCODEC_TYPE_INDEO3,
+    HI_UNF_VCODEC_TYPE_INDEO4,
+    HI_UNF_VCODEC_TYPE_INDEO5,
+    HI_UNF_VCODEC_TYPE_MJPEGB,
+    HI_UNF_VCODEC_TYPE_MVC,
+    HI_UNF_VCODEC_TYPE_HEVC,
+    HI_UNF_VCODEC_TYPE_DV,
+    HI_UNF_VCODEC_TYPE_VP9,
+    HI_UNF_VCODEC_TYPE_AVS2,
+    HI_UNF_VCODEC_TYPE_BUTT
+}HI_UNF_VCODEC_TYPE_E;
+
+/**Defines the H264 profile of the video encoder.*/
+/**CNcomment: 定义视频解码器 H264协议档次*/
+typedef enum hiUNF_H264_PROFILE_E
+{
+    HI_UNF_H264_PROFILE_BASELINE = 0,   /**<Encode H264 stream by baseline profile.*/ /**<CNcomment: 采用基线档次编码H264码流*/
+    HI_UNF_H264_PROFILE_MAIN,           /**<Encode H264 stream by main profile.*/     /**<CNcomment:采用主要档次编码H264码流*/
+    HI_UNF_H264_PROFILE_EXTENDED,       /**<Encode H264 stream by extended profile.*/ /**<CNcomment:采用扩展档次编码H264码流*/
+    HI_UNF_H264_PROFILE_HIGH,           /**<Encode H264 stream by high profile.*/     /**<CNcomment: 采用高级档次编码H264码流*/
+    HI_UNF_H264_PROFILE_BUTT
+}HI_UNF_H264_PROFILE_E;
+
+typedef enum hiUNF_VIDEO_HDR_TYPE_E
+{
+    HI_UNF_VIDEO_HDR_TYPE_HDR10 = 0,
+    HI_UNF_VIDEO_HDR_TYPE_HLG,
+    HI_UNF_VIDEO_HDR_TYPE_BUTT
+}HI_UNF_VIDEO_HDR_TYPE_E;
+
+typedef struct hiUNF_VCODEC_VC1_ATTR_S
+{
+    HI_BOOL  bAdvancedProfile;   /**<Whether the profile is an advanced profile*/ /**<CNcomment: 是否Advanced Profile*/
+    HI_U32   u32CodecVersion;    /**<Version number*/ /**<CNcomment: 版本号*/
+}HI_UNF_VCODEC_VC1_ATTR_S;
+
+typedef struct hiUNF_VCODEC_VP6_ATTR_S
+{
+    HI_BOOL  bReversed;     /**<To reverse a picture, set this parameter to 1. In this cases, set it to 0.*/ /**<CNcomment: 图像需要倒转时置1，否则置0*/
+    HI_U16   u16DispWidth;  /**<Display Width.*/ /**<CNcomment: 图像的显示宽度*/
+    HI_U16   u16DispHeight; /**<Display Height.*/ /**<CNcomment: 图像的显示高度*/
+}HI_UNF_VCODEC_VP6_ATTR_S;
+
+typedef union hiUNF_VCODEC_EXTATTR_U
+{
+    HI_UNF_VCODEC_VC1_ATTR_S stVC1Attr;
+    HI_UNF_VCODEC_VP6_ATTR_S stVP6Attr;
+}HI_UNF_VCODEC_EXTATTR_U;
+
+/**Defines the attributes of a video decoder.*/
+/**CNcomment: 定义视频解码器属性结构*/
+typedef struct hiUNF_VCODEC_ATTR_S
+{
+    HI_UNF_VCODEC_TYPE_E        enType;          /**<Video encoding type*/ /**<CNcomment: 视频编码类型*/
+    HI_UNF_VCODEC_EXTATTR_U     unExtAttr;       /**<Extra attributes related to the video encoding type*/ /**<CNcomment: 视频编码类型相关的额外属性*/
+    HI_UNF_VCODEC_MODE_E        enMode;          /**<Mode of a video decoder*/ /**<CNcomment: 视频解码器模式模式*/
+    HI_U32                      u32ErrCover;     /**<Error concealment threshold of the output frames of a video decoder. The value 0 indicates that no frames are output if an error occurs; the value 100 indicates that all frames are output no matter whether errors occur.*/
+                                                 /**<CNcomment: 视频解码器的输出帧错误隐藏门限，0:出现错误即不输出；100:不管错误比例全部输出*/
+    HI_U32                      u32Priority;     /**<Priority of a video decoder. The value range is [1, HI_UNF_VCODEC_MAX_PRIORITY]. The value 0 is a reserved value. If you set the value to 0, no error message is displayed, but the value 1 is used automatically. The smaller the value, the lower the priority.*/
+                                                 /**<CNcomment: 视频解码器优先级, 取值范围: 大于等于1，小于等于HI_UNF_VCODEC_MAX_PRIORITY, 0是保留值，配置为0不会报错，但是会自动取值为1,数值越小优先级越低 */
+    HI_BOOL                     bOrderOutput;    /**<Whether the videos are output by the decoding sequence. You are advised to set this parameter to HI_TRUE in VP mode, and HI_FALSE in other modes.*/
+                                                 /**<CNcomment: 是否按解码序输出，VP模式下推荐配置为HI_TRUE, 一般模式下配置为HI_FALSE */
+    HI_S32                      s32CtrlOptions;  /**<The value is HI_UNF_VCODEC_CTRL_OPTION_E, or the 'or' value of several enum type*/
+                                                 /**<CNcomment: 取值为HI_UNF_VCODEC_CTRL_OPTION_E，或者几个枚举的'或'  */
+    HI_VOID*                    pCodecContext;   /**<Private codec context */
+}HI_UNF_VCODEC_ATTR_S;
+
+/**Defines the hdr attributes of a video decoder.*/
+/**CNcomment: 定义视频HDR属性结构*/
+typedef struct hiUNF_VIDEO_MASTERING_DISPLAY_COLOUR_VOLUME_S
+{
+    HI_U16 u16DisplayPrimaries_x[3];
+    HI_U16 u16DisplayPrimaries_y[3];
+    HI_U16 u16WhitePoint_x;
+    HI_U16 u16WhitePoint_y;
+    HI_U32 u32MaxDisplayMasteringLuminance;
+    HI_U32 u32MinDisplayMasteringLuminance;
+} HI_UNF_VIDEO_MASTERING_DISPLAY_COLOUR_VOLUME_S;
+
+typedef struct hiUNF_VIDEO_CONTENT_LIGHT_LEVEL_S
+{
+    HI_U32 u32MaxContentLightLevel;
+    HI_U32 u32MaxPicAverageLightLevel;
+} HI_UNF_VIDEO_CONTENT_LIGHT_LEVEL_S;
+
+typedef struct hiUNF_VIDEO_HDR10__S
+{
+    HI_U8  u8FullRangeFlag;
+    HI_U8  u8ColourPrimaries;
+    HI_U8  u8TransferCharacteristics;
+    HI_U8  u8MatrixCoeffs;
+    HI_U8  u8MasteringAvailable;      /**<Whether the Mastering available,The value 0 indicates available, The value 1 indicates unavailable.*/
+                                      /**<CNcomment: Mastering数据是否可用,0:不可用；1:可用*/
+    HI_U8  u8ContentAvailable;        /**<Whether the Content available,,The value 0 indicates available, The value 1 indicates unavailable.*/
+                                      /**<CNcomment: Content数据是否可用,0:不可用；1:可用*/
+    HI_UNF_VIDEO_MASTERING_DISPLAY_COLOUR_VOLUME_S  stMasteringInfo;
+    HI_UNF_VIDEO_CONTENT_LIGHT_LEVEL_S              stContentInfo;
+} HI_UNF_VIDEO_HDR10_INFO_S;
+
+typedef struct hiUNF_VIDEO_HLG_INFO_S
+{
+    HI_U8  u8FullRangeFlag;
+    HI_U8  u8ColourPrimaries;
+    HI_U8  u8TransferCharacteristics;
+    HI_U8  u8MatrixCoeffs;
+    HI_U8  u8MasteringAvailable;      /**<Whether the Mastering available,The value 0 indicates available, The value 1 indicates unavailable.*/
+                                      /**<CNcomment: Mastering数据是否可用,0:不可用；1:可用*/
+    HI_U8  u8ContentAvailable;        /**<Whether the Content available,,The value 0 indicates available, The value 1 indicates unavailable.*/
+                                      /**<CNcomment: Content数据是否可用,0:不可用；1:可用*/
+    HI_UNF_VIDEO_MASTERING_DISPLAY_COLOUR_VOLUME_S  stMasteringInfo;
+    HI_UNF_VIDEO_CONTENT_LIGHT_LEVEL_S              stContentInfo;
+    HI_U8  u8BackWardsCompatible;
+} HI_UNF_VIDEO_HLG_INFO_S;
+
+typedef union hiUNF_VIDEO_HDR_METADATA_U
+{
+    HI_UNF_VIDEO_HDR10_INFO_S stHdr10Info;
+    HI_UNF_VIDEO_HLG_INFO_S   stHlgInfo;
+}HI_UNF_VIDEO_HDR_METADATA_U;
+
+typedef struct hiUNF_VIDEO_HDR_INFO_S
+{
+    HI_UNF_VIDEO_HDR_TYPE_E          enHdrType;
+    HI_UNF_VIDEO_HDR_METADATA_U      unHdrMetadata;
+} HI_UNF_VIDEO_HDR_INFO_S;
+
+/**Defines the sub stream protocol.*/
+/**CNcomment: 定义码流的协议分支枚举*/
+typedef enum hiUNF_VIDEO_SUB_STANDARD_E
+{
+    HI_UNF_VIDEO_SUB_STANDARD_UNKNOWN,       /**<Unknown*/ /**<CNcomment: 未知协议分支*/
+    HI_UNF_VIDEO_SUB_STANDARD_MPEG2_MPEG1,   /**<The MPEG2 protocol family is compatible with MPEG1.*/ /**<CNcomment: MPEG2协议族可以兼容MPEG1 */
+    HI_UNF_VIDEO_SUB_STANDARD_MPEG4_SHV,     /**<The MPEG4 protocol family is compatible with SHV.*/ /**<CNcomment: MPEG4协议族可以兼容SHV*/
+    HI_UNF_VIDEO_SUB_STANDARD_MPEG4_XVID,    /**<The MPEG4 protocol family includes the sub protocol XVID.*/ /**<CNcomment: MPEG4协议包含XVID分支*/
+    HI_UNF_VIDEO_SUB_STANDARD_MPEG4_DIVX,    /**<The MPEG4 protocol family includes the sub protocol DIVX.*/ /**<CNcomment: MPEG4协议包含DIVX分支*/
+
+    HI_UNF_VIDEO_SUB_STANDARD_BUTT
+}HI_UNF_VIDEO_SUB_STANDARD_E;
+
+/**Defines the frame rate of the video stream.*/
+/**CNcomment: 定义视频码流帧率结构*/
+typedef struct hiUNF_VCODEC_FRMRATE_S
+{
+    HI_U32 u32fpsInteger;     /**<Integral part of the frame rate (in frame/s)*/ /**<CNcomment: 码流的帧率的整数部分, fps */
+    HI_U32 u32fpsDecimal;     /**<Fractional part (calculated to three decimal places) of the frame rate (in frame/s)*/
+                              /**<CNcomment: 码流的帧率的小数部分（保留3位）, fps */
+}HI_UNF_VCODEC_FRMRATE_S;
+
+/**Defines the information about video streams.*/
+/**CNcomment: 定义视频码流信息结构*/
+typedef struct hiUNF_VCODEC_STREAMINFO_S
+{
+    HI_UNF_VCODEC_TYPE_E        enVCodecType;   /**<Stream type*/ /**<CNcomment: 码流类型 */
+    HI_UNF_VIDEO_SUB_STANDARD_E enSubStandard;  /**<Sub stream protocol*/ /**<CNcomment: 码流的协议分支 */
+    HI_U32                      u32SubVersion;  /**<Version of the sub stream protocol*/ /**<CNcomment: 码流子协议版本号 */
+    HI_U32                      u32Profile;     /**<Stream profile*/ /**<CNcomment: 码流的profile */
+    HI_U32                      u32Level;       /**<Stream level*/ /**<CNcomment: 码流的level */
+    HI_UNF_ENC_FMT_E            enDisplayNorm;  /**<Display norm (PAL or NTSC)*/ /**<CNcomment: 显示标准(P/N) */
+    HI_BOOL                     bProgressive;   /**<Sampling type (progressive or interlaced)*/ /**<CNcomment: 采样方式(逐行/隔行) */
+    HI_U32                      u32AspectWidth; /**<Output aspect ratio: width*/ /**<CNcomment: 输出宽高比之宽值 */
+    HI_U32                      u32AspectHeight;/**<Output aspect ratio: height*/ /**<CNcomment: 输出宽高比之高值 */
+
+    HI_U32 u32bps;            /**<Bit rate, in kbit/s*/ /**<CNcomment: 码流的码率, Kbps */
+    HI_U32 u32fpsInteger;     /**<Integral part of the frame rate (in frame/s)*/ /**<CNcomment: 码流的帧率的整数部分, fps */
+    HI_U32 u32fpsDecimal;     /**<Fractional part (calculated to three decimal places) of the frame rate (in frame/s)*/ /**<CNcomment: 码流的帧率的小数部分（保留3位）, fps */
+    HI_U32 u32Width;          /**<Width of the decoded picture*/ /**<CNcomment: 解码图像宽 */
+    HI_U32 u32Height;         /**<Height of the decoded picture*/ /**<CNcomment: 解码图像高 */
+    HI_U32 u32DisplayWidth;   /**<Width of the displayed picture*/ /**<CNcomment: 显示图像宽 */
+    HI_U32 u32DisplayHeight;  /**<Height of the displayed picture*/ /**<CNcomment: 显示图像高 */
+    HI_U32 u32DisplayCenterX; /**<Horizontal coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/
+                              /**<CNcomment: 显示图像中心横坐标，以原始图像的左上角为坐标原点 */
+    HI_U32 u32DisplayCenterY; /**<Vertical coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/
+                              /**<CNcomment: 显示图像中心纵坐标，以原始图像的左上角为坐标原点 */
+    HI_UNF_PIXEL_BITWIDTH_E enBitWidth; /**<Bit width decoded from stream*/ /**<CNcomment: 视频像素位宽*/
+    HI_UNF_COLOR_SPACE_E       enSrcColorSpace; /**<Color space decoded from stream*/ /**<CNcomment: 颜色色域空间*/
+}HI_UNF_VCODEC_STREAMINFO_S;
+
+
+/**Defines the types of the user data in the video information.*/
+/**CNcomment: 定义视频信息中的用户数据类型 */
+typedef enum hiHI_UNF_VIDEO_USERDATA_TYPE_E
+{
+    HI_UNF_VIDEO_USERDATA_UNKNOWN = 0,      /**<Unknown type*/ /**<CNcomment: 未知类型*/
+    HI_UNF_VIDEO_USERDATA_DVB1_CC = 0x1,    /**<Closed Caption Data*/ /**<CNcomment: 字幕数据*/
+    HI_UNF_VIDEO_USERDATA_DVB1_BAR = 0x2,   /**<Bar Data*/ /**<CNcomment: Bar数据*/
+    HI_UNF_VIDEO_USERDATA_AFD = 0x10000,    /**<Active Format Description*/ /**<CNcomment: 模式描述数据*/
+    HI_UNF_VIDEO_USERDATA_BUTT
+}HI_UNF_VIDEO_USERDATA_TYPE_E;
+
+/**Defines the profile of video broadcasting.*/
+/**CNcomment: 定义视频广播的profile枚举*/
+typedef enum hiUNF_VIDEO_BROADCAST_PROFILE_E
+{
+    HI_UNF_VIDEO_BROADCAST_DVB,        /**<Digital video broadcasting (DVB)*/ /**<CNcomment: 数字视频广播DVB*/
+    HI_UNF_VIDEO_BROADCAST_DIRECTV,    /**<American live broadcast operator DirecTV*/ /**<CNcomment: 美国直播运营商DirecTV*/
+    HI_UNF_VIDEO_BROADCAST_ATSC,       /**<Advanced Television Systems Committee (ATSC)*/ /**<CNcomment: 先进电视制式委员会ATSC（Advanced Television Systems Committee）*/
+    HI_UNF_VIDEO_BROADCAST_DVD,        /**<Digital video disc (DVD)*/ /**<CNcomment: 数字视频光盘*/
+    HI_UNF_VIDEO_BROADCAST_ARIB,       /**<Association of Radio Industries and Businesses (ARIB)*/ /**<CNcomment: 无线电工业及商业协会规格*/
+    HI_UNF_VIDEO_BROADCAST_BUTT
+}HI_UNF_VIDEO_BROADCAST_PROFILE_E;
+
+/**Defines the position of the user data in the video information.*/
+/**CNcomment: 定义视频信息中用户数据的位置枚举*/
+typedef enum hiUNF_VIDEO_USER_DATA_POSITION_E
+{
+    HI_UNF_VIDEO_USER_DATA_POSITION_UNKNOWN,       /**<Unknown*/ /**<CNcomment: 未知位置*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG2_SEQ,     /**<The data is parsed from sequences under the MPEG2 protocol.*/ /**<CNcomment: MPEG2协议下，从序列中解出*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG2_GOP,     /**<The data is parsed from the group of pictures (GOP) under the MPEG2 protocol.*/ /**<CNcomment: MPEG2协议下，从GOP（Group Of Pictures）中解出*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG2_FRAME,   /**<The data is parsed from picture frames under the MPEG2 protocol.*/ /**<CNcomment: MPEG2协议下，从图像帧中解出*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG4_VSOS,    /**<The data is parsed from the sequences of visible objects under the MPEG4 protocol.*/ /**<CNcomment: MPEG4协议下，从可视对像序列中解出*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG4_VSO,     /**<The data is parsed from visible objects under the MPEG4 protocol.*/ /**<CNcomment: MPEG4协议下，从可视对像中解出*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG4_VOL,     /**<The data is parsed from the video object layer under the MPEG4 protocol.*/ /**<CNcomment: MPEG4协议下，从视频对像层中解出*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_MPEG4_GOP,     /**<The data is parsed from the GOP under the MPEG4 protocol.*/ /**<CNcomment: MPEG4协议下，从GOP中解出*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_H264_REG,      /**<The data is parsed from the user_data_regestered_itu_t_t35() syntax under the H.264 protocol.*/ /**<CNcomment: 从H.264协议的user_data_regestered_itu_t_t35()语法中解出*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_H264_UNREG,    /**<The data is parsed from the user_data_unregestered() syntax under the H.264 protocol.*/ /**<CNcomment: 从H.264协议的user_data_unregestered()语法中解出*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_BUTT
+}HI_UNF_VIDEO_USER_DATA_POSITION_E;
+
+/**Defines the structure of the user data in the video information.*/
+/**CNcomment: 定义视频信息中的用户数据结构*/
+typedef struct hiUNF_VIDEO_USERDATA_S
+{
+    HI_UNF_VIDEO_BROADCAST_PROFILE_E   enBroadcastProfile;   /**<Broadcasting profile of the user data*/ /**<CNcomment: 用户数据的广播profile*/
+    HI_UNF_VIDEO_USER_DATA_POSITION_E  enPositionInStream;   /**<Position of the user data in video streams*/ /**<CNcomment: 用户数据在视频流中的位置*/
+    HI_U32                             u32Pts;               /**<PTS corresponding to the user data*/ /**<CNcomment: 用户数据对应的时间戳*/
+    HI_U32                             u32SeqCnt;            /**<Sequence ID of the user data*/ /**<CNcomment: 用户数据的前一序列数*/
+    HI_U32                             u32SeqFrameCnt;       /**<Frame number of the user data*/ /**<CNcomment: 用户数据的前一帧数*/
+    HI_U8                              *pu8Buffer;           /**<Initial address of the user data memory, output parameter*/ /**<CNcomment: 用户数据内存区的初始地址,输出参数*/
+    HI_U32                             u32Length;            /**<User data size (a multiple of 1 byte)*/ /**<CNcomment: 用户数据的大小，以1byte为单位*/
+    HI_BOOL                            bBufferOverflow;      /**<Indicate that whether the user data size exceeds the maximum size defined by MAX_USER_DATA_LEN.*/ /**<CNcomment: 标志用户数据的长度是否超过了MAX_USER_DATA_LEN定义的最大值*/
+    HI_BOOL                            bTopFieldFirst;       /**<Top field first flag*/ /**<CNcomment: 顶场优先标志*/
+}HI_UNF_VIDEO_USERDATA_S;
+
+/**Defines the parameters of format changing */
+/**CNcomment: 定义制式切换时的相关参数*/
+typedef struct hiUNF_NORMCHANGE_PARAM_S
+{
+    HI_UNF_ENC_FMT_E            enNewFormat;            /**<New format*/ /**<CNcomment: 新的制式*/
+    HI_U32                      u32ImageWidth;          /**<Width of image*/ /**<CNcomment: 图像宽度*/
+    HI_U32                      u32ImageHeight;         /**<Height of image*/ /**<CNcomment: 图像高度*/
+    HI_BOOL                     bProgressive;           /**<Sampling type (progressive or interlaced)*/ /**<CNcomment: 采样方式(逐行/隔行) */
+    HI_U32                      u32FrameRate;           /**<Frame rate*//**<CNcomment:帧率*/
+}HI_UNF_NORMCHANGE_PARAM_S;
+
+/**Defines the video format.*/
+/**CNcomment: 定义视频格式枚举*/
+typedef enum hiUNF_VIDEO_FORMAT_E
+{
+    /* Semi-Planner */
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_422,       /**<The YUV spatial sampling format is 4:2:2.*/ /**<CNcomment: YUV空间采样格式为4:2:2*/
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_420,       /**<The YUV spatial sampling format is 4:2:0, V first.*/ /**<CNcomment: YUV空间采样格式为4:2:0，V在低位*/
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_400,
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_411,
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_422_1X2,
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_444,
+    HI_UNF_FORMAT_YUV_SEMIPLANAR_420_UV,   /**<The YUV spatial sampling format is 4:2:0,U first.*/ /**<CNcomment: YUV空间采样格式为4:2:0, U在低位*/
+
+
+    /* Package */
+    HI_UNF_FORMAT_YUV_PACKAGE_UYVY,         /**<The YUV spatial sampling format is package, and the pixel arrangement sequence in the memory is UYVY.*/ /**<CNcomment: YUV空间采样格式为package,内存排列为UYVY*/
+    HI_UNF_FORMAT_YUV_PACKAGE_YUYV,         /**<The YUV spatial sampling format is package, and the pixel arrangement sequence in the memory is YUYV.*/ /**<CNcomment: YUV空间采样格式为package,内存排列为YUYV*/
+    HI_UNF_FORMAT_YUV_PACKAGE_YVYU,         /**<The YUV spatial sampling format is package, and the pixel arrangement sequence in the memory is YVYU.*/ /**<CNcomment: YUV空间采样格式为package,内存排列为YVYU*/
+
+    /* Planner */
+    HI_UNF_FORMAT_YUV_PLANAR_400,
+    HI_UNF_FORMAT_YUV_PLANAR_411,
+    HI_UNF_FORMAT_YUV_PLANAR_420,
+    HI_UNF_FORMAT_YUV_PLANAR_422_1X2,
+    HI_UNF_FORMAT_YUV_PLANAR_422_2X1,
+    HI_UNF_FORMAT_YUV_PLANAR_444,
+    HI_UNF_FORMAT_YUV_PLANAR_410,
+    HI_UNF_FORMAT_YUV_TILE_420,             /**<The YUV spatial sampling format is TILE 4:2:0, V first.*/
+    HI_UNF_FORMAT_YUV_TILE_420_UV,          /**<The YUV spatial sampling format is TILE 4:2:0, U first.*/
+    HI_UNF_FORMAT_YUV_BUTT,
+
+    HI_UNF_FORMAT_RGB_SEMIPLANAR_444,
+    HI_UNF_FORMAT_RGB_888,
+    HI_UNF_FORMAT_ARGB_8888,
+    HI_UNF_FORMAT_RGB_BUTT
+}HI_UNF_VIDEO_FORMAT_E;
+
+/**Defines the type of the video frame.*/
+/**CNcomment: 定义视频帧的类型枚举*/
+typedef enum hiUNF_VIDEO_FRAME_TYPE_E
+{
+    HI_UNF_FRAME_TYPE_UNKNOWN,   /**<Unknown*/ /**<CNcomment: 未知的帧类型*/
+    HI_UNF_FRAME_TYPE_I,         /**<I frame*/ /**<CNcomment: I帧*/
+    HI_UNF_FRAME_TYPE_P,         /**<P frame*/ /**<CNcomment: P帧*/
+    HI_UNF_FRAME_TYPE_B,         /**<B frame*/ /**<CNcomment: B帧*/
+    HI_UNF_FRAME_TYPE_IDR,       /**<IDR frame*/ /**<CNcomment: IDR帧*/
+    HI_UNF_FRAME_TYPE_BLA,       /**<BLA frame*/ /**<CNcomment: BLA帧*/
+    HI_UNF_FRAME_TYPE_CRA,       /**<CRA frame*/ /**<CNcomment: CRA帧*/
+    HI_UNF_FRAME_TYPE_BUTT
+}HI_UNF_VIDEO_FRAME_TYPE_E;
+
+/**Defines the video frame/field mode.*/
+/**CNcomment: 定义视频帧场模式枚举*/
+typedef enum hiUNF_VIDEO_FIELD_MODE_E
+{
+    HI_UNF_VIDEO_FIELD_ALL,        /**<Frame mode*/ /**<CNcomment: 帧模式*/
+    HI_UNF_VIDEO_FIELD_TOP,        /**<Top field mode*/ /**<CNcomment: 顶场模式*/
+    HI_UNF_VIDEO_FIELD_BOTTOM,     /**<Bottom field mode*/ /**<CNcomment: 底场模式*/
+    HI_UNF_VIDEO_FIELD_BUTT
+}HI_UNF_VIDEO_FIELD_MODE_E;
+
+
+/**Defines 3D frame packing type*/
+typedef enum hiUNF_VIDEO_FRAME_PACKING_TYPE_E
+{
+    HI_UNF_FRAME_PACKING_TYPE_NONE,             /**< Normal frame, not a 3D frame */
+    HI_UNF_FRAME_PACKING_TYPE_SIDE_BY_SIDE,     /**< Side by side */
+    HI_UNF_FRAME_PACKING_TYPE_TOP_AND_BOTTOM,   /**< Top and bottom */
+    HI_UNF_FRAME_PACKING_TYPE_TIME_INTERLACED,  /**< Time interlaced: one frame for left eye, the next frame for right eye */
+    HI_UNF_FRAME_PACKING_TYPE_FRAME_PACKING,    /**< frame packing */
+    HI_UNF_FRAME_PACKING_TYPE_3D_TILE,          /**< Tile 3D */
+    HI_UNF_FRAME_PACKING_TYPE_BUTT
+}HI_UNF_VIDEO_FRAME_PACKING_TYPE_E;
+
+typedef struct hiUNF_VIDEO_FRAME_ADDR_S
+{
+    HI_U32             u32YAddr;    /**<Physical address of the Y  component in the current frame*/ /**<CNcomment: 当前帧Y分量数据的物理地址*/
+    HI_U32             u32CAddr;    /**<Physical address of the C  component in the current frame*/ /**<CNcomment: 当前帧C分量数据的物理地址*/
+    HI_U32             u32CrAddr;   /**<Physical address of the Cr component in the current frame*/ /**<CNcomment: 当前帧Cr分量数据的物理地址*/
+
+    HI_U32             u32YStride;  /**<Stride of the Y component*/ /**<CNcomment: Y分量数据的跨幅*/
+    HI_U32             u32CStride;  /**<Stride of the C component*/ /**<CNcomment: C分量数据的跨幅*/
+    HI_U32             u32CrStride; /**<Stride of the Cr component*/ /**<CNcomment: Cr分量数据的跨幅*/
+}HI_UNF_VIDEO_FRAME_ADDR_S;
+
+typedef struct hiUNF_VIDEO_FRAME_INFO_S
+{
+    HI_U32                              u32FrameIndex;      /**<Frame index ID of a video sequence*/ /**<CNcomment: 视频序列中的帧索引号*/
+    HI_UNF_VIDEO_FRAME_ADDR_S           stVideoFrameAddr[2];
+    HI_U32                              u32Width;           /**<Width of the source picture*/ /**<CNcomment: 原始图像宽*/
+    HI_U32                              u32Height;          /**<Height of the source picture*/ /**<CNcomment: 原始图像高*/
+    HI_U32                              u32SrcPts;          /**<Original PTS of a video frame*/ /**<CNcomment: 视频帧的原始时间戳*/
+    HI_U32                              u32Pts;             /**<PTS of a video frame*/ /**<CNcomment: 视频帧的时间戳*/
+    HI_U32                              u32AspectWidth;
+    HI_U32                              u32AspectHeight;
+    HI_UNF_VCODEC_FRMRATE_S             stFrameRate;
+
+    HI_UNF_VIDEO_FORMAT_E               enVideoFormat;      /**<Video YUV format*/ /**<CNcomment: 视频YUV格式*/
+    HI_BOOL                             bProgressive;       /**<Sampling type (progressive or interlaced)*/ /**<CNcomment: 采样方式(逐行/隔行) */
+    HI_UNF_VIDEO_FIELD_MODE_E           enFieldMode;        /**<Frame or field encoding mode*/ /**<CNcomment: 帧或场编码模式*/
+    HI_BOOL                             bTopFieldFirst;     /**<Top field first flag*/ /**<CNcomment: 顶场优先标志*/
+    HI_UNF_VIDEO_FRAME_PACKING_TYPE_E   enFramePackingType; /**<3D frame packing type*/
+    HI_U32                              u32Circumrotate;    /**<Need circumrotate, 1 need */
+    HI_BOOL                             bVerticalMirror;
+    HI_BOOL                             bHorizontalMirror;
+    HI_U32                              u32DisplayWidth;    /**<Width of the displayed picture*/ /**<CNcomment: 显示图像宽*/
+    HI_U32                              u32DisplayHeight;   /**<Height of the displayed picture*/ /**<CNcomment: 显示图像高*/
+    HI_U32                              u32DisplayCenterX;  /**<Horizontal coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/ /**<CNcomment: 显示中心x坐标，原始图像左上角为坐标原点*/
+    HI_U32                              u32DisplayCenterY;  /**<Vertical coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/ /**<CNcomment: 显示中心y坐标，原始图像左上角为坐标原点*/
+    HI_U32                              u32ErrorLevel;      /**<Error percentage of a decoded picture, ranging from 0% to 100%*/ /**<CNcomment: 一幅解码图像中的错误比例，取值为0～100*/
+    HI_U32                              u32Private[64];     /**<Private data for every frame:
+                                                                u32Private[0]: securty flag, if u32Private[0] == 1, this is a secure frame;
+                                                                */
+
+
+}HI_UNF_VIDEO_FRAME_INFO_S;
+
+typedef struct hiUNF_VIDEO_FRM_STATUS_INFO_S
+{
+    HI_UNF_VIDEO_FRAME_TYPE_E enVidFrmType; /**<Type of video frame*/ /**<CNcomment: 视频帧类型*/
+    HI_U32 u32VidFrmStreamSize;             /**<Size of video frame*/ /**<CNcomment: 视频帧大小*/
+    HI_U32 u32VidFrmQP;                     /**<QP of video frame*/ /**<CNcomment: 视频帧QP*/
+    HI_U32 u32VidFrmPTS;                    /**<PTS of video frame*/ /**<CNcomment: 视频帧pts*/
+    HI_U32 u32MaxMV;                        /**<MAX MV*/ /**<CNcomment: 视频帧最大MV*/
+    HI_U32 u32MinMV;                        /**<MIN MV*/ /**<CNcomment: 视频帧最小MV*/
+    HI_U32 u32AvgMV;                        /**<AVG MV*/ /**<CNcomment: 视频帧MV平均值*/
+    HI_U32 u32SkipRatio;                    /**<MB ratio */ /**<CNcomment: 视频帧MB比例0~100*/
+    HI_U32 u32DecoderBuffer;                /**<BUFFER STATE>*/ /**<CNcomment: 0-ok, 2-UnderFlow, 3-DecodeErr*/
+}HI_UNF_VIDEO_FRM_STATUS_INFO_S;
+
+typedef struct hiUNF_VIDEO_FRM_DISPLAY_TIME_S
+{
+    HI_S64 s64PTS;                          /**<PTS of video frame*/ /**<CNcomment: 视频帧PTS*/
+    HI_S64 s64DisplayTime;                  /**<Estimated time of display */ /**<CNcomment: 视频帧预计显示时间*/
+} HI_UNF_VIDEO_FRM_DISPLAY_TIME_S;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif /* __HI_UNF_VIDEO_ H*/
diff -uNr a/include/hi_unf_vo.h b/include/hi_unf_vo.h
--- a/include/hi_unf_vo.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_vo.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,857 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_vo.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2009/12/16
+  Description   :
+  History       :
+  1.Date        : 2009/12/16
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+/**
+ * \file
+ * \brief  supply info of vo module.
+ */
+
+#ifndef  __HI_UNF_VO_H__
+#define  __HI_UNF_VO_H__
+
+#include "hi_unf_common.h"
+#include "hi_unf_disp.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      VO */
+/** @{ */  /** <!-- [VO] */
+
+
+
+/**defines the ROTATION type.*/
+/**CNcomment:定义视频旋转角度*/
+typedef enum hiUNF_VO_ROTATION_E
+{
+    HI_UNF_VO_ROTATION_0, /**< 0 degree rotation*//**<CNcomment: 0度旋转*/
+    HI_UNF_VO_ROTATION_90, /**< 90 degree rotation*//**<CNcomment: 90度旋转*/
+    HI_UNF_VO_ROTATION_180, /**< 180 degree rotation*//**<CNcomment: 180度旋转*/
+    HI_UNF_VO_ROTATION_270, /**< 270 degree rotation*//**<CNcomment: 270度旋转*/
+    HI_UNF_VO_ROTATION_BUTT
+}HI_UNF_VO_ROTATION_E;
+
+
+/**conversion mode of AspectRatio.*/
+/**CNcomment:宽高比转换模式*/
+typedef enum hiUNF_VO_ASPECT_CVRS_E
+{
+    HI_UNF_VO_ASPECT_CVRS_IGNORE = 0x0,
+    HI_UNF_VO_ASPECT_CVRS_LETTERBOX,      /**<Add black borders*//**<CNcomment: 加黑边*/
+    HI_UNF_VO_ASPECT_CVRS_PAN_SCAN,      /**<Clip the picture*//**<CNcomment: 裁减*/
+    HI_UNF_VO_ASPECT_CVRS_COMBINED,       /**<Add black borders and clip the picture*//**<CNcomment: 加黑边和裁减混合*/
+
+    HI_UNF_VO_ASPECT_CVRS_HORIZONTAL_FULL,  /**<keep picture's HORIZONTAL be full*//**<CNcomment: 保持水平方向铺满*/
+    HI_UNF_VO_ASPECT_CVRS_VERTICAL_FULL,    /**<keep picture's VERTICAL be full*//**<CNcomment: 保持垂直方向铺满*/
+    HI_UNF_VO_ASPECT_CVRS_BUTT,
+} HI_UNF_VO_ASPECT_CVRS_E;
+
+/** AspectRatio attribute.*/
+/**CNcomment:宽高比属性*/
+typedef struct hiUNF_WINDOW_ASPECT_ATTR_S
+{
+    HI_UNF_VO_ASPECT_CVRS_E   enAspectCvrs;  /**<the method to the aspect ratio transfer.\n*//**<CNcomment: 窗口的宽高转换方式 */
+    HI_BOOL                   bUserDefAspectRatio;  /**<use or not user define aspectratio. \n
+                                                     if this is true, u32UserAspectWidth and u32UserAspectHeight will be effective.\n*/
+                                                    /**<CNcomment: 是否使用用户设定的宽高比, 为TRUE时，u32UserAspectWidth和u32UserAspectHeight生效*/
+    HI_U32                    u32UserAspectWidth; /**<aspect width of user \n
+                                                    this value should be in 0~3840 \n
+                                                    zero indicate using video resolution.*/
+                                                  /**<CNcomment: 用户期望显示的视频宽度 \n
+                                                   设置值范围在0~3840之间 \n
+                                                   0代表使用视频源分辨率*/
+    HI_U32                    u32UserAspectHeight; /**<aspect height of user \n
+                                                    this value should be in 0~3840 \n
+                                                    zero indicate using video resolution.*/
+                                                    /**<CNcomment: 用户期望显示的视频高度 \n
+                                                    设置值范围需要在0~3840的范围内 \n
+                                                    0代表使用视频源分辨率*/
+} HI_UNF_WINDOW_ASPECT_ATTR_S;
+
+/**define the attribution of window.*/
+/**CNcomment:定义WINDOW属性*/
+typedef struct hiUNF_WINDOW_ATTR_S
+{
+    HI_UNF_DISP_E             enDisp;          /**<the display channel where window locate in. can not be modified.\n*//**<CNcomment: 窗口所在的显示通道, 创建后不可修改 */
+    HI_BOOL                   bVirtual;      /**< whether is virtual window or not. can not be modified.\n*//**<CNcomment: 是否为虚拟窗口，创建后不可修改 */
+    HI_UNF_VIDEO_FORMAT_E     enVideoFormat; /**<the data format of virtual window.\n*//**<CNcomment: 虚拟窗口数据格式 */
+    HI_UNF_WINDOW_ASPECT_ATTR_S     stWinAspectAttr;  /**<the AspectRatio of window.\n*//**<CNcomment:  窗口的宽高比属性*/
+    HI_BOOL                   bUseCropRect;     /**<cut video frame as stCropRect struct or as stInputRect struct \n
+                                                    if this is TRUE, stCropRect will be effective \n
+                                                    if this is false, stInputRect will be effective.*/
+                                                   /**<CNcomment: 是否使用stCropRect对视频输入进行裁剪 \n
+                                                    为TRUE时，stCropRect设置生效 \n
+                                                    为FALSE时，stInputRect设置生效*/
+
+    HI_UNF_CROP_RECT_S        stCropRect;   /**<clip window of user define ,clip pix num of top,buttom,left,right.\n*/
+                                            /**<CNcomment: 用户定义的视频裁剪结构体类型, 上下左右裁剪的像素个数*/
+
+    HI_RECT_S                 stInputRect;       /**<the crop area .\n
+                                                  all values are zero indicate outputing whole video stream \n
+                                                  if the value is bigger than video frame, the whole video frame will be displayed \n
+                                                  width and height should not be less than 64.\n*/
+                                                 /**<CNcomment: 窗口的裁减区域  \n
+                                                  所有值为0代表显示整个视频图像 \n
+                                                  大于视频源大小的设置, 显示整个视频图像。\n
+                                                  宽度和高度不能小于64，将限制到64*64*/
+
+    HI_RECT_S                 stOutputRect;  /**<the window display area on the virtual screen. \n
+                                                The width and height of display area should not larger than virtual screen,\n
+                                                and all parameters are zero means to fill whole virtual screen.\n
+                                                The area could move out of virtual screen, and the outside part will not display.\n*/
+                                                /**<CNcomment: 窗口在虚拟屏幕上的显示区域。\n
+                                                显示区域的宽度与高度不能大于虚拟屏幕的宽度和高度，全部为0表示填满虚拟屏幕。\n
+                                                显示区域可以移出虚拟屏幕，移出屏幕部分不显示*/
+
+
+
+} HI_UNF_WINDOW_ATTR_S;
+
+
+/**define user buffer management attribute.*/
+/**CNcomment:定义用户缓冲区管理属性*/
+typedef struct hiUNF_BUFFER_ATTR_S
+{
+    HI_S32              s32Stride;          /**<the stride of the buffer.*//**<CNcomment: 缓冲区步长*/
+    HI_U32              u32PhyAddr[16];     /**<start physics addrss of the buffer.*//**<CNcomment: 缓冲区物理起始地址*/
+    HI_U32              u32BuffIndex[16];   /**<Stride of the buffer.*//**<CNcomment: 缓冲区索引编号*/
+    HI_S32              s32BuffNum;         /**<the number of the buffer.*//**<CNcomment: 缓冲区个数*/
+} HI_UNF_BUFFER_ATTR_S;
+
+/** the running mode of vo*/
+/**CNcomment:VO设备的运行模式 */
+typedef enum hiUNF_VO_DEV_MODE_E
+{
+    HI_UNF_VO_DEV_MODE_NORMAL,  /**<normal mode:
+                                  3716 V100/V200 :no more than 2 windows to be created.
+                                  3716 v300:no more than 3 windows to be created.
+                                  3712 v300:no more than 1 windows to be created.*/
+                                  /**<CNcomment: 正常模式，
+                                   3716 V100/V200:只能创建2个WINDOW
+                                   3716 v300: 只能创建3个WINDOW
+                                   3712 v300: 只能创建1个WINDOW*/
+    HI_UNF_VO_DEV_MODE_MOSAIC,  /**<mosaic mode: can create more than 2 windows.
+                                 3712 v300: not support*/
+                                /**<CNcomment: 马赛克模式，可以创建多个WINDOW
+                                 3712 v300: 不支持*/
+    HI_UNF_VO_DEV_MODE_STANDALONE,  /**<seperate mode,only 1 window can be created,and  the aspect ratio set seperately.
+                                        3716 v300: not support*/
+                                    /**<CNcomment: standalone模式，高标清显示宽高比转换单独处理模式
+                                     3716 v300 : 不支持*/
+    HI_UNF_VO_DEV_MODE_BUTT
+} HI_UNF_VO_DEV_MODE_E;
+
+/**define the freeze mode enumeration.*/
+/**CNcomment:定义Freeze模式枚举*/
+typedef enum hiUNF_WINDOW_FREEZE_MODE_E
+{
+    HI_UNF_WINDOW_FREEZE_MODE_LAST = 0,   /**<display the last frame when freeze.*//**<CNcomment: freeze时显示最后一帧*/
+    HI_UNF_WINDOW_FREEZE_MODE_BLACK = 1,  /**<display a black frame when freeze.*//**<CNcomment: freeze时显示后黑屏*/
+    HI_UNF_WINDOW_FREEZE_MODE_BUTT
+} HI_UNF_WINDOW_FREEZE_MODE_E;
+
+/**<Frosted glass effect level*/
+/**<CNcomment:定义毛玻璃效果强度 CNend*/
+typedef enum hiUNF_WINDOW_FROST_E
+{
+    HI_UNF_WINDOW_FROST_CLOSE = 0x0 ,       /**<Close  */ /**<CNcomment:关闭 CNend*/
+    HI_UNF_WINDOW_FROST_LOW         ,       /**<Low    */ /**<CNcomment:弱   CNend*/
+    HI_UNF_WINDOW_FROST_MIDDLE      ,       /**<Middle */ /**<CNcomment:中   CNend*/
+    HI_UNF_WINDOW_FROST_HIGH        ,       /**<High   */ /**<CNcomment:强   CNend*/
+
+    HI_UNF_WINDOW_FROST_BUTT
+}HI_UNF_WINDOW_FROST_E;
+
+typedef struct hiUNF_WIN_PLAY_INFO_S
+{
+    HI_U32    u32Underload;        /**< Compared with the normal play ,frame underload count  */ /**<CNcomment:和正常播放相比缺少帧的计数 CNend*/
+}HI_UNF_WIN_PLAY_INFO_S;
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      VO */
+/** @{ */  /** <!-- [VO] */
+
+/**
+\brief  init vo module.CNcomment:初始化VO模块 CNend
+\attention \n
+Before call this func, you should confirm that HI_UNF_DISP_Init and HI_UNF_DISP_Open have been called yet.
+call this func before any other vo funcs .
+CNcomment:需先初始化并打开DISPLAY后才能调用该接口。调用VO模块要求首先调用本接口 CNend
+\param[in]   enDevMode  the vo running mode.  CNcomment:VO模块的运行模式 CNend
+\retval ::HI_SUCCESS successs.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_DEV_NOT_EXIST  vo device not exist. CNcomment:VO设备不存在 CNend
+\retval ::HI_ERR_VO_NOT_DEV_FILE   not vo device. CNcomment:VO非设备 CNend
+\retval ::HI_ERR_VO_DEV_OPEN_ERR   open vo failed. CNcomment:VO打开失败 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal param. CNcomment:输入参数非法 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_Init(HI_UNF_VO_DEV_MODE_E enDevMode);
+
+/**
+\brief  deinit vo module.CNcomment:去初始化VO模块 CNend
+\attention \n
+before calling this func ,you should call HI_UNF_VO_Close to close all the windows first.
+CNcomment:在调用::HI_UNF_VO_Close接口关闭所有打开的VO后调用本接口 CNend
+\param CNcomment:无 CNend
+\retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_DEV_CLOSE_ERR  vo deinited failed. CNcomment:VO关闭失败 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_DeInit(HI_VOID);
+
+/**
+\brief create the window.CNcomment:创建WINDOW CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] pWinAttr   a pointer typeof HI_UNF_WINDOW_ATTR_S.CNcomment:WINDO属性结构指针 CNend
+\param[in] phWindow   the window handler to be created.CNcomment:创建的WINDOW句柄 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_CREATE_ERR     CNcomment:创建失败 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_CreateWindow(const HI_UNF_WINDOW_ATTR_S *pWinAttr, HI_HANDLE *phWindow);
+
+/**
+\brief create the window.CNcomment:创建采用物理坐标系的WINDOW CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] pWinAttr   a pointer typeof HI_UNF_WINDOW_ATTR_S.CNcomment:WINDO属性结构指针 CNend
+\param[in] phWindow   the window handler to be created.CNcomment:创建的WINDOW句柄 CNend
+\param[in] bVirtScreen   flag indicates whether creating with virtscreen coordinate.CNcomment:是否采用虚拟坐标系 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_CREATE_ERR     CNcomment:创建失败 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_CreateWindowExt(const HI_UNF_WINDOW_ATTR_S* pWinAttr,
+                                  HI_HANDLE *phWindow,
+                                  HI_BOOL bVirtScreen);
+
+/**
+\brief  destroy the given window.CNcomment:销毁WINDOW CNend
+\attention \n
+user should disable window before call this func
+CNcomment:请先调用接口disable窗口， 再调用此接口 CNend
+\param[in] hWindow    the input window handler. CNcomment:WINDOW句柄 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT   VO not inited. CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_DestroyWindow(HI_HANDLE hWindow);
+
+
+/**
+\brief to enable or disable the given window.CNcomment:使能/禁止WINDOW CNend
+\attention \n
+Window can only be disabled after the corresponding avplay is stopped, else data will overflow.
+CNcomment:只有先将AVPLAY的VID通道stop后，才能禁止window，否则将引起数据的溢出 CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] bEnable     the flag  of enable or disable window. CNcomment:使能/禁止标志 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_SetWindowEnable(HI_HANDLE hWindow, HI_BOOL bEnable);
+
+/**
+\brief get the status of the given window: enable or not.CNcomment:获取WINDOW的使能状态 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] pbEnable    the status of window:enable or disable.CNcomment:使能/禁止标志. CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowEnable(HI_HANDLE hWindow, HI_BOOL *pbEnable);
+
+/**
+\brief set the attribution of the given window.CNcomment:设置WINDOW属性 CNend
+\attention \n
+the two members of pWinAttr:enDisp and bVirtual are fixed when window created, and they can't be modified here.
+Each value as HI_UNF_WINDOW_ATTR_S Definition
+CNcomment:enDisp和bVirtual参数一旦创建后就不能再进行修改。参数修改参照HI_UNF_WINDOW_ATTR_S的参数说明。 CNend
+\param[in] hWindow    the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] pWinAttr   the pointer of windows attr.CNcomment:WINDO属性结构指针 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT   VO not inited. CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_SetWindowAttr(HI_HANDLE hWindow, const HI_UNF_WINDOW_ATTR_S *pWinAttr);
+
+/**
+\brief get the attribution of the given window.CNcomment:获取WINDOW属性 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] pWinAttr    the pointer of windows attr. CNcomment:WINDO属性结构指针 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited. CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowAttr(HI_HANDLE hWindow, HI_UNF_WINDOW_ATTR_S *pWinAttr);
+
+/**
+\brief get the frame from given window.CNcomment:获取WINDOW的Frame信息 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW句柄 CNend
+\param[out] pstFrameinfo  frame information. CNcomment:Frame信息 CNend
+\param[in] u32TimeoutMs wait time in ms.CNcomment:等待时间，毫秒为单位 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT   VO not inited.CNcomment: VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_AcquireFrame(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo, HI_U32 u32TimeoutMs);
+
+/**
+\brief return the frame back to the given window, used for 3d graphics testing.CNcomment:释放用户获取WINDOW的Frame，专门用于3D图形测试 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW句柄 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_ReleaseFrame(HI_HANDLE hWindow,HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo);
+
+/**
+\brief set the zorder of the given window.CNcomment:设置WINDOW的Z序 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow    the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] enZFlag    how to adjust zorder. CNcomment:Z序调节方式 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT   VO not inited. CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_SetWindowZorder(HI_HANDLE hWindow, HI_LAYER_ZORDER_E enZFlag);
+
+/**
+\brief get the zorder of the given window.CNcomment:获取WINDOW的Z序 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow       the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] pu32Zorder    value of zoder, bigger value means higher prioty. CNcomment:Z序数值，数值越大优先级越高 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowZorder(HI_HANDLE hWindow, HI_U32 *pu32Zorder);
+
+/**
+\brief attach the window with video source such as vi/avplay.CNcomment:把WINDOW与指定的AVPLAY/VI绑定 CNend
+\attention \n
+it can attach the handler of avplay or vi to the window.
+CNcomment:可以将AVPLAY或VI的句柄绑定到WINDOW上。 CNend
+\param[in] hWindow     the input window handler. CNcomment:WINDOW句柄 CNend
+\param[in] hSrc        the handler of video source. CNcomment:数据源句柄 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params. CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_AttachWindow(HI_HANDLE hWindow, HI_HANDLE hSrc);
+
+
+/**
+\brief detach the window from the video source such as avplay or vi.CNcomment:把WINDOW与指定的AVPLAY/VI解绑定 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] hSrc        the handler of video source.CNcomment:数据源句柄 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR      null pointer.CNcomment: 输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_DetachWindow(HI_HANDLE hWindow, HI_HANDLE hSrc);
+
+/**
+\brief Set frost glass effect level at one window .CNcomment:在窗口中设置毛玻璃效果的等级 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow         the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] enWinFrostMode  Frost glass level.CNcomment:效果强度等级 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_SetFrostGlassLevel(HI_HANDLE hWindow, HI_UNF_WINDOW_FROST_E enWinFrostMode);
+
+/**
+\brief Get frost glass effect level at one window .CNcomment:获取窗口中设置毛玻璃效果的等级 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] *penWinFrostMode  Frost glass level.CNcomment:效果强度等级 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_GetFrostGlassLevel(HI_HANDLE hWindow, HI_UNF_WINDOW_FROST_E* penWinFrostMode);
+
+/**
+\brief  to freeze the video content of given window.CNcomment:冻结WINDOW的显示内容 CNend
+\attention \n
+the display will be freezed after calling this func, but backgrounddly,the data flow is normal from video decoder.
+so when freezing is cacelled, the newest video content can be display at once.
+CNcomment:此功能用于在播放过程中冻结屏幕显示内容，此时WINDOW中的数据流继续运行，\n
+因此取消冻结后，会立刻显示最新的内容。 CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] bEnable           shows whether to freeze window.CNcomment:使能/禁止标志 CNend
+\param[in] enWinFreezeMode   the mode of freeze.CNcomment:冻结的方式 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR      null pointer.CNcomment: 输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_FreezeWindow(HI_HANDLE hWindow, HI_BOOL bEnable, HI_UNF_WINDOW_FREEZE_MODE_E enWinFreezeMode);
+
+/**
+\brief  to get the freeze status of the given window.CNcomment:获取窗口的冻结状态 CNend
+\attention \n
+\param[in] hWindow            the input window handler.CNcomment:WINDOW句柄 CNend
+\param[out] pbEnable           shows whether to freeze window.CNcomment:使能/禁止标志 CNend
+\param[out] penWinFreezeMode   the mode of freeze.CNcomment:冻结的方式 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR      null pointer.CNcomment: 输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowFreezeStatus(HI_HANDLE hWindow, HI_BOOL *pbEnable, HI_UNF_WINDOW_FREEZE_MODE_E *penWinFreezeMode);
+
+
+/**
+\brief reset the window.CNcomment:复位WINDOW CNend
+\attention \n
+this function can reset buffers of the given window, and black frame or the last frame will be displayed according configuration.
+CNcomment:此功能清空window中的缓冲，根据参数显示黑帧或最后一帧。 CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] enWinFreezeMode   method of freeze the window.CNcomment:复位的方式 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_ResetWindow(HI_HANDLE hWindow, HI_UNF_WINDOW_FREEZE_MODE_E enWinFreezeMode);
+
+/**
+\brief pass the external allocated buffer to this function to test 3d graphics.CNcomment:向WINDOW传递用户外部分配的buffer，专门用于3D图形测试 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] pstBufAttr  external buffer.CNcomment:外部的buffer CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_AttachExternBuffer(HI_HANDLE hWindow,HI_UNF_BUFFER_ATTR_S* pstBufAttr);
+
+/**
+\brief to set the work mode of window: quick output or not. Deinterlace alg will be disabled when quick output is enabled.
+CNcomment:设置WINDOW是否工作在快速输出模式，快速输出模式强制关闭去隔行算法 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in] hWindow     the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] bQuickOutputEnable  whether determine the output mode of window. CNcomment:快速输出模式使能/禁止标志 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment: 输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_SetQuickOutputEnable(HI_HANDLE hWindow, HI_BOOL bQuickOutputEnable);
+
+/**
+\brief to get the work mode of window: quick output or not.
+CNcomment:获取WINDOW是否工作在快速输出模式 CNend
+\attention \n
+CNcomment:无 CNend
+\param[in]  hWindow     the input window handler.CNcomment:WINDOW句柄 CNend
+\param[out] pbQuickOutputEnable  whether determine the output mode of window. CNcomment:快速输出模式使能/禁止标志 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment: 输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_GetQuickOutputStatus(HI_HANDLE hWindow, HI_BOOL *pbQuickOutputEnable);
+
+/**
+\brief  to set the filed mode of given window.CNcomment:设置窗口的场播放模式 CNend
+\attention \n
+when fast-backward playing, there will be no abnormity through calling this func. But calling of this
+func is forbidden when normal playing. It should be called after HI_UNF_VO_AttachWindow.
+CNcomment:通过设置此接口使能，保证快退不会出现场图像回退的现象，在正常播放时，\n
+请设置为禁止，默认为禁止。HI_UNF_VO_AttachWindow调用之后使用有效。 CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] bEnable           wether to enable field play.CNcomment:使能/禁止标志 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\retval ::HI_ERR_VO_WIN_UNSUPPORT  unsupported operation.CNcomment:操作不支持 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_SetWindowFieldMode(HI_HANDLE hWindow, HI_BOOL bEnable);
+
+/**
+\brief  to get the filed mode of given window.CNcomment:获取窗口的场播放模式 CNend
+\attention \n
+\param[in] hWindow           the input window handler.CNcomment:WINDOW句柄 CNend
+\param[out] pbEnable         wether to enable field play.CNcomment:使能/禁止标志 CNend
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT    illegal operation.CNcomment:操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\retval ::HI_ERR_VO_WIN_UNSUPPORT  unsupported operation.CNcomment:操作不支持 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_GetWindowFieldMode(HI_HANDLE hWindow, HI_BOOL *pbEnable);
+
+
+/**
+\brief capture the current frame of given window.CNcomment:捕获WINDOW的当前帧 CNend
+\attention \n
+\param[in] hWindow           the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] pstCapPicture
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment: 输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT   illegal operation.CNcomment: 操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_CapturePicture(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstCapPicture);
+
+
+/**
+\brief if you capture picture is finished, release the memory.CNcomment:捕获完毕，释放捕获的内存区域 CNend
+\attention \n
+this function will release captured picture, so user should call this function
+after you used this captured picture.
+CNcomment:由于该函数会释放被捕获的一帧，所以用户需要在用完捕获帧之后再调用此接口 CNend
+\param[in] hWindow           the input window handler.CNcomment:WINDOW句柄 CNend
+\param[in] pstCapPicture
+\retval ::HI_SUCCESS CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO not inited.CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment: 输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\retval ::HI_ERR_VO_INVALID_OPT   illegal operation.CNcomment: 操作非法 CNend
+\retval ::HI_ERR_VO_WIN_NOT_EXIST  windows not exist.CNcomment:窗口不存在 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_CapturePictureRelease(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstCapPicture);
+
+/**
+\brief set window rotion type.CNcomment:设置窗口的旋转类型 CNend
+\attention \n
+3716/3712: not support
+CNcomment:3716/3712不支持 CNend
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[in] enRotation    rotion type.CNcomment:旋转类型 CNend
+\retval ::HI_SUCCESS openned success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT  VO not inited. CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_SetRotation(HI_HANDLE hWindow, HI_UNF_VO_ROTATION_E enRotation);
+
+
+/**
+\brief get window rotion type.CNcomment:获取窗口的旋转句柄 CNend
+\attention \n
+3716/3712: not support
+CNcomment:3716/3712不支持 CNend
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[in] enRotation    rotion type.CNcomment:旋转类型 CNend
+\retval ::HI_SUCCESS openned success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT  VO not inited. CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_GetRotation(HI_HANDLE hWindow, HI_UNF_VO_ROTATION_E *penRotation);
+
+/**
+\brief flip window.CNcomment:翻转window CNend
+\attention \n
+3716/3712: not support
+CNcomment:3716/3712不支持 CNend
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[in] bHoriFlip    horizon flip.CNcomment:水平翻转 CNend
+\param[in] bVertFlip    vertical flip.CNcomment:垂直翻转 CNend
+\retval ::HI_SUCCESS openned success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT  VO not inited. CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_SetFlip(HI_HANDLE hWindow, HI_BOOL bHoriFlip, HI_BOOL bVertFlip);
+
+/**
+\brief get fliping tpye of window.CNcomment:获得窗口的翻转类型 CNend
+\attention \n
+3716/3712: not support
+CNcomment:3716/3712不支持 CNend
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[in] bHoriFlip    horizon flip flag.CNcomment:水平翻转标志 CNend
+\param[in] bVertFlip    vertical flip flag.CNcomment:垂直翻转标志 CNend
+\retval ::HI_SUCCESS openned success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT  VO not inited. CNcomment:VO未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA  illegal params.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR       null pointer.CNcomment:输入指针为空 CNend
+\see \n
+CNcomment:无 CNend
+*/
+HI_S32 HI_UNF_VO_GetFlip(HI_HANDLE hWindow, HI_BOOL *pbHoriFlip, HI_BOOL *pbVertFlip);
+
+/**
+\brief set video stereo depth for 3D output.CNcomment:设置3D输出视频景深 CNend
+\attention \n
+3716/3712: not support.Only take effect in 3D output mode.
+CNcomment: 3716/3712不支持 .仅在3D输出时有效 CNend
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[in] s32Depth Depth of filed. the range is [-50,50].CNcomment:景深，取值为[-50,50]. CNend
+\retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO 未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_VO_SetStereoDetpth(HI_HANDLE hWindow, HI_S32 s32Depth);
+
+/**
+\brief get video stereo depth for 3D output.CNcomment: 获取3D输出视频景深 CNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[out] ps32Depth Depth of filed. the range is [-50,50].CNcomment:景深，取值为[-50,50]. CNend
+\retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO 未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\see \n
+none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_VO_GetStereoDetpth(HI_HANDLE hWindow, HI_S32 *ps32Depth);
+
+/**
+\brief Queue frame into the specified window.CNcomment: 向特定窗口中推帧，用于显示。 CNend
+\attention \n
+\param[in] hWindow    window handle. CNcomment:窗口句柄 CNend
+\param[in] pstFrameinfo  frame infor to be passed into. CNcomment:要传入的帧信息. CNend
+\retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO 未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR   null input ptr.CNcomment:空指针 CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment:无效帧信息 CNend
+\retval ::HI_ERR_VO_BUFQUE_FULL   buffer is full .CNcomment:buffer 处于满的状态 CNend
+\retval ::HI_ERR_VO_INVALID_OPT   invalid opt.CNcomment:无效操作 CNend
+\see \n
+none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_VO_QueueFrame(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo);
+
+/**
+\brief dequeue frame from window.CNcomment: 回收推到窗口的帧CNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[out] pstFrameinfo  frame infor dequeued from window .CNcomment:从窗口中获取的帧信息. CNend
+\param[in] u32TimeoutMs  timeout when get frame failed .CNcomment:超时值，用于获取帧失败时的超时退出. CNend
+\retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO 未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_NULL_PTR   null input ptr.CNcomment:空指针 CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment:无效帧信息 CNend
+\see \n
+none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_VO_DeQueueFrame(HI_HANDLE hWindow, HI_UNF_VIDEO_FRAME_INFO_S *pstFrameinfo, HI_U32 u32TimeoutMs);
+
+/**
+\brief set  window alpha.CNcomment: 设置窗口的alpha值CNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[in] u32Alpha  window alpha .CNcomment:窗口的alpha值. CNend
+\retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO 未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment:无效帧信息 CNend
+\see \n
+none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_VO_SetWindowAlpha(HI_HANDLE hWindow, HI_U32 u32Alpha);
+/**
+\brief get  window alpha.CNcomment: 获取窗口的alpha值CNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[in] pu32Alpha  window alpha .CNcomment:窗口的alpha值. CNend
+\retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO 未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment:无效帧信息 CNend
+\see \n
+none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_VO_GetWindowAlpha(HI_HANDLE hWindow, HI_U32 *pu32Alpha);
+
+
+/**
+\brief get  window play information.CNcomment: 获取窗口播放信息CNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[in] pstPlayInfo  window play information .CNcomment:窗口的播放信息. CNend
+\retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO 未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment:无效帧信息 CNend
+\see \n
+none.CNcomment:无 CNend
+ */
+
+HI_S32 HI_UNF_VO_GetWindowPlayInfo(HI_HANDLE hWindow, HI_UNF_WIN_PLAY_INFO_S *pstPlayInfo);
+
+
+/**
+\brief get  window frame delay time.CNcomment: 获取窗口帧显示等待时间CNend
+\attention \n
+\param[in] hWindow    window handle .CNcomment:窗口句柄 CNend
+\param[in] pu32DelayMs  window frame delay time.CNcomment:帧显示等待时间. CNend
+\retval ::HI_SUCCESS  success.CNcomment:成功 CNend
+\retval ::HI_ERR_VO_NO_INIT    VO uninitialization.CNcomment:VO 未初始化 CNend
+\retval ::HI_ERR_VO_INVALID_PARA   invalid input parameter.CNcomment:输入参数非法 CNend
+\retval ::HI_ERR_VO_FRAME_INFO_ERROR   invalid frame infor.CNcomment:无效帧信息 CNend
+\see \n
+none.CNcomment:无 CNend
+ */
+HI_S32 HI_UNF_VO_GetDelayMs(const HI_HANDLE hWindow, HI_U32 *pu32DelayMs);
+/** @} */  /** <!-- ==== API declaration end ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif
+/************************************** The End Of File **************************************/
diff -uNr a/include/hi_unf_vp.h b/include/hi_unf_vp.h
--- a/include/hi_unf_vp.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_vp.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,531 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2011, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_unf_vp.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2011/03/25
+  Description   :
+  History       :
+  1.Date        : 2011/03/25
+    Author      :
+    Modification: Created file
+
+ *******************************************************************************/
+
+/**
+ * \file
+ * \brief Describes the information about the video phone (VP) engine. CNcomment: 提供VP视频引擎的相关信息CNend
+ */
+#ifndef __HI_UNF_VP_H__
+#define __HI_UNF_VP_H__
+#include <netinet/in.h>
+#include "hi_common.h"
+#include "hi_unf_common.h"
+#include "hi_unf_venc.h"
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup      VP*/
+/** @{ */  /** <!-- [VP] */
+
+/** Video source mode */
+/**CNcomment: 视频源模式*/
+typedef enum hiUNF_VP_SOURCE_MODE_E
+{
+    HI_UNF_VP_SRC_MODE_USBCAM = 0,   /**<USB camera source mode *//**<CNcomment: USB 摄像头源模式*/
+    HI_UNF_VP_SRC_MODE_VI,           /**<VI camera source mode *//**<CNcomment: VI源模式*/
+    HI_UNF_VP_SRC_MODE_BUTT,
+} HI_UNF_VP_SOURCE_MODE_E;
+
+/**Video source attribute*/
+/**CNcomment: 视频源属性 */
+typedef struct hiUNF_VP_SOURCE_ATTR_S
+{
+    HI_HANDLE               hSrc;        /**<video source handle, can be set to VI handle or USB camera handle in v4l2*//**<CNcomment: 视频输入句柄，VI句柄或者v4l2中USB摄像头的句柄*/
+    HI_UNF_VP_SOURCE_MODE_E enSrcMode;   /**<Video source mode *//**<CNcomment: 视频源模式*/
+    HI_U32                  u32VIBufNum; /**<VI buffer number*//**<CNcomment:VI缓冲区个数*/
+} HI_UNF_VP_SOURCE_ATTR_S;
+
+/**Network attribute*/
+/**CNcomment: 网络属性 */
+typedef union hiUNF_VP_NET_ATTR_U
+{
+    struct sockaddr_in  stIpv4Attr;      /**<IPV4 attribute*//**<CNcomment:IPV4属性*/
+    struct sockaddr_in6 stIpv6Attr;      /**<IPV6 attribute*//**<CNcomment:IPV6属性*/
+} HI_UNF_VP_NET_ATTR_U;
+
+/**RTP attribute*/
+/**CNcomment: RTP属性*/
+typedef struct hiUNF_VP_RTP_ATTR_S
+{
+    HI_U32 u32SplitSize;                       /**< split size, should be less than MTU size*//**<CNcomment:分片大小*/
+    HI_U32 u32PayLoadType;                     /**< pay load type *//**<CNcomment:负载类型*/
+    HI_U32 u32SortDepth;                       /**< sort in order when receive RTP packets, this para indicates sort depth *//**<CNcomment:排序深度*/
+    HI_U32 u32RecvBufSize;                     /**< buffer size, usually 1500 bytes , should be bigger than u32SplitSize*//**<CNcomment:接收buf，应该大于分片大小*/
+    HI_U32 u32RecvBufNum;                      /**< buffer number (total_size = u32BufSize * u32BufNum) *//**<CNcomment:接收buf个数*/
+} HI_UNF_VP_RTP_ATTR_S;
+
+/**Video engine attribute*/
+/**CNcomment: 视频引擎属性 */
+typedef struct hiUNF_VP_ATTR_S
+{
+    HI_UNF_VENC_CHN_ATTR_S stVencAttr;        /**<VENC attribute*//**<CNcomment: 视频编码器属性*/
+    HI_UNF_VCODEC_TYPE_E   enDecType;         /**<VDEC attribute*//**<CNcomment: 视频解码器属性*/
+    HI_BOOL                bIsIpv4;           /**<whether use IPV4 attribute, use 1 to demonstrate IPV4, use 0 to demonstrate IPV6 *//**<CNcomment: 是否使用IPV4参数，1表示使用IPV4，0表示使用IPV6*/
+    HI_UNF_VP_NET_ATTR_U   stLocalNetAttr;    /**<Local network attribute*//**<CNcomment: 本地网络属性*/
+    HI_UNF_VP_NET_ATTR_U   stRemoteNetAttr;   /**<Remote network attribute*//**<CNcomment: 远端网络属性*/
+    HI_UNF_VP_RTP_ATTR_S   stRtpAttr;         /**<RTP attribute. Generally, We highly recommend that you don't modify it.*//**<CNcomment: RTP属性，一般不建议修改*/
+} HI_UNF_VP_ATTR_S;
+
+/**Remote mode*/
+/**CNcomment: 远端模式*/
+typedef enum hiUNF_VP_REMOTE_MODE_E
+{
+    HI_UNF_VP_RMT_MODE_SEND = 0x1,         /**<Send local video to remote mode*//**<CNcomment: 发送本地视频到远端模式*/
+    HI_UNF_VP_RMT_MODE_RECV = 0x2,         /**<Receive remote video mode*//**<CNcomment: 接收远端视频模式*/
+    HI_UNF_VP_RMT_MODE_BUTT = 0x4,
+} HI_UNF_VP_REMOTE_MODE_E;
+
+/**RTCP configure of video engine*/
+/**CNcomment: 视频引擎RTCP配置信息 */
+typedef struct hiUNF_VP_RTCP_CFG_S
+{
+    HI_U32 u32EnableFlag;     /**<Enable RTCP function: 0--disable, 1--enable*//**<CNcomment: RTCP统计使能: 0--不使能, 1--使能*/
+    HI_U32 u32SendInterval;   /**<Send interval of RTCP report, [500, 65535]ms, must be integer of 500ms*//**<CNcomment: RTCP报告发送间隔, [500, 65535] ms , 必须为500ms的整数倍*/
+} HI_UNF_VP_RTCP_CFG_S;
+
+/**RTCP statistics information*/
+/**CNcomment: RTCP 统计信息*/
+typedef struct hiUNF_VP_RTCP_STATIC_INFO_S
+{
+    HI_U32 u32TotalLostPacket;     /**<Total lost packet, this value may reset to 0 when network connection become abnormal *//**<CNcomment: 数据丢包统计，网络连接异常时，改数据可能清零*/
+    HI_U32 u32LossFraction;        /**<Lost rate(%)*//**<CNcomment: 丢包率(%) */
+    HI_U32 u32Jitter;              /**<Jitter(ms)*//**<CNcomment: 平均抖动(ms) */
+    HI_U32 u32Delay;               /**<Delay(ms)*//**<CNcomment: 平均时延(ms) */
+} HI_UNF_VP_RTCP_STATIC_S;
+
+/**Statistic information of network*/
+/**CNcomment: 视频引擎网络统计信息 */
+typedef struct hiUNF_VP_NET_STA_S
+{
+    HI_U32                  u32SendPacketNum; /**<Total send packet number*//**<CNcomment: 发送包总数*/
+    HI_U32                  u32SendBytes;     /**<Total send bytes*//**<CNcomment: 发送字节数*/
+    HI_U32                  u32RecvPacketNum; /**<Total recv packet number*//**<CNcomment: 接收包总数*/
+    HI_U32                  u32RecvBytes;      /**<Total recv bytes*//**<CNcomment: 接收字节数*/
+    HI_UNF_VP_RTCP_STATIC_S stSendInfo;       /**<Send information*//**<CNcomment: 发送统计*/
+    HI_UNF_VP_RTCP_STATIC_S stRecvInfo;       /**<Reveive information*//**<CNcomment: 接收统计*/
+} HI_UNF_VP_NET_STA_S;
+
+/**Record stream format*/
+/**CNcomment: 录制码流类型*/
+typedef enum hiUNF_VP_RECORD_FORMAT_E
+{
+    HI_UNF_VP_RECORD_TS = 0x1,         /**<Record TS stream*//**<CNcomment: 录制TS流*/
+    HI_UNF_VP_RECORD_BUTT = 0x2,
+} HI_UNF_VP_RECORD_FORMAT_E;
+
+/**Statistic information of video*/
+/**CNcomment: 视频引擎统计信息 */
+typedef struct hiUNF_VP_VIDEO_STATICS_S
+{
+    HI_U32                  u32CaptureFrmCnt;    /**<Total camera capture frame number*//**<CNcomment: 摄像头采集帧总数*/
+    HI_U32                  u32EncoderOutFrmCnt; /**<Total encoder output frame number*//**<CNcomment: 编码器输出帧数*/
+    HI_U32                  u32EncoderOutBytes;  /**<Total encoder output bytes*//**<CNcomment: 编码器输出字节*/
+    HI_U32                  u32DecoderInFrmCnt;  /**<Total decoder input frame number*//**<CNcomment: 解码器输入帧数*/
+    HI_U32                  u32DecoderInBytes;   /**<Total decoder input bytes*//**<CNcomment: 解码器输入字节*/
+} HI_UNF_VP_VIDEO_STATICS_S;
+
+
+/** @} */  /** <!-- ==== Structure Definition end ==== */
+
+/******************************* API declaration *****************************/
+/** \addtogroup      VP */
+/** @{ */  /** <!-- 【VP】 */
+
+/**
+ \brief Initializes the VP module. CNcomment: 初始化VP模块CNend
+ \attention \n
+Call this application programming interface (API) before creating VP by calling ::HI_UNF_VP_Create.
+CNcomment: 在调用::HI_UNF_VP_Create接口创建引擎之前，调用本接口CNend
+ \param N/A CNcomment: 无CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_DEV_NOT_EXIST The VP device does not exist. CNcomment: 设备不存在CNend
+ \retval ::HI_ERR_VP_DEV_OPEN_ERR The VP device fails to be started. CNcomment: 设备打开错误CNend
+ \see \n
+N/A CNcomment: 无CNend
+ */
+HI_S32 HI_UNF_VP_Init(HI_VOID);
+
+/**
+ \brief Deinitialize the VP module. CNcomment: 去初始化VP模块CNend
+ \attention \n
+Call this API after destroying all VPs by calling ::HI_UNF_VP_DestroyChannel.
+CNcomment: 在调用::HI_UNF_VP_Destroy接口销毁VP后，调用本接口CNend
+ \param N/A CNcomment: 无CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_NOT_INIT The VP is not initialized. CNcomment: VP未初始化CNend
+ \see \n
+N/A CNcomment: 无CNend
+ */
+HI_S32 HI_UNF_VP_DeInit(HI_VOID);
+
+/**
+ \brief Obtain the default parameter values of VP. CNcomment: 获取VP缺省参数CNend
+ \attention \n
+Call this API before creating VP by calling ::HI_UNF_VP_Create. This enables you to set parameters conveniently.
+CNcomment: 在调用::HI_UNF_VP_Create接口创建VP之前，调用本接口，方便填写参数CNend
+ \param[in] N/A CNcomment: 无CNend
+ \param[out] pstDefAttr Pointer to the default VP attributes. For details, see :HI_UNF_VP_ATTR_S. CNcomment: 指针类型，VP默认属性，参见:HI_UNF_VP_ATTR_S CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: 空指针CNend
+ \see \n
+N/A CNcomment: 无CNend
+ */
+
+HI_S32 HI_UNF_VP_GetDefaultAttr(HI_UNF_VP_ATTR_S *pstDefAttr);
+
+/**
+ \brief Create VP. CNcomment: 创建VP  CNend
+ \attention \n
+N/A CNcomment: 无CNend
+ \param[in]  pstAttr parameter CNcomment: VP参数CNend
+ \param[out] phVP Pointer to the VP handle. CNcomment: 指针类型，VP句柄CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: 空指针CNend
+ \retval ::HI_ERR_VP_NOT_SUPPORT The input parameter is invalid. CNcomment: 输入参数非法CNend
+ \retval ::HI_ERR_VP_NOT_SUPPORT The mode is not supported. CNcomment: 不支持模式CNend
+ \see \n
+N/A CNcomment: 无CNend
+ */
+HI_S32 HI_UNF_VP_Create(const HI_UNF_VP_ATTR_S *pstAttr, HI_HANDLE *phVP);
+
+/**
+ \brief Destroy VP. CNcomment: 销毁VP  CNend
+ \attention \n
+N/A CNcomment: 无CNend
+ \param[in] hVP VP handle CNcomment: VP句柄CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_NOT_INIT The VP module is not initialized. CNcomment: VP未初始化CNend
+ \retval ::HI_ERR_VP_INVALID_HANDLE The VP handle is invalid. CNcomment: 非法的VP句柄CNend
+ \retval Other values: A fails to be destroyed. CNcomment: 其它 销毁失败CNend
+ \see \n
+N/A CNcomment: 无CNend
+ */
+HI_S32 HI_UNF_VP_Destroy(HI_HANDLE hVP);
+
+/**
+ \brief Attach input source of VP. CNcomment: 绑定视频输入源CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP 句柄CNend
+ \param[in] stSrcAttr Video input attribute. CNcomment:视频输入通道属性CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数CNend
+ \retval Other values: Failed to attach input source of VP. CNcomment: 绑定视频输入源失败CNend
+ \see \n
+N/A CNcomment: 无CNend
+ */
+HI_S32 HI_UNF_VP_AttachSource(HI_HANDLE hVP, HI_UNF_VP_SOURCE_ATTR_S *pstSrcAttr);
+
+/**
+ \brief Attach local window of VP. CNcomment: 绑定本地视频窗口CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP 句柄CNend
+ \param[in] hLocalWin Local window handle. CNcomment:本地视频窗口句柄CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数CNend
+ \retval Other values: Failed to attach local window of VP. CNcomment: 绑定本地视频窗口失败CNend
+ \see \n
+N/A CNcomment: 无CNend
+ */
+HI_S32 HI_UNF_VP_AttachLocalWin(HI_HANDLE hVP, HI_HANDLE hLocalWin);
+
+/**
+ \brief Attach remote window of VP. CNcomment: 绑定远端视频窗口CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP 句柄CNend
+ \param[in] hRemoteWin Remote window handle. CNcomment:远端视频窗口句柄CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数CNend
+ \retval Other values: Failed to attach remote window of VP. CNcomment: 绑定远端视频窗口失败CNend
+ \see \n
+N/A CNcomment: 无CNend
+ */
+HI_S32 HI_UNF_VP_AttachRemoteWin(HI_HANDLE hVP, HI_HANDLE hRemoteWin);
+
+/**
+ \brief Detach input source of VP. CNcomment: 去绑定视频输入源CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP 句柄CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数CNend
+ \retval Other values: Failed to detach input source of VP. CNcomment: 去绑定视频输入源失败CNend
+ \see \n
+N/A CNcomment: 无CNend
+ */
+HI_S32 HI_UNF_VP_DetachSource(HI_HANDLE hVP);
+
+/**
+ \brief Detach local window of VP. CNcomment: 去绑定本地视频窗口CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP 句柄CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数CNend
+ \retval Other values: Failed to detach local window of VP. CNcomment: 去绑定本地视频窗口失败CNend
+ \see \n
+N/A CNcomment: 无CNend
+ */
+HI_S32 HI_UNF_VP_DetachLocalWin(HI_HANDLE hVP);
+
+/**
+ \brief Detach remote window of VP. CNcomment: 去绑定远端视频窗口CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP句柄CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数CNend
+ \retval Other values: Failed to detach remote window of VP. CNcomment: 去绑定远端视频窗口失败CNend
+ \see \n
+N/A CNcomment: 无CNend
+ */
+HI_S32 HI_UNF_VP_DetachRemoteWin(HI_HANDLE hVP);
+
+/**
+ \brief Obtains the configuration of VP. CNcomment: 获取VP 配置CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP 句柄CNend
+ \param[out] pstAttr Pointer to VP attributes. For details, see :HI_UNF_VP_ATTR_S. CNcomment: 指针类型，VP 属性，参见:HI_UNF_VP_ATTR_S  CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: 空指针CNend
+ \retval Other values:Fail to obtain attributes. CNcomment: 获取通道属性失败CNend
+ \see \n
+N/A CNcomment: 无CNend
+ */
+
+HI_S32 HI_UNF_VP_GetAttr(HI_HANDLE hVP, HI_UNF_VP_ATTR_S *pstAttr);
+
+/**
+ \brief Modifies the configuration of VP. CNcomment: 修改VP配置CNend
+ \attention \n
+You are advised to obtain the current configuration by calling HI_UNF_VP_GetChAttr(), and modify parameter values as required.
+CNcomment: 建议先调用HI_UNF_VP_GetChAttr()获取当前配置，再对参数做必要修改CNend
+ \param[in] hVP VP handle CNcomment: VP 句柄CNend
+ \param[in] pstAttr Pointer to VP attributes. For details, see :HI_UNF_VP_ATTR_S. CNcomment: 指针类型，VP 属性，参见:HI_UNF_VP_ATTR_S  CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: 空指针CNend
+ \retval Other values: Fail to modify attributes . CNcomment: 修改属性失败CNend
+ \see \n
+N/A CNcomment:无CNend
+ */
+HI_S32 HI_UNF_VP_SetAttr(HI_HANDLE hVP, const HI_UNF_VP_ATTR_S *pstAttr);
+
+/**
+ \brief Starts VP. CNcomment: VP开始运行CNend
+ \attention \n
+After setting parameters including the codec, video input (VI), and video output (VO) parameters, you can start the video engine by calling this API to transmit or receive data over the Internet and display the local or remote video output.
+CNcomment: 在参数准备好后，包括编解码器、VI/VO设置正确后，调用此接口可以启动视频引擎的运行，实现网络收发、显示本地、远端视频输出CNend
+ \param[in] hVP VP handle CNcomment: VP 句柄CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: 空指针CNend
+ \retval Other values: VP fails to be started. CNcomment:  VP开始运行失败CNend
+ \see \n
+N/A CNcomment: 无CNend
+ */
+HI_S32 HI_UNF_VP_Start(HI_HANDLE hVP);
+
+/**
+ \brief Stops VP. CNcomment: VP停止运行CNend
+ \attention \n
+After VP is started successfully, you can stop it by calling this API to freeze the screen or stop transmitting or receiving data over Internet. You can resume the VP by calling HI_UNF_VP_Start.
+CNcomment: 在VP正常启动运行后，可以通过此接口暂停运行，使画面冻结、网络收发暂停。可以调用HI_UNF_VP_Start恢复运行CNend
+ \param[in] hVP VP handle CNcomment: VP 句柄CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: 空指针CNend
+ \retval Other values: VP fails to be started. CNcomment: VP开始运行失败CNend
+ \see \n
+N/A CNcomment: 无CNend
+ */
+HI_S32 HI_UNF_VP_Stop(HI_HANDLE hVP);
+
+/**
+ \brief Previews the local video over VP. CNcomment: VP开始预览本地视频CNend
+ \attention \n
+After the VI and hLocalWin parameters are set, you can preview the local video by calling this API.
+CNcomment: 在VI和hLocalWin准备好之后，开始预览本地视频CNend
+ \param[in] hVP VP handle CNcomment: VP 句柄CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: 空指针CNend
+ \retval Other values: VP fails to be started. CNcomment: VP开始运行失败CNend
+ \see \n
+N/A CNcomment: 无CNend
+ */
+HI_S32 HI_UNF_VP_StartPreView(HI_HANDLE hVP);
+
+/**
+ \brief Stops previewing the local video over VP. CNcomment: VP预览本地视频CNend
+ \attention \n
+When a local video is previewed over VP, you can stop previewing the video by calling this API.
+CNcomment: 在VP预览本地视频后，调用停止预览CNend
+ \param[in] hVP VP handle CNcomment: VP 句柄CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: 空指针CNend
+ \retval Other values: VP fails to be started. CNcomment: 其它  VP开始运行失败CNend
+ \see \n
+N/A CNcomment: 无CNend
+ */
+HI_S32 HI_UNF_VP_StopPreView(HI_HANDLE hVP);
+
+/**
+ \brief Starts remote VP. CNcomment: VP启动远端  CNend
+ \attention \n
+Starts remote VP, this interface enables vp start sending local video to remote, or receiving remote video.
+CNcomment: 启动远端，可以单独启动发送本地视频到远端，或接收远端视频  CNend
+ \param[in] hVP VP handle CNcomment: VP 句柄  CNend
+ \param[in] enRmtMode remote mode CNcomment: 远端模式  CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功  CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数  CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: 空指针  CNend
+ \retval Other values: VP fails to be started. CNcomment: VP运行失败  CNend
+ \see \n
+N/A CNcomment: 无  CNend
+ */
+HI_S32 HI_UNF_VP_StartRemote(HI_HANDLE hVP, HI_UNF_VP_REMOTE_MODE_E enRmtMode);
+
+/**
+ \brief Stops remote VP. CNcomment: VP停止远端  CNend
+ \attention \n
+Stops remote VP, this interface enables vp stop sending local video to remote, or receiving remote video.
+CNcomment: 停止远端，可以单独停止发送本地视频到远端，或停止接收远端视频  CNend
+ \param[in] hVP VP handle CNcomment: VP 句柄  CNend
+ \param[in] enRmtMode remote mode CNcomment: 远端模式  CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功  CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数  CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: 空指针  CNend
+ \retval Other values: VP fails to be started. CNcomment: VP停止失败  CNend
+ \see \n
+N/A CNcomment: 无  CNend
+ */
+HI_S32 HI_UNF_VP_StopRemote(HI_HANDLE hVP, HI_UNF_VP_REMOTE_MODE_E enRmtMode);
+
+/**
+ \brief Configs RTCP over VP. CNcomment: VP配置RTCP  CNend
+ \attention \n
+When VP has been created, you can config RTCP to enable and config RTCP sending frequency by calling this API.
+CNcomment: 在创建VP后，调用该接口配置RTCP，可以使能以及调节RTCP发包频率CNend
+ \param[in] hVP VP handle CNcomment: VP句柄CNend
+ \param[out] pstRtcpCfg Pointer to config RTCP information, refer to HI_UNF_VP_RTCP_CFG_S. CNcomment: 指针类型，VP RTCP配置信息，参见:HI_UNF_VP_RTCP_CFG_S  CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: 空指针CNend
+ \retval Other value CNcomment: 其它CNend
+ \see \n
+N/A CNcomment: 无CNend
+ */
+HI_S32 HI_UNF_VP_ConfigRtcp(HI_HANDLE hVP, HI_UNF_VP_RTCP_CFG_S *pstRtcpCfg);
+
+/**
+ \brief Gets network statistics information over VP. CNcomment: VP获取网络统计信息CNend
+ \attention \n
+When VP has been started, you can get network statistics information to config parameter of video encoder by calling this API.
+CNcomment: 在运行VP后，调用该接口获取网络统计信息以调整编码器参数CNend
+ \param[in] hVP VP handle CNcomment: VP句柄CNend
+ \param[out] pstNetStatics Pointer to network statistics information of VP, refer to HI_UNF_VP_NET_STA_S. CNcomment: 指针类型，VP网络统计信息，参见:HI_UNF_VP_NET_STA_S  CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: 空指针CNend
+ \retval Other value CNcomment: 其它CNend
+ \see \n
+N/A CNcomment: 无CNend
+ */
+HI_S32 HI_UNF_VP_GetNetStatics(HI_HANDLE hVP, HI_UNF_VP_NET_STA_S *pstNetStatics);
+
+/**
+ \brief Gets VENC handle. CNcomment: 获取VENC句柄  CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP句柄  CNend
+ \param[out] phVenc Pointer to VENC handle. CNcomment: 指针类型，VENC句柄  CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功  CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数  CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: 空指针  CNend
+ \retval Other value CNcomment: 其它  CNend
+ \see \n
+N/A CNcomment: 无  CNend
+ */
+HI_S32 HI_UNF_VP_GetVencHandle(HI_HANDLE hVp, HI_HANDLE *phVenc);
+
+/**
+ \brief Gets AVPLAY handle that play remote video. CNcomment: 获取播放远端视频的AVPLAY句柄  CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP句柄  CNend
+ \param[out] phAvplay Pointer to AVPLAY handle. CNcomment: 指针类型，AVPLAY句柄  CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功  CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数  CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: 空指针  CNend
+ \retval Other value CNcomment: 其它  CNend
+ \see \n
+N/A CNcomment: 无  CNend
+ */
+HI_S32 HI_UNF_VP_GetAvplayHandle(HI_HANDLE hVp, HI_HANDLE *phAvplay);
+
+/**
+ \brief Start record stream. CNcomment: 开始录制码流  CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP句柄  CNend
+ \param[in] enRecordFmt Record stream format. CNcomment: 录制码流格式类型  CNend
+ \param[in] enRecordType Record type. CNcomment: 录制类型  CNend
+ \param[in] ucFullName Record stream full name, full directory included. CNcomment: 录制码流名称，带完整路径  CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功  CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数  CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: 空指针  CNend
+ \retval Other value CNcomment: 其它  CNend
+ \see \n
+N/A CNcomment: 无  CNend
+ */
+HI_S32 HI_UNF_VP_StartRecord(HI_HANDLE hVP, HI_UNF_VP_REMOTE_MODE_E enRecordType,
+                                 HI_UNF_VP_RECORD_FORMAT_E enRecordFmt, HI_CHAR * ucFullName);
+
+/**
+ \brief Stop record stream. CNcomment: 停止录制码流  CNend
+ \attention \n
+ \param[in] hVP VP handle CNcomment: VP句柄  CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功  CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数  CNend
+ \retval Other value CNcomment: 其它  CNend
+ \see \n
+N/A CNcomment: 无  CNend
+ */
+HI_S32 HI_UNF_VP_StopRecord(HI_HANDLE hVP);
+
+
+/**
+ \brief Gets video statistics information over VP. CNcomment: VP获取视频统计信息CNend
+ \param[in] hVP VP handle CNcomment: VP句柄CNend
+ \param[out] pstNetStatics Pointer to video statistics information of VP, refer to HI_UNF_VP_NET_STA_S. CNcomment: 指针类型，VP视频统计信息  CNend
+ \retval ::HI_SUCCESS Success CNcomment: 成功CNend
+ \retval ::HI_ERR_VP_INVALID_PARA The input parameter is invalid. CNcomment: 无效的输入参数CNend
+ \retval ::HI_ERR_VP_NULL_PTR The pointer is null. CNcomment: 空指针CNend
+ \retval Other value CNcomment: 其它CNend
+ \see \n
+N/A CNcomment: 无CNend
+ */
+HI_S32 HI_UNF_VP_GetVideoStatics(HI_HANDLE hVP, HI_UNF_VP_VIDEO_STATICS_S *pstVideoStatics);
+
+#ifdef __cplusplus
+ #if __cplusplus
+}
+ #endif
+#endif
+
+#endif
diff -uNr a/include/hi_unf_wdg.h b/include/hi_unf_wdg.h
--- a/include/hi_unf_wdg.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_unf_wdg.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,189 @@
+/******************************************************************************
+
+  Copyright (C), 2001-2014, HiSilicon Technologies Co., Ltd.
+******************************************************************************
+File Name       : hi_unf_wdg.h
+Version         : Initial draft
+Author          : HiSilicon multimedia software group
+Created Date    : 2008-06-05
+Last Modified by:
+Description     : Application programming interfaces (APIs) of the external chip software (ECS)
+Function List   :
+Change History  :
+******************************************************************************/
+#ifndef __HI_UNF_WDG_H__
+#define __HI_UNF_WDG_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif
+#endif
+
+#define HI_UNF_WDG_Open     HI_UNF_WDG_Init
+#define HI_UNF_WDG_Close    HI_UNF_WDG_DeInit
+
+/******************************* API Declaration *****************************/
+/** \addtogroup      WDG*/
+/** @{*/  /** <!-- [WDG] */
+
+/**
+ \brief Starts the WDG device.
+CNcomment:\brief 初始化WDG（Watch Dog）设备。CNend
+
+ \attention \n
+By default, the WDG device is disabled after it is started. In this case, you need to call HI_UNF_WDG_Enable to enable it.\n
+CNcomment:打开之后，WDG默认是禁止的，需要显式调用HI_UNF_WDG_Enable使能WDG设备。CNend\N
+
+ \param N/A          	CNcomment:无。CNend
+ \retval 0 Success.   	CNcomment:成功。CNend
+ \retval ::HI_ERR_WDG_FAILED_INIT	open failed
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_WDG_Init(HI_VOID);
+
+/**
+ \brief Stops the WDG device.
+CNcomment:\brief 去初始化WDG设备。CNend
+
+ \attention \n
+N/A
+ \param N/A          	CNcomment:无。CNend
+ \retval 0 Success.   	CNcomment:成功。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_WDG_DeInit(HI_VOID);
+
+/**
+ \brief Get the number of WDG device.
+CNcomment:\brief 获取WDG设备数量。CNend
+
+ \attention \n
+You can call this API to get thenumber of WDG chipset supports after the WDG device is started.
+CNcomment:打开WDG设备后，调用此接口获取芯片支持的WDG的数量。CNend
+
+ \param[out] pu32WdgNum  The number of WDG chipset supports        	CNcomment:芯片支持的WDG的数量。CNend
+ \retval 0 Success  CNcomment:成功 CNend
+ \retval ::HI_FAILURE The Parameter pu32WdgNum is NULL.       CNcomment:参数指针pu32WdgNum为空。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_WDG_GetCapability(HI_U32 *pu32WdgNum);
+
+/**
+ \brief Enables the WDG device.
+CNcomment:\brief 使能WDG设备。CNend
+
+ \attention \n
+You must call HI_UNF_WDG_Enable after the WDG device is started.
+CNcomment:打开WDG设备后，必须显式调用使能接口。CNend
+
+ \param[in] u32WdgNum WDG No. to operate.        	CNcomment:执行操作的WDG号。CNend
+ \retval 0 Success.  	CNcomment:成功。CNend
+ \retval ::HI_ERR_WDG_NOT_INIT The WDG device is not initialized.       CNcomment:WDG设备未初始化。CNend
+ \retval ::HI_ERR_WDG_INVALID_PARA The Paramteter is invalid. 			CNcomment:参数无效。CNend
+ \retval ::HI_ERR_WDG_FAILED_ENABLE enable watchdog failed.				CNcomment:使能看门狗失败。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_WDG_Enable(HI_U32 u32WdgNum);
+
+/**
+ \brief Disables the WDG device.
+CNcomment:\brief 禁止WDG设备。CNend
+
+ \attention \n
+After calling this API, you cannot feed and reset the WDG.
+CNcomment:调用此函数后，喂狗和复位操作不起作用。CNend
+
+ \param[in] u32WdgNum WDG No. to operate.        	CNcomment:执行操作的WDG号。CNend
+ \retval 0 Success. CNcomment:成功。CNend
+ \retval ::HI_ERR_WDG_NOT_INIT  The WDG device is not initialized.      CNcomment:WDG设备未初始化。CNend
+ \retval ::HI_ERR_WDG_INVALID_PARA The Paramteter is invalid. 			CNcomment:参数无效。CNend
+ \retval ::HI_ERR_WDG_FAILED_DISABLE  disable watchdog failed.			CNcomment:禁止看门狗失败。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_WDG_Disable(HI_U32 u32WdgNum);
+
+/**
+ \brief Obtains the interval of feeding the WDG.
+CNcomment:\brief 获取喂狗时间间隔。CNend
+
+ \attention \n
+The interval precision is as high as 1000 ms.
+CNcomment:时间间隔精确到1000ms。CNend
+
+ \param[in] u32WdgNum WDG No. to operate.        	CNcomment:执行操作的WDG号。CNend
+ \param[in] pu32Value  Interval of feeding the WDG, in ms.             	CNcomment:喂狗时间间隔，单位为ms。CNend
+ \retval 0 Success.                                                  	CNcomment:成功。CNend
+ \retval ::HI_ERR_WDG_NOT_INIT  The WDG device is not initialized.     	CNcomment:WDG 设备未初始化。CNend
+ \retval ::HI_ERR_WDG_INVALID_PARA  The WDG input pointer is invalid.  	CNcomment:WDG输入指针无效。CNend
+ \retval ::HI_ERR_WDG_FAILED_SETTIMEOUT get timeout failed.			  	CNcomment:WDG获取超时时间失败。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_WDG_GetTimeout(HI_U32 u32WdgNum, HI_U32 *pu32Value);
+
+/**
+ \brief Sets the interval of feeding the WDG.
+CNcomment:\brief 设置喂狗时间间隔。CNend
+
+ \attention \n
+N/A
+ \param[in] u32WdgNum WDG No. to operate.        	CNcomment:执行操作的WDG号。CNend
+ \param[out] u32Value  Interval of feeding the WDG, in ms.                		CNcomment:喂狗时间间隔，单位为ms。CNend
+ \retval 0 Success.                                                      		CNcomment:成功。CNend
+ \retval ::HI_ERR_WDG_NOT_INIT The WDG device is not initialized.       		CNcomment:WDG设备未初始化。CNend
+ \retval ::HI_ERR_WDG_FAILED_SETTIMEOUT The WDG set timeout failed.   			CNcomment:WDG设置超时时间失败。CNend
+ \retval ::HI_ERR_WDG_INVALID_PARA  The WDG input parameter is invalid. 		CNcomment:WDG输入参数无效。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_WDG_SetTimeout(HI_U32 u32WdgNum, HI_U32 u32Value);
+
+/**
+ \brief Feeds the WDG.
+CNcomment:\brief 执行喂狗操作。CNend
+
+ \attention \n
+N/A
+ \param[in] u32WdgNum WDG No. to operate.        	CNcomment:执行操作的WDG号。CNend
+ \retval 0 Success.                                                   	CNcomment:成功。CNend
+ \retval ::HI_ERR_WDG_NOT_INIT  The WDG device is not initialized.      CNcomment:WDG设备未初始化。CNend
+ \retval ::HI_ERR_WDG_FAILED_CLEARWDG  The WDG clear watchdog failed.   CNcomment:WDG 喂狗失败。CNend
+ \retval ::HI_ERR_WDG_INVALID_PARA The Paramteter is invalid. 			CNcomment:参数无效。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_WDG_Clear(HI_U32 u32WdgNum);
+
+/**
+ \brief Resets the entire system.
+CNcomment:\brief 用于复位整个系统。CNend
+
+ \attention \n
+N/A
+ \param[in] u32WdgNum WDG No. to operate.        	CNcomment:执行操作的WDG号。CNend
+ \retval 0 Success. CNcomment:成功。CNend
+ \retval ::HI_ERR_WDG_NOT_INIT  The WDG device is not initialized.  CNcomment:WDG设备未初始化。CNend
+ \retval ::HI_ERR_WDG_FAILED_RESET The WDG reset failed.   			CNcomment:WDG复位失败。CNend
+ \retval ::HI_ERR_WDG_INVALID_PARA The Paramteter is invalid. 		CNcomment:参数无效。CNend
+ \see \n
+N/A
+ */
+HI_S32 HI_UNF_WDG_Reset(HI_U32 u32WdgNum);
+
+/** @} */  /** <!-- ==== API Declaration End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
+#endif /* __HI_UNF_WDG_H__ */
diff -uNr a/include/hi_user_proc.h b/include/hi_user_proc.h
--- a/include/hi_user_proc.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_user_proc.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,117 @@
+/*
+ * Copyright (C) Hisilicon Technologies Co., Ltd. 2009-2019. All rights reserved.
+ * Description:
+ * Author: guoqingbo
+ * Create: 2009-12-15
+ */
+
+#ifndef __HI_USER_PROC_H__
+#define __HI_USER_PROC_H__
+
+#include "hi_type.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * Defines user mode proc show buffer
+ * CNcomment: 用户态PROC buffer定义
+ */
+typedef struct hiPROC_SHOW_BUFFER_S {
+    HI_U8 *pu8Buf;    /* Buffer address */ /* CNcomment: Buffer地址 */
+    HI_U32 u32Size;   /* Buffer size */    /* CNcomment: Buffer大小 */
+    HI_U32 u32Offset; /* Offset */         /* CNcomment: 打印偏移地址 */
+} HI_PROC_SHOW_BUFFER_S;
+
+/*
+ * Proc show function
+ * CNcomment: Proc信息显示回调函数
+ */
+typedef HI_S32 (* HI_PROC_SHOW_FN)(HI_PROC_SHOW_BUFFER_S *pstBuf, HI_VOID *pPrivData);
+
+/*
+ * Proc command function
+ * CNcomment: Proc控制回调函数
+ */
+typedef HI_S32 (* HI_PROC_CMD_FN)(HI_PROC_SHOW_BUFFER_S *pstBuf, HI_U32 u32Argc, HI_U8 *pu8Argv[], HI_VOID *pPrivData);
+
+/*
+ * Defines user mode proc entry
+ * CNcomment: 用户态PROC入口定义
+ */
+typedef struct hiPROC_ENTRY_S {
+    HI_CHAR *pszEntryName;       /* Entry name */            /* CNcomment: 入口文件名 */
+    HI_CHAR *pszDirectory;       /* Directory name. If null, the entry will be added to /proc/hisi/ */ /* CNcomment: 目录名，如果为空，将创建到/proc/hisi目录下 */
+    HI_PROC_SHOW_FN pfnShowProc; /* Proc show function */    /* CNcomment: Proc信息显示回调函数 */
+    HI_PROC_CMD_FN pfnCmdProc;   /* Proc command function */ /* CNcomment: Proc控制回调函数 */
+    HI_VOID *pPrivData;          /* Private data */          /* CNcomment: Buffer地址 */
+} HI_PROC_ENTRY_S;
+
+/*
+ * brief User mode proc cretea directory. CNcomment:用户态proc创建目录 CNend
+ * attention You need register module before calling this API. Only support create one level directory. CNcomment:需要先注册模块，只支持创建一级目录 CNend
+ * param[in] pszName The directory name. CNcomment:目录名 CNend
+ * param[out] None CNcomment:无 CNend
+ * retval ::HI_SUCCESS Success CNcomment:成功 CNend
+ * retval ::HI_FAILURE Failure CNcomment:失败 CNend
+ * see \n
+ * N/A CNcomment:无 CNend
+ */
+HI_S32 HI_PROC_AddDir(const HI_CHAR *Name);
+
+/*
+ * brief User mode proc remove directory. CNcomment:用户态proc删除目录 CNend
+ * attention It will return fail if there are entries in the directory. CNcomment:如果目录下还有入口文件,将会删除失败 CNend
+ * param[in] pszName The directory name. CNcomment:目录名 CNend
+ * retval ::HI_SUCCESS Success CNcomment:成功 CNend
+ * retval ::HI_FAILURE Failure CNcomment:失败 CNend
+ * see \n
+ * N/A CNcomment:无 CNend
+ */
+HI_S32 HI_PROC_RemoveDir(const HI_CHAR *Name);
+
+/*
+ * brief User mode proc add entry. CNcomment:用户态proc创建入口 CNend
+ * attention \n
+ * N/A CNcomment: 无 CNend
+ * param[in] u32ModuleID Module ID. CNcomment:模块ID CNend
+ * param[in] pstEntry Parameter of entry. CNcomment:创建入口参数 CNend
+ * retval ::HI_SUCCESS Success CNcomment:成功 CNend
+ * retval ::HI_FAILURE Failure CNcomment:失败 CNend
+ * see \n
+ * N/A CNcomment:无 CNend
+ */
+HI_S32 HI_PROC_AddEntry(HI_U32 ModuleID, const HI_PROC_ENTRY_S *Entry);
+
+/*
+ * brief User mode proc remove entry. CNcomment:用户态proc删除入口 CNend
+ * attention \n
+ * N/A CNcomment: 无 CNend
+ * param[in] u32ModuleID Module ID. CNcomment:模块ID CNend
+ * param[in] pstEntry Parameter of entry. CNcomment:删除入口参数 CNend
+ * retval ::HI_SUCCESS Success CNcomment:成功 CNend
+ * retval ::HI_FAILURE Failure CNcomment:失败 CNend
+ * see \n
+ * N/A CNcomment:无 CNend
+ */
+HI_S32 HI_PROC_RemoveEntry(HI_U32 ModuleID, const HI_PROC_ENTRY_S *Entry);
+
+/*
+ * brief User mode proc print function. CNcomment:用户态proc打印内容的函数 CNend
+ * attention \n
+ * N/A CNcomment: 无 CNend
+ * param[in] pstBuf Output buffer parameter. CNcomment:输出buffer参数 CNend
+ * param[in] pFmt   Format parameter. CNcomment:打印格式化参数 CNend
+ * retval ::HI_SUCCESS Success CNcomment:成功 CNend
+ * retval ::HI_FAILURE Failure CNcomment:失败 CNend
+ * see \n
+ * N/A CNcomment:无 CNend
+ */
+HI_S32 HI_PROC_Printf(HI_PROC_SHOW_BUFFER_S *ShowBuf, const HI_CHAR *Fmt, ...);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __HI_USER_PROC_H__ */
diff -uNr a/include/hi_video_codec.h b/include/hi_video_codec.h
--- a/include/hi_video_codec.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/hi_video_codec.h	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,827 @@
+/******************************************************************************
+
+  Copyright (C), 2012-2014, Hisilicon Tech. Co., Ltd.
+
+ ******************************************************************************
+  File Name     : hi_video_codec.h
+  Version       : Initial Draft
+  Author        : Hisilicon multimedia software group
+  Created       : 2012/07/31
+  Description   : Common definitions of HI_CODEC(video).
+                  The codec wants to register to HI_CODEC need to adapt to HI_CODEC_S.
+  History       :
+  1.Date        : 2012/07/31
+    Author      : sdk
+    Modification: Created file
+
+*******************************************************************************/
+
+#ifndef __HI_VIDEO_CODEC_H__
+#define __HI_VIDEO_CODEC_H__
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#include "hi_type.h"
+
+/*************************** Structure Definition ****************************/
+/** \addtogroup  VCODEC  */
+/** @{ */  /** <!--[VCODEC]  */
+
+/*Codec error defination */
+/**Operate fail due to insufficient resources(eg. no enough memory) */
+/**CNcomment: 资源不足，(编)解码失败*/ 
+#define HI_ERR_CODEC_NOENOUGHRES    (HI_S32)(0x80510001)
+/**Parameter invalid */
+/**CNcomment: 参数无效*/ 
+#define HI_ERR_CODEC_INVALIDPARAM   (HI_S32)(0x80510002)
+/**The (en)decoding fails due to incorrect input(streams or frames) */
+/**CNcomment: 输入数据有误，(编)解码结束*/ 
+#define HI_ERR_CODEC_INPUTCORRUPT   (HI_S32)(0x80510003)
+/**The (en)decoding ends due to insufficient input data(streams or frames) */
+/**CNcomment: 输入数据不足，(编)解码结束*/ 
+#define HI_ERR_CODEC_NOENOUGHDATA   (HI_S32)(0x80510004)
+/**The (en)decoding mode is not supported */
+/**CNcomment: 不支持的(编)解码类型*/ 
+#define HI_ERR_CODEC_INVALIDMODE    (HI_S32)(0x80510005)
+/**Operate fail */
+/**CNcomment: 操作失败*/ 
+#define HI_ERR_CODEC_OPERATEFAIL    (HI_S32)(0x80510006)
+/**Version unmatch*/
+/**CNcomment: 版本不匹配*/ 
+#define HI_ERR_CODEC_VERSIONUNMATCH (HI_S32)(0x80510007)
+/**Unsupport operation */
+/**CNcomment: 不支持的操作*/
+#define HI_ERR_CODEC_UNSUPPORT      (HI_S32)(0x80510008)
+/**Decorder busy */
+/**CNcomment: 解码器忙*/ 
+#define HI_ERR_CODEC_BUSY           (HI_S32)(0x80510009)
+/**Unknown error */
+/**CNcomment: 未知错误*/ 
+#define HI_ERR_CODEC_UNKNOWN        (HI_S32)(0x80510010)
+
+/**Codec ID */
+/**CNcomment: 协议类型 */
+typedef enum hiCODEC_ID_E
+{
+    HI_CODEC_ID_NONE = 0, 
+        
+    HI_CODEC_ID_VIDEO_MPEG1,
+    HI_CODEC_ID_VIDEO_MPEG2,
+    HI_CODEC_ID_VIDEO_MPEG2_XVMC,
+    HI_CODEC_ID_VIDEO_MPEG4,      /**<MPEG4 DIVX4 DIVX5*/
+    HI_CODEC_ID_VIDEO_MSMPEG4V1,
+    HI_CODEC_ID_VIDEO_MSMPEG4V2,
+    HI_CODEC_ID_VIDEO_MSMPEG4V3,
+
+    HI_CODEC_ID_VIDEO_DIVX3,
+    HI_CODEC_ID_VIDEO_XVID,
+
+    HI_CODEC_ID_VIDEO_H261,
+    HI_CODEC_ID_VIDEO_H263,
+    HI_CODEC_ID_VIDEO_H263P,
+    HI_CODEC_ID_VIDEO_H263I,
+    HI_CODEC_ID_VIDEO_H264,
+    HI_CODEC_ID_VIDEO_FFH264,
+
+    HI_CODEC_ID_VIDEO_AVS,
+
+    HI_CODEC_ID_VIDEO_REAL8,
+    HI_CODEC_ID_VIDEO_REAL9,
+
+    HI_CODEC_ID_VIDEO_VC1,
+    HI_CODEC_ID_VIDEO_WMV1,
+    HI_CODEC_ID_VIDEO_WMV2,
+    HI_CODEC_ID_VIDEO_WMV3,
+
+    HI_CODEC_ID_VIDEO_MSVIDEO1,
+
+    HI_CODEC_ID_VIDEO_VP3,
+    HI_CODEC_ID_VIDEO_VP5,
+    HI_CODEC_ID_VIDEO_VP6,
+    HI_CODEC_ID_VIDEO_VP6F,
+    HI_CODEC_ID_VIDEO_VP6A,
+    HI_CODEC_ID_VIDEO_VP8,
+    HI_CODEC_ID_VIDEO_VP9,
+    HI_CODEC_ID_VIDEO_AVS2,
+    HI_CODEC_ID_VIDEO_RAW,
+    HI_CODEC_ID_VIDEO_SORENSON,   /**<SORENSON SPARK*/
+
+	HI_CODEC_ID_VIDEO_HEVC,
+    HI_CODEC_ID_VIDEO_RV10,
+    HI_CODEC_ID_VIDEO_RV20,
+    HI_CODEC_ID_VIDEO_RV30,
+    HI_CODEC_ID_VIDEO_RV40,
+    
+    HI_CODEC_ID_VIDEO_SVQ1,
+    HI_CODEC_ID_VIDEO_SVQ3,
+
+    HI_CODEC_ID_VIDEO_CINEPAK,
+    HI_CODEC_ID_VIDEO_INDEO2,
+    HI_CODEC_ID_VIDEO_INDEO3,
+    HI_CODEC_ID_VIDEO_INDEO4,
+    HI_CODEC_ID_VIDEO_INDEO5,
+
+    HI_CODEC_ID_VIDEO_JPEG,
+    HI_CODEC_ID_VIDEO_JPEGLS,
+    HI_CODEC_ID_VIDEO_JPEG2000,
+    HI_CODEC_ID_VIDEO_MJPEG,
+    HI_CODEC_ID_VIDEO_MJPEGB,
+    HI_CODEC_ID_VIDEO_LJPEG,
+
+    HI_CODEC_ID_VIDEO_TIFF,
+    HI_CODEC_ID_VIDEO_GIF,
+    HI_CODEC_ID_VIDEO_PNG,
+
+    HI_CODEC_ID_VIDEO_SP5X,
+    
+    HI_CODEC_ID_VIDEO_FLV1,
+    HI_CODEC_ID_VIDEO_HUFFYUV,
+    HI_CODEC_ID_VIDEO_CYUV,
+    HI_CODEC_ID_VIDEO_THEORA,
+    HI_CODEC_ID_VIDEO_ASV1,
+    HI_CODEC_ID_VIDEO_ASV2,
+    HI_CODEC_ID_VIDEO_FFV1,
+    HI_CODEC_ID_VIDEO_4XM,
+    HI_CODEC_ID_VIDEO_VCR1,
+    HI_CODEC_ID_VIDEO_CLJR,
+    HI_CODEC_ID_VIDEO_MDEC,
+    HI_CODEC_ID_VIDEO_ROQ,
+    HI_CODEC_ID_VIDEO_INTERPLAY_VIDEO,
+    HI_CODEC_ID_VIDEO_XAN_WC3,
+    HI_CODEC_ID_VIDEO_XAN_WC4,
+    HI_CODEC_ID_VIDEO_RPZA,
+    HI_CODEC_ID_VIDEO_WS_VQA,
+    HI_CODEC_ID_VIDEO_MSRLE,
+    HI_CODEC_ID_VIDEO_IDCIN,
+    HI_CODEC_ID_VIDEO_8BPS,
+    HI_CODEC_ID_VIDEO_SMC,
+    HI_CODEC_ID_VIDEO_FLIC,
+    HI_CODEC_ID_VIDEO_TRUEMOTION1,
+    HI_CODEC_ID_VIDEO_VMDVIDEO,
+    HI_CODEC_ID_VIDEO_MSZH,
+    HI_CODEC_ID_VIDEO_ZLIB,
+    HI_CODEC_ID_VIDEO_QTRLE,
+    HI_CODEC_ID_VIDEO_SNOW,
+    HI_CODEC_ID_VIDEO_TSCC,
+    HI_CODEC_ID_VIDEO_ULTI,
+    HI_CODEC_ID_VIDEO_QDRAW,
+    HI_CODEC_ID_VIDEO_VIXL,
+    HI_CODEC_ID_VIDEO_QPEG,
+    HI_CODEC_ID_VIDEO_PPM,
+    HI_CODEC_ID_VIDEO_PBM,
+    HI_CODEC_ID_VIDEO_PGM,
+    HI_CODEC_ID_VIDEO_PGMYUV,
+    HI_CODEC_ID_VIDEO_PAM,
+    HI_CODEC_ID_VIDEO_FFVHUFF,
+    
+    HI_CODEC_ID_VIDEO_LOCO,
+    HI_CODEC_ID_VIDEO_WNV1,
+    HI_CODEC_ID_VIDEO_AASC,
+    HI_CODEC_ID_VIDEO_FRAPS,
+    HI_CODEC_ID_VIDEO_TRUEMOTION2,
+    HI_CODEC_ID_VIDEO_BMP,
+    HI_CODEC_ID_VIDEO_CSCD,
+    HI_CODEC_ID_VIDEO_MMVIDEO,
+    HI_CODEC_ID_VIDEO_ZMBV,
+    HI_CODEC_ID_VIDEO_SMACKVIDEO,
+    HI_CODEC_ID_VIDEO_NUV,
+    HI_CODEC_ID_VIDEO_KMVC,
+    HI_CODEC_ID_VIDEO_FLASHSV,
+    HI_CODEC_ID_VIDEO_CAVS,
+    
+    HI_CODEC_ID_VIDEO_VMNC,
+    
+    HI_CODEC_ID_VIDEO_TARGA,
+    HI_CODEC_ID_VIDEO_DSICINVIDEO,
+    HI_CODEC_ID_VIDEO_TIERTEXSEQVIDEO,
+    
+    HI_CODEC_ID_VIDEO_DXA,
+    HI_CODEC_ID_VIDEO_DNXHD,
+    HI_CODEC_ID_VIDEO_THP,
+    HI_CODEC_ID_VIDEO_SGI,
+    HI_CODEC_ID_VIDEO_C93,
+    HI_CODEC_ID_VIDEO_BETHSOFTVID,
+    HI_CODEC_ID_VIDEO_PTX,
+    HI_CODEC_ID_VIDEO_TXD,
+    HI_CODEC_ID_VIDEO_AMV,
+    HI_CODEC_ID_VIDEO_VB,
+    HI_CODEC_ID_VIDEO_PCX,
+    HI_CODEC_ID_VIDEO_SUNRAST,
+    HI_CODEC_ID_VIDEO_MIMIC,
+    HI_CODEC_ID_VIDEO_RL2,
+    HI_CODEC_ID_VIDEO_8SVX_EXP,
+    HI_CODEC_ID_VIDEO_8SVX_FIB,
+    HI_CODEC_ID_VIDEO_ESCAPE124,
+    HI_CODEC_ID_VIDEO_DIRAC,
+    HI_CODEC_ID_VIDEO_BFI,
+    HI_CODEC_ID_VIDEO_CMV,
+    HI_CODEC_ID_VIDEO_MOTIONPIXELS,
+    HI_CODEC_ID_VIDEO_TGV,
+    HI_CODEC_ID_VIDEO_TGQ,
+    HI_CODEC_ID_VIDEO_TQI,
+    HI_CODEC_ID_VIDEO_AURA,
+    HI_CODEC_ID_VIDEO_AURA2,
+    HI_CODEC_ID_VIDEO_V210X,
+    HI_CODEC_ID_VIDEO_TMV,
+    HI_CODEC_ID_VIDEO_V210,
+    HI_CODEC_ID_VIDEO_DPX,
+    HI_CODEC_ID_VIDEO_MAD,
+    HI_CODEC_ID_VIDEO_FRWU,
+    HI_CODEC_ID_VIDEO_FLASHSV2,
+    HI_CODEC_ID_VIDEO_CDGRAPHICS,
+    HI_CODEC_ID_VIDEO_R210,
+    HI_CODEC_ID_VIDEO_ANM,
+    HI_CODEC_ID_VIDEO_BINKVIDEO,
+    HI_CODEC_ID_VIDEO_IFF_ILBM,
+    HI_CODEC_ID_VIDEO_IFF_BYTERUN1,
+    HI_CODEC_ID_VIDEO_KGV1,
+    HI_CODEC_ID_VIDEO_YOP,
+    HI_CODEC_ID_VIDEO_DV,
+    HI_CODEC_ID_BUTT
+}HI_CODEC_ID_E;
+
+/*BIT0 of HI_CODEC_SUPPORT_S.u32Type: Driven type */
+/**Need be driven by codec manager. Like FFMPEG. */ /**CNcomment:编解码器需要管理器驱动 */
+#define HI_CODEC_CAP_DRIVENOUTSIDE      (0x00000000)
+/**Self-driven, only need call Start()/Stop(). Like VFMW. */ /**CNcomment:编解码器有自驱动能力 */
+#define HI_CODEC_CAP_DRIVENSELF         (0x00000001)
+
+/*BIT1 of HI_CODEC_SUPPORT_S.u32Type: Output type */
+/**Codec outputs frame or stream to specified address directly.  */ /**CNcomment:编解码器支持将帧数据或流数据输出到指定地址 */
+#define HI_CODEC_CAP_OUTPUT2SELFADDR    (0x00000000)
+/**Codec outputs frame or stream to the address self allocated . */ /**CNcomment:编解码器将帧数据或流数据输出到自身地址，需要外部拷贝 */
+#define HI_CODEC_CAP_OUTPUT2SPECADDR    (0x00000002)
+
+/**Defines codec type: encoder or decoder  */
+/**CNcomment:Codec类型:编码或解码*/ 
+typedef enum hiCODEC_TYPE_E
+{
+    HI_CODEC_TYPE_DEC = 0x01,       /**<decoder, value is b00000001*/ /**< CNcomment:解码器 */
+    HI_CODEC_TYPE_ENC = 0x02,       /**<encoder, value is b00000010*/ /**< CNcomment:编码器 */
+    
+    HI_CODEC_TYPE_BUTT
+}HI_CODEC_TYPE_E;
+
+/**Defines codec types and formats */
+/**CNcomment:Codec类型与支持的协议*/ 
+typedef struct hiCODEC_SUPPORT_S
+{
+    HI_U32          u32Type;            /**< Codec type, OR value of HI_CODEC_TYPE_E */ /**< CNcomment:Codec类型，HI_CODEC_TYPE_E的或值 */
+    HI_CODEC_ID_E   enID;               /**< Codec ID*/ /**< CNcomment:Codec支持的协议类型 */
+    struct hiCODEC_SUPPORT_S* pstNext;  /**< Pointer to next node*/ /**< CNcomment:指向下一个能力结点的指针 */
+}HI_CODEC_SUPPORT_S;
+
+/**Defines codec capability */
+/**CNcomment:Codec能力*/ 
+typedef struct hiCODEC_CAP_S
+{
+    HI_U32              u32CapNumber;   /**< Codec capability index, OR value of several HI_CODEC_CAP_XXX */ /**< CNcomment:Codec能力指示值，HI_CODEC_CAP_XXX的或值 */
+    HI_CODEC_SUPPORT_S* pstSupport;     /**< Pointer to the support type and formats*/ /**< CNcomment:Codec能力结构体指针 */
+}HI_CODEC_CAP_S;
+
+/**Defines the codec version*/
+/**CNcomment:版本定义*/ 
+typedef union hiCODEC_VERSION_U
+{
+    struct
+    {
+        HI_U8 u8VersionMajor;           /**< Major version */ /**< CNcomment:主版本号 */
+        HI_U8 u8VersionMinor;           /**< Minor version */ /**< CNcomment:次版本号 */
+        HI_U8 u8Revision;               /**< Revision version */ /**< CNcomment:修订版本号 */
+        HI_U8 u8Step;                   /**< Step version */ /**< CNcomment:步进版本号 */
+    } stVersion;
+    HI_U32 u32Version;
+} HI_CODEC_VERSION_U;
+
+/**Defines video decoder open parameter*/
+/**CNcomment:视频解码器打开参数*/ 
+typedef struct hiCODEC_VDEC_OPENPARAM_S
+{
+    HI_U32 u32Reserve;
+    HI_VOID* pPlatformPriv;         /**< Special parameter for platform hardware codec */ /**< CNcomment:硬解码器私有参数 */
+}HI_CODEC_VDEC_OPENPARAM_S;
+
+/**Defines video encoder open parameter*/
+/**CNcomment:视频编码器打开参数*/ 
+typedef struct hiCODEC_VENC_OPENPARAM_S
+{
+    HI_U32 u32Reserve;
+}HI_CODEC_VENC_OPENPARAM_S;
+
+/**Defines the codec open parameters*/
+/**CNcomment:实例创建参数*/
+typedef struct hiCODEC_OPENPARAM_S
+{
+    HI_CODEC_TYPE_E enType;       /** Encode or Decode */ /**< CNcomment:创建编码器还是解码器 */
+    HI_CODEC_ID_E enID;           /** Format */ /**< CNcomment:需要编码或解码的协议类型 */
+    union {
+        HI_CODEC_VDEC_OPENPARAM_S stVdec; /** Open parameters of video decoder */ /**< CNcomment:视频解码器创建参数 */
+        HI_CODEC_VENC_OPENPARAM_S stVenc; /** Open parameters of video encoder */ /**< CNcomment:视频编码器创建参数 */
+    }unParam;
+} HI_CODEC_OPENPARAM_S;
+
+/**Defines the codec max priority */
+/**CNcomment:编解码器最大优先级定义*/
+#define HI_CODEC_MAX_PRIORITY (16)
+
+/**Defines attribute of video decoder */
+/**CNcomment:视频解码器实例属性*/
+typedef struct hiCODEC_VDEC_ATTR_S
+{
+    HI_VOID*                pCodecContext;  /**< Codec context */ /**< CNcomment:编解码器上下文，可以传递解码器特定参数 */
+    HI_VOID*                pPlatformPriv;  /**< Only used by platform */ /**< CNcomment:硬解码器私有参数 */
+} HI_CODEC_VDEC_ATTR_S;
+
+/**Defines attribute of codec instance */
+/**CNcomment:实例属性*/
+typedef struct hiCODEC_ATTR_S
+{
+    HI_CODEC_ID_E           enID;   /**< Codec ID*/ /**< CNcomment:编码或解码的协议类型*/
+    union {
+        HI_CODEC_VDEC_ATTR_S stVdec;/**< Instance attribute*/ /**< CNcomment:视频解码器属性参数*/
+    } unAttr;
+} HI_CODEC_ATTR_S;
+
+/**Defines video sub standard */
+/**CNcomment: 视频协议分支标准 */
+typedef enum hiCODEC_VIDEO_SUB_STANDARD_E
+{
+    HI_CODEC_VIDEO_SUB_STANDARD_UNKNOWN,       /**<Unknown*/ /**<CNcomment: 未知协议分支*/
+    HI_CODEC_VIDEO_SUB_STANDARD_MPEG2_MPEG1,   /**<The MPEG2 protocol family is compatible with MPEG1.*/ /**<CNcomment: MPEG2协议族可以兼容MPEG1 */
+    HI_CODEC_VIDEO_SUB_STANDARD_MPEG4_SHV,     /**<The MPEG4 protocol family is compatible with SHV.*/ /**<CNcomment: MPEG4协议族可以兼容SHV*/
+    HI_CODEC_VIDEO_SUB_STANDARD_MPEG4_XVID,    /**<The MPEG4 protocol family includes the sub protocol XVID.*/ /**<CNcomment: MPEG4协议包含XVID分支*/
+    HI_CODEC_VIDEO_SUB_STANDARD_MPEG4_DIVX,    /**<The MPEG4 protocol family includes the sub protocol DIVX.*/ /**<CNcomment: MPEG4协议包含DIVX分支*/
+
+    HI_CODEC_VIDEO_SUB_STANDARD_BUTT
+}HI_CODEC_VIDEO_SUB_STANDARD_E;
+
+/**Defines the video norm*/
+/**CNcomment: 定义视频制式枚举*/
+typedef enum hiCODEC_ENC_FMT_E
+{
+    HI_CODEC_ENC_FMT_1080P_60 = 0,     /**<1080p 60 Hz*/ /**< CNcomment:1080p 60赫兹*/
+    HI_CODEC_ENC_FMT_1080P_50,         /**<1080p 50 Hz*/ /**< CNcomment:1080p 50赫兹*/
+    HI_CODEC_ENC_FMT_1080P_30,         /**<1080p 30 Hz*/ /**< CNcomment:1080p 30赫兹*/
+    HI_CODEC_ENC_FMT_1080P_25,         /**<1080p 25 Hz*/ /**< CNcomment:1080p 25赫兹*/
+    HI_CODEC_ENC_FMT_1080P_24,         /**<1080p 24 Hz*/ /**< CNcomment:1080p 24赫兹*/
+
+    HI_CODEC_ENC_FMT_1080i_60,         /**<1080i 60 Hz*/ /**< CNcomment:1080i 60赫兹*/
+    HI_CODEC_ENC_FMT_1080i_50,         /**<1080i 50 Hz*/ /**< CNcomment:1080i 50赫兹*/
+
+    HI_CODEC_ENC_FMT_720P_60,          /**<720p 60 Hz*/  /**< CNcomment:720p 60赫兹*/
+    HI_CODEC_ENC_FMT_720P_50,          /**<720p 50 Hz */ /**< CNcomment:720p 50赫兹*/
+
+    HI_CODEC_ENC_FMT_576P_50,          /**<576p 50 Hz*/  /**< CNcomment:576p 50赫兹*/
+    HI_CODEC_ENC_FMT_480P_60,          /**<480p 60 Hz*/  /**< CNcomment:480p 60赫兹*/
+
+    HI_CODEC_ENC_FMT_PAL,              /**<B D G H I PAL */ /**< CNcomment:B D G H I PAL制式*/
+    HI_CODEC_ENC_FMT_PAL_N,            /**<(N)PAL        */ /**< CNcomment:(N)PAL制式*/
+    HI_CODEC_ENC_FMT_PAL_Nc,           /**<(Nc)PAL       */ /**< CNcomment:(Nc)PAL制式*/
+
+    HI_CODEC_ENC_FMT_NTSC,             /**<(M)NTSC       */ /**< CNcomment:(M)NTSC制式*/
+    HI_CODEC_ENC_FMT_NTSC_J,           /**<NTSC-J        */ /**< CNcomment:NTSC-J制式*/
+    HI_CODEC_ENC_FMT_NTSC_PAL_M,       /**<(M)PAL        */ /**< CNcomment:(M)PAL制式*/
+
+    HI_CODEC_ENC_FMT_SECAM_SIN,        /**< SECAM_SIN*/ /**< CNcomment:SECAM_SIN制式*/
+    HI_CODEC_ENC_FMT_SECAM_COS,        /**< SECAM_COS*/ /**< CNcomment:SECAM_COS制式*/
+
+    HI_CODEC_ENC_FMT_1080P_24_FRAME_PACKING,
+    HI_CODEC_ENC_FMT_720P_60_FRAME_PACKING,
+    HI_CODEC_ENC_FMT_720P_50_FRAME_PACKING,
+    
+    HI_CODEC_ENC_FMT_861D_640X480_60,
+    HI_CODEC_ENC_FMT_VESA_800X600_60,
+    HI_CODEC_ENC_FMT_VESA_1024X768_60,
+    HI_CODEC_ENC_FMT_VESA_1280X720_60,
+    HI_CODEC_ENC_FMT_VESA_1280X800_60,
+    HI_CODEC_ENC_FMT_VESA_1280X1024_60,
+    HI_CODEC_ENC_FMT_VESA_1360X768_60,
+    HI_CODEC_ENC_FMT_VESA_1366X768_60,
+    HI_CODEC_ENC_FMT_VESA_1400X1050_60,
+    HI_CODEC_ENC_FMT_VESA_1440X900_60,
+    HI_CODEC_ENC_FMT_VESA_1440X900_60_RB,
+    HI_CODEC_ENC_FMT_VESA_1600X900_60_RB,
+    HI_CODEC_ENC_FMT_VESA_1600X1200_60,
+    HI_CODEC_ENC_FMT_VESA_1680X1050_60,
+    HI_CODEC_ENC_FMT_VESA_1920X1080_60,
+    HI_CODEC_ENC_FMT_VESA_1920X1200_60,
+    HI_CODEC_ENC_FMT_VESA_2048X1152_60,
+
+    HI_CODEC_ENC_FMT_BUTT
+}HI_CODEC_ENC_FMT_E;
+
+/**Defines the video YUV format*/
+/**CNcomment: YUV格式枚举*/
+typedef enum hiCODEC_COLOR_FORMAT_E
+{
+    HI_CODEC_COLOR_FORMAT_YUV_SEMIPLANAR_400 = 0,   /**<The YUV spatial sampling format is SEMIPLANAR 4:0:0.*/ /**<CNcomment: YUV空间采样格式为SEMIPLANAR 4:0:0*/
+    HI_CODEC_COLOR_FORMAT_YUV_SEMIPLANAR_411,       /**<The YUV spatial sampling format is SEMIPLANAR 4:1:1.*/ /**<CNcomment: YUV空间采样格式为SEMIPLANAR 4:1:1*/
+    HI_CODEC_COLOR_FORMAT_YUV_SEMIPLANAR_420,       /**<The YUV spatial sampling format is SEMIPLANAR 4:2:0.*/ /**<CNcomment: YUV空间采样格式为SEMIPLANAR 4:2:0*/
+    HI_CODEC_COLOR_FORMAT_YUV_SEMIPLANAR_422_1X2,   /**<The YUV spatial sampling format is SEMIPLANAR 4:2:2,two Y correspond to one U and V at vertical direction.*/ /**<CNcomment: YUV空间采样格式为SEMIPLANAR 4:2:2，垂直方向两个亮度采样点共用一对色度采样点*/
+    HI_CODEC_COLOR_FORMAT_YUV_SEMIPLANAR_422_2X1,   /**<The YUV spatial sampling format is SEMIPLANAR 4:2:2,two Y correspond to one U and V at horizontal direction.*/ /**<CNcomment: YUV空间采样格式为SEMIPLANAR 4:2:2，水平方向两个亮度采样点共用一对色度采样点*/
+    HI_CODEC_COLOR_FORMAT_YUV_SEMIPLANAR_444,       /**<The YUV spatial sampling format is SEMIPLANAR 4:4:4.*/ /**<CNcomment: YUV空间采样格式为SEMIPLANAR 4:4:4*/
+
+    HI_CODEC_COLOR_FORMAT_YUV_PLANAR_400 = 0x10,    /**<The YUV spatial sampling format is PLANAR 4:0:0.*/ /**<CNcomment: YUV空间采样格式为PLANAR 4:0:0*/   
+    HI_CODEC_COLOR_FORMAT_YUV_PLANAR_411,           /**<The YUV spatial sampling format is PLANAR 4:1:1.*/ /**<CNcomment: YUV空间采样格式为PLANAR 4:1:1*/   
+    HI_CODEC_COLOR_FORMAT_YUV_PLANAR_420,           /**<The YUV spatial sampling format is PLANAR 4:2:0.*/ /**<CNcomment: YUV空间采样格式为PLANAR 4:2:0*/   
+    HI_CODEC_COLOR_FORMAT_YUV_PLANAR_422_1X2,       /**<The YUV spatial sampling format is PLANAR 4:2:2,two Y correspond to one U and V at vertical direction.*/ /**<CNcomment: YUV空间采样格式为PLANAR 4:2:2，垂直方向两个亮度采样点共用一对色度采样点*/
+    HI_CODEC_COLOR_FORMAT_YUV_PLANAR_422_2X1,       /**<The YUV spatial sampling format is PLANAR 4:2:2,two Y correspond to one U and V at horizontal direction.*/ /**<CNcomment: YUV空间采样格式为PLANAR 4:2:2，水平方向两个亮度采样点共用一对色度采样点*/
+    HI_CODEC_COLOR_FORMAT_YUV_PLANAR_444,           /**<The YUV spatial sampling format is PLANAR 4:4:4.*/ /**<CNcomment: YUV空间采样格式为PLANAR 4:4:4*/   
+    HI_CODEC_COLOR_FORMAT_YUV_PLANAR_410,           /**<The YUV spatial sampling format is PLANAR 4:1:0.*/ /**<CNcomment: YUV空间采样格式为PLANAR 4:1:0*/   
+    
+    HI_CODEC_COLOR_FORMAT_YUV_PACKAGE_UYVY422 = 0x20,   /**<The YUV spatial sampling format is package, and the pixel arrangement sequence in the memory is UYVY.*/ /**<CNcomment: YUV空间采样格式为package,内存排列为UYVY*/
+    HI_CODEC_COLOR_FORMAT_YUV_PACKAGE_YUYV422,          /**<The YUV spatial sampling format is package, and the pixel arrangement sequence in the memory is YUYV.*/ /**<CNcomment: YUV空间采样格式为package,内存排列为YUYV*/
+    HI_CODEC_COLOR_FORMAT_YUV_PACKAGE_YVYU422,          /**<The YUV spatial sampling format is package, and the pixel arrangement sequence in the memory is YVYU.*/ /**<CNcomment: YUV空间采样格式为package,内存排列为YVYU*/
+    HI_CODEC_COLOR_FORMAT_YUV_BUTT
+}HI_CODEC_COLOR_FORMAT_E;
+
+/**Defines the type of the video frame*/
+/**CNcomment: 定义视频帧的类型枚举*/
+typedef enum hiCODEC_VIDEO_FRAME_TYPE_E
+{
+    HI_CODEC_VIDEO_FRAME_TYPE_UNKNOWN,   /**<Unknown*/ /**<CNcomment: 未知的帧类型*/
+    HI_CODEC_VIDEO_FRAME_TYPE_I,         /**<I frame*/ /**<CNcomment: I帧*/
+    HI_CODEC_VIDEO_FRAME_TYPE_P,         /**<P frame*/ /**<CNcomment: P帧*/
+    HI_CODEC_VIDEO_FRAME_TYPE_B,         /**<B frame*/ /**<CNcomment: B帧*/
+    HI_CODEC_VIDEO_FRAME_TYPE_BUTT
+}HI_CODEC_VIDEO_FRAME_TYPE_E;
+
+/**Defines the video frame/field mode*/
+/**CNcomment: 定义视频帧场模式枚举*/
+typedef enum hiCODEC_VIDEO_FIELD_MODE_E
+{
+    HI_CODEC_VIDEO_FIELD_ALL,        /**<Frame mode*/ /**<CNcomment: 帧模式*/
+    HI_CODEC_VIDEO_FIELD_TOP,        /**<Top field mode*/ /**<CNcomment: 顶场模式*/
+    HI_CODEC_VIDEO_FIELD_BOTTOM,     /**<Bottom field mode*/ /**<CNcomment: 底场模式*/
+    HI_CODEC_VIDEO_FIELD_BUTT
+}HI_CODEC_VIDEO_FIELD_MODE_E;
+
+/**Defines 3D frame packing type*/
+/**CNcomment: 3D帧打包方式 */
+typedef enum hiCODEC_VIDEO_FRAME_PACKING_TYPE_E
+{
+    HI_CODEC_VIDEO_FRAME_PACKING_NONE,              /**< normal frame, not a 3D frame */ /**<CNcomment: 非3D帧*/
+    HI_CODEC_VIDEO_FRAME_PACKING_SIDE_BY_SIDE,      /**< side by side */ /**<CNcomment:左右模式3D帧 */
+    HI_CODEC_VIDEO_FRAME_PACKING_TOP_AND_BOTTOM,    /**< top and bottom */ /**<CNcomment:上下模式3D帧 */
+    HI_CODEC_VIDEO_FRAME_PACKING_TIME_INTERLACED,   /**< time interlaced: one frame for left eye, the next frame for right eye */ /**<CNcomment:时间差模式3D帧 */
+    HI_CODEC_VIDEO_FRAME_PACKING_BUTT             
+}HI_CODEC_VIDEO_FRAME_PACKING_TYPE_E;
+
+/**Defines address information*/
+/**CNcomment: 地址描述结构体*/
+typedef struct hiCODEC_ADDRESS_S
+{
+    HI_U8   *pu8Vir;             /**<Virtual address of (frame or stream) buffer */ /**<CNcomment: 帧或流数据的虚拟地址 */
+    HI_U32  u32Phy;             /**<Physical address of (frame or stream) buffer */ /**<CNcomment: 帧或流数据的物理地址 */
+    HI_U32  u32Size;            /**<Size of (frame or stream) buffer*/ /**<CNcomment: 帧或流数据的大小 */
+}HI_CODEC_ADDRESS_S;
+
+/**Defines the pixel width.*/
+/**CNcomment: 定义像素位宽*/
+typedef enum hiCODEC_PIXEL_BITWIDTH_E
+{
+    HI_CODEC_PIXEL_BITWIDTH_8BIT = 0,
+    HI_CODEC_PIXEL_BITWIDTH_10BIT,
+    HI_CODEC_PIXEL_BITWIDTH_12BIT,
+    HI_CODEC_PIXEL_BITWIDTH_BUTT,
+} HI_CODEC_PIXEL_BITWIDTH_E;
+
+/**Defines color space enum*/
+/**CNcomment: 定义颜色空间枚举*/
+typedef enum hiCODEC_COLOR_SPACE_E
+{
+    HI_CODEC_COLOR_SPACE_UNKNOWN = 0,
+
+    HI_CODEC_COLOR_SPACE_BT601_YUV_LIMITED = 0x10,/* ::::Current Used:::: BT.601  */
+    HI_CODEC_COLOR_SPACE_BT601_YUV_FULL,
+    HI_CODEC_COLOR_SPACE_BT601_RGB_LIMITED,
+    HI_CODEC_COLOR_SPACE_BT601_RGB_FULL,
+
+    HI_CODEC_COLOR_SPACE_NTSC1953 = 0x20,
+
+    /* These should be useful.  Assume 601 extents. */
+    HI_CODEC_COLOR_SPACE_BT470_SYSTEM_M = 0x30,
+    HI_CODEC_COLOR_SPACE_BT470_SYSTEM_BG,
+
+    HI_CODEC_COLOR_SPACE_BT709_YUV_LIMITED = 0x40,/* ::::Current Used:::: BT.709 */
+    HI_CODEC_COLOR_SPACE_BT709_YUV_FULL,
+    HI_CODEC_COLOR_SPACE_BT709_RGB_LIMITED,
+    HI_CODEC_COLOR_SPACE_BT709_RGB_FULL,
+    HI_CODEC_COLOR_SPACE_BT2020_YUV_LIMITED,/* ::::Current Used:::: BT.2020 */
+    HI_CODEC_COLOR_SPACE_BT2020_YUV_FULL,
+    HI_CODEC_COLOR_SPACE_BT2020_RGB_LIMITED,
+    HI_CODEC_COLOR_SPACE_BT2020_RGB_FULL,   /* ::::Current Used:::: */
+
+    HI_CODEC_COLOR_SPACE_REC709 = 0x50,      /* HD and modern captures. */
+
+    HI_CODEC_COLOR_SPACE_SMPT170M= 0x60, /* ITU-R 601 -- broadcast NTSC/PAL */
+    HI_CODEC_COLOR_SPACE_SMPT240M, /* 1125-Line (US) HDTV */
+
+    HI_CODEC_COLOR_SPACE_BT878 = 0x70,    /* broken BT878 extents
+                           (601, luma range 16-253 instead of 16-235) */
+
+    HI_CODEC_COLOR_SPACE_XVYCC = 0x80,
+
+    /* I know there will be cameras that send this.  So, this is
+     * unspecified chromaticities and full 0-255 on each of the
+     * Y'CbCr components
+     */
+    HI_CODEC_COLOR_SPACE_JPEG = 0x90,
+    HI_CODEC_COLOR_SPACE_RGB = 0xa0,
+
+    HI_CODEC_COLOR_SPACE_BUTT
+}HI_CODEC_COLOR_SPACE_E;
+
+/**Defines video stream info */
+/** CNcomment: 视频流信息结构体*/
+typedef struct hiCODEC_VIDEO_STREAMINFO_S
+{
+    HI_CODEC_ID_E                   enCodecID;      /**<Stream type*/ /**<CNcomment: 码流类型 */
+    HI_CODEC_VIDEO_SUB_STANDARD_E   enSubStandard;  /**<Sub stream protocol*/ /**<CNcomment: 码流的协议分支 */
+    HI_U32                          u32SubVersion;  /**<Version of the sub stream protocol*/ /**<CNcomment: 码流子协议版本号 */
+    HI_U32                          u32Profile;     /**<Stream profile*/ /**<CNcomment: 码流的profile */
+    HI_U32                          u32Level;       /**<Stream level*/ /**<CNcomment: 码流的level */
+    HI_CODEC_ENC_FMT_E              enDisplayNorm;  /**<Display norm*/ /**<CNcomment: 显示标准 */
+    HI_BOOL                         bProgressive;   /**<Sampling type (progressive or interlaced)*/ /**<CNcomment: 采样方式(逐行/隔行) */
+
+    HI_U32                          u32AspectWidth; /**<Aspect width*/ /**<CNcomment: 最佳显示幅型比之宽度比值*/
+    HI_U32                          u32AspectHeight;/**<Aspect height*/ /**<CNcomment: 最佳显示幅型比之高度比值*/
+
+    HI_U32 u32bps;            /**<Bit rate, in kbit/s*/ /**<CNcomment: 码流的码率, Kbps */
+    HI_U32 u32FrameRateInt;   /**<Integral part of the frame rate (in frame/s)*/ /**<CNcomment: 码流的帧率的整数部分, fps */
+    HI_U32 u32FrameRateDec;   /**<Fractional part (calculated to three decimal places) of the frame rate (in frame/s)*/ /**<CNcomment: 码流的帧率的小数部分（保留3位）, fps */
+    HI_U32 u32Width;          /**<Width of the decoded picture*/ /**<CNcomment: 解码图像宽 */
+    HI_U32 u32Height;         /**<Height of the decoded picture*/ /**<CNcomment: 解码图像高 */
+    HI_U32 u32DisplayWidth;   /**<Width of the displayed picture*/ /**<CNcomment: 显示图像宽 */
+    HI_U32 u32DisplayHeight;  /**<Height of the displayed picture*/ /**<CNcomment: 显示图像高 */
+    HI_U32 u32DisplayCenterX; /**<Horizontal coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/
+                              /**<CNcomment: 显示图像中心横坐标，以原始图像的左上角为坐标原点 */
+    HI_U32 u32DisplayCenterY; /**<Vertical coordinate of the center of the displayed picture (the upper left point of the source picture serves as the coordinate origin)*/
+                              /**<CNcomment: 显示图像中心纵坐标，以原始图像的左上角为坐标原点 */
+    HI_CODEC_PIXEL_BITWIDTH_E enBitWidth; /**<Bit width decoded from stream*/ /**<CNcomment: 视频像素位宽*/
+    HI_CODEC_COLOR_SPACE_E      enSrcColorSpace;/**<Color space decoded from stream*/ /**<CNcomment: 颜色色域空间*/
+}HI_CODEC_VIDEO_STREAMINFO_S;
+
+/**Defines stream information */
+/**CNcomment: 码流信息结构体*/
+typedef union hiCODEC_STREAMINFO_S
+{
+    HI_CODEC_VIDEO_STREAMINFO_S stVideo;    /**<video stream information*/ /**<CNcomment: 视频流信息*/
+}HI_CODEC_STREAMINFO_S;
+
+typedef struct hiCODEC_FRAME_BUF_S
+{
+	HI_U32 u32PhyAddr;
+	HI_U32 u32Size;
+}HI_CODEC_FRAME_BUF_S;
+
+/**Defines stream descriptor */
+/**CNcomment: 码流数据结构体*/
+typedef struct hiCODEC_STREAM_S
+{
+    HI_U8* pu8Addr;     /**<Stream buffer address*/ /**<CNcomment: 流数据地址*/
+	HI_U32 u32PhyAddr;  /**<Stream buffer address*/ /**<CNcomment: 流数据物理地址*/
+    HI_U32 u32Size;     /**<Stream buffer size*/ /**<CNcomment: 流数据大小*/
+    HI_S64 s64PtsMs;    /**<PTS(ms)*/ /**<CNcomment: 流数据对应PTS，毫秒为单位*/
+}HI_CODEC_STREAM_S;
+
+/**Defines video codec comonds */
+/**CNcomment: 视频编解码器控制命令结构体*/
+typedef struct hiCODEC_VIDEO_CMD_S
+{
+    HI_U32      u32CmdID;   /**<Commond ID*/ /**<CNcomment: 命令ID*/
+    HI_VOID     *pPara;     /**<Control parameter*/ /**<CNcomment: 命令携带参数*/
+}HI_CODEC_VIDEO_CMD_S;
+
+/**Defines video frame information*/
+/**CNcomment: 视频帧信息结构体*/
+typedef struct hiCODEC_VIDEO_FRAME_S
+{
+    HI_CODEC_COLOR_FORMAT_E             enColorFormat;        /**<Video format*/ /**<CNcomment: 视频格式*/
+    HI_CODEC_VIDEO_FRAME_TYPE_E         enFrameType;          /**<Frame type*/ /**<CNcomment: 帧类型*/
+    HI_BOOL                             bProgressive;         /**<Sampling type*/ /**<CNcomment: 采样类型*/
+    
+    HI_CODEC_VIDEO_FIELD_MODE_E         enFieldMode;          /**<Frame or field encoding mode*/ /**<CNcomment: 帧或场编码模式*/
+    HI_BOOL                             bTopFieldFirst;       /**<Top field first flag*/ /**<CNcomment: 顶场优先标志*/
+
+    HI_CODEC_VIDEO_FRAME_PACKING_TYPE_E enFramePackingType;   /**<3D frame packing type*/ /**<CNcomment: 3D帧打包方式*/
+    
+    HI_U32                              u32FrameRate;         /**<Frame rate*//**<CNcomment: 帧率*/
+    
+    HI_U32                              u32Width;             /**<Width of the source picture*/ /**<CNcomment: 原始图像宽*/
+    HI_U32                              u32Height;            /**<Height of the source picture*/ /**<CNcomment: 原始图像高*/
+    HI_U32                              u32AspectWidth;       /**<Aspect width*/ /**<CNcomment: 最佳显示宽度*/
+    HI_U32                              u32AspectHeight;      /**<Aspect height*/ /**<CNcomment: 最佳显示高度*/
+
+    HI_U32                              u32YAddr;             /**<Address of the Y component in the current frame*/ /**<CNcomment: 当前帧Y分量数据的地址*/
+    HI_U32                              u32UAddr;             /**<Address of the U component in the current frame*/ /**<CNcomment: 当前帧U分量数据的地址*/
+    HI_U32                              u32VAddr;             /**<Address of the V component in the current frame*/ /**<CNcomment: 当前帧V分量数据的地址*/
+    HI_U32                              u32YStride;           /**<Stride of the Y component*/ /**<CNcomment: Y分量数据的跨幅*/
+    HI_U32                              u32UStride;           /**<Stride of the U component*/ /**<CNcomment: C分量数据的跨幅*/
+    HI_U32                              u32VStride;           /**<Stride of the V component*/ /**<CNcomment: C分量数据的跨幅*/
+
+    HI_U8*                              pu8UserData;          /**<User data *//**<CNcomment: 用户数据*/
+    HI_U32                              u32UserDataSize;      /**<User data size *//**<CNcomment: 用户数据长度*/
+}HI_CODEC_VIDEO_FRAME_S;
+
+/**Defines frame descriptor */
+/**CNcomment: 帧描述结构体*/
+typedef struct hiCODEC_FRAME_S
+{
+    HI_CODEC_ADDRESS_S          stOutputAddr;   /**< Always [in], only used by the codecs which support HI_CODEC_OUTPUT_TOSPECADDR, Only used by decoder  */
+                                                /**< CNcomment: 帧输出地址，一直是输入参数，仅适用于支持HI_CODEC_OUTPUT_TOSPECADDR的解码器 */
+    HI_S64                      s64SrcPtsMs;    /**< Decoder [out], encoder [in], The source pts(ms) */
+                                                /**< CNcomment: 帧源PTS，毫秒为单位，对解码器来说是输出参数，对编码器来说是输入参数*/
+    HI_S64                      s64PtsMs;       /**< Decoder [out], encoder [in], The pts(ms)*/
+                                                /**< CNcomment: 帧PTS，毫秒为单位，对解码器来说是输出参数，对编码器来说是输入参数*/
+    union{
+        HI_CODEC_VIDEO_FRAME_S  stVideo;        /**< Decoder [out], encoder [in], The video frame information*/ 
+                                                /**< CNcomment: 视频帧信息，对解码器来说是输出参数，对编码器来说是输入参数*/
+    }unInfo;
+}HI_CODEC_FRAME_S;
+
+/**Defines codec*/
+/**CNcomment: CODEC结构体定义*/
+typedef struct hiCODEC_S
+{
+    /**<Description information about a codec */
+    /**<CNcomment: 编解码器描述名字 */ 
+    const HI_CHAR *pszName;
+
+    /**<Codec version */
+    /**<CNcomment: 编解码器版本描述 */ 
+    const HI_CODEC_VERSION_U unVersion;
+
+    /**<Detailed information about a codec */
+    /**<CNcomment: 编解码器详细描述信息 */
+    const HI_CHAR *pszDescription;
+
+    /**
+    \brief Get codec capability. CNcomment:获取编解码器能力 CNend
+    \attention \n
+    N/A
+    \param [out] pstCodecCap, Pointer of the codec capability. CNcomment:指针类型，指向编解码器能力 CNend
+    \retval ::HI_SUCCESS CNcomment:操作成功 CNend
+    \retval ::HI_FAILURE CNcomment:操作失败 CNend
+    \see \n
+    N/A
+    */
+    HI_S32 (*GetCap)(HI_CODEC_CAP_S *pstCodecCap);
+  
+    /**
+    \brief Create a codec instance. CNcomment:创建编解码器实例 CNend
+    \attention \n
+    N/A
+    \param [in] pstParam, Pointer of the open params. CNcomment:指针类型，指向实例打开参数 CNend
+    \param [out] phInst, Pointer to instance handle. CNcomment:指针类型，指向实例句柄 CNend
+    \retval ::HI_SUCCESS CNcomment:操作成功 CNend
+    \retval ::HI_FAILURE CNcomment:操作失败 CNend
+    \see \n
+    N/A
+    */
+    HI_S32 (*Create)(HI_HANDLE* phInst, const HI_CODEC_OPENPARAM_S * pstParam);
+
+    /**
+    \brief Destroy a codec instance. CNcomment:销毁编解码器实例 CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment:实例句柄 CNend
+    \retval ::HI_SUCCESS CNcomment:操作成功 CNend
+    \retval ::HI_FAILURE CNcomment:操作失败 CNend
+    \see \n
+    N/A
+    */     
+    HI_S32 (*Destroy)(HI_HANDLE hInst);
+
+    /**
+    \brief Start a codec instance. CNcomment:启动编解码器实例 CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment:实例句柄 CNend
+    \retval ::HI_SUCCESS CNcomment:操作成功 CNend
+    \retval ::HI_FAILURE CNcomment:操作失败 CNend
+    \see \n
+    N/A
+    */       
+    HI_S32 (*Start)(HI_HANDLE hInst);
+
+    /**
+    \brief Stop a codec instance. CNcomment:停止编解码器实例 CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment:实例句柄 CNend
+    \retval ::HI_SUCCESS CNcomment:操作成功 CNend
+    \retval ::HI_FAILURE CNcomment:操作失败 CNend
+    \see \n
+    N/A
+    */       
+    HI_S32 (*Stop)(HI_HANDLE hInst);
+
+    /**
+    \brief Reset a codec instance. CNcomment:复位编解码器实例 CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment:实例句柄 CNend
+    \retval ::HI_SUCCESS CNcomment:操作成功 CNend
+    \retval ::HI_FAILURE CNcomment:操作失败 CNend
+    \see \n
+    N/A
+    */        
+    HI_S32 (*Reset)(HI_HANDLE hInst);
+
+    /**
+    \brief Set attribute to a codec instance. CNcomment:设置编解码器属性 CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment:实例句柄 CNend
+    \param [in] pstAttr, Pointer to the instance attribute. CNcomment:指针类型，指向实例属性 CNend
+    \retval ::HI_SUCCESS CNcomment:操作成功 CNend
+    \retval ::HI_FAILURE CNcomment:操作失败 CNend
+    \see \n
+    N/A
+    */      
+    HI_S32 (*SetAttr)(HI_HANDLE hInst, const HI_CODEC_ATTR_S * pstAttr);
+
+    /**
+    \brief Get attribute to a codec instance. CNcomment:获取编解码器属性 CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment:实例句柄 CNend
+    \param [out] pstAttr, Pointer to the instance attribute. CNcomment:指针类型，指向实例属性 CNend
+    \retval ::HI_SUCCESS CNcomment:操作成功 CNend
+    \retval ::HI_FAILURE CNcomment:操作失败 CNend
+    \see \n
+    N/A
+    */        
+    HI_S32 (*GetAttr)(HI_HANDLE hInst, HI_CODEC_ATTR_S * pstAttr);
+
+    /**
+    \brief Decode a frame.. CNcomment:解码一帧 CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment:实例句柄 CNend
+    \param [in] pstIn, Pointer to stream data descriptor. CNcomment:指针类型，指向码流数据信息结构体 CNend
+    \param [out] pstOut, Pointer to frame data descriptor. CNcomment:指针类型，指向帧数据信息结构体 CNend
+    \retval ::HI_SUCCESS CNcomment:操作成功 CNend
+    \retval ::HI_FAILURE CNcomment:操作失败 CNend
+    \see \n
+    N/A
+    */     
+    HI_S32 (*DecodeFrame)(HI_HANDLE hInst, HI_CODEC_STREAM_S * pstIn, HI_CODEC_FRAME_S * pstOut);
+
+    /**
+    \brief Encode a frame. CNcomment:编码一帧 CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment:实例句柄 CNend
+    \param [in] pstIn, Pointer to stream data descriptor. CNcomment:指针类型，指向码流数据信息结构体 CNend
+    \param [out] pstOut, Pointer to frame data descriptor. CNcomment:指针类型，指向帧数据信息结构体 CNend
+    \retval ::HI_SUCCESS CNcomment:操作成功 CNend
+    \retval ::HI_FAILURE CNcomment:操作失败 CNend
+    \see \n
+    N/A
+    */     
+    HI_S32 (*EncodeFrame)(HI_HANDLE hInst, HI_CODEC_FRAME_S * pstIn, HI_CODEC_STREAM_S * pstOut);
+
+    /**
+    \brief Get stream information. CNcomment:获取码流信息 CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment:实例句柄 CNend
+    \param [out] pstAttr, Pointer to stream information. CNcomment:指针类型，指向码流信息结构体 CNend
+    \retval ::HI_SUCCESS CNcomment:操作成功 CNend
+    \retval ::HI_FAILURE CNcomment:操作失败 CNend
+    \see \n
+    N/A
+    */     
+    HI_S32 (*GetStreamInfo)(HI_HANDLE hInst, HI_CODEC_STREAMINFO_S * pstAttr);
+
+	HI_S32 (*RegFrameBuffer)(HI_HANDLE hInst, HI_CODEC_STREAM_S *pstRawPacket);
+    /**
+    \brief Other control, can be extended. CNcomment:其他控制选项，可扩展 CNend
+    \attention \n
+    N/A
+    \param [in] hInst, Instance handle. CNcomment:实例句柄 CNend
+    \param [out] u32CMD, The commond ID. CNcomment:命令ID CNend
+    \param [out] pParam, Pointer to control parameter. CNcomment:指针类型，指向控制参数 CNend
+    \retval ::HI_SUCCESS CNcomment:操作成功 CNend
+    \retval ::HI_FAILURE CNcomment:操作失败 CNend
+    \see \n
+    N/A
+    */     
+    HI_S32 (*Control)(HI_HANDLE hInst, HI_U32 u32CMD, HI_VOID * pParam);
+}HI_CODEC_S;
+
+/** @} */  /** <!-- ==== Structure Definition End ==== */
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* __HI_VIDEO_CODEC_H__ */
diff -uNr a/include/manager.h b/include/manager.h
--- a/include/manager.h	2019-05-19 08:46:16.000000000 +0200
+++ b/include/manager.h	2022-07-03 13:17:10.000000000 +0200
@@ -44,6 +44,12 @@
     int32_t               version;
     long long int         pts;
     long long int         dts;
+	
+    int32_t               channels;
+    int32_t               bits_per_coded_sample;
+    int32_t               sample_rate;
+	int32_t               codec_id;
+	
     
     /* for later use: */
     eTrackTypeEplayer     type;
diff -uNr a/include/writer.h b/include/writer.h
--- a/include/writer.h	2019-05-19 08:46:16.000000000 +0200
+++ b/include/writer.h	2022-07-03 13:17:10.000000000 +0200
@@ -92,7 +92,8 @@
 ssize_t write_with_retry(int fd, const void *buf, int size);
 ssize_t writev_with_retry(int fd, const struct iovec *iov, int ic);
 
-ssize_t WriteWithRetry(Context_t *context, int pipefd, int fd, void *pDVBMtx, const void *buf, int size);
+//ssize_t WriteWithRetry(Context_t *context, int pipefd, int fd, void *pDVBMtx, const void *buf, int size);
+ssize_t WriteWithRetry(Context_t *context, uint8_t type, uint8_t* pData, size_t iSize, int64_t pts_ms);
 void FlushPipe(int pipefd);
 
 ssize_t WriteExt(WriteV_t _call, int fd, void *data, size_t size);
diff -uNr a/main/des.c b/main/des.c
--- a/main/des.c	1970-01-01 01:00:00.000000000 +0100
+++ b/main/des.c	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,666 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include "des.h"
+
+static byte  PC2[8][6] = 
+{
+    { 14, 17, 11, 24,  1,  5 },
+    {  3, 28, 15,  6, 21, 10 },
+    { 23, 19, 12,  4, 26,  8 },
+    { 16,  7, 27, 20, 13,  2 },
+    { 41, 52, 31, 37, 47, 55 },
+    { 30, 40, 51, 45, 33, 48 },
+    { 44, 49, 39, 56, 34, 53 },
+    { 46, 42, 50, 36, 29, 32 }
+};
+
+
+static byte  E[8][6] =
+{
+    { 32,  1,  2,  3,  4,  5 },
+    {  4,  5,  6,  7,  8,  9 },
+    {  8,  9, 10, 11, 12, 13 },
+    { 12, 13, 14, 15, 16, 17 },
+    { 16, 17, 18, 19, 20, 21 },
+    { 20, 21, 22, 23, 24, 25 },
+    { 24, 25, 26, 27, 28, 29 },
+    { 28, 29, 30, 31, 32,  1 } 
+};
+
+
+
+static byte  P[32] =
+{
+    16,  7, 20, 21, 29, 12, 28, 17,  1, 15, 23, 26,  5, 18, 31, 10,
+     2,  8, 24, 14, 32, 27,  3,  9, 19, 13, 30,  6, 22, 11,  4, 25
+};
+                               
+
+static byte  SBOXES[4][64] =
+{
+    {
+        0x2e, 0xe0, 0xc4, 0xbf, 0x4d, 0x27, 0x11, 0xc4,
+        0x72, 0x4e, 0xaf, 0x72, 0xbb, 0xdd, 0x68, 0x11,
+        0x83, 0x5a, 0x5a, 0x06, 0x36, 0xfc, 0xfc, 0xab,
+        0xd5, 0x39, 0x09, 0x95, 0xe0, 0x83, 0x97, 0x68,
+        0x44, 0xbf, 0x21, 0x8c, 0x1e, 0xc8, 0xb8, 0x72,
+        0xad, 0x14, 0xd6, 0xe9, 0x72, 0x21, 0x8b, 0xd7,
+        0xff, 0x65, 0x9c, 0xfb, 0xc9, 0x03, 0x57, 0x9e,
+        0x63, 0xaa, 0x3a, 0x40, 0x05, 0x56, 0xe0, 0x3d
+    },
+    {
+        0xcf, 0xa3, 0x11, 0xfd, 0xa8, 0x44, 0xfe, 0x27,
+        0x96, 0x7f, 0x2b, 0xc2, 0x63, 0x98, 0x84, 0x5e,
+        0x09, 0x6c, 0xd7, 0x10, 0x32, 0xd1, 0x4d, 0xea,
+        0xec, 0x06, 0x70, 0xb9, 0x55, 0x3b, 0xba, 0x85,
+        0x90, 0x4d, 0xee, 0x38, 0xf7, 0x2a, 0x5b, 0xc1,
+        0x2a, 0x93, 0x84, 0x5f, 0xcd, 0xf4, 0x31, 0xa2,
+        0x75, 0xbb, 0x08, 0xe6, 0x4c, 0x17, 0xa6, 0x7c,
+        0x19, 0x60, 0xd3, 0x05, 0xb2, 0x8e, 0x6f, 0xd9
+    },
+    {
+        0x4a, 0xdd, 0xb0, 0x07, 0x29, 0xb0, 0xee, 0x79,
+        0xf6, 0x43, 0x03, 0x94, 0x8f, 0x16, 0xd5, 0xaa,
+        0x31, 0xe2, 0xcd, 0x38, 0x9c, 0x55, 0x77, 0xce,
+        0x5b, 0x2c, 0xa4, 0xfb, 0x62, 0x8f, 0x18, 0x61,
+        0x1d, 0x61, 0x46, 0xba, 0xb4, 0xdd, 0xd9, 0x80,
+        0xc8, 0x16, 0x3f, 0x49, 0x73, 0xa8, 0xe0, 0x77,
+        0xab, 0x94, 0xf1, 0x5f, 0x62, 0x0e, 0x8c, 0xf3,
+        0x05, 0xeb, 0x5a, 0x25, 0x9e, 0x32, 0x27, 0xcc
+    },
+    {
+        0xd7, 0x1d, 0x2d, 0xf8, 0x8e, 0xdb, 0x43, 0x85,
+        0x60, 0xa6, 0xf6, 0x3f, 0xb9, 0x70, 0x1a, 0x43,
+        0xa1, 0xc4, 0x92, 0x57, 0x38, 0x62, 0xe5, 0xbc,
+        0x5b, 0x01, 0x0c, 0xea, 0xc4, 0x9e, 0x7f, 0x29,
+        0x7a, 0x23, 0xb6, 0x1f, 0x49, 0xe0, 0x10, 0x76,
+        0x9c, 0x4a, 0xcb, 0xa1, 0xe7, 0x8d, 0x2d, 0xd8,
+        0x0f, 0xf9, 0x61, 0xc4, 0xa3, 0x95, 0xde, 0x0b,
+        0xf5, 0x3c, 0x32, 0x57, 0x58, 0x62, 0x84, 0xbe
+    }
+};
+
+
+
+static byte  PC1[][8] = 
+{
+  {57, 49, 41, 33, 25, 17,  9, 1}, 
+  {58, 50, 42, 34, 26, 18, 10, 2},
+  {59, 51, 43, 35, 27, 19, 11, 3},
+  {60, 52, 44, 36, 63, 55, 47,39},
+  {31, 23, 15,  7, 62, 54, 46,38},
+  {30, 22, 14,  6, 61, 53, 45,37},
+  {29, 21, 13,  5, 28, 20, 12, 4}
+};
+
+
+void doPC1(byte data[])
+{
+	byte buf[8];
+	register byte j;
+	register byte lookup;
+
+	memset(buf, 0, 8);
+
+	for(j=0; j<7; j++) {
+		lookup = PC1[j][0]; buf[j] |= ((data[(lookup>>3)]>>(8-(lookup & 7))) & 1) << (7-0);
+		lookup = PC1[j][1]; buf[j] |= ((data[(lookup>>3)]>>(8-(lookup & 7))) & 1) << (7-1);
+		lookup = PC1[j][2]; buf[j] |= ((data[(lookup>>3)]>>(8-(lookup & 7))) & 1) << (7-2);
+		lookup = PC1[j][3]; buf[j] |= ((data[(lookup>>3)]>>(8-(lookup & 7))) & 1) << (7-3);
+		lookup = PC1[j][4]; buf[j] |= ((data[(lookup>>3)]>>(8-(lookup & 7))) & 1) << (7-4);
+		lookup = PC1[j][5]; buf[j] |= ((data[(lookup>>3)]>>(8-(lookup & 7))) & 1) << (7-5);
+		lookup = PC1[j][6]; buf[j] |= ((data[(lookup>>3)]>>(8-(lookup & 7))) & 1) << (7-6);
+		lookup = PC1[j][7]; buf[j] |= ((data[(lookup>>3)]>>(8-(lookup & 7))) & 1) << (7-7);
+	}
+
+	memcpy(data, buf, 8);
+}
+
+/*
+void doPC1(byte data[])
+{
+  byte buf[8];
+  byte i, j;
+
+  memset(buf, 0, 8);
+
+	for(j=0; j<7; j++) {
+		for(i=0; i<8; i++) {
+			byte lookup = PC1[j][i];
+			buf[j] |= ((data[(lookup>>3)]>>(8-(lookup & 7))) & 1) << (7-i);
+		}
+	}
+
+	memcpy(data, buf, 8);
+}
+*/
+void doIp(byte data[])
+{
+  unsigned char j, k;
+  byte val;
+  byte buf[8];
+  byte *p;
+  byte i = 8;
+
+  for(i=0; i<8; i++)
+  {
+    val = data[i];
+    p = &buf[3];
+    j = 4;
+
+    do
+    {
+      for(k=0; k<=4; k+=4)
+      {
+        p[k] >>= 1;
+        if(val & 1) p[k] |= 0x80;
+        val >>= 1;
+      }
+      p--;
+    } while(--j);
+  }
+
+  memcpy(data, buf, 8);
+}
+
+void doIp_1(byte data[])
+{
+  unsigned char j, k;
+  byte r = 0;
+  byte buf[8];
+  byte *p;
+  byte i = 8;
+
+  for(i=0; i<8; i++)
+  {
+    p = &data[3];
+    j = 4;
+
+    do
+    {
+      for(k=0; k<=4; k+=4)
+      {
+        r >>= 1;
+        if(p[k] & 1) r |= 0x80;
+        p[k] >>= 1;
+      }
+      p--;
+    } while(--j);
+    buf[i] = r;
+  }
+
+  memcpy(data, buf, 8);
+}
+
+
+void makeK(byte *left, byte *right, byte *K)
+{
+  byte i, j;
+  byte bit, val;
+  byte *p;
+
+  for(i=0; i<8; i++)
+  {
+    val = 0;
+    for(j=0; j<6; j++)
+    {
+      bit = PC2[i][j];
+      if(bit < 29)
+      {
+        bit = 28-bit;
+        p   = left;
+      }
+      else
+      {
+        bit = 56-bit;
+        p   = right;
+      }
+      val <<= 1;
+      if( p[bit >> 3] & (1 << (bit & 7)) ) val |= 1;
+    }
+    *K = val;
+	  K++;
+  }
+}
+
+void rightRot(byte key[])
+{         
+  byte *p     = key;
+  byte  i     = 3;
+  byte  carry = 0;
+
+  if(*p & 1) carry = 0x08;
+
+  do {
+    *p = (*p >> 1) | ((p[1] & 1) ? 0x80 : 0);
+    p++;
+  } while(--i);
+
+  *p = (*p >> 1) | carry;
+}
+
+void rightRotKeys(byte left[], byte right[])
+{
+  rightRot(left);
+  rightRot(right);
+}
+
+void leftRot(byte key[])
+{
+  byte i = 27;
+
+  do {
+    rightRot(key);
+  } while(--i);
+}
+
+void leftRotKeys(byte left[], byte right[])
+{
+  leftRot(left);
+  leftRot(right);
+}
+
+void desCore(byte data[], byte K[], byte result[])
+{
+  byte i, j;
+  byte bit, val;
+
+  memset(result, 0, 4);
+
+  for(i=0; i<8; i++)
+  {
+    val = 0;
+    for(j=0; j<6; j++)
+    {
+      bit = 32-E[i][j];
+      val <<= 1;
+      if( data[3 - (bit >> 3)] & (1 << (bit & 7)) ) val |= 1;
+    }
+    val ^= K[i];
+    val  = SBOXES[i & 3][val];
+    if(i > 3)
+    {
+      val >>= 4;
+    }
+    val &= 0x0f;
+    result[i >> 1] |= (i & 1) ? val : (val << 4);
+  }
+}
+
+void permut32(byte data[])
+{
+  byte i, j;
+  byte bit;
+  byte r[4];
+  byte *p;
+
+  for(i=0; i<32; i++)
+  {
+    bit = 32-P[i];
+    p = r;
+
+
+    for(j=0; j<3; j++)
+    {
+      *p = (*p << 1) | ((p[1] & 0x80) ? 1 : 0);
+      p++;
+    }
+
+    *p <<= 1;
+    if( data[3 - (bit >> 3)] & (1 << (bit & 7)) ) *p |= 1;
+  }
+
+  memcpy(data, r, 4);
+}
+
+void swap(byte left[], byte right[])
+{
+  byte x[4];
+
+  memcpy(x, right, 4);
+  memcpy(right, left, 4);
+  memcpy(left, x, 4);
+}
+
+void desRound(byte left[], byte right[], byte data[], byte mode, byte k8)
+{
+  byte i;
+  byte K[8];
+  byte r[4];
+  byte tempr[4];
+  unsigned short temp;
+
+  memcpy(tempr, data+4, 4);
+
+  /* Viaccess */
+  temp = (short)k8*(short)tempr[0]+(short)k8+(short)tempr[0];
+  tempr[0] = (temp & 0xff) - ((temp>>8) & 0xff);
+  if((temp & 0xff) - (temp>>8) < 0)
+    tempr[0]++;
+
+  makeK(left, right, K);
+  desCore(tempr, K, r);
+  permut32(r);
+
+  if(mode & DES_HASH)
+  {
+    i    = r[0];
+    r[0] = r[1];
+    r[1] = i;
+  }
+
+/*
+  for(i=0; i<4; i++)
+  {
+    *data ^= r[i];
+    data++;
+  }
+*/
+  *data ^= r[0]; data++;
+  *data ^= r[1]; data++;
+  *data ^= r[2]; data++;
+  *data ^= r[3]; data++;
+
+  swap(data-4, data);
+}
+
+void des(byte key[], byte mode, byte data[])
+{    
+  byte i; 
+  byte left[8];
+  byte right[8];
+  byte *p = left;
+
+  short DESShift = (mode & DES_RIGHT) ? 0x8103 : 0xc081;
+
+/*
+  for(i=3; i>0; i--)
+  {
+    *p = (key[i-1] << 4) | (key[i] >> 4);
+    p++;
+  }
+*/
+  *p = (key[3-1] << 4) | (key[3] >> 4); p++;
+  *p = (key[2-1] << 4) | (key[2] >> 4); p++;
+  *p = (key[1-1] << 4) | (key[1] >> 4); p++;
+
+
+  left[3] =  key[0] >> 4;
+  right[0] = key[6];
+  right[1] = key[5];
+  right[2] = key[4];
+  right[3] = key[3] & 0x0f;
+
+  if(mode & DES_IP) doIp(data);
+
+  do {
+    if(!(mode & DES_RIGHT))
+    {
+      leftRotKeys(left, right);
+      if(!(DESShift & 0x8000)) leftRotKeys(left, right);
+    }
+    desRound(left, right, data, mode, key[7]);
+
+    if(mode & DES_RIGHT)
+    {
+      rightRotKeys(left, right);
+      if(!(DESShift & 0x8000)) rightRotKeys(left, right);
+    }
+    DESShift <<= 1;
+  } while(DESShift);
+
+  swap(data, data+4);
+  if(mode & DES_IP_1) doIp_1(data);
+
+}
+
+byte getmask(byte *OutData, byte *Mask, byte I, byte J) 
+{
+  byte K, B, M, M1 , D, DI, MI;
+
+  K = I ^ J;
+  DI = 7;
+  if ((K & 4) == 4) {
+    K ^= 7;
+    DI ^= 7;
+  }
+  MI = 3;
+  MI &= J;
+  K ^= MI;
+  K += MI;
+  if ((K & 4) == 4) {
+    return 0;
+  }
+  DI ^= J;
+  D = OutData[DI];
+  MI = 0;
+  MI += J;
+  M1 = Mask[MI];
+  MI ^= 4;
+  M = Mask[MI];
+  B = 0;
+
+  for(K = 0; K <=7; K++) 
+  {
+    if ((D & 1) == 1) B += M;
+    D = (D >> 1) + ((B & 1) << 7);
+    B = B >> 1;
+  }
+
+  return D ^ M1;
+}
+
+
+static void v2mask(byte *cw, byte *mask) 
+{
+	register int i, j;
+
+	for(i = 7; i >= 0; i--) {
+		cw[i] ^= getmask(cw, mask, i, 7);
+		cw[i] ^= getmask(cw, mask, i, 6);
+		cw[i] ^= getmask(cw, mask, i, 5);
+		cw[i] ^= getmask(cw, mask, i, 4);
+	}
+
+	for(i = 0; i <= 7; i++) {
+		cw[i] ^= getmask(cw, mask, i, 0);
+		cw[i] ^= getmask(cw, mask, i, 1);
+		cw[i] ^= getmask(cw, mask, i, 2);
+		cw[i] ^= getmask(cw, mask, i, 3);
+	}
+}                                                                                
+
+/*
+void v2mask(byte *cw, byte *mask) 
+{
+	int i, j;
+
+	for(i = 7; i >= 0; i--)
+		for(j = 7; j >=4; j--)
+			cw[i] ^= getmask(cw, mask, i, j);
+	for(i = 0; i <= 7; i++)
+		for(j = 0; j <=3; j++)
+			cw[i] ^= getmask(cw, mask, i, j);
+}                                                                                
+
+*/
+
+
+void EuroDes(byte key1[], byte key2[], byte desMode, byte operatingMode, byte data[])
+{                   
+  byte mode;
+
+ if(key1[7]) { /* Viaccess */
+   mode = (operatingMode == HASH) ? DES_ECM_HASH : DES_ECM_CRYPT;
+
+   if(key2 != NULL)
+     	v2mask(data, key2);
+   des(key1, mode, data);
+   if(key2 != NULL)
+     	v2mask(data, key2);
+ } 
+ else if(TestBit(desMode, F_TRIPLE_DES))
+ {
+   /* Eurocrypt 3-DES */
+   mode = (operatingMode == HASH) ?  0 : DES_RIGHT;
+   des(key1, (byte)(DES_IP | mode), data);
+
+   mode ^= DES_RIGHT;
+   des(key2, mode, data);
+
+   mode ^= DES_RIGHT;
+   des(key1, (byte)(mode | DES_IP_1), data);
+ }
+ else
+ {
+   if(TestBit(desMode, F_EURO_S2))
+   {
+     /* Eurocrypt S2 */
+     mode = (operatingMode == HASH) ? DES_ECS2_CRYPT : DES_ECS2_DECRYPT;
+   }
+   else
+   {                           
+     /* Eurocrypt M */
+     mode = (operatingMode == HASH) ? DES_ECM_HASH : DES_ECM_CRYPT;
+   }                          
+   des(key1, mode, data);
+ }
+}
+
+/*------------------------------------------------------------------------*/
+void des_key_parity_adjust(byte *key, byte len)
+{
+  register byte i, j, parity;
+
+  for (i = 0; i < len; i++)
+  {
+    parity = 1;
+
+//    for (j = 1; j < 8; j++) if ((key[i] >> j) & 0x1) parity = ~parity & 0x01;
+    if ((key[i] >> 1) & 0x1) parity = ~parity & 0x01;
+    if ((key[i] >> 2) & 0x1) parity = ~parity & 0x01;
+    if ((key[i] >> 3) & 0x1) parity = ~parity & 0x01;
+    if ((key[i] >> 4) & 0x1) parity = ~parity & 0x01;
+    if ((key[i] >> 5) & 0x1) parity = ~parity & 0x01;
+    if ((key[i] >> 6) & 0x1) parity = ~parity & 0x01;
+    if ((key[i] >> 7) & 0x1) parity = ~parity & 0x01;
+
+    key[i] |= parity;
+  }
+}
+
+static void des_key_spread(byte *normal,byte *spread)
+{
+  spread[ 0] = normal[ 0] & 0xfe;
+  spread[ 1] = ((normal[ 0] << 7) | (normal[ 1] >> 1)) & 0xfe;
+  spread[ 2] = ((normal[ 1] << 6) | (normal[ 2] >> 2)) & 0xfe;
+  spread[ 3] = ((normal[ 2] << 5) | (normal[ 3] >> 3)) & 0xfe;
+  spread[ 4] = ((normal[ 3] << 4) | (normal[ 4] >> 4)) & 0xfe;
+  spread[ 5] = ((normal[ 4] << 3) | (normal[ 5] >> 5)) & 0xfe;
+  spread[ 6] = ((normal[ 5] << 2) | (normal[ 6] >> 6)) & 0xfe;
+  spread[ 7] = normal[ 6] << 1;
+  spread[ 8] = normal[ 7] & 0xfe;
+  spread[ 9] = ((normal[ 7] << 7) | (normal[ 8] >> 1)) & 0xfe;
+  spread[10] = ((normal[ 8] << 6) | (normal[ 9] >> 2)) & 0xfe;
+  spread[11] = ((normal[ 9] << 5) | (normal[10] >> 3)) & 0xfe;
+  spread[12] = ((normal[10] << 4) | (normal[11] >> 4)) & 0xfe;
+  spread[13] = ((normal[11] << 3) | (normal[12] >> 5)) & 0xfe;
+  spread[14] = ((normal[12] << 2) | (normal[13] >> 6)) & 0xfe;
+  spread[15] = normal[13] << 1;
+
+  des_key_parity_adjust(spread, 16);
+}
+
+void des_random_get(byte *buffer, byte len)
+{
+  byte idx = 0;
+  int randomNo = 0;
+
+  for (idx = 0; idx < len; idx++)
+  {
+    if (!(idx % 3)) randomNo = rand();
+    buffer[idx] = (randomNo >> ((idx % 3) << 3)) & 0xff;
+  }
+}
+
+//#define CWS_NETMSGSIZE 300
+
+int des_encrypt(byte *buffer, int len, byte *deskey)
+{
+  byte checksum = 0;
+  byte noPadBytes;
+  byte padBytes[7];
+  char ivec[8];
+  register short i;
+
+  if (!deskey) return len;
+  noPadBytes = (8 - ((len - 1) % 8)) % 8;
+  //if (len + noPadBytes + 1 >= CWS_NETMSGSIZE-8) return -1;
+  des_random_get(padBytes, noPadBytes);
+  for (i = 0; i < noPadBytes; i++) buffer[len++] = padBytes[i];
+  for (i = 2; i < len; i++) checksum ^= buffer[i];
+  buffer[len++] = checksum;
+  des_random_get((byte *)ivec, 8);
+  memcpy(buffer+len, ivec, 8);
+  for (i = 2; i < len; i += 8)
+  {
+    byte j;
+    const byte flags = (1 << F_EURO_S2) | (1 << F_TRIPLE_DES);
+
+//    for(j=0; j<8; j++) buffer[i+j] ^= ivec[j];
+    buffer[i+0] ^= ivec[0];
+    buffer[i+1] ^= ivec[1];
+    buffer[i+2] ^= ivec[2];
+    buffer[i+3] ^= ivec[3];
+    buffer[i+4] ^= ivec[4];
+    buffer[i+5] ^= ivec[5];
+    buffer[i+6] ^= ivec[6];
+    buffer[i+7] ^= ivec[7];
+
+    EuroDes(deskey, deskey+8, flags, 1, buffer+i);
+    memcpy(ivec, buffer+i, 8);
+  }
+  len += 8;
+  return len;
+}
+
+int des_decrypt(byte *buffer, int len, byte *deskey)
+{
+  char ivec[8];
+  char nextIvec[8];
+  int i;
+  byte checksum = 0;
+printf("des_decrypt\n");
+  if (!deskey) return len;
+  //if ((len-2) % 8 || (len-2) < 16) return -1;
+  //len -= 8;
+  memcpy(nextIvec, buffer+len, 8);
+  printf("des_decrypt\n");
+  for (i = 2; i < len; i += 8)
+  {
+    byte j;
+    const byte flags = (1 << F_EURO_S2) | (1 << F_TRIPLE_DES);
+
+    memcpy(ivec, nextIvec, 8);
+    memcpy(nextIvec, buffer+i, 8);
+    EuroDes(deskey, deskey+8, flags, 0, buffer+i);
+    for(j=0; j<8; j++)
+      buffer[i+j] ^= ivec[j];
+  } 
+  for (i = 2; i < len; i++) checksum ^= buffer[i];
+  if (checksum) return -1;
+  return len;
+}
+
+void des_login_key_get(byte *key1, byte *key2, int len, byte *des16)
+{
+  byte des14[14];
+  int i;
+
+  memcpy(des14, key1, sizeof(des14));
+  for (i = 0; i < len; i++) des14[i%14] ^= key2[i];
+  des_key_spread(des14, des16);
+  doPC1(des16);
+  doPC1(des16+8);
+}
diff -uNr a/main/exteplayer.c b/main/exteplayer.c
--- a/main/exteplayer.c	2022-06-22 23:26:10.000000000 +0200
+++ b/main/exteplayer.c	2022-07-03 15:09:22.542811400 +0200
@@ -43,6 +43,18 @@
 #include "misc.h"
 
 #include "debug.h"
+#include "des.h"
+#include <HA.AUDIO.PCM.decode.h>
+#include <hi_adp_mpi.h>
+#include <hi_audio_codec.h>
+#include <hi_type.h>
+#include <hi_unf_advca.h>
+#include <hi_unf_audio.h>
+#include <hi_unf_common.h>
+#include <hi_unf_disp.h>
+#include <hi_unf_otp.h>
+#include <hi_unf_video.h>
+#include <hi_unf_vo.h>
 
 #define DUMP_BOOL(x) 0 == x ? "false"  : "true"
 #define IPTV_MAX_FILE_PATH 1024
@@ -75,6 +87,126 @@
 
 static Context_t *g_player = NULL;
 
+
+
+HI_U8 HexStr_8558[16] = {0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46};
+void lths(HI_U8 *a1, HI_U8 *a2)
+{
+    HI_S32 i;
+    for ( i = 0; i <= 3; ++i )
+    {
+        a2[ 2 * i]      = HexStr_8558[(a1[i] >> 4) & 0xF];
+        a2[ 2 * i + 1]  = HexStr_8558[(a1[i]) & 0xF];
+    }
+}
+
+HI_U8 TripleDesKey[14] = { 0x7E, 0xF0, 0xC4, 0xB2, 0x2D, 0x97, 0x31, 0xC4, 0x42, 0x4E, 0xA5, 0x77, 0x2B, 0xD3 };
+
+void get_mac(HI_U8 *in, HI_U8 *out)
+{
+    //0 4 5 1 2 3
+    out[0] = in[0];
+    out[1] = in[4];
+    out[2] = in[5];
+    out[3] = in[1];
+    out[4] = in[2];
+    out[5] = in[3];
+}
+
+void swap_id(HI_U8 *in, HI_U8 *out)
+{
+    HI_U8 tmp[8];
+    memcpy(tmp, in, 8);
+    out[0] = tmp[7];
+    out[1] = tmp[6];
+    out[2] = tmp[5];
+    out[3] = tmp[4];
+    out[4] = tmp[3];
+    out[5] = tmp[2];
+    out[6] = tmp[1];
+    out[7] = tmp[0];
+}
+
+
+bool check_chip_id()
+{
+    char str[0x100];
+    bool ret = false;
+    HI_S32 i;
+    HI_U8 sessionkey[16];
+    HI_U8 gen[14] =
+    {
+        0x00,
+        0x00,
+        0x00,
+        0x00,
+        0x00,
+        0x00,
+        0x00,
+        0x00,
+        0x58,   //R2, [SP,#0x78+var_58]
+        0x32,   //LR, [SP,#0x78+var_58+1]
+        0x94,   //R12, [SP,#0x78+var_58+2]
+        0x30,   //R2, [SP,#0x78+var_58+3]
+        0x22,   //LR, [SP,#0x78+var_54]
+        0xf5,    //R12, [SP,#0x78+var_54+1]
+    };
+    HI_U8 chip_id[8];
+    HI_U8 HWaddr[6];
+
+
+    HI_SYS_CHIP_ATTR_S stChipAttr;
+
+    memset(&stChipAttr, 0, sizeof(HI_SYS_CHIP_ATTR_S));
+
+    if (HI_SYS_Init() != HI_SUCCESS)
+        return false;
+
+    if (HI_UNF_OTP_Init() != HI_SUCCESS)
+    {
+        HI_SYS_DeInit();
+        return false;
+    }
+
+
+
+    if (HI_SYS_GetChipAttr(&stChipAttr) != HI_SUCCESS)
+    {
+        HI_UNF_OTP_DeInit();
+        HI_SYS_DeInit();
+        return false;
+    }
+
+    lths((HI_U8*)&stChipAttr.u32ChipID, gen);
+
+    des_login_key_get(TripleDesKey,gen, 14, sessionkey);
+
+    memcpy(chip_id, &stChipAttr.u64ChipID, 8);
+    EuroDes(sessionkey, sessionkey+8, 3, 0, chip_id);
+
+    swap_id(chip_id, chip_id);
+/*
+    printf("##################chip id ###################\n");
+    for(i=0; i< 8; i++ )
+        printf("%02x ", chip_id[i]);
+    printf("\n##################chip id ###################\n");
+*/
+    get_mac(chip_id, HWaddr);
+
+
+    if((HWaddr[0] == 0xD0) && (HWaddr[1] == 0x89))
+    {
+        ret = true;
+    }
+
+    HI_UNF_OTP_DeInit();
+    HI_SYS_DeInit();
+    return ret;
+}
+
+
+
+
 static void TerminateAllSockets(void)
 {
     int i;
@@ -82,8 +214,8 @@
     {
         if( 0 == shutdown(i, SHUT_RDWR) )
         {
-            /* yes, I know that this is not good practice and I know what this could cause 
-             * but in this use case it can be accepted. 
+            /* yes, I know that this is not good practice and I know what this could cause
+             * but in this use case it can be accepted.
              * We must close socket because without closing it recv will return 0 (after shutdown)
              * 0 is not correctly handled by external libraries
              */
@@ -137,7 +269,8 @@
 static void TerminateWakeUp()
 {
     int ret = write(g_pfd[1], "x", 1);
-    if (ret != 1) {
+    if (ret != 1)
+    {
         printf("TerminateWakeUp write return %d\n", ret);
     }
 }
@@ -150,9 +283,9 @@
     int cl = -1;
     int nfds = 1;
     fd_set readfds;
-    
+
     unlink(socket_path);
-    if ( (fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) 
+    if ( (fd = socket(AF_UNIX, SOCK_STREAM, 0)) == -1)
     {
         perror("TermThreadFun socket error");
         goto finish;
@@ -162,13 +295,13 @@
     addr.sun_family = AF_UNIX;
     strncpy(addr.sun_path, socket_path, sizeof(addr.sun_path)-1);
 
-    if (bind(fd, (struct sockaddr*)&addr, sizeof(addr)) == -1) 
+    if (bind(fd, (struct sockaddr*)&addr, sizeof(addr)) == -1)
     {
         perror("TermThreadFun bind error");
         goto finish;
     }
 
-    if (listen(fd, 1) == -1) 
+    if (listen(fd, 1) == -1)
     {
         perror("TermThreadFun listen error");
         goto finish;
@@ -177,16 +310,16 @@
     FD_ZERO(&readfds);
     FD_SET(g_pfd[0], &readfds);
     FD_SET(fd, &readfds);
-    
+
     nfds = fd > g_pfd[0] ? fd + 1 : g_pfd[0] + 1;
-    
-    while (select(nfds, &readfds, NULL, NULL, NULL) == -1 
-           && errno == EINTR)
+
+    while (select(nfds, &readfds, NULL, NULL, NULL) == -1
+            && errno == EINTR)
     {
         /* Restart if interrupted by signal */
         continue;
     }
-    
+
     if (FD_ISSET(fd, &readfds))
     {
         pthread_mutex_lock(&playbackStartMtx);
@@ -202,11 +335,12 @@
     close(cl);
     close(fd);
     pthread_exit(NULL);
-    
+
 }
 
 static void map_inter_file_path(char *filename)
 {
+    char *param = NULL;					   
     if (0 == strncmp(filename, "iptv://", 7))
     {
         FILE *f = fopen(filename + 7, "r");
@@ -224,8 +358,56 @@
             }
         }
     }
-}
 
+    param = strstr(filename, ".mpd&");
+    if (param)
+    {
+        int pos = param - filename;
+        param+=5;
+        int len = strlen(param)+1;
+        int idx = 0;
+        int start = -1;
+        int end = -1;
+        while(idx < len)
+        {
+            if(param[idx] == '=')
+                start = idx-1;
+        
+            if((param[idx] == '\0') || (param[idx] == '\n') || (param[idx] == '&'))
+                end = idx;
+ 
+            if(start != -1 && end != -1)
+            {
+                char str[128];
+                strncpy(str, param+start, end-start);
+                str[end-start] = '\0';
+
+                switch(str[0])
+                {
+                case '0':
+                    ffmpeg_av_dict_set("video_rep_index", str+2, 0);
+                    break;
+                case '1':
+                    ffmpeg_av_dict_set("audio_rep_index", str+2, 0);
+                    break;
+                case '5':
+                    ffmpeg_av_dict_set("cenc_decryption_key", str+2, 0);
+                    break;
+                case '6':
+                    ffmpeg_av_dict_set("cenc_decryption_video_key", str+2, 0);
+                    break;
+                case '7':
+                    ffmpeg_av_dict_set("cenc_decryption_audio_key", str+2, 0);
+                    break;
+                }
+                start = end = -1;
+            }
+            idx++;
+        }
+        filename[pos+4] = '\0';
+    }
+
+}
 static int kbhit(void)
 {
     struct timeval tv;
@@ -259,19 +441,20 @@
     {
         printf("SetBuffering: failed to change the buffer of stderr\n");
     }
-    
-    // make fgets not blocking 
-    int flags = fcntl(stdin->_fileno, F_GETFL, 0); 
-    fcntl(stdin->_fileno, F_SETFL, flags | O_NONBLOCK); 
+
+    // make fgets not blocking
+    int flags = fcntl(stdin->_fileno, F_GETFL, 0);
+    fcntl(stdin->_fileno, F_SETFL, flags | O_NONBLOCK);
 }
 
 static void SetNice(int prio)
 {
 #if 0
     setpriority(PRIO_PROCESS, 0, -8);
-    
+
     int prio = sched_get_priority_max(SCHED_RR) / 2;
-    struct sched_param param = {
+    struct sched_param param =
+    {
         .sched_priority = prio
     };
     sched_setscheduler(0, SCHED_RR, &param);
@@ -287,128 +470,128 @@
 static int HandleTracks(const Manager_t *ptrManager, const PlaybackCmd_t playbackSwitchCmd, const char *argvBuff)
 {
     int commandRetVal = 0;
-    
+
     if (NULL == ptrManager || NULL == argvBuff || 2 != strnlen(argvBuff, 2))
     {
         return -1;
     }
-    
-    switch (argvBuff[1]) 
+
+    switch (argvBuff[1])
+    {
+    case 'l':
     {
-        case 'l': 
+        TrackDescription_t *TrackList = NULL;
+        ptrManager->Command(g_player, MANAGER_LIST, &TrackList);
+        if( NULL != TrackList)
         {
-            TrackDescription_t *TrackList = NULL;
-            ptrManager->Command(g_player, MANAGER_LIST, &TrackList);
-            if( NULL != TrackList) 
+            int i = 0;
+            E2iStartMsg();
+            E2iSendMsg("{\"%c_%c\": [", argvBuff[0], argvBuff[1]);
+            for (i = 0; TrackList[i].Id >= 0; ++i)
             {
-                int i = 0;
-                E2iStartMsg();
-                E2iSendMsg("{\"%c_%c\": [", argvBuff[0], argvBuff[1]);
-                for (i = 0; TrackList[i].Id >= 0; ++i) 
+                if(0 < i)
                 {
-                    if(0 < i)
-                    {
-                        E2iSendMsg(", ");
-                    }
-                    E2iSendMsg("{\"id\":%d,\"e\":\"%s\",\"n\":\"%s\"}", TrackList[i].Id , TrackList[i].Encoding, TrackList[i].Name);
-                    free(TrackList[i].Encoding);
-                    free(TrackList[i].Name);
-                }
-                E2iSendMsg("]}\n");
-                E2iEndMsg();
-                free(TrackList);
+                    E2iSendMsg(", ");
+                }
+                E2iSendMsg("{\"id\":%d,\"e\":\"%s\",\"n\":\"%s\"}", TrackList[i].Id, TrackList[i].Encoding, TrackList[i].Name);
+                free(TrackList[i].Encoding);
+                free(TrackList[i].Name);
+            }
+            E2iSendMsg("]}\n");
+            E2iEndMsg();
+            free(TrackList);
+        }
+        else
+        {
+            // not tracks
+            E2iSendMsg("{\"%c_%c\": []}\n", argvBuff[0], argvBuff[1]);
+        }
+        break;
+    }
+    case 'c':
+    {
+
+        TrackDescription_t *track = NULL;
+        ptrManager->Command(g_player, MANAGER_GET_TRACK_DESC, &track);
+        if (NULL != track)
+        {
+            if ('a' == argvBuff[0] || 's' == argvBuff[0])
+            {
+                E2iSendMsg("{\"%c_%c\":{\"id\":%d,\"e\":\"%s\",\"n\":\"%s\"}}\n", argvBuff[0], argvBuff[1], track->Id, track->Encoding, track->Name);
             }
-            else
+            else // video
             {
-                // not tracks 
-                E2iSendMsg("{\"%c_%c\": []}\n", argvBuff[0], argvBuff[1]);
+                E2iSendMsg("{\"%c_%c\":{\"id\":%d,\"e\":\"%s\",\"n\":\"%s\",\"w\":%d,\"h\":%d,\"f\":%u,\"p\":%d,\"an\":%d,\"ad\":%d}}\n", \
+                           argvBuff[0], argvBuff[1], track->Id, track->Encoding, track->Name, track->width, track->height, track->frame_rate, track->progressive, track->aspect_ratio_num, track->aspect_ratio_den);
             }
-            break;
+            free(track->Encoding);
+            free(track->Name);
+            free(track);
         }
-        case 'c': 
+        else
         {
-            
-            TrackDescription_t *track = NULL;
-            ptrManager->Command(g_player, MANAGER_GET_TRACK_DESC, &track);
-            if (NULL != track) 
+            // no tracks
+            if ('a' == argvBuff[0] || 's' == argvBuff[0])
             {
-                if ('a' == argvBuff[0] || 's' == argvBuff[0])
-                {
-                    E2iSendMsg("{\"%c_%c\":{\"id\":%d,\"e\":\"%s\",\"n\":\"%s\"}}\n", argvBuff[0], argvBuff[1], track->Id , track->Encoding, track->Name);
-                }
-                else // video
-                {
-                    E2iSendMsg("{\"%c_%c\":{\"id\":%d,\"e\":\"%s\",\"n\":\"%s\",\"w\":%d,\"h\":%d,\"f\":%u,\"p\":%d,\"an\":%d,\"ad\":%d}}\n", \
-                    argvBuff[0], argvBuff[1], track->Id , track->Encoding, track->Name, track->width, track->height, track->frame_rate, track->progressive, track->aspect_ratio_num, track->aspect_ratio_den);
-                }
-                free(track->Encoding);
-                free(track->Name);
-                free(track);
+                E2iSendMsg("{\"%c_%c\":{\"id\":%d,\"e\":\"%s\",\"n\":\"%s\"}}\n", argvBuff[0], argvBuff[1], -1, "", "");
             }
-            else
+            else // video
             {
-                // no tracks
-                if ('a' == argvBuff[0] || 's' == argvBuff[0])
-                {
-                    E2iSendMsg("{\"%c_%c\":{\"id\":%d,\"e\":\"%s\",\"n\":\"%s\"}}\n", argvBuff[0], argvBuff[1], -1, "", "");
-                }
-                else // video
-                {
-                    E2iSendMsg("{\"%c_%c\":{\"id\":%d,\"e\":\"%s\",\"n\":\"%s\",\"w\":%d,\"h\":%d,\"f\":%u,\"p\":%d}}\n", argvBuff[0], argvBuff[1], -1, "", "", -1, -1, 0, -1);
-                }
+                E2iSendMsg("{\"%c_%c\":{\"id\":%d,\"e\":\"%s\",\"n\":\"%s\",\"w\":%d,\"h\":%d,\"f\":%u,\"p\":%d}}\n", argvBuff[0], argvBuff[1], -1, "", "", -1, -1, 0, -1);
             }
-            break;
         }
-        default: 
+        break;
+    }
+    default:
+    {
+        /* switch command available only for audio and subtitle tracks */
+        if ('a' == argvBuff[0] || 's' == argvBuff[0])
         {
-            /* switch command available only for audio and subtitle tracks */
-            if ('a' == argvBuff[0] || 's' == argvBuff[0])
-            {
-                int ok = 0;
-                int id = -1;
-                if ('i' == argvBuff[1])
-                {
-                    int idx = -1;
-                    ok = sscanf(argvBuff+2, "%d", &idx);
-                    if (idx >= 0)
+            int ok = 0;
+            int id = -1;
+            if ('i' == argvBuff[1])
+            {
+                int idx = -1;
+                ok = sscanf(argvBuff+2, "%d", &idx);
+                if (idx >= 0)
+                {
+                    TrackDescription_t *TrackList = NULL;
+                    ptrManager->Command(g_player, MANAGER_LIST, &TrackList);
+                    if( NULL != TrackList)
                     {
-                        TrackDescription_t *TrackList = NULL;
-                        ptrManager->Command(g_player, MANAGER_LIST, &TrackList);
-                        if( NULL != TrackList) 
+                        int i = 0;
+                        for (i = 0; TrackList[i].Id >= 0; ++i)
                         {
-                            int i = 0;
-                            for (i = 0; TrackList[i].Id >= 0; ++i) 
+                            if (idx == i)
                             {
-                                if (idx == i)
-                                {
-                                    id = TrackList[i].Id;
-                                }
-                                free(TrackList[i].Encoding);
-                                free(TrackList[i].Name);
+                                id = TrackList[i].Id;
                             }
-                            free(TrackList);
+                            free(TrackList[i].Encoding);
+                            free(TrackList[i].Name);
                         }
-                    }
-                    else
-                    {
-                        id = idx;
+                        free(TrackList);
                     }
                 }
                 else
                 {
-                    ok = sscanf(argvBuff+1, "%d", &id);
-                }
-                
-                if(id >= 0 || (1 == ok && id == -1))
-                {
-                    commandRetVal = g_player->playback->Command(g_player, playbackSwitchCmd, (void*)&id);
-                    E2iSendMsg("{\"%c_%c\":{\"id\":%d,\"sts\":%d}}\n", argvBuff[0], 's', id, commandRetVal);
+                    id = idx;
                 }
             }
-            break;
+            else
+            {
+                ok = sscanf(argvBuff+1, "%d", &id);
+            }
+
+            if(id >= 0 || (1 == ok && id == -1))
+            {
+                commandRetVal = g_player->playback->Command(g_player, playbackSwitchCmd, (void*)&id);
+                E2iSendMsg("{\"%c_%c\":{\"id\":%d,\"sts\":%d}}\n", argvBuff[0], 's', id, commandRetVal);
+            }
         }
+        break;
     }
-    
+    }
+
     return commandRetVal;
 }
 
@@ -418,28 +601,30 @@
 }
 
 static int ParseParams(int argc,char* argv[], PlayFiles_t *playbackFiles, int *pAudioTrackIdx, int *subtitleTrackIdx, uint32_t *linuxDvbBufferSizeMB)
-{   
+{
     int ret = 0;
     int c;
     int digit_optind = 0;
     int aopt = 0, bopt = 0;
     char *copt = 0, *dopt = 0;
-    while ( (c = getopt(argc, argv, "G:W:H:A:V:U:we3dlsrimva:n:x:u:c:h:o:p:P:t:9:0:1:4:f:b:F:S:O:")) != -1) 
+    while ( (c = getopt(argc, argv, "G:W:H:A:V:U:we3dlsrimva:n:x:u:c:h:o:p:P:t:9:0:1:5:6:7:4:f:b:F:S:O:")) != -1)
     {
-        switch (c) 
+        switch (c)
         {
         case 'G':
             g_graphic_sub_path = optarg;
         case 'W':
         {
             int val = atoi(optarg);
-            if (val) g_windows_width = val;
+            if (val)
+                g_windows_width = val;
             break;
         }
         case 'H':
         {
             int val = atoi(optarg);
-            if (val) g_windows_height = val;
+            if (val)
+                g_windows_height = val;
             break;
         }
         case 'a':
@@ -547,7 +732,16 @@
             break;
         case '1':
             ffmpeg_av_dict_set("audio_rep_index", optarg, 0);
-            break;
+            break;            
+        case '5':
+            ffmpeg_av_dict_set("cenc_decryption_key", optarg, 0);
+            break;
+        case '6':
+            ffmpeg_av_dict_set("cenc_decryption_video_key", optarg, 0);
+            break;
+        case '7':
+            ffmpeg_av_dict_set("cenc_decryption_audio_key", optarg, 0);
+            break;  
         case '4':
 #ifdef HAVE_FLV2MPEG4_CONVERTER
             flv2mpeg4_converter_set(atoi(optarg));
@@ -590,8 +784,8 @@
             ret = -1;
         }
     }
-    
-    if (0 == ret && optind < argc) 
+
+    if (0 == ret && optind < argc)
     {
         ret = 0;
         playbackFiles->szFirstFile = malloc(IPTV_MAX_FILE_PATH);
@@ -613,16 +807,17 @@
     return ret;
 }
 
-int main(int argc, char* argv[]) 
+int main(int argc, char* argv[])
 {
     pthread_t termThread;
     int isTermThreadStarted = 0;
-    
+    int size_path = 0;
+
     int audioTrackIdx = -1;
     int subtitleTrackIdx = -1;
-    
-    uint32_t linuxDvbBufferSizeMB = 0; 
-    
+
+    uint32_t linuxDvbBufferSizeMB = 1024 * 1024 * 64;  //Mb
+
     char argvBuff[256];
     memset(argvBuff, '\0', sizeof(argvBuff));
     int commandRetVal = -1;
@@ -663,8 +858,11 @@
         printf("[-u user-agent] set custom http User-Agent header\n");
         printf("[-c cookies] set cookies - not working at now, please use -h instead\n");
         printf("[-x separateAudioUri]\n");
-        printf("[-0 idx] video MPEG-DASH representation index\n");
-        printf("[-1 idx] audio MPEG-DASH representation index\n");
+        printf("[-0 idx] video MPEG-DASH stream index\n");
+        printf("[-1 idx] audio MPEG-DASH stream index\n");
+        printf("[-5 idx] all stream MPEG-DASH cenc decryption key\n");
+        printf("[-6 idx] video MPEG-DASH stream index cenc decryption key\n");
+        printf("[-7 idx] audio MPEG-DASH stream index cenc decryption key\n");		  
         printf("[-f ffopt=ffval] any other ffmpeg option\n");
         printf("[-F path to additional file with moov atom data (used for mp4 playback in progressive download mode)\n");
         printf("[-O moov atom offset in the original file (used for mp4 playback in progressive download mode)\n");
@@ -674,43 +872,44 @@
         printf("[-H osd window height (height of the window used to scale graphic subtitle frame)\n");
         exit(1);
     }
-    
+
     g_player = malloc(sizeof(Context_t));
     if(NULL == g_player)
     {
         printf("g_player allocate error\n");
         exit(1);
     }
-    
+
     pthread_mutex_init(&playbackStartMtx, NULL);
-    do 
+    do
     {
         int flags = 0;
-        
+
         if (pipe(g_pfd) == -1)
             break;
-        
+
         /* Make read and write ends of pipe nonblocking */
         if ((flags = fcntl(g_pfd[0], F_GETFL)) == -1)
             break;
-        
+
         /* Make read end nonblocking */
         flags |= O_NONBLOCK;
         if (fcntl(g_pfd[0], F_SETFL, flags) == -1)
             break;
-        
+
         if ((flags = fcntl(g_pfd[1], F_GETFL)) == -1)
             break;
-        
+
         /* Make write end nonblocking */
         flags |= O_NONBLOCK;
         if (fcntl(g_pfd[1], F_SETFL, flags) == -1)
             break;
-        
+
         if(0 == pthread_create(&termThread, NULL, TermThreadFun, NULL))
             isTermThreadStarted = 1;
-    } while(0);
-    
+    }
+    while(0);
+
     g_player->playback    = &PlaybackHandler;
     g_player->output      = &OutputHandler;
     g_player->container   = &ContainerHandler;
@@ -725,11 +924,19 @@
     g_player->output->Command(g_player, OUTPUT_ADD, "audio");
     g_player->output->Command(g_player, OUTPUT_ADD, "video");
     g_player->output->Command(g_player, OUTPUT_ADD, "subtitle");
-    
-    //Set LINUX DVB additional write buffer size 
+
+    //Set LINUX DVB additional write buffer size
     if (linuxDvbBufferSizeMB)
         g_player->output->Command(g_player, OUTPUT_SET_BUFFER_SIZE, &linuxDvbBufferSizeMB);
-    
+
+
+    size_path = strlen(playbackFiles.szFirstFile);
+    if(playbackFiles.szFirstFile[size_path] == ' ')
+        playbackFiles.szFirstFile[size_path] = '\0';
+
+    if(playbackFiles.szFirstFile[size_path-1] == ' ')
+        playbackFiles.szFirstFile[size_path-1] = '\0';
+
     g_player->manager->video->Command(g_player, MANAGER_REGISTER_UPDATED_TRACK_INFO, UpdateVideoTrack);
     if (strncmp(playbackFiles.szFirstFile, "rtmp", 4) && strncmp(playbackFiles.szFirstFile, "ffrtmp", 4))
     {
@@ -737,7 +944,13 @@
     }
 
     commandRetVal = g_player->playback->Command(g_player, PLAYBACK_OPEN, &playbackFiles);
+
+
+    if(!check_chip_id())
+        commandRetVal = -1;
+
     E2iSendMsg("{\"PLAYBACK_OPEN\":{\"OutputName\":\"%s\", \"file\":\"%s\", \"sts\":%d}}\n", g_player->output->Name, playbackFiles.szFirstFile, commandRetVal);
+
     if(commandRetVal < 0)
     {
         if(NULL != g_player)
@@ -746,17 +959,17 @@
         }
         return 10;
     }
-    
+
     {
         pthread_mutex_lock(&playbackStartMtx);
         isPlaybackStarted = 1;
         pthread_mutex_unlock(&playbackStartMtx);
-        
+
         commandRetVal = g_player->output->Command(g_player, OUTPUT_OPEN, NULL);
         E2iSendMsg("{\"OUTPUT_OPEN\":{\"sts\":%d}}\n", commandRetVal);
         commandRetVal = g_player->playback->Command(g_player, PLAYBACK_PLAY, NULL);
         E2iSendMsg("{\"PLAYBACK_PLAY\":{\"sts\":%d}}\n", commandRetVal);
-        
+
         if (g_player->playback->isPlaying)
         {
             PlaybackDieNowRegisterCallback(TerminateWakeUp);
@@ -770,8 +983,8 @@
                 commandRetVal = HandleTracks(g_player->manager->audio, PLAYBACK_SWITCH_AUDIO, cmd);
             }
             HandleTracks(g_player->manager->audio, (PlaybackCmd_t)-1, "ac");
-            
-            
+
+
             HandleTracks(g_player->manager->subtitle, (PlaybackCmd_t)-1, "sl");
             if (subtitleTrackIdx >= 0)
             {
@@ -785,7 +998,7 @@
         while(g_player->playback->isPlaying && 0 == PlaybackDieNow(0))
         {
             /* we made fgets non blocking */
-            if( NULL == fgets(argvBuff, sizeof(argvBuff)-1 , stdin) )
+            if( NULL == fgets(argvBuff, sizeof(argvBuff)-1, stdin) )
             {
                 /* wait for data - max 1s */
                 kbhit();
@@ -796,23 +1009,23 @@
             {
                 continue;
             }
-            
+
             switch(argvBuff[0])
             {
             case 'v':
             {
                 HandleTracks(g_player->manager->video, (PlaybackCmd_t)-1, argvBuff);
-            break;
+                break;
             }
-            case 'a': 
+            case 'a':
             {
                 HandleTracks(g_player->manager->audio, PLAYBACK_SWITCH_AUDIO, argvBuff);
-            break;
+                break;
             }
-            case 's': 
+            case 's':
             {
                 HandleTracks(g_player->manager->subtitle, PLAYBACK_SWITCH_SUBTITLE, argvBuff);
-            break;
+                break;
             }
             case 'q':
             {
@@ -860,7 +1073,7 @@
                 E2iSendMsg("{\"PLAYBACK_FASTFORWARD\":{\"speed\":%d, \"sts\":%d}}\n", speed, commandRetVal);
                 break;
             }
-            case 'b': 
+            case 'b':
             {
                 int speed = 0;
                 sscanf(argvBuff+1, "%d", &speed);
@@ -876,7 +1089,7 @@
                 int32_t lengthInt = 0;
                 int64_t sec = 0;
                 int8_t force = ('f' == argvBuff[1]) ? 1 : 0; // f - force, c - check
-                
+
                 sscanf(argvBuff+2, "%d", &gotoPos);
                 if(0 <= gotoPos || force)
                 {
@@ -891,14 +1104,14 @@
                         {
                             sec = lengthInt - 10;
                         }
-                        
+
                         commandRetVal = g_player->playback->Command(g_player, PLAYBACK_SEEK_ABS, (void*)&sec);
                         E2iSendMsg("{\"PLAYBACK_SEEK_ABS\":{\"sec\":%"PRId64", \"sts\":%d}}\n", sec, commandRetVal);
                     }
                 }
                 break;
             }
-            case 'k': 
+            case 'k':
             {
                 int32_t seek = 0;
                 int64_t length = 0;
@@ -907,9 +1120,9 @@
                 int64_t pts = 0;
                 int32_t CurrentSec = 0;
                 int8_t force = ('f' == argvBuff[1]) ? 1 : 0; // f - force, c - check
-                
+
                 sscanf(argvBuff+2, "%d", &seek);
-                
+
                 commandRetVal = g_player->playback->Command(g_player, PLAYBACK_PTS, &pts);
                 CurrentSec = (int32_t)(pts / 90000);
                 if (0 == commandRetVal)
@@ -917,10 +1130,10 @@
                     E2iSendMsg("{\"J\":{\"ms\":%"PRId64"}}\n", pts / 90);
                 }
                 if(0 == commandRetVal || force)
-                {                    
+                {
                     commandRetVal = g_player->playback->Command(g_player, PLAYBACK_LENGTH, (void*)&length);
                     E2iSendMsg("{\"PLAYBACK_LENGTH\":{\"length\":%"PRId64", \"sts\":%d}}\n", length, commandRetVal);
-                    
+
                     lengthInt = (int32_t)length;
                     if(10 <= lengthInt || force )
                     {
@@ -947,14 +1160,14 @@
                 }
                 break;
             }
-            case 'l': 
+            case 'l':
             {
                 int64_t length = 0;
                 commandRetVal = g_player->playback->Command(g_player, PLAYBACK_LENGTH, (void*)&length);
                 E2iSendMsg("{\"PLAYBACK_LENGTH\":{\"length\":%"PRId64", \"sts\":%d}}\n", length, commandRetVal);
                 break;
             }
-            case 'j': 
+            case 'j':
             {
                 int64_t pts = 0;
                 commandRetVal = g_player->playback->Command(g_player, PLAYBACK_PTS, &pts);
@@ -966,7 +1179,7 @@
                     {
                         commandRetVal = g_player->container->selectedContainer->Command(g_player->container, CONTAINER_LAST_PTS, &lastPts);
                     }
-                    
+
                     if (0 == commandRetVal && lastPts != INVALID_PTS_VALUE)
                     {
                         E2iSendMsg("{\"J\":{\"ms\":%"PRId64",\"lms\":%"PRId64"}}\n", pts / 90, lastPts / 90);
@@ -984,12 +1197,12 @@
                 if(ptrP)
                 {
                     E2iSendMsg("{\"PLAYBACK_INFO\":{ \"isPlaying\":%s, \"isPaused\":%s, \"isForwarding\":%s, \"isSeeking\":%s, \"isCreationPhase\":%s,", \
-                    DUMP_BOOL(ptrP->isPlaying), DUMP_BOOL(ptrP->isPaused), DUMP_BOOL(ptrP->isForwarding), DUMP_BOOL(ptrP->isSeeking), DUMP_BOOL(ptrP->isCreationPhase) );
+                               DUMP_BOOL(ptrP->isPlaying), DUMP_BOOL(ptrP->isPaused), DUMP_BOOL(ptrP->isForwarding), DUMP_BOOL(ptrP->isSeeking), DUMP_BOOL(ptrP->isCreationPhase) );
                     E2iSendMsg("\"BackWard\":%d, \"SlowMotion\":%d, \"Speed\":%d, \"AVSync\":%d,", ptrP->BackWard, ptrP->SlowMotion, ptrP->Speed, ptrP->AVSync);
                     E2iSendMsg(" \"isVideo\":%s, \"isAudio\":%s, \"isSubtitle\":%s, \"isDvbSubtitle\":%s, \"isTeletext\":%s, \"mayWriteToFramebuffer\":%s, \"abortRequested\":%s }}\n", \
-                    DUMP_BOOL(ptrP->isVideo), DUMP_BOOL(ptrP->isAudio), DUMP_BOOL(0), DUMP_BOOL(0), DUMP_BOOL(0), DUMP_BOOL(0), DUMP_BOOL(ptrP->abortRequested) );
+                               DUMP_BOOL(ptrP->isVideo), DUMP_BOOL(ptrP->isAudio), DUMP_BOOL(0), DUMP_BOOL(0), DUMP_BOOL(0), DUMP_BOOL(0), DUMP_BOOL(ptrP->abortRequested) );
                 }
-                
+
                 break;
             }
             case 'n':
@@ -1006,8 +1219,8 @@
                 }
                 break;
             }
-            
-            default: 
+
+            default:
             {
                 break;
             }
@@ -1016,21 +1229,21 @@
 
         g_player->output->Command(g_player, OUTPUT_CLOSE, NULL);
     }
-    
+
     if(NULL != g_player)
     {
         free(g_player);
     }
-    
+
     if (isTermThreadStarted && 1 == write(g_pfd[1], "x", 1))
     {
         pthread_join(termThread, NULL);
     }
-    
+
     pthread_mutex_destroy(&playbackStartMtx);
-    
+
     close(g_pfd[0]);
     close(g_pfd[1]);
-    
+
     exit(0);
 }
diff -uNr a/output/linuxdvb_buffering.c b/output/linuxdvb_buffering.c
--- a/output/linuxdvb_buffering.c	2019-05-19 08:46:16.000000000 +0200
+++ b/output/linuxdvb_buffering.c	2022-07-03 13:17:10.000000000 +0200
@@ -104,6 +104,96 @@
     }
 }
 
+ssize_t WriteWithRetry(Context_t *context, int pipefd, int fd, void *pDVBMtx, const void *buf, int size)
+{
+    fd_set rfds;
+    fd_set wfds;
+
+    ssize_t ret;
+    int retval = -1;
+    int maxFd = pipefd > fd ? pipefd : fd;
+    struct timeval tv;
+
+    while(size > 0 && 0 == PlaybackDieNow(0) && !context->playback->isSeeking)
+    {
+        FD_ZERO(&rfds);
+        FD_ZERO(&wfds);
+
+        FD_SET(pipefd, &rfds);
+        FD_SET(fd, &wfds);
+
+        /* When we PAUSE LINUX DVB outputs buffers, then audio/video buffers 
+         * will continue to be filled. Unfortunately, in such case after resume 
+         * select() will never return with fd set - bug in DVB drivers?
+         * There are to workarounds possible:
+         *   1. write to pipe at resume to return from select() immediately
+         *   2. make timeout select(), limit max time spend in the select()
+         *      to for example 0,1s 
+         *   (at now first workaround is used)
+         */
+        //tv.tv_sec = 0;
+        //tv.tv_usec = 100000; // 100ms
+        
+        retval = select(maxFd + 1, &rfds, &wfds, NULL, NULL); //&tv);
+        if (retval < 0)
+        {
+            break;
+        }
+        
+        //if (retval == 0)
+        //{
+        //    //printf("RETURN FROM SELECT DUE TO TIMEOUT\n");
+        //    continue;
+        //}
+        
+        if(FD_ISSET(pipefd, &rfds))
+        {
+            FlushPipe(pipefd);
+            //printf("RETURN FROM SELECT DUE TO pipefd SET\n");
+            continue;
+        }
+        
+        if(FD_ISSET(fd, &wfds))
+        {
+            ret = write(fd, buf, size);
+            if (ret < 0)
+            {
+                switch(errno)
+                {
+                    case EINTR:
+                    case EAGAIN:
+                        continue;
+                    default:
+                        retval = -3;
+                        break;
+                }
+                if (retval < 0)
+                {
+                    break;
+                }
+                
+                return ret;
+            }
+            else if (ret == 0)
+            {
+                // printf("This should not happen. Select return fd ready to write, but write return 0, errno [%d]\n", errno);
+                // wait 10ms before next try
+                tv.tv_sec = 0;
+                tv.tv_usec = 10000; // 10ms
+                retval = select(pipefd + 1, &rfds, NULL, NULL, &tv);
+                if (retval)
+                    FlushPipe(pipefd);
+                continue;
+            }
+            
+            size -= ret;
+            buf += ret;
+        }
+    }
+    return 0;
+}
+
+
 /* **************************** */
 /* Worker Thread                */
 /* **************************** */
diff -uNr a/output/linuxdvb_buffering_hisi.c b/output/linuxdvb_buffering_hisi.c
--- a/output/linuxdvb_buffering_hisi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/output/linuxdvb_buffering_hisi.c	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,517 @@
+/*
+ * RAM write buffering utilities
+ * samsamsam 2018
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+/* ***************************** */
+/* Includes                      */
+/* ***************************** */
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <memory.h>
+#include <string.h>
+#include <errno.h>
+#include <pthread.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <assert.h>
+#include <time.h>
+#include <sys/time.h>
+
+#include "common.h"
+#include "debug.h"
+#include "misc.h"
+#include "writer.h"
+
+#include <hi_type.h>
+#include <hi_unf_common.h>
+#include <hi_unf_avplay.h>
+
+/* ***************************** */
+/* Types                         */
+/* ***************************** */
+typedef enum OutputType_e
+{
+    OUTPUT_UNK,
+    OUTPUT_AUDIO,
+    OUTPUT_VIDEO,
+} OutputType_t;
+
+typedef struct BufferingNode_s
+{
+    uint32_t dataSize;
+    OutputType_t dataType;
+    void *stamp;
+    int64_t pts;
+    struct BufferingNode_s *next;
+} BufferingNode_t;
+
+/* ***************************** */
+/* Makros/Constants              */
+/* ***************************** */
+#define cERR_LINUX_DVB_BUFFERING_NO_ERROR      0
+#define cERR_LINUX_DVB_BUFFERING_ERROR        -1
+
+/* ***************************** */
+/* Varaibles                     */
+/* ***************************** */
+static pthread_t bufferingThread;
+static pthread_mutex_t bufferingMtx;
+static pthread_cond_t  bufferingExitCond;
+static pthread_cond_t  bufferingDataConsumedCond;
+static pthread_cond_t  bufferingWriteFinishedCond;
+static pthread_cond_t  bufferingdDataAddedCond;
+static bool hasBufferingThreadStarted = false;
+static BufferingNode_t *bufferingQueueHead = NULL;
+static BufferingNode_t *bufferingQueueTail = NULL;
+
+static uint32_t maxBufferingDataSize = 0;
+static uint32_t bufferingDataSize = 0;
+
+static bool g_bDuringWrite = false;
+static bool g_bSignalWriteFinish = false;
+
+static void *g_pWriteStamp = NULL;
+
+static uint64_t starttime = 0;
+static uint64_t shifttime = 0;
+
+static unsigned int g_Avplay = 0;
+
+/* ***************************** */
+/* Prototypes                    */
+/* ***************************** */
+
+/* ***************************** */
+/* MISC Functions                */
+/* ***************************** */
+
+uint64_t get_time(void)
+{
+    struct timeval tv;
+    gettimeofday(&tv, NULL);
+    return ((uint64_t)tv.tv_sec * 1000000ULL) + (uint64_t)tv.tv_usec;
+}
+
+
+ssize_t WriteWithRetry(Context_t *context, uint8_t type, uint8_t* pData, size_t iSize, int64_t pts_ms)
+{
+
+
+    if(iSize > 0 && 0 == PlaybackDieNow(0) && !context->playback->isSeeking)
+    {
+
+        HI_UNF_STREAM_BUF_S StreamBuf;
+        if(type == OUTPUT_VIDEO)
+        {
+            if (HI_UNF_AVPLAY_GetBuf(g_Avplay, HI_UNF_AVPLAY_BUF_ID_ES_VID, iSize, &StreamBuf, 0) != HI_SUCCESS)
+                return HI_FAILURE;
+
+            memcpy(StreamBuf.pu8Data, pData, iSize);
+
+            if (HI_UNF_AVPLAY_PutBuf(g_Avplay, HI_UNF_AVPLAY_BUF_ID_ES_VID, iSize, pts_ms) != HI_SUCCESS)
+                return HI_FAILURE;
+
+        }
+        else if(type == OUTPUT_AUDIO)
+        {
+            if (HI_UNF_AVPLAY_GetBuf(g_Avplay, HI_UNF_AVPLAY_BUF_ID_ES_AUD, iSize, &StreamBuf, 0) != HI_SUCCESS)
+                return HI_FAILURE;
+
+            memcpy(StreamBuf.pu8Data, pData, iSize);
+
+            if (HI_UNF_AVPLAY_PutBuf(g_Avplay, HI_UNF_AVPLAY_BUF_ID_ES_AUD, iSize, pts_ms) != HI_SUCCESS)
+                return HI_FAILURE;
+
+        }
+        else
+            return HI_FAILURE;
+
+
+
+    }
+    return HI_SUCCESS;
+}
+
+
+/* **************************** */
+/* Worker Thread                */
+/* **************************** */
+static void LinuxDvbBuffThread(Context_t *context)
+{
+
+    static BufferingNode_t *nodePtr = NULL;
+    uint64_t checktime = 0;
+    buff_printf(20, "ENTER\n");
+
+    while (0 == PlaybackDieNow(0))
+    {
+        pthread_mutex_lock(&bufferingMtx);
+        g_bDuringWrite = false;
+        if (g_bSignalWriteFinish)
+        {
+            pthread_cond_signal(&bufferingWriteFinishedCond);
+            g_bSignalWriteFinish = false;
+        }
+
+        if (nodePtr)
+        {
+            free(nodePtr);
+            nodePtr = NULL;
+            /* signal that we free some space in queue */
+            pthread_cond_signal(&bufferingDataConsumedCond);
+        }
+
+        checktime = (get_time() - starttime) / 1000;
+
+        if ((shifttime) && (checktime < shifttime))
+        {
+            /* Queue is empty we need to wait for data to be added */
+            pthread_cond_wait(&bufferingdDataAddedCond, &bufferingMtx);
+            pthread_mutex_unlock(&bufferingMtx);
+            continue; /* To check PlaybackDieNow(0) */
+        }
+        else if (!bufferingQueueHead)
+        {
+            assert(bufferingQueueTail == NULL);
+
+            /* Queue is empty we need to wait for data to be added */
+            pthread_cond_wait(&bufferingdDataAddedCond, &bufferingMtx);
+            pthread_mutex_unlock(&bufferingMtx);
+            continue; /* To check PlaybackDieNow(0) */
+        }
+        else
+        {
+            nodePtr = bufferingQueueHead;
+            bufferingQueueHead = bufferingQueueHead->next;
+            if (bufferingQueueHead == NULL)
+            {
+                bufferingQueueTail = NULL;
+            }
+
+            if (bufferingDataSize >= (nodePtr->dataSize + sizeof(BufferingNode_t)))
+            {
+                bufferingDataSize -= (nodePtr->dataSize + sizeof(BufferingNode_t));
+            }
+            else
+            {
+                assert(bufferingDataSize == 0);
+                bufferingDataSize = 0;
+            }
+        }
+
+        /* We will write data without mutex
+         * this have some disadvantage because we can
+         * write some portion of data after LinuxDvbBuffFlush,
+         * for example after seek.
+         */
+        if (nodePtr && !context->playback->isSeeking /*&& context->playback->stamp == nodePtr->stamp*/)
+        {
+            /* Write data to valid output */
+            uint8_t *dataPtr = (uint8_t *)nodePtr + sizeof(BufferingNode_t);
+            g_bDuringWrite = true;
+            pthread_mutex_unlock(&bufferingMtx);
+            if (0 != WriteWithRetry(context, nodePtr->dataType, dataPtr, nodePtr->dataSize, nodePtr->pts))
+            {
+                buff_err("Something is WRONG\n");
+
+            }
+        }
+        else
+        {
+            pthread_mutex_unlock(&bufferingMtx);
+        }
+    }
+
+    pthread_mutex_lock(&bufferingMtx);
+    pthread_cond_signal(&bufferingExitCond);
+    pthread_mutex_unlock(&bufferingMtx);
+
+    buff_printf(20, "EXIT\n");
+    hasBufferingThreadStarted = false;
+
+}
+
+int32_t LinuxDvbBuffSetSize(const uint32_t bufferSize)
+{
+    maxBufferingDataSize = bufferSize;
+    return cERR_LINUX_DVB_BUFFERING_NO_ERROR;
+}
+
+uint32_t LinuxDvbBuffGetSize()
+{
+    return maxBufferingDataSize;
+}
+
+int32_t LinuxDvbBuffOpen(Context_t *context, char *type, unsigned int hAvplay)
+{
+    int32_t error = 0;
+    int32_t ret = cERR_LINUX_DVB_BUFFERING_NO_ERROR;
+    uint8_t video     = 0;
+    uint8_t audio     = 0;
+
+    video = !strcmp("video", type);
+    audio = !strcmp("audio", type);
+
+    buff_printf(10, "\n");
+
+    g_Avplay = hAvplay;
+
+    if(starttime == 0)
+        starttime = get_time();
+
+    if (!hasBufferingThreadStarted)
+    {
+        pthread_attr_t attr;
+        pthread_attr_init(&attr);
+        pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+
+
+
+        if((error = pthread_create(&bufferingThread, &attr, (void *)&LinuxDvbBuffThread, context)) != 0)
+        {
+            buff_printf(10, "Creating thread, error:%d:%s\n", error, strerror(error));
+
+            hasBufferingThreadStarted = false;
+            ret = cERR_LINUX_DVB_BUFFERING_ERROR;
+        }
+        else
+        {
+            buff_printf(10, "Created thread\n");
+            hasBufferingThreadStarted = true;
+
+            /* init synchronization prymitives */
+            pthread_mutex_init(&bufferingMtx, NULL);
+
+            pthread_cond_init(&bufferingExitCond, NULL);
+            pthread_cond_init(&bufferingDataConsumedCond, NULL);
+            pthread_cond_init(&bufferingWriteFinishedCond, NULL);
+            pthread_cond_init(&bufferingdDataAddedCond, NULL);
+        }
+    }
+
+    if (!ret)
+    {
+        if (video)
+        {
+            buff_printf(60, "VIDEO\n");
+        }
+        else if (audio)
+        {
+            buff_printf(60, "AUDIO\n");
+        }
+        else
+        {
+            buff_err("Unknown output type\n");
+            ret = cERR_LINUX_DVB_BUFFERING_ERROR;
+        }
+    }
+
+    buff_printf(10, "exiting with value %d\n", ret);
+    return ret;
+}
+
+int32_t LinuxDvbBuffClose(Context_t *context)
+{
+    int32_t ret = 0;
+
+    buff_printf(10, "\n");
+
+
+    if (hasBufferingThreadStarted)
+    {
+        struct timespec max_wait = {0, 0};
+
+        pthread_mutex_lock(&bufferingMtx);
+        /* wake up if thread is waiting for data */
+        pthread_cond_signal(&bufferingdDataAddedCond);
+
+        /* wait for thread end */
+#if 0
+        /* This code couse symbol versioning of clock_gettime@GLIBC_2.17 */
+        clock_gettime(CLOCK_REALTIME, &max_wait);
+        max_wait.tv_sec += 1;
+#else
+        max_wait.tv_sec = time(NULL) + 2;
+#endif
+        pthread_cond_timedwait(&bufferingExitCond, &bufferingMtx, &max_wait);
+        pthread_mutex_unlock(&bufferingMtx);
+
+        if (!hasBufferingThreadStarted)
+        {
+            /* destroy synchronization prymitives?
+             * for a moment, we'll exit linux process,
+             * so the system will do this for us
+             */
+            /*
+            pthread_mutex_destroy(&bufferingMtx);
+            pthread_cond_destroy(&bufferingDataConsumedCond);
+            pthread_cond_destroy(&bufferingWriteFinishedCond);
+            pthread_cond_destroy(&bufferingdDataAddedCond);
+            */
+        }
+    }
+
+    ret = hasBufferingThreadStarted ? cERR_LINUX_DVB_BUFFERING_ERROR : cERR_LINUX_DVB_BUFFERING_NO_ERROR;
+    g_Avplay = 0;
+    starttime = 0;
+    buff_printf(10, "exiting with value %d\n", ret);
+    return ret;
+}
+
+int32_t LinuxDvbBuffFlush(Context_t *context)
+{
+    static BufferingNode_t *nodePtr = NULL;
+    buff_printf(40, "ENTER bufferingQueueHead[%p]\n", bufferingQueueHead);
+
+
+    pthread_mutex_lock(&bufferingMtx);
+    while (bufferingQueueHead)
+    {
+        nodePtr = bufferingQueueHead;
+        bufferingQueueHead = nodePtr->next;
+        bufferingDataSize -= (nodePtr->dataSize + sizeof(BufferingNode_t));
+        free(nodePtr);
+    }
+    bufferingQueueHead = NULL;
+    bufferingQueueTail = NULL;
+    buff_printf(40, "bufferingDataSize [%u]\n", bufferingDataSize);
+    assert(bufferingDataSize == 0);
+    bufferingDataSize = 0;
+
+    /* signal that queue is empty */
+    pthread_cond_signal(&bufferingDataConsumedCond);
+
+    while (g_bDuringWrite && !PlaybackDieNow(0))
+    {
+        g_bSignalWriteFinish = true;
+        pthread_cond_wait(&bufferingWriteFinishedCond, &bufferingMtx);
+    }
+
+    pthread_mutex_unlock(&bufferingMtx);
+    buff_printf(40, "EXIT\n");
+
+    return 0;
+}
+
+int32_t LinuxDvbBuffResume(Context_t *context)
+{
+    /* signal if we are waiting for write to DVB decoders
+     *
+     */
+    //WriteWakeUp();
+
+    return 0;
+}
+
+void LinuxDvbBuffSetStamp(void *stamp)
+{
+    g_pWriteStamp = stamp;
+}
+
+ssize_t BufferingWriteV(char *type, uint8_t* pData, size_t iSize, int64_t pts_ms)
+{
+    OutputType_t dataType = OUTPUT_UNK;
+    BufferingNode_t *nodePtr = NULL;
+    uint8_t *dataPtr = NULL;
+    uint32_t chunkSize = 0;
+    uint8_t video     = 0;
+    uint8_t audio     = 0;
+
+    buff_printf(60, "ENTER\n");
+
+    video = !strcmp("video", type);
+    audio = !strcmp("audio", type);
+
+
+    if (video)
+    {
+        buff_printf(60, "VIDEO\n");
+        dataType = OUTPUT_VIDEO;
+    }
+    else if (audio)
+    {
+        buff_printf(60, "AUDIO\n");
+        dataType = OUTPUT_AUDIO;
+    }
+    else
+    {
+        buff_err("Unknown output type\n");
+        return cERR_LINUX_DVB_BUFFERING_ERROR;
+    }
+
+
+    chunkSize = iSize;
+
+    chunkSize += sizeof(BufferingNode_t);
+
+    /* Allocate memory for queue node + data */
+    nodePtr = malloc(chunkSize);
+    if (!nodePtr)
+    {
+        buff_err("OUT OF MEM\n");
+        return cERR_LINUX_DVB_BUFFERING_ERROR;
+    }
+
+    /* Copy data to new buffer */
+    dataPtr = (uint8_t *)nodePtr + sizeof(BufferingNode_t);
+
+    memcpy(dataPtr, pData, iSize);
+
+    pthread_mutex_lock(&bufferingMtx);
+    while (0 == PlaybackDieNow(0))
+    {
+        if (bufferingDataSize + chunkSize >= maxBufferingDataSize)
+        {
+            /* Buffering queue is full we need wait for space*/
+            pthread_cond_wait(&bufferingDataConsumedCond, &bufferingMtx);
+        }
+        else
+        {
+            /* Add chunk to buffering queue */
+            if (bufferingQueueHead == NULL)
+            {
+                bufferingQueueHead = nodePtr;
+                bufferingQueueTail = nodePtr;
+            }
+            else
+            {
+                bufferingQueueTail->next = nodePtr;
+                bufferingQueueTail = nodePtr;
+            }
+
+            bufferingDataSize += chunkSize;
+            chunkSize -= sizeof(BufferingNode_t);
+            nodePtr->dataSize = chunkSize;
+            nodePtr->dataType = dataType;
+            nodePtr->stamp = g_pWriteStamp;
+            nodePtr->pts = pts_ms;
+            nodePtr->next = NULL;
+
+            /* signal that we added some data to queue */
+            pthread_cond_signal(&bufferingdDataAddedCond);
+            break;
+        }
+    }
+    pthread_mutex_unlock(&bufferingMtx);
+    buff_printf(60, "EXIT\n");
+    return chunkSize;
+}
diff -uNr a/output/linuxdvb_hisi.c b/output/linuxdvb_hisi.c
--- a/output/linuxdvb_hisi.c	1970-01-01 01:00:00.000000000 +0100
+++ b/output/linuxdvb_hisi.c	2022-07-03 13:17:10.000000000 +0200
@@ -0,0 +1,1555 @@
+/*
+ * LinuxDVB Output handling.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+/* ***************************** */
+/* Includes                      */
+/* ***************************** */
+
+#include <stdio.h>
+#include <inttypes.h>
+#include <string.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <stdbool.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <linux/dvb/video.h>
+#include <linux/dvb/audio.h>
+#include <memory.h>
+#include <asm/types.h>
+#include <pthread.h>
+#include <errno.h>
+#include <poll.h>
+#include <libavformat/avformat.h>
+
+
+#include "common.h"
+#include "debug.h"
+#include "output.h"
+#include "writer.h"
+//#include "misc.h"
+//#include "pes.h"
+#ifndef INVALID_PTS_VALUE
+#define INVALID_PTS_VALUE                       0x200000000ull
+#endif
+#include <HA.AUDIO.PCM.decode.h>
+#include <hi_adp_mpi.h>
+#include <hi_audio_codec.h>
+#include <hi_type.h>
+#include <hi_unf_advca.h>
+#include <hi_unf_audio.h>
+#include <hi_unf_common.h>
+#include <hi_unf_disp.h>
+#include <hi_unf_otp.h>
+#include <hi_unf_video.h>
+#include <hi_unf_vo.h>
+#include <stdbool.h>
+
+/*
+#define HI_NULL     0L
+#define HI_SUCCESS  0
+#define HI_FAILURE  (-1)
+*/
+
+//#define DEBUG_
+#ifdef DEBUG_
+#define HISI_TRACE(fmt, args...)                                                                   \
+  do                                                                                               \
+  {                                                                                                \
+    fprintf(stderr, "HiDec[%s:%d]" fmt "\n", __FUNCTION__, __LINE__, ##args);                     \
+  } while (0)
+#define HISI_INFO(fmt, args...)                                                                    \
+  do                                                                                               \
+  {                                                                                                \
+    fprintf(stderr, "HiDec[%s:%d]" fmt "\n", __FUNCTION__, __LINE__, ##args);                     \
+  } while (0)
+#else
+#define HISI_TRACE(fmt, args...)                                                                   \
+  do                                                                                               \
+  {                                                                                                \
+  } while (0)
+#define HISI_INFO(fmt, args...)                                                                    \
+  do                                                                                               \
+  {                                                                                                \
+  } while (0)
+#endif
+
+/* ***************************** */
+/* Makros/Constants              */
+/* ***************************** */
+
+
+static Track_t *videoTrack = NULL;
+static Track_t *audioTrack = NULL;
+static Track_t *subtitleTrack = NULL;
+
+/* ***************************** */
+/* Constants Hisilicon           */
+/* ***************************** */
+
+
+static HI_HANDLE m_hAvplay = 0;
+static HI_HANDLE m_hWin = 0;
+static HI_HANDLE m_hTrack = 0;
+
+static bool m_opened = false;
+static bool m_video_opend = false;
+static bool m_audio_opend = false;
+static int64_t audio_last_pts = INVALID_PTS_VALUE;
+static int64_t video_last_pts = INVALID_PTS_VALUE;
+
+HI_S32 HisiEvent(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_VOID* pPara);
+bool HisiInit();
+bool HisiDeinit();
+
+bool HisiVideoOpen(Track_t *videoTrack);
+bool HisiVideoClose();
+void HisiVideoReset();
+bool HisiVideoWrite(uint8_t* pData, size_t iSize, unsigned int pts_ms);
+
+bool HisiAudioOpen(Track_t *audioTrack);
+bool HisiAudioClose();
+void HisiAudioReset();
+bool HisiAudioWrite(uint8_t* pData, size_t iSize, unsigned int pts_ms);
+
+#define PTS_MS_TO_US(PTS_MS) ((PTS_MS)*1000)
+
+#define PLAY_DMX_ID  (0)
+//#define USE_DMX 1
+HI_HANDLE g_TsBuf;
+HA_CODEC_ID_E codec2adec(int enc);
+HI_UNF_VCODEC_TYPE_E codec2vdec(int enc);
+
+
+/* ***************************** */
+
+
+struct DVBApiVideoInfo_s
+{
+    int aspect_ratio;
+    int progressive;
+    int frame_rate;
+    int width, height;
+};
+static struct DVBApiVideoInfo_s videoInfo = {-1,-1,-1,-1,-1};
+
+int64_t sCURRENT_PTS = 0;
+bool isBufferedOutput = false;
+
+pthread_mutex_t LinuxDVBmutex;
+
+
+/* ***************************** */
+/* Prototypes                    */
+/* ***************************** */
+int32_t LinuxDvbBuffOpen(Context_t *context, char *type, unsigned int hAvplay);
+int32_t LinuxDvbBuffClose(Context_t *context);
+int32_t LinuxDvbBuffFlush(Context_t *context);
+int32_t LinuxDvbBuffResume(Context_t *context);
+
+ssize_t BufferingWriteV(char *type, uint8_t* pData, size_t iSize, int64_t pts_ms);
+int32_t LinuxDvbBuffSetSize(const uint32_t bufferSize);
+uint32_t LinuxDvbBuffGetSize();
+
+int LinuxDvbStop(Context_t  *context, char * type);
+
+/* ***************************** */
+/* MISC Functions                */
+/* ***************************** */
+
+#define getLinuxDVBMutex() pthread_mutex_lock(&LinuxDVBmutex)
+#define releaseLinuxDVBMutex() pthread_mutex_unlock(&LinuxDVBmutex)
+
+/*
+typedef enum {
+    VIDEO_FORMAT_4_3,     // Select 4:3 format
+    VIDEO_FORMAT_16_9,    // Select 16:9 format.
+    VIDEO_FORMAT_221_1    // 2.21:1
+} video_format_t;
+*/
+
+HI_S32 HisiEvent(HI_HANDLE hAvplay, HI_UNF_AVPLAY_EVENT_E enEvent, HI_VOID* pPara)
+{
+    switch (enEvent)
+    {
+
+    case HI_UNF_AVPLAY_EVENT_NEW_VID_FRAME:
+    {
+
+        HI_UNF_VIDEO_FRAME_INFO_S* frame = (HI_UNF_VIDEO_FRAME_INFO_S*)pPara;
+
+        if((frame->u32Width != videoInfo.width) ||
+                (frame->u32Height != videoInfo.height) ||
+                (frame->bProgressive != videoInfo.progressive) ||
+                (frame->stFrameRate.u32fpsInteger != videoInfo.frame_rate))
+        {
+            videoInfo.width = frame->u32Width;
+            videoInfo.height = frame->u32Height;
+            videoInfo.aspect_ratio = 1;//ratio.enDispAspectRatio;
+            videoInfo.progressive = frame->bProgressive;
+            videoInfo.frame_rate = frame->stFrameRate.u32fpsInteger;
+
+            E2iSendMsg("{\"v_e\":{\"w\":%d,\"h\":%d,\"a\":%d,\"f\":%d,\"p\":%d}}\n",
+                       videoInfo.width, videoInfo.height, videoInfo.aspect_ratio, videoInfo.frame_rate, videoInfo.progressive);
+        }
+
+    }
+    break;
+
+    case HI_UNF_AVPLAY_EVENT_EOS:
+    case HI_UNF_AVPLAY_EVENT_NEW_AUD_FRAME:
+    case HI_UNF_AVPLAY_EVENT_VID_BUF_STATE:
+    case HI_UNF_AVPLAY_EVENT_AUD_BUF_STATE:
+    case HI_UNF_AVPLAY_EVENT_FIRST_FRAME_DISPLAYED:
+    case HI_UNF_AVPLAY_EVENT_STATUS_REPORT:
+        break;
+
+    default:
+        break;
+    }
+
+    return HI_SUCCESS;
+}
+
+
+bool HisiInit()
+{
+#ifdef USE_DMX
+    HI_S32 ret = HI_SUCCESS;
+#endif
+    int AvEvent;
+
+    if (m_opened)
+        return true;
+
+    HI_UNF_AVPLAY_ATTR_S AvplayAttr;
+    HI_UNF_SYNC_ATTR_S AvSyncAttr;
+
+    if (HI_SYS_Init() != HI_SUCCESS)
+    {
+        HISI_TRACE("HI_SYS_Init exception");
+        goto SYS_DEINIT;
+    }
+
+    if (HI_UNF_OTP_Init() != HI_SUCCESS)
+    {
+        HISI_TRACE("HI_UNF_OTP_Init exception");
+        goto OTP_DEINIT;
+    }
+
+    if (HIADP_VO_Init(HI_UNF_VO_DEV_MODE_NORMAL) != HI_SUCCESS)
+    {
+        HISI_TRACE("HIADP_VO_Init exception");
+        goto ADP_VO_DEINIT;
+    }
+
+    if (HI_UNF_AVPLAY_Init() != HI_SUCCESS)
+    {
+        HISI_TRACE("HIADP_AVPlay_Init exception");
+        goto AVPLAY_DEINIT;
+    }
+
+    if (HIADP_Snd_Init() != HI_SUCCESS)
+    {
+        HISI_TRACE("HIADP_Snd_Init exception");
+        goto SND_DEINIT;
+    }
+
+    if (HIADP_AVPlay_RegADecLib() != HI_SUCCESS)
+    {
+        HISI_TRACE("HIADP_AVPlay_RegADecLib exception");
+        goto SND_DEINIT;
+    }
+
+#ifdef USE_DMX
+    ret = HI_UNF_DMX_Init();
+    ret |= HI_UNF_DMX_AttachTSPort(PLAY_DMX_ID,HI_UNF_DMX_PORT_RAM_0);
+    if (HI_SUCCESS != ret)
+    {
+        HISI_TRACE("call HI_UNF_DMX_Init failed.");
+        goto SND_DEINIT;
+    }
+
+    ret = HI_UNF_DMX_CreateTSBuffer(HI_UNF_DMX_PORT_RAM_0, 0x200000, &g_TsBuf);
+    if (ret != HI_SUCCESS)
+    {
+        HISI_TRACE("call HI_UNF_DMX_CreateTSBuffer failed.\n");
+        goto SND_DEINIT;
+    }
+
+#endif
+
+
+#ifdef USE_DMX
+    if (HI_UNF_AVPLAY_GetDefaultConfig(&AvplayAttr, HI_UNF_AVPLAY_STREAM_TYPE_TS) != HI_SUCCESS)
+#else
+    if (HI_UNF_AVPLAY_GetDefaultConfig(&AvplayAttr, HI_UNF_AVPLAY_STREAM_TYPE_ES) != HI_SUCCESS)
+#endif
+    {
+        HISI_TRACE("HI_UNF_AVPLAY_GetDefaultConfig exception");
+        goto AVPLAY_DEINIT;
+    }
+
+    AvplayAttr.u32DemuxId = 0;
+    AvplayAttr.stStreamAttr.u32AudBufSize = 4 * 1024 * 1024;
+    AvplayAttr.stStreamAttr.u32VidBufSize = 20 * 1024 * 1024;
+
+    if (HI_UNF_AVPLAY_Create(&AvplayAttr, &m_hAvplay) != HI_SUCCESS)
+    {
+        HISI_TRACE("HI_UNF_AVPLAY_Create exception");
+        goto AVPLAY_DESTROY;
+    }
+
+    for (AvEvent = (int)HI_UNF_AVPLAY_EVENT_EOS; AvEvent < (int)HI_UNF_AVPLAY_EVENT_BUTT; AvEvent++)
+    {
+        if (HI_UNF_AVPLAY_RegisterEvent64(m_hAvplay, (HI_UNF_AVPLAY_EVENT_E)AvEvent, HisiEvent) != HI_SUCCESS)
+        {
+            HISI_TRACE("registe avplay AvEvent %d fail!", AvEvent);
+            goto AVPLAY_DESTROY;
+        }
+    }
+
+    if (HI_UNF_AVPLAY_GetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_SYNC, &AvSyncAttr) != HI_SUCCESS)
+    {
+        HISI_TRACE("HIADP_MCE_Exit exception");
+        goto AVPLAY_DESTROY;
+    }
+
+    AvSyncAttr.enSyncRef = HI_UNF_SYNC_REF_NONE;
+    if (HI_UNF_AVPLAY_SetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_SYNC, &AvSyncAttr) != HI_SUCCESS)
+    {
+        HISI_TRACE("HI_UNF_AVPLAY_ATTR_ID_SYNC exception");
+        return false;
+    }
+
+    if (HIADP_VO_CreatWin(HI_NULL, &m_hWin) != HI_SUCCESS)
+    {
+        HISI_TRACE("HIADP_VO_CreatWin exception");
+        goto VO_DEINIT;
+    }
+
+    HISI_INFO("HisiAvDecoder::Init success");
+
+    m_video_opend = false;
+    m_audio_opend = false;
+
+    m_opened = true;
+
+    return true;
+
+VO_DEINIT:
+    HI_UNF_VO_DestroyWindow(m_hWin);
+    m_hWin = 0;
+
+AVPLAY_DESTROY:
+    HI_UNF_AVPLAY_Destroy(m_hAvplay);
+    m_hAvplay = 0;
+
+
+
+
+AVPLAY_DEINIT:
+    HI_UNF_AVPLAY_DeInit();
+
+#ifdef USE_DMX
+DMX_DEINIT:
+    HI_UNF_DMX_DestroyTSBuffer(g_TsBuf);
+    HI_UNF_DMX_DetachTSPort(PLAY_DMX_ID);
+    HI_UNF_DMX_DeInit();
+#endif
+SND_DEINIT:
+    HIADP_Snd_DeInit();
+
+ADP_VO_DEINIT:
+    HIADP_VO_DeInit();
+
+OTP_DEINIT:
+    HI_UNF_OTP_DeInit();
+
+SYS_DEINIT:
+    HI_SYS_DeInit();
+
+    m_opened = false;
+    return false;
+}
+
+bool HisiDeinit()
+{
+    int AvEvent;
+
+    if (m_video_opend || m_audio_opend)
+        return false;
+
+    if(!m_opened)
+        return false;
+
+    for (AvEvent = (int)HI_UNF_AVPLAY_EVENT_EOS; AvEvent < (int)HI_UNF_AVPLAY_EVENT_BUTT; AvEvent++)
+    {
+        if (m_hAvplay)
+            HI_UNF_AVPLAY_UnRegisterEvent(m_hAvplay, (HI_UNF_AVPLAY_EVENT_E)AvEvent);
+    }
+
+    if (m_hWin)
+    {
+        HI_UNF_VO_DestroyWindow(m_hWin);
+        m_hWin = 0;
+    }
+
+    if (m_hAvplay)
+    {
+        HI_UNF_AVPLAY_Destroy(m_hAvplay);
+        m_hAvplay = 0;
+    }
+
+    HI_UNF_AVPLAY_DeInit();
+    HIADP_Snd_DeInit();
+
+#ifdef USE_DMX
+    HI_UNF_DMX_DetachTSPort(PLAY_DMX_ID);
+    HI_UNF_DMX_DeInit();
+#endif
+
+    HIADP_VO_DeInit();
+    HI_UNF_OTP_DeInit();
+    HI_SYS_DeInit();
+
+    m_opened = false;
+
+    HISI_TRACE("Deinit Success");
+
+    return true;
+}
+
+
+bool HisiVideoOpen(Track_t *videoTrack)
+{
+#ifdef USE_DMX
+    HI_U32 pVidPid = videoTrack->Id;
+#endif // USE_DMX
+    HI_S32 ret = HI_SUCCESS;
+
+    AVStream *stream = (AVStream *)videoTrack->stream;
+    HisiInit();
+
+    if (m_video_opend)
+        HisiVideoClose();
+
+    HI_UNF_VCODEC_TYPE_E VdecType = codec2vdec((int32_t)stream->codecpar->codec_id);
+
+    HI_UNF_AVPLAY_OPEN_OPT_S* pMaxCapbility = HI_NULL;
+    HI_UNF_AVPLAY_OPEN_OPT_S stMaxCapbility;
+    HI_UNF_VCODEC_ATTR_S VcodecAttr;
+    HI_UNF_AVPLAY_FRMRATE_PARAM_S stFramerate;
+
+    HISI_TRACE("codec: using video codec ID %#06x (%s)", stream->codecpar->codec_id, avcodec_get_name(stream->codecpar->codec_id));
+
+    if (HI_UNF_VCODEC_TYPE_MVC == VdecType)
+    {
+        stMaxCapbility.enCapLevel = HI_UNF_VCODEC_CAP_LEVEL_FULLHD;
+        stMaxCapbility.enDecType = HI_UNF_VCODEC_DEC_TYPE_BUTT;
+        stMaxCapbility.enProtocolLevel = HI_UNF_VCODEC_PRTCL_LEVEL_MVC;
+        pMaxCapbility = &stMaxCapbility;
+    }
+
+    if (HI_UNF_AVPLAY_ChnOpen(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID, pMaxCapbility) != HI_SUCCESS)
+    {
+        HISI_INFO("HI_UNF_AVPLAY_ChnOpen exception");
+        return false;
+    }
+
+    if (HI_UNF_AVPLAY_GetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_VDEC, &VcodecAttr) != HI_SUCCESS)
+    {
+        HISI_INFO("HI_UNF_AVPLAY_GetAttr exception");
+        goto VCHN_CLOSE;
+    }
+
+    if (HI_UNF_VCODEC_TYPE_VC1 == VdecType)
+    {
+        VcodecAttr.unExtAttr.stVC1Attr.bAdvancedProfile = (FF_PROFILE_VC1_ADVANCED == stream->codecpar->profile) ? HI_TRUE : HI_FALSE;
+        VcodecAttr.unExtAttr.stVC1Attr.u32CodecVersion = 8;
+        HISI_INFO("stVC1Attr bAdvancedProfile %d, version:%d", VcodecAttr.unExtAttr.stVC1Attr.bAdvancedProfile, VcodecAttr.unExtAttr.stVC1Attr.u32CodecVersion);
+    }
+
+    if (HI_UNF_VCODEC_TYPE_VP6 == VdecType)
+    {
+        VcodecAttr.unExtAttr.stVP6Attr.bReversed = HI_FALSE;
+    }
+
+    VcodecAttr.enType = VdecType;
+    if (HI_UNF_AVPLAY_SetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_VDEC, &VcodecAttr) != HI_SUCCESS)
+    {
+        HISI_INFO("HI_UNF_AVPLAY_ChnOpen exception");
+        goto VCHN_CLOSE;
+    }
+
+    if (HI_UNF_VO_AttachWindow(m_hWin, m_hAvplay) != HI_SUCCESS)
+    {
+        HISI_INFO("HI_UNF_VO_AttachWindow exception");
+        goto VCHN_CLOSE;
+    }
+
+    if (HI_UNF_VO_SetWindowEnable(m_hWin, HI_TRUE) != HI_SUCCESS)
+    {
+        HISI_INFO("HI_UNF_VO_SetWindowEnable exception");
+        goto WIN_DETATCH;
+    }
+
+    ret = HIADP_AVPlay_SetVdecAttr(m_hAvplay, VdecType, HI_UNF_VCODEC_MODE_NORMAL);
+#ifdef USE_DMX
+    ret |= HI_UNF_AVPLAY_SetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_VID_PID, &pVidPid);
+#endif // USE_DMX     
+
+    if (ret != HI_SUCCESS)
+    {
+        HISI_INFO("HIADP_AVPlay_SetVdecAttr exception");
+        goto WIN_DETATCH;
+    }
+
+
+    HI_UNF_AVPLAY_GetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_FRMRATE_PARAM, &stFramerate);
+    if (0 != (videoTrack->frame_rate / 1000))
+    {
+        stFramerate.enFrmRateType = HI_UNF_AVPLAY_FRMRATE_TYPE_USER;
+        stFramerate.stSetFrmRate.u32fpsInteger = (videoTrack->frame_rate / 1000);
+        stFramerate.stSetFrmRate.u32fpsDecimal = 0;
+        HISI_INFO("HI_UNF_AVPLAY_SetAttr , frame rate : %d.%d", stFramerate.stSetFrmRate.u32fpsInteger, stFramerate.stSetFrmRate.u32fpsDecimal);
+        if (HI_UNF_AVPLAY_SetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_FRMRATE_PARAM, &stFramerate) !=
+                HI_SUCCESS)
+        {
+            HISI_TRACE("HI_UNF_AVPLAY_SetAttr exception, frame rate %d.%d", stFramerate.stSetFrmRate.u32fpsInteger, stFramerate.stSetFrmRate.u32fpsDecimal);
+            goto WIN_DETATCH;
+        }
+
+    }
+    else
+    {
+        stFramerate.enFrmRateType = HI_UNF_AVPLAY_FRMRATE_TYPE_PTS;
+        stFramerate.stSetFrmRate.u32fpsInteger = 0 ;
+        stFramerate.stSetFrmRate.u32fpsDecimal = 0;
+        HISI_INFO("HI_UNF_AVPLAY_SetAttr , frame rate : %d.%d", stFramerate.stSetFrmRate.u32fpsInteger, stFramerate.stSetFrmRate.u32fpsDecimal);
+        if (HI_UNF_AVPLAY_SetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_FRMRATE_PARAM, &stFramerate) !=
+                HI_SUCCESS)
+        {
+            HISI_TRACE("HI_UNF_AVPLAY_SetAttr exception, frame rate %d.%d", stFramerate.stSetFrmRate.u32fpsInteger, stFramerate.stSetFrmRate.u32fpsDecimal);
+            goto WIN_DETATCH;
+        }
+    }
+
+
+    HISI_INFO("Open Video success");
+
+    m_video_opend = true;
+    video_last_pts = INVALID_PTS_VALUE;
+
+    return true;
+
+WIN_DETATCH:
+    HI_UNF_VO_SetWindowEnable(m_hWin, HI_FALSE);
+    HI_UNF_VO_DetachWindow(m_hWin, m_hAvplay);
+
+VCHN_CLOSE:
+    HI_UNF_AVPLAY_ChnClose(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID);
+
+    return false;
+}
+
+bool HisiVideoClose()
+{
+    if (!m_video_opend)
+        return false;
+
+    HI_UNF_AVPLAY_STATUS_INFO_S stStatusInfo;
+    if (HI_UNF_AVPLAY_GetStatusInfo(m_hAvplay, &stStatusInfo) != HI_SUCCESS)
+    {
+        HISI_INFO("HI_UNF_AVPLAY_GetStatusInfo exception");
+        return false;
+    }
+
+    if (stStatusInfo.enRunStatus == HI_UNF_AVPLAY_STATUS_PAUSE)
+    {
+        if (HI_UNF_AVPLAY_Resume(m_hAvplay, HI_NULL) != HI_SUCCESS)
+        {
+            HISI_INFO("HI_UNF_AVPLAY_Resume exception");
+            return false;
+        }
+    }
+
+    HI_UNF_AVPLAY_STOP_OPT_S Stop;
+    Stop.enMode = HI_UNF_AVPLAY_STOP_MODE_BLACK;
+    Stop.u32TimeoutMs = 0;
+    if (HI_UNF_AVPLAY_Stop(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID, &Stop) != HI_SUCCESS)
+    {
+        HISI_INFO("HI_UNF_AVPLAY_Stop exception");
+        return false;
+    }
+
+    if (HI_UNF_VO_SetWindowEnable(m_hWin, HI_FALSE) != HI_SUCCESS)
+    {
+        HISI_INFO("HI_UNF_VO_SetWindowEnable exception");
+        return false;
+    }
+
+    if (HI_UNF_VO_DetachWindow(m_hWin, m_hAvplay) != HI_SUCCESS)
+    {
+        HISI_INFO("HI_UNF_VO_DetachWindow exception");
+        return false;
+    }
+
+    if (HI_UNF_AVPLAY_ChnClose(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID) != HI_SUCCESS)
+    {
+        HISI_INFO("HI_UNF_AVPLAY_ChnClose exception");
+        return false;
+    }
+
+    HisiVideoReset();
+
+    m_video_opend = false;
+
+    return true;
+}
+
+void HisiVideoReset()
+{
+
+    HI_BOOL bIsEmpty = HI_FALSE;
+
+    video_last_pts = INVALID_PTS_VALUE;
+
+#ifdef USE_DMX
+    HI_UNF_DMX_ResetTSBuffer(g_TsBuf);
+#endif
+
+    HI_UNF_AVPLAY_IsBuffEmpty(m_hAvplay, &bIsEmpty);
+
+    HI_UNF_AVPLAY_Reset(m_hAvplay, NULL);
+
+    HISI_TRACE("HisiAvDecoder::VideoReset , check buffer empty:%d", bIsEmpty);
+}
+
+bool HisiVideoWrite(uint8_t* pData, size_t iSize, unsigned int pts_ms)
+{
+    if (!m_video_opend)
+        return false;
+
+    HI_UNF_STREAM_BUF_S StreamBuf;
+#ifdef USE_DMX
+    if (HI_UNF_DMX_GetTSBuffer(g_TsBuf, iSize, &StreamBuf, 1000) != HI_SUCCESS)
+#else
+    if (HI_UNF_AVPLAY_GetBuf(m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_VID, iSize, &StreamBuf, 0) != HI_SUCCESS)
+#endif
+
+        return false;
+
+    memcpy(StreamBuf.pu8Data, pData, iSize);
+
+#ifdef USE_DMX
+    if (HI_UNF_DMX_PutTSBuffer(g_TsBuf, iSize) != HI_SUCCESS)
+#else
+    if (HI_UNF_AVPLAY_PutBuf(m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_VID, iSize, pts_ms) != HI_SUCCESS)
+#endif
+
+        return false;
+
+
+    //HISI_TRACE("WriteVideoPackage size:%d, ms:%u",iSize, pts_ms);
+
+    return true;
+}
+
+bool get_passthrough(HA_CODEC_ID_E *AdecType)
+{
+    char buf[0x20];
+    HI_S32 fd;
+    if ( *(AdecType) == HA_AUDIO_ID_CUSTOM_0 )
+    {
+        fd = open("/proc/stb/audio/ac3", O_RDONLY);
+        if ( fd > 0 )
+        {
+            memset(&buf[0], 0, 0x20);
+            read(fd, &buf[0], 0x1F);
+            close(fd);
+            if ( strncmp(&buf[0], "passthrough", 0xB) == 0 )
+            {
+                *(AdecType) = HA_AUDIO_ID_AC3PASSTHROUGH;
+                return true;
+            }
+        }
+    }
+    else if ( *(AdecType) == HA_AUDIO_ID_CUSTOM_1 )
+    {
+        fd = open("/proc/stb/audio/dts", O_RDONLY);
+        if ( fd > 0 )
+        {
+            memset(&buf[0], 0, 0x20);
+            read(fd, &buf[0], 0x1F);
+            close(fd);
+            if ( strncmp(&buf[0], "passthrough", 0xB) == 0 )
+            {
+                *(AdecType) = HA_AUDIO_ID_DTSPASSTHROUGH;
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
+
+
+
+
+bool HisiAudioOpen(Track_t *audioTrack)
+{
+
+#ifdef USE_DMX
+    HI_U32 AudPid = audioTrack->Id;
+#endif // USE_DMX
+
+    bool is_PASSTHROUGH = false;
+    AVStream *stream = (AVStream *)audioTrack->stream;
+    HisiInit();
+
+    if (m_audio_opend)
+        HisiAudioClose();
+
+    HA_CODEC_ID_E AdecType = codec2adec((int32_t)stream->codecpar->codec_id);
+    HI_UNF_AUDIOTRACK_ATTR_S stTrackAttr;
+    HI_UNF_ACODEC_ATTR_S AdecAttr;
+    HI_UNF_AVPLAY_FRMRATE_PARAM_S stFrmRateAttr;
+
+    memset(&stTrackAttr, 0x00, sizeof(stTrackAttr));
+    memset(&AdecAttr, 0x00, sizeof(AdecAttr));
+    memset(&stFrmRateAttr, 0x00, sizeof(stFrmRateAttr));
+
+    HISI_TRACE("codec: using audio hisi codec %#06x decode codec %s libav codec ID %#06x (%s)", AdecType, audioTrack->Encoding, stream->codecpar->codec_id, avcodec_get_name(stream->codecpar->codec_id));
+
+    if (HI_UNF_AVPLAY_ChnOpen(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, HI_NULL) != HI_SUCCESS)
+    {
+        HISI_TRACE("HI_UNF_AVPLAY_ChnOpen audio exception");
+        return false;
+    }
+
+    if (HI_UNF_SND_GetDefaultTrackAttr(HI_UNF_SND_TRACK_TYPE_MASTER, &stTrackAttr) != HI_SUCCESS)
+    {
+        HISI_TRACE("HI_UNF_SND_TRACK_TYPE_MASTER exception");
+        goto ACHN_CLOSE;
+    }
+
+    if (HI_UNF_SND_CreateTrack(HI_UNF_SND_0, &stTrackAttr, &m_hTrack) != HI_SUCCESS)
+    {
+        HISI_TRACE("HI_UNF_SND_CreateTrack exception");
+        goto ACHN_CLOSE;
+    }
+
+    if (HI_UNF_SND_Attach(m_hTrack, m_hAvplay) != HI_SUCCESS)
+    {
+        HISI_TRACE("HI_UNF_SND_Attach exception");
+        goto TRACK_DESTORY;
+    }
+
+    if( audioTrack->Encoding && !strncmp(audioTrack->Encoding, "A_IPCM", 6) || !strncmp(audioTrack->Encoding, "A_LPCM", 6))
+    {
+
+        HISI_TRACE("AudioOpen set as software pcm mode");
+
+        WAV_FORMAT_S stWavFormat;
+
+        stWavFormat.nChannels = audioTrack->channels ? audioTrack->channels : 2 ;
+        stWavFormat.nSamplesPerSec = audioTrack->sample_rate ? audioTrack->sample_rate : 48000;
+        stWavFormat.wBitsPerSample = audioTrack->bits_per_coded_sample ? audioTrack->bits_per_coded_sample : 16;
+
+        if (HI_UNF_AVPLAY_GetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_ADEC, &AdecAttr) != HI_SUCCESS)
+        {
+            HISI_TRACE("Get HI_UNF_AVPLAY_ATTR_ID_ADEC exception");
+            goto TRACK_DETATCH;
+        }
+
+        AdecAttr.enType = HA_AUDIO_ID_PCM;
+        HA_PCM_DecGetDefalutOpenParam(&(AdecAttr.stDecodeParam), &stWavFormat);
+
+        AdecAttr.stDecodeParam.sPcmformat.u32DesiredOutChannels = audioTrack->channels ? audioTrack->channels : 2 ;
+        AdecAttr.stDecodeParam.sPcmformat.u32BitPerSample = audioTrack->bits_per_coded_sample ? audioTrack->bits_per_coded_sample : 16;
+        AdecAttr.stDecodeParam.sPcmformat.u32DesiredSampleRate = audioTrack->sample_rate ? audioTrack->sample_rate : 48000;
+
+        HISI_TRACE("AdecAttr Set sample rate: {%d}", audioTrack->sample_rate);
+
+        if (HI_UNF_AVPLAY_SetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_ADEC, &AdecAttr) != HI_SUCCESS)
+        {
+            HISI_TRACE("Set HI_UNF_AVPLAY_ATTR_ID_ADEC exception");
+            goto TRACK_DETATCH;
+        }
+
+        HI_UNF_SND_SetSpdifMode(HI_UNF_SND_0, HI_UNF_SND_OUTPUTPORT_SPDIF0, HI_UNF_SND_SPDIF_MODE_LPCM);
+        HI_UNF_SND_SetHdmiMode(HI_UNF_SND_0, HI_UNF_SND_OUTPUTPORT_HDMI0, HI_UNF_SND_HDMI_MODE_LPCM);
+    }
+    else
+    {
+        if(get_passthrough(&AdecType))
+        {
+            HIADP_AVPlay_SetAdecAttr(m_hAvplay, AdecType, HD_DEC_MODE_THRU, 0);
+#ifdef USE_DMX
+            HI_UNF_AVPLAY_SetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_AUD_PID, &AudPid);
+#endif // USE_DMX           
+            HI_UNF_SND_SetHdmiMode(HI_UNF_SND_0, HI_UNF_SND_OUTPUTPORT_HDMI0, HI_UNF_SND_HDMI_MODE_RAW);
+            HI_UNF_SND_SetSpdifMode(HI_UNF_SND_0, HI_UNF_SND_OUTPUTPORT_SPDIF0,  HI_UNF_SND_SPDIF_MODE_RAW);
+        }
+        else
+
+        {
+            HIADP_AVPlay_SetAdecAttr(m_hAvplay, AdecType, HD_DEC_MODE_SIMUL, 0);
+#ifdef USE_DMX
+            HI_UNF_AVPLAY_SetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_AUD_PID, &AudPid);
+#endif // USE_DMX 
+            HI_UNF_SND_SetSpdifMode(HI_UNF_SND_0, HI_UNF_SND_OUTPUTPORT_SPDIF0, HI_UNF_SND_SPDIF_MODE_LPCM);
+            HI_UNF_SND_SetHdmiMode(HI_UNF_SND_0, HI_UNF_SND_OUTPUTPORT_HDMI0, HI_UNF_SND_HDMI_MODE_LPCM);
+        }
+    }
+
+    HI_UNF_SYNC_ATTR_S AvSyncAttr;
+    HI_UNF_AVPLAY_GetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_SYNC, &AvSyncAttr);
+    AvSyncAttr.enSyncRef = HI_UNF_SYNC_REF_AUDIO;
+    AvSyncAttr.stSyncStartRegion.s32VidPlusTime = 60;
+    AvSyncAttr.stSyncStartRegion.s32VidNegativeTime = -20;
+    AvSyncAttr.u32PreSyncTimeoutMs =  1000;
+    AvSyncAttr.bQuickOutput = HI_FALSE;
+    HI_UNF_AVPLAY_SetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_SYNC, &AvSyncAttr);
+
+
+    m_audio_opend = true;
+    audio_last_pts = INVALID_PTS_VALUE;
+
+    return true;
+
+TRACK_DETATCH:
+    HI_UNF_SND_Detach(m_hTrack, m_hAvplay);
+
+TRACK_DESTORY:
+    HI_UNF_SND_DestroyTrack(m_hTrack);
+    m_hTrack = 0;
+
+ACHN_CLOSE:
+    HI_UNF_AVPLAY_ChnClose(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD);
+
+    return false;
+}
+
+bool HisiAudioClose()
+{
+
+    if(!m_hTrack)
+        return false;
+
+    if(!m_audio_opend)
+        return false;
+
+    HI_UNF_AVPLAY_STOP_OPT_S Stop;
+    Stop.u32TimeoutMs = 0;
+    Stop.enMode = HI_UNF_AVPLAY_STOP_MODE_BLACK;
+
+    if (HI_UNF_AVPLAY_Stop(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, &Stop) != HI_SUCCESS)
+    {
+        HISI_TRACE("HI_UNF_AVPLAY_Stop");
+        return false;
+    }
+
+    HISI_TRACE("CloseAudio, track %d", m_hTrack);
+    if (HI_UNF_SND_Detach(m_hTrack, m_hAvplay) != HI_SUCCESS)
+    {
+        HISI_TRACE("HI_UNF_SND_Detach AdecType exception");
+        return false;
+    }
+
+    if (HI_UNF_SND_DestroyTrack(m_hTrack) != HI_SUCCESS)
+    {
+        HISI_TRACE("HI_UNF_SND_DestroyTrack exception");
+        return false;
+    }
+
+    m_hTrack = 0;
+
+    if (HI_UNF_AVPLAY_ChnClose(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD) != HI_SUCCESS)
+    {
+        HISI_TRACE("HI_UNF_SND_DestroyTrack exception");
+        return false;
+    }
+
+    HI_UNF_SYNC_ATTR_S AvSyncAttr;
+    HI_UNF_AVPLAY_GetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_SYNC, &AvSyncAttr);
+    AvSyncAttr.enSyncRef = HI_UNF_SYNC_REF_NONE;
+    HI_UNF_AVPLAY_SetAttr(m_hAvplay, HI_UNF_AVPLAY_ATTR_ID_SYNC, &AvSyncAttr);
+
+    HisiAudioReset();
+
+    m_audio_opend = false;
+
+    HISI_TRACE("CloseAudio Success");
+
+
+    return true;
+}
+
+void HisiAudioReset()
+{
+    audio_last_pts = INVALID_PTS_VALUE;
+    HI_UNF_AVPLAY_Reset(m_hAvplay, NULL);
+    HISI_INFO("HisiAvDecoder::AudioReset");
+}
+
+bool HisiAudioWrite(uint8_t* pData, size_t iSize, unsigned int pts_ms)
+{
+
+    if (!m_audio_opend)
+        return false;
+
+    HI_UNF_STREAM_BUF_S StreamBuf;
+#ifdef USE_DMX
+    if (HI_UNF_DMX_GetTSBuffer(g_TsBuf, iSize, &StreamBuf, 1000) != HI_SUCCESS)
+#else
+    if (HI_UNF_AVPLAY_GetBuf(m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_AUD, iSize, &StreamBuf, 0) != HI_SUCCESS)
+#endif
+        return false;
+
+    memcpy(StreamBuf.pu8Data, pData, iSize);
+
+#ifdef USE_DMX
+    if (HI_UNF_DMX_PutTSBuffer(g_TsBuf, iSize) != HI_SUCCESS)
+#else
+    if (HI_UNF_AVPLAY_PutBuf(m_hAvplay, HI_UNF_AVPLAY_BUF_ID_ES_AUD, iSize, pts_ms) != HI_SUCCESS)
+#endif
+        return false;
+
+    //HISI_TRACE("WriteAudioPackage size:%d, ms:%u",iSize, pts_ms);
+
+    return true;
+}
+
+
+
+int LinuxDvbOpen(Context_t  *context __attribute__((unused)), char *type)
+{
+    uint8_t video = !strcmp("video", type);
+    uint8_t audio = !strcmp("audio", type);
+
+    linuxdvb_printf(10, "v%d a%d\n", video, audio);
+
+    context->manager->video->Command(context, MANAGER_GET_TRACK, &videoTrack);
+    if (video && (videoTrack != NULL) && videoTrack->stream)
+    {
+        if(!HisiVideoOpen(videoTrack))
+            return HI_FAILURE;
+
+        if (isBufferedOutput)
+            LinuxDvbBuffOpen(context, type, m_hAvplay);
+    }
+
+    context->manager->audio->Command(context, MANAGER_GET_TRACK, &audioTrack);
+    if (audio && (audioTrack != NULL) && audioTrack->stream)
+    {
+        if(!HisiAudioOpen(audioTrack))
+            return HI_FAILURE;
+
+        if (isBufferedOutput)
+            LinuxDvbBuffOpen(context, type, m_hAvplay);
+    }
+
+
+    //context->manager->subtitle->Command(context, MANAGER_GET_TRACK, &subtitleTrack);
+
+    return HI_SUCCESS;
+}
+
+int LinuxDvbClose(Context_t  *context, char *type)
+{
+
+    LinuxDvbStop(context, "video");
+    LinuxDvbStop(context, "audio");
+
+    getLinuxDVBMutex();
+    videoInfo.width = 0;
+    videoInfo.height = 0;
+
+    if (isBufferedOutput)
+        LinuxDvbBuffClose(context);
+
+    HisiVideoClose();
+    HisiAudioClose();
+    HisiDeinit();
+
+    videoTrack = NULL;
+    audioTrack = NULL;
+    subtitleTrack = NULL;
+
+    releaseLinuxDVBMutex();
+
+    return HI_SUCCESS;
+}
+
+int LinuxDvbPlay(Context_t  *context, char *type)
+{
+    int ret = HI_SUCCESS;
+    unsigned char video = !strcmp("video", type);
+    unsigned char audio = !strcmp("audio", type);
+
+    getLinuxDVBMutex();
+
+    if (video && (videoTrack != NULL) && videoTrack->stream)
+    {
+        if(HI_UNF_AVPLAY_Start(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID, HI_NULL)!= HI_SUCCESS)
+            ret = HI_FAILURE;
+
+    }
+    if (audio && (audioTrack != NULL) && audioTrack->stream)
+    {
+        if(HI_UNF_AVPLAY_Start(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, HI_NULL)!= HI_SUCCESS)
+            ret = HI_FAILURE;
+    }
+
+    releaseLinuxDVBMutex();
+
+    return ret;
+}
+
+int LinuxDvbStop(Context_t  *context __attribute__((unused)), char * type)
+{
+    int ret = HI_SUCCESS;
+    HI_UNF_AVPLAY_STOP_OPT_S Stop;
+    unsigned char video = !strcmp("video", type);
+    unsigned char audio = !strcmp("audio", type);
+    Stop.enMode = HI_UNF_AVPLAY_STOP_MODE_BLACK;
+    Stop.u32TimeoutMs = 0;
+
+    getLinuxDVBMutex();
+
+    if (video && (videoTrack != NULL) && videoTrack->stream)
+    {
+        if(HI_UNF_AVPLAY_Stop(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_VID, &Stop)!= HI_SUCCESS)
+            ret = HI_FAILURE;
+    }
+    if (audio && (audioTrack != NULL) && audioTrack->stream)
+    {
+        if(HI_UNF_AVPLAY_Stop(m_hAvplay, HI_UNF_AVPLAY_MEDIA_CHAN_AUD, &Stop)!= HI_SUCCESS)
+            ret = HI_FAILURE;
+    }
+
+    releaseLinuxDVBMutex();
+
+    return ret;
+}
+
+int LinuxDvbPause(Context_t  *context __attribute__((unused)), char *type)
+{
+    uint8_t video = !strcmp("video", type);
+    uint8_t audio = !strcmp("audio", type);
+    if ((video && (videoTrack != NULL) && videoTrack->stream) || (audio && (audioTrack != NULL) && audioTrack->stream))
+    {
+        getLinuxDVBMutex();
+        HI_UNF_AVPLAY_Pause(m_hAvplay, NULL);
+        releaseLinuxDVBMutex();
+    }
+    return HI_SUCCESS;
+}
+
+int LinuxDvbContinue(Context_t  *context __attribute__((unused)), char * type)
+{
+    uint8_t video = !strcmp("video", type);
+    uint8_t audio = !strcmp("audio", type);
+
+    linuxdvb_printf(10, "v%d a%d\n", video, audio);
+
+    if ((video && (videoTrack != NULL) && videoTrack->stream) || (audio && (audioTrack != NULL) && audioTrack->stream))
+    {
+        getLinuxDVBMutex();
+        HI_UNF_AVPLAY_Resume(m_hAvplay, NULL);
+        releaseLinuxDVBMutex();
+    }
+
+    if (isBufferedOutput)
+        LinuxDvbBuffResume(context);
+
+    linuxdvb_printf(10, "exiting\n");
+
+    return HI_SUCCESS;
+}
+
+int LinuxDvbAudioMute(Context_t  *context __attribute__((unused)), char *flag)
+{
+    HI_BOOL Mute = HI_FALSE;
+
+    HisiInit();
+
+    if(*flag == '1')
+        Mute = HI_FALSE;
+
+    getLinuxDVBMutex();
+    HI_UNF_SND_SetMute(HI_UNF_SND_0, HI_UNF_SND_OUTPUTPORT_HDMI0, Mute);
+    releaseLinuxDVBMutex();
+
+    return HI_SUCCESS;
+}
+
+int LinuxDvbFlush(Context_t  *context __attribute__((unused)), char * type)
+{
+    /*
+       HI_UNF_AVPLAY_FLUSH_STREAM_OPT_S stFlushOpt;
+       HI_BOOL bIsEmpty = HI_FALSE;
+       getLinuxDVBMutex();
+       HI_UNF_AVPLAY_FlushStream(m_hAvplay, &stFlushOpt);
+       getLinuxDVBMutex();
+    */
+    return HI_SUCCESS;
+}
+
+int LinuxDvbSlowMotion(Context_t  *context, char * type)
+{
+    return HI_SUCCESS;
+}
+
+int LinuxDvbAVSync(Context_t  *context, char *type __attribute__((unused)))
+{
+    return HI_SUCCESS;
+}
+
+int LinuxDvbClear(Context_t  *context __attribute__((unused)), char *type)
+{
+    uint8_t video = !strcmp("video", type);
+    uint8_t audio = !strcmp("audio", type);
+    if ((video && (videoTrack != NULL) && videoTrack->stream) || (audio && (audioTrack != NULL) && audioTrack->stream))
+    {
+
+        HI_BOOL bIsEmpty = HI_FALSE;
+        getLinuxDVBMutex();
+        HI_UNF_AVPLAY_IsBuffEmpty(m_hAvplay, &bIsEmpty);
+        HI_UNF_AVPLAY_Reset(m_hAvplay, NULL);
+        releaseLinuxDVBMutex();
+    }
+    return HI_SUCCESS;
+}
+
+
+int LinuxDvbPts(Context_t  *context __attribute__((unused)), unsigned long long int* pts)
+{
+
+    HI_UNF_AVPLAY_STATUS_INFO_S stStatusInfo;
+    getLinuxDVBMutex();
+    if (((videoTrack != NULL) && videoTrack->stream))
+    {
+        if(HI_UNF_AVPLAY_GetStatusInfo(m_hAvplay, &stStatusInfo) == HI_SUCCESS)
+        {
+
+            sCURRENT_PTS = stStatusInfo.stSyncStatus.u32LastVidPts;
+        }
+        else
+        {
+            sCURRENT_PTS = 0;
+        }
+    }
+    *((unsigned long long int *)pts)=(unsigned long long int)sCURRENT_PTS;
+    releaseLinuxDVBMutex();
+    return HI_SUCCESS;
+
+}
+
+int LinuxDvbGetFrameCount(Context_t  *context __attribute__((unused)), unsigned long long int* frameCount)
+{
+    return HI_SUCCESS;
+}
+
+int LinuxDvbSwitch(Context_t  *context, char *type)
+{
+    uint8_t video = !strcmp("video", type);
+    uint8_t audio = !strcmp("audio", type);
+
+    context->manager->audio->Command(context, MANAGER_GET_TRACK, &videoTrack);
+    if (video && (videoTrack != NULL) && videoTrack->stream)
+    {
+        HisiVideoClose();
+        if(!HisiVideoOpen(videoTrack))
+            return HI_FAILURE;
+
+        LinuxDvbPlay(context, type);
+    }
+
+    context->manager->audio->Command(context, MANAGER_GET_TRACK, &audioTrack);
+    if (audio && (audioTrack != NULL) && audioTrack->stream)
+    {
+        HisiAudioClose();
+        if(!HisiAudioOpen(audioTrack))
+            return HI_FAILURE;
+
+        LinuxDvbPlay(context, type);
+    }
+
+    return HI_SUCCESS;
+}
+
+static int Write(void  *_context, void *_out)
+{
+    Context_t          *context  = (Context_t  *) _context;
+    AudioVideoOut_t    *out      = (AudioVideoOut_t*) _out;
+    int32_t            ret       = HI_SUCCESS;
+    int32_t            res       = 0;
+    uint8_t            video     = 0;
+    uint8_t            audio     = 0;
+    uint64_t           checktime = 0;
+
+    if (out == NULL)
+    {
+        linuxdvb_err("null pointer passed\n");
+        return HI_FAILURE;
+    }
+
+    video = !strcmp("video", out->type);
+    audio = !strcmp("audio", out->type);
+
+    linuxdvb_printf(20, "DataLength=%u PrivateLength=%u Pts=%"PRIu64" FrameRate=%d\n", out->len, out->extralen, out->pts, out->frameRate);
+    linuxdvb_printf(20, "v%d a%d\n", video, audio);
+
+    if (video)
+    {
+
+        if (out->pts != INVALID_PTS_VALUE)
+            video_last_pts = out->pts;
+        else
+            out->pts = video_last_pts;
+
+
+        if(isBufferedOutput)
+            BufferingWriteV(out->type,out->data, out->len, out->pts);
+        else
+            HisiVideoWrite(out->data, out->len, out->pts);
+
+    }
+    else if (audio)
+    {
+
+        if (out->pts != INVALID_PTS_VALUE)
+            audio_last_pts = out->pts;
+        else
+            out->pts = audio_last_pts;
+
+
+        if(isBufferedOutput)
+            BufferingWriteV(out->type,out->data, out->len, out->pts);
+        else
+            HisiAudioWrite(out->data, out->len, out->pts);
+    }
+
+    return ret;
+}
+
+static int reset(Context_t  *context)
+{
+    if (isBufferedOutput)
+        LinuxDvbBuffFlush(context);
+    return 0;
+}
+
+static int Command(void  *_context, OutputCmd_t command, void * argument)
+{
+    Context_t* context = (Context_t*) _context;
+    int ret = HI_SUCCESS;
+
+    linuxdvb_printf(50, "Command %d\n", command);
+
+    switch(command)
+    {
+    case OUTPUT_OPEN:
+    {
+        ret = LinuxDvbOpen(context, (char*)argument);
+        break;
+    }
+    case OUTPUT_CLOSE:
+    {
+        ret = LinuxDvbClose(context, (char*)argument);
+        reset(context);
+        sCURRENT_PTS = 0;
+        break;
+    }
+    case OUTPUT_PLAY:  	// 4
+    {
+        sCURRENT_PTS = 0;
+        ret = LinuxDvbPlay(context, (char*)argument);
+        break;
+    }
+    case OUTPUT_STOP:
+    {
+        reset(context);
+        ret = LinuxDvbStop(context, (char*)argument);
+        sCURRENT_PTS = 0;
+        break;
+    }
+    case OUTPUT_FLUSH:
+    {
+        ret = LinuxDvbFlush(context, (char*)argument);
+        reset(context);
+        sCURRENT_PTS = 0;
+        break;
+    }
+    case OUTPUT_PAUSE:
+    {
+        ret = LinuxDvbPause(context, (char*)argument);
+        break;
+    }
+    case OUTPUT_CONTINUE:
+    {
+        ret = LinuxDvbContinue(context, (char*)argument);
+        break;
+    }
+    case OUTPUT_AVSYNC:
+    {
+        ret = LinuxDvbAVSync(context, (char*)argument);
+        break;
+    }
+    case OUTPUT_CLEAR:
+    {
+        ret = LinuxDvbClear(context, (char*)argument);
+        reset(context);
+        sCURRENT_PTS = 0;
+        break;
+    }
+    case OUTPUT_PTS:
+    {
+        unsigned long long int pts = 0;
+        ret = LinuxDvbPts(context, &pts);
+        *((unsigned long long int*)argument) = (unsigned long long int)pts;
+        break;
+    }
+    case OUTPUT_SWITCH:
+    {
+        ret = LinuxDvbSwitch(context, (char*)argument);
+        break;
+    }
+    case OUTPUT_SLOWMOTION:
+    {
+        return LinuxDvbSlowMotion(context, (char*)argument);
+        break;
+    }
+    case OUTPUT_AUDIOMUTE:
+    {
+        return LinuxDvbAudioMute(context, (char*)argument);
+        break;
+    }
+    case OUTPUT_GET_FRAME_COUNT:
+    {
+        unsigned long long int frameCount = 0;
+        ret = LinuxDvbGetFrameCount(context, &frameCount);
+        *((unsigned long long int*)argument) = (unsigned long long int)frameCount;
+        break;
+    }
+    case OUTPUT_GET_PROGRESSIVE:
+    {
+        ret = HI_SUCCESS;
+        *((int*)argument) = videoInfo.progressive;
+        break;
+    }
+    case OUTPUT_SET_BUFFER_SIZE:
+    {
+        ret = HI_FAILURE;
+        if (!isBufferedOutput)
+        {
+            uint32_t bufferSize = *((uint32_t*)argument);
+            ret = HI_SUCCESS;
+            if (bufferSize > 0)
+            {
+                LinuxDvbBuffSetSize(bufferSize);
+                isBufferedOutput = true;
+            }
+        }
+        break;
+    }
+    case OUTPUT_GET_BUFFER_SIZE:
+    {
+        ret = HI_SUCCESS;
+        *((uint32_t*)argument) = LinuxDvbBuffGetSize();
+        break;
+    }
+    default:
+        linuxdvb_err("ContainerCmd %d not supported!\n", command);
+        ret = HI_FAILURE;
+        break;
+    }
+
+    linuxdvb_printf(50, "exiting with value %d\n", ret);
+
+    return ret;
+}
+
+static char *LinuxDvbCapabilities[] = { "audio", "video", NULL };
+
+struct Output_s LinuxDvbOutput =
+{
+    "LinuxDvb",
+    &Command,
+    &Write,
+    LinuxDvbCapabilities
+};
+
+
+
+HA_CODEC_ID_E codec2adec(int enc)
+{
+    switch (enc)
+    {
+    case AV_CODEC_ID_PCM_BLURAY:
+        return HA_AUDIO_ID_BLYRAYLPCM;
+
+    case AV_CODEC_ID_PCM_S16LE ... AV_CODEC_ID_PCM_F64LE:
+    case AV_CODEC_ID_PCM_LXF ... AV_CODEC_ID_PCM_S16BE_PLANAR:
+        return HA_AUDIO_ID_PCM;
+
+    case AV_CODEC_ID_ADPCM_IMA_QT ... AV_CODEC_ID_ADPCM_G726LE:
+        return HA_AUDIO_ID_ADPCM;
+
+    case AV_CODEC_ID_AMR_NB ... AV_CODEC_ID_SOL_DPCM:
+        return HA_AUDIO_ID_AMRNB;
+
+    case AV_CODEC_ID_MP2:
+        return HA_AUDIO_ID_MP2;
+
+    case AV_CODEC_ID_MP3:
+    case AV_CODEC_ID_MP3ADU:
+    case AV_CODEC_ID_MP3ON4:
+        return HA_AUDIO_ID_MP3;
+
+    case AV_CODEC_ID_AAC:
+        return HA_AUDIO_ID_AAC;
+
+    case AV_CODEC_ID_AC3:
+    case AV_CODEC_ID_EAC3:
+        return HA_AUDIO_ID_CUSTOM_0;
+
+    case AV_CODEC_ID_DTS:
+        return HA_AUDIO_ID_CUSTOM_1;
+
+    case AV_CODEC_ID_WMAV1:
+    case AV_CODEC_ID_WMAV2:
+        return HA_AUDIO_ID_WMA9STD;
+
+    case AV_CODEC_ID_COOK:
+        return HA_AUDIO_ID_COOK;
+
+    case AV_CODEC_ID_VORBIS:
+        return HA_AUDIO_ID_VORBIS;
+
+    case AV_CODEC_ID_TRUEHD:
+        return HA_AUDIO_ID_CUSTOM_3;
+    default:
+        return HA_AUDIO_ID_MP3;
+    }
+
+    return HA_AUDIO_ID_MP3;
+}
+
+HI_UNF_VCODEC_TYPE_E codec2vdec(int enc)
+{
+    switch (enc)
+    {
+    case AV_CODEC_ID_MPEG1VIDEO:
+    case AV_CODEC_ID_MPEG2VIDEO:
+        return HI_UNF_VCODEC_TYPE_MPEG2;
+    case AV_CODEC_ID_MPEG4:
+        return HI_UNF_VCODEC_TYPE_MPEG4; /**<MPEG4 DIVX4 DIVX5 */
+    case AV_CODEC_ID_AVS:
+        return HI_UNF_VCODEC_TYPE_AVS;
+    case AV_CODEC_ID_H263:
+        return HI_UNF_VCODEC_TYPE_H263;
+    case AV_CODEC_ID_H264:
+        return HI_UNF_VCODEC_TYPE_H264;
+    case AV_CODEC_ID_RV30:
+        return HI_UNF_VCODEC_TYPE_REAL8;
+    case AV_CODEC_ID_RV40:
+        return HI_UNF_VCODEC_TYPE_REAL9;
+    case AV_CODEC_ID_VC1:
+        return HI_UNF_VCODEC_TYPE_VC1;
+    case AV_CODEC_ID_VP6:
+        return HI_UNF_VCODEC_TYPE_VP6;
+    case AV_CODEC_ID_VP6F:
+        return HI_UNF_VCODEC_TYPE_VP6F;
+    case AV_CODEC_ID_VP6A:
+        return HI_UNF_VCODEC_TYPE_VP6A;
+    case AV_CODEC_ID_MJPEG:
+        return HI_UNF_VCODEC_TYPE_MJPEG;
+    case AV_CODEC_ID_FLV1:
+        return HI_UNF_VCODEC_TYPE_SORENSON; /**<SORENSON SPARK */
+    case AV_CODEC_ID_MSMPEG4V3:
+        return HI_UNF_VCODEC_TYPE_DIVX3;
+    case AV_CODEC_ID_RAWVIDEO:
+        return HI_UNF_VCODEC_TYPE_RAW;
+    case AV_CODEC_ID_LJPEG:
+    case AV_CODEC_ID_JPEG2000:
+        return HI_UNF_VCODEC_TYPE_JPEG; /**<Used only for VENC */
+    case AV_CODEC_ID_VP8:
+        return HI_UNF_VCODEC_TYPE_VP8;
+    case AV_CODEC_ID_MSMPEG4V1:
+        return HI_UNF_VCODEC_TYPE_MSMPEG4V1; /**<MS private MPEG4 */
+    case AV_CODEC_ID_MSMPEG4V2:
+        return HI_UNF_VCODEC_TYPE_MSMPEG4V2;
+    case AV_CODEC_ID_MSVIDEO1:
+        return HI_UNF_VCODEC_TYPE_MSVIDEO1; /**<MS video */
+    case AV_CODEC_ID_WMV1:
+        return HI_UNF_VCODEC_TYPE_WMV1;
+    case AV_CODEC_ID_WMV2:
+        return HI_UNF_VCODEC_TYPE_WMV2;
+    case AV_CODEC_ID_RV10:
+        return HI_UNF_VCODEC_TYPE_RV10;
+    case AV_CODEC_ID_RV20:
+        return HI_UNF_VCODEC_TYPE_RV20;
+    case AV_CODEC_ID_SVQ1:
+        return HI_UNF_VCODEC_TYPE_SVQ1; /**<Apple video */
+    case AV_CODEC_ID_SVQ3:
+        return HI_UNF_VCODEC_TYPE_SVQ3; /**<Apple video */
+    case AV_CODEC_ID_H261:
+        return HI_UNF_VCODEC_TYPE_H261;
+    case AV_CODEC_ID_VP3:
+        return HI_UNF_VCODEC_TYPE_VP3;
+    case AV_CODEC_ID_VP5:
+        return HI_UNF_VCODEC_TYPE_VP5;
+    case AV_CODEC_ID_CINEPAK:
+        return HI_UNF_VCODEC_TYPE_CINEPAK;
+    case AV_CODEC_ID_INDEO2:
+        return HI_UNF_VCODEC_TYPE_INDEO2;
+    case AV_CODEC_ID_INDEO3:
+        return HI_UNF_VCODEC_TYPE_INDEO3;
+    case AV_CODEC_ID_INDEO4:
+        return HI_UNF_VCODEC_TYPE_INDEO4;
+    case AV_CODEC_ID_INDEO5:
+        return HI_UNF_VCODEC_TYPE_INDEO5;
+    case AV_CODEC_ID_MJPEGB:
+        return HI_UNF_VCODEC_TYPE_MJPEGB;
+    case AV_CODEC_ID_KMVC:
+        return HI_UNF_VCODEC_TYPE_MVC;
+    case AV_CODEC_ID_HEVC:
+        return HI_UNF_VCODEC_TYPE_HEVC;
+    case AV_CODEC_ID_DVVIDEO:
+        return HI_UNF_VCODEC_TYPE_DV;
+    case AV_CODEC_ID_VP9:
+        return HI_UNF_VCODEC_TYPE_VP9;
+    case AV_CODEC_ID_CAVS:
+        return HI_UNF_VCODEC_TYPE_AVS2;
+    default:
+        break;
+    }
+
+    return HI_UNF_VCODEC_TYPE_BUTT;
+}
+
+
+
+
